/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/ably/build/ably-commonjs.js":
/*!**************************************************!*\
  !*** ./node_modules/ably/build/ably-commonjs.js ***!
  \**************************************************/
/***/ ((module) => {

/*!
 * @license Copyright 2015-2022 Ably Real-time Ltd (ably.com)
 * 
 * Ably JavaScript Library v1.2.43
 * https://github.com/ably/ably-js
 * 
 * Released under the Apache Licence v2.0
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_723__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_723__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_723__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_723__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_723__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_723__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_723__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__nested_webpack_require_723__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __nested_webpack_require_723__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__nested_webpack_require_723__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_723__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_723__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_723__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_723__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_723__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_723__(__nested_webpack_require_723__.s = 42);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_4200__) {

"use strict";
__nested_webpack_require_4200__.r(__nested_webpack_exports__);
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__spreadArray", function() { return __spreadArray; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}


/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_19043__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.allToUpperCase = exports.allToLowerCase = exports.encodeBody = exports.decodeBody = exports.Format = exports.promisify = exports.trim = exports.arrChooseN = exports.randomHexString = exports.randomString = exports.cheapRandStr = exports.dataSizeBytes = exports.inspectBody = exports.inspectError = exports.isErrorInfoOrPartialErrorInfo = exports.now = exports.parseQueryString = exports.toQueryString = exports.arrPopRandomElement = exports.defaultPostHeaders = exports.defaultGetHeaders = exports.allSame = exports.arrEvery = exports.arrFilter = exports.arrMap = exports.safeArrForEach = exports.arrForEach = exports.forInOwnNonNullProperties = exports.valuesArray = exports.keysArray = exports.arrWithoutValue = exports.arrDeleteValue = exports.arrIn = exports.arrIndexOf = exports.arrSubtract = exports.arrIntersectOb = exports.arrIntersect = exports.intersect = exports.containsValue = exports.inherits = exports.prototypicalClone = exports.shallowClone = exports.isEmptyArg = exports.isOnlyPropIn = exports.isEmpty = exports.isObject = exports.ensureArray = exports.isArray = exports.copy = exports.mixin = void 0;
exports.toBase64 = exports.matchDerivedChannel = exports.shallowEquals = exports.getGlobalObject = exports.getRetryTime = exports.getJitterCoefficient = exports.getBackoffCoefficient = void 0;
var tslib_1 = __nested_webpack_require_19043__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_19043__(3));
var defaults_1 = tslib_1.__importStar(__nested_webpack_require_19043__(8));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_19043__(4));
var enc_base64_1 = __nested_webpack_require_19043__(11);
var enc_utf8_1 = __nested_webpack_require_19043__(31);
function randomPosn(arrOrStr) {
    return Math.floor(Math.random() * arrOrStr.length);
}
/*
 * Add a set of properties to a target object
 * target: the target object
 * props:  an object whose enumerable properties are
 *         added, by reference only
 */
function mixin(target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < args.length; i++) {
        var source = args[i];
        if (!source) {
            break;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        for (var key in source) {
            if (!hasOwnProperty || hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }
    return target;
}
exports.mixin = mixin;
/*
 * Add a set of properties to a target object
 * target: the target object
 * props:  an object whose enumerable properties are
 *         added, by reference only
 */
function copy(src) {
    return mixin({}, src);
}
exports.copy = copy;
/*
 * Determine whether or not a given object is
 * an array.
 */
exports.isArray = Array.isArray ||
    function (value) {
        return Object.prototype.toString.call(value) == '[object Array]';
    };
/*
 * Ensures that an Array object is always returned
 * returning the original Array of obj is an Array
 * else wrapping the obj in a single element Array
 */
function ensureArray(obj) {
    if (isEmptyArg(obj)) {
        return [];
    }
    if ((0, exports.isArray)(obj)) {
        return obj;
    }
    return [obj];
}
exports.ensureArray = ensureArray;
function isObject(ob) {
    return Object.prototype.toString.call(ob) == '[object Object]';
}
exports.isObject = isObject;
/*
 * Determine whether or not an object contains
 * any enumerable properties.
 * ob: the object
 */
function isEmpty(ob) {
    for (var prop in ob)
        return false;
    return true;
}
exports.isEmpty = isEmpty;
function isOnlyPropIn(ob, property) {
    for (var prop in ob) {
        if (prop !== property) {
            return false;
        }
    }
    return true;
}
exports.isOnlyPropIn = isOnlyPropIn;
/*
 * Determine whether or not an argument to an overloaded function is
 * undefined (missing) or null.
 * This method is useful when constructing functions such as (WebIDL terminology):
 *   off([TreatUndefinedAs=Null] DOMString? event)
 * as you can then confirm the argument using:
 *   Utils.isEmptyArg(event)
 */
function isEmptyArg(arg) {
    return arg === null || arg === undefined;
}
exports.isEmptyArg = isEmptyArg;
/*
 * Perform a simple shallow clone of an object.
 * Result is an object irrespective of whether
 * the input is an object or array. All
 * enumerable properties are copied.
 * ob: the object
 */
function shallowClone(ob) {
    var result = new Object();
    for (var prop in ob)
        result[prop] = ob[prop];
    return result;
}
exports.shallowClone = shallowClone;
/*
 * Clone an object by creating a new object with the
 * given object as its prototype. Optionally
 * a set of additional own properties can be
 * supplied to be added to the newly created clone.
 * ob:            the object to be cloned
 * ownProperties: optional object with additional
 *                properties to add
 */
function prototypicalClone(ob, ownProperties) {
    var F = /** @class */ (function () {
        function F() {
        }
        return F;
    }());
    F.prototype = ob;
    var result = new F();
    if (ownProperties)
        mixin(result, ownProperties);
    return result;
}
exports.prototypicalClone = prototypicalClone;
/*
 * Declare a constructor to represent a subclass
 * of another constructor
 * If platform has a built-in version we use that from Platform, else we
 * define here (so can make use of other Utils fns)
 * See node.js util.inherits
 */
var inherits = function (ctor, superCtor) {
    if (platform_1.default.Config.inherits) {
        platform_1.default.Config.inherits(ctor, superCtor);
        return;
    }
    ctor.super_ = superCtor;
    ctor.prototype = prototypicalClone(superCtor.prototype, { constructor: ctor });
};
exports.inherits = inherits;
/*
 * Determine whether or not an object has an enumerable
 * property whose value equals a given value.
 * ob:  the object
 * val: the value to find
 */
function containsValue(ob, val) {
    for (var i in ob) {
        if (ob[i] == val)
            return true;
    }
    return false;
}
exports.containsValue = containsValue;
function intersect(arr, ob) {
    return (0, exports.isArray)(ob) ? arrIntersect(arr, ob) : arrIntersectOb(arr, ob);
}
exports.intersect = intersect;
function arrIntersect(arr1, arr2) {
    var result = [];
    for (var i = 0; i < arr1.length; i++) {
        var member = arr1[i];
        if ((0, exports.arrIndexOf)(arr2, member) != -1)
            result.push(member);
    }
    return result;
}
exports.arrIntersect = arrIntersect;
function arrIntersectOb(arr, ob) {
    var result = [];
    for (var i = 0; i < arr.length; i++) {
        var member = arr[i];
        if (member in ob)
            result.push(member);
    }
    return result;
}
exports.arrIntersectOb = arrIntersectOb;
function arrSubtract(arr1, arr2) {
    var result = [];
    for (var i = 0; i < arr1.length; i++) {
        var element = arr1[i];
        if ((0, exports.arrIndexOf)(arr2, element) == -1)
            result.push(element);
    }
    return result;
}
exports.arrSubtract = arrSubtract;
exports.arrIndexOf = Array.prototype.indexOf
    ? function (arr, elem, fromIndex) {
        return arr.indexOf(elem, fromIndex);
    }
    : function (arr, elem, fromIndex) {
        fromIndex = fromIndex || 0;
        var len = arr.length;
        for (; fromIndex < len; fromIndex++) {
            if (arr[fromIndex] === elem) {
                return fromIndex;
            }
        }
        return -1;
    };
function arrIn(arr, val) {
    return (0, exports.arrIndexOf)(arr, val) !== -1;
}
exports.arrIn = arrIn;
function arrDeleteValue(arr, val) {
    var idx = (0, exports.arrIndexOf)(arr, val);
    var res = idx != -1;
    if (res)
        arr.splice(idx, 1);
    return res;
}
exports.arrDeleteValue = arrDeleteValue;
function arrWithoutValue(arr, val) {
    var newArr = arr.slice();
    arrDeleteValue(newArr, val);
    return newArr;
}
exports.arrWithoutValue = arrWithoutValue;
/*
 * Construct an array of the keys of the enumerable
 * properties of a given object, optionally limited
 * to only the own properties.
 * ob:      the object
 * ownOnly: boolean, get own properties only
 */
function keysArray(ob, ownOnly) {
    var result = [];
    for (var prop in ob) {
        if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))
            continue;
        result.push(prop);
    }
    return result;
}
exports.keysArray = keysArray;
/*
 * Construct an array of the values of the enumerable
 * properties of a given object, optionally limited
 * to only the own properties.
 * ob:      the object
 * ownOnly: boolean, get own properties only
 */
function valuesArray(ob, ownOnly) {
    var result = [];
    for (var prop in ob) {
        if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))
            continue;
        result.push(ob[prop]);
    }
    return result;
}
exports.valuesArray = valuesArray;
function forInOwnNonNullProperties(ob, fn) {
    for (var prop in ob) {
        if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {
            fn(prop);
        }
    }
}
exports.forInOwnNonNullProperties = forInOwnNonNullProperties;
exports.arrForEach = Array.prototype.forEach
    ? function (arr, fn) {
        arr.forEach(fn);
    }
    : function (arr, fn) {
        var len = arr.length;
        for (var i = 0; i < len; i++) {
            fn(arr[i], i, arr);
        }
    };
/* Useful when the function may mutate the array */
function safeArrForEach(arr, fn) {
    return (0, exports.arrForEach)(arr.slice(), fn);
}
exports.safeArrForEach = safeArrForEach;
exports.arrMap = Array.prototype.map
    ? function (arr, fn) {
        return arr.map(fn);
    }
    : function (arr, fn) {
        var result = [];
        var len = arr.length;
        for (var i = 0; i < len; i++) {
            result.push(fn(arr[i], i, arr));
        }
        return result;
    };
exports.arrFilter = Array.prototype.filter
    ? function (arr, fn) {
        return arr.filter(fn);
    }
    : function (arr, fn) {
        var result = [], len = arr.length;
        for (var i = 0; i < len; i++) {
            if (fn(arr[i])) {
                result.push(arr[i]);
            }
        }
        return result;
    };
exports.arrEvery = Array.prototype.every
    ? function (arr, fn) {
        return arr.every(fn);
    }
    : function (arr, fn) {
        var len = arr.length;
        for (var i = 0; i < len; i++) {
            if (!fn(arr[i], i, arr)) {
                return false;
            }
        }
        return true;
    };
function allSame(arr, prop) {
    if (arr.length === 0) {
        return true;
    }
    var first = arr[0][prop];
    return (0, exports.arrEvery)(arr, function (item) {
        return item[prop] === first;
    });
}
exports.allSame = allSame;
var contentTypes = {
    json: 'application/json',
    jsonp: 'application/javascript',
    xml: 'application/xml',
    html: 'text/html',
    msgpack: 'application/x-msgpack',
};
function defaultGetHeaders(options, format) {
    var accept = contentTypes[format || Format.json];
    return {
        accept: accept,
        'X-Ably-Version': defaults_1.default.protocolVersion.toString(),
        'Ably-Agent': (0, defaults_1.getAgentString)(options),
    };
}
exports.defaultGetHeaders = defaultGetHeaders;
function defaultPostHeaders(options, format) {
    var contentType;
    var accept = (contentType = contentTypes[format || Format.json]);
    return {
        accept: accept,
        'content-type': contentType,
        'X-Ably-Version': defaults_1.default.protocolVersion.toString(),
        'Ably-Agent': (0, defaults_1.getAgentString)(options),
    };
}
exports.defaultPostHeaders = defaultPostHeaders;
function arrPopRandomElement(arr) {
    return arr.splice(randomPosn(arr), 1)[0];
}
exports.arrPopRandomElement = arrPopRandomElement;
function toQueryString(params) {
    var parts = [];
    if (params) {
        for (var key in params)
            parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));
    }
    return parts.length ? '?' + parts.join('&') : '';
}
exports.toQueryString = toQueryString;
function parseQueryString(query) {
    var match;
    var search = /([^?&=]+)=?([^&]*)/g;
    var result = {};
    while ((match = search.exec(query)))
        result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);
    return result;
}
exports.parseQueryString = parseQueryString;
exports.now = Date.now ||
    function () {
        /* IE 8 */
        return new Date().getTime();
    };
function isErrorInfoOrPartialErrorInfo(err) {
    return (typeof err == 'object' &&
        err !== null &&
        (err.constructor.name == 'ErrorInfo' || err.constructor.name == 'PartialErrorInfo'));
}
exports.isErrorInfoOrPartialErrorInfo = isErrorInfoOrPartialErrorInfo;
function inspectError(err) {
    var _a, _b;
    if (err instanceof Error ||
        ((_a = err === null || err === void 0 ? void 0 : err.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'ErrorInfo' ||
        ((_b = err === null || err === void 0 ? void 0 : err.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'PartialErrorInfo')
        return err.toString();
    return platform_1.default.Config.inspect(err);
}
exports.inspectError = inspectError;
function inspectBody(body) {
    if (platform_1.default.BufferUtils.isBuffer(body)) {
        return body.toString();
    }
    else if (typeof body === 'string') {
        return body;
    }
    else {
        return platform_1.default.Config.inspect(body);
    }
}
exports.inspectBody = inspectBody;
/* Data is assumed to be either a string or a buffer. */
function dataSizeBytes(data) {
    if (platform_1.default.BufferUtils.isBuffer(data)) {
        return platform_1.default.BufferUtils.byteLength(data);
    }
    if (typeof data === 'string') {
        return platform_1.default.Config.stringByteSize(data);
    }
    throw new Error('Expected input of Utils.dataSizeBytes to be a buffer or string, but was: ' + typeof data);
}
exports.dataSizeBytes = dataSizeBytes;
function cheapRandStr() {
    return String(Math.random()).substr(2);
}
exports.cheapRandStr = cheapRandStr;
/* Takes param the minimum number of bytes of entropy the string must
 * include, not the length of the string. String length produced is not
 * guaranteed. */
var randomString = function (numBytes) {
    if (platform_1.default.Config.getRandomValues && typeof Uint8Array !== 'undefined') {
        var uIntArr = new Uint8Array(numBytes);
        platform_1.default.Config.getRandomValues(uIntArr);
        return platform_1.default.BufferUtils.base64Encode(uIntArr);
    }
    /* Old browser; fall back to Math.random. Could just use a
     * CryptoJS version of the above, but want this to still work in nocrypto
     * versions of the library */
    var charset = platform_1.default.BufferUtils.base64CharSet;
    /* base64 has 33% overhead; round length up */
    var length = Math.round((numBytes * 4) / 3);
    var result = '';
    for (var i = 0; i < length; i++) {
        result += charset[randomPosn(charset)];
    }
    return result;
};
exports.randomString = randomString;
var randomHexString = function (numBytes) {
    if (platform_1.default.Config.getRandomValues && typeof Uint8Array !== 'undefined') {
        var uIntArr = new Uint8Array(numBytes);
        platform_1.default.Config.getRandomValues(uIntArr);
        return platform_1.default.BufferUtils.hexEncode(uIntArr);
    }
    var charset = platform_1.default.BufferUtils.hexCharSet;
    var length = numBytes * 2;
    var result = '';
    for (var i = 0; i < length; i++) {
        result += charset[randomPosn(charset)];
    }
    return result;
};
exports.randomHexString = randomHexString;
/* Pick n elements at random without replacement from an array */
function arrChooseN(arr, n) {
    var numItems = Math.min(n, arr.length), mutableArr = arr.slice(), result = [];
    for (var i = 0; i < numItems; i++) {
        result.push(arrPopRandomElement(mutableArr));
    }
    return result;
}
exports.arrChooseN = arrChooseN;
exports.trim = String.prototype.trim
    ? function (str) {
        return str.trim();
    }
    : function (str) {
        return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
    };
function promisify(ob, fnName, args) {
    return new Promise(function (resolve, reject) {
        ob[fnName].apply(ob, tslib_1.__spreadArray(tslib_1.__spreadArray([], args, false), [function (err, res) {
                err ? reject(err) : resolve(res);
            }], false));
    });
}
exports.promisify = promisify;
var Format;
(function (Format) {
    Format["msgpack"] = "msgpack";
    Format["json"] = "json";
})(Format = exports.Format || (exports.Format = {}));
function decodeBody(body, format) {
    return format == 'msgpack' ? platform_1.default.Config.msgpack.decode(body) : JSON.parse(String(body));
}
exports.decodeBody = decodeBody;
function encodeBody(body, format) {
    return format == 'msgpack' ? platform_1.default.Config.msgpack.encode(body, true) : JSON.stringify(body);
}
exports.encodeBody = encodeBody;
function allToLowerCase(arr) {
    return arr.map(function (element) {
        return element && element.toLowerCase();
    });
}
exports.allToLowerCase = allToLowerCase;
function allToUpperCase(arr) {
    return arr.map(function (element) {
        return element && element.toUpperCase();
    });
}
exports.allToUpperCase = allToUpperCase;
function getBackoffCoefficient(count) {
    return Math.min((count + 2) / 3, 2);
}
exports.getBackoffCoefficient = getBackoffCoefficient;
function getJitterCoefficient() {
    return 1 - Math.random() * 0.2;
}
exports.getJitterCoefficient = getJitterCoefficient;
/**
 *
 * @param initialTimeout initial timeout value
 * @param retryAttempt integer indicating retryAttempt
 * @returns RetryTimeout value for given timeout and retryAttempt.
 * If x is the value generated then,
 * Upper bound = min((retryAttempt + 2) / 3, 2) * initialTimeout,
 * Lower bound = 0.8 * Upper bound,
 * Lower bound < x < Upper bound
 */
function getRetryTime(initialTimeout, retryAttempt) {
    return initialTimeout * getBackoffCoefficient(retryAttempt) * getJitterCoefficient();
}
exports.getRetryTime = getRetryTime;
function getGlobalObject() {
    if (global) {
        return global;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    return self;
}
exports.getGlobalObject = getGlobalObject;
function shallowEquals(source, target) {
    return (Object.keys(source).every(function (key) { return source[key] === target[key]; }) &&
        Object.keys(target).every(function (key) { return target[key] === source[key]; }));
}
exports.shallowEquals = shallowEquals;
function matchDerivedChannel(name) {
    /**
     * This regex check is to retain existing channel params if any e.g [?rewind=1]foo to
     * [filter=xyz?rewind=1]foo. This is to keep channel compatibility around use of
     * channel params that work with derived channels.
     *
     * This eslint unsafe regex warning is triggered because the RegExp uses nested quantifiers,
     * but it does not create any situation where the regex engine has to
     * explore a large number of possible matches so it’s safe to ignore
     */
    var regex = /^(\[([^?]*)(?:(.*))\])?(.+)$/; // eslint-disable-line
    var match = name.match(regex);
    if (!match || !match.length || match.length < 5) {
        throw new errorinfo_1.default('regex match failed', 400, 40010);
    }
    // Fail if there is already a channel qualifier, eg [meta]foo should fail instead of just overriding with [filter=xyz]foo
    if (match[2]) {
        throw new errorinfo_1.default("cannot use a derived option with a ".concat(match[2], " channel"), 400, 40010);
    }
    // Return match values to be added to derive channel quantifier.
    return {
        qualifierParam: match[3] || '',
        channelName: match[4],
    };
}
exports.matchDerivedChannel = matchDerivedChannel;
function toBase64(str) {
    if (platform_1.default.Config.createHmac) {
        return Buffer.from(str, 'ascii').toString('base64');
    }
    return (0, enc_base64_1.stringify)((0, enc_utf8_1.parse)(str));
}
exports.toBase64 = toBase64;

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_19043__(13)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __nested_webpack_require_39587__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_39587__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_39587__(3));
// Workaround for salesforce lightning locker compatibility
// This is a shorthand version of Utils.getGlobalObject (which we can't use here without creating a circular import)
var globalObject = global || (typeof window !== 'undefined' ? window : self);
var LogLevels;
(function (LogLevels) {
    LogLevels[LogLevels["None"] = 0] = "None";
    LogLevels[LogLevels["Error"] = 1] = "Error";
    LogLevels[LogLevels["Major"] = 2] = "Major";
    LogLevels[LogLevels["Minor"] = 3] = "Minor";
    LogLevels[LogLevels["Micro"] = 4] = "Micro";
})(LogLevels || (LogLevels = {}));
function pad(timeSegment, three) {
    return "".concat(timeSegment).padStart(three ? 3 : 2, '0');
}
function getHandler(logger) {
    return platform_1.default.Config.logTimestamps
        ? function (msg) {
            var time = new Date();
            logger(pad(time.getHours()) +
                ':' +
                pad(time.getMinutes()) +
                ':' +
                pad(time.getSeconds()) +
                '.' +
                pad(time.getMilliseconds(), 1) +
                ' ' +
                msg);
        }
        : logger;
}
var getDefaultLoggers = function () {
    var _a, _b;
    var consoleLogger;
    var errorLogger;
    /* Can't just check for console && console.log; fails in IE <=9 */
    if ((typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') /* node */ ||
        typeof ((_b = (_a = globalObject === null || globalObject === void 0 ? void 0 : globalObject.console) === null || _a === void 0 ? void 0 : _a.log) === null || _b === void 0 ? void 0 : _b.apply) === 'function' /* sensible browsers */) {
        consoleLogger = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            console.log.apply(console, args);
        };
        errorLogger = console.warn
            ? function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                console.warn.apply(console, args);
            }
            : consoleLogger;
    }
    else if (globalObject === null || globalObject === void 0 ? void 0 : globalObject.console.log) {
        /* IE <= 9 with the console open -- console.log does not
         * inherit from Function, so has no apply method */
        consoleLogger = errorLogger = function () {
            Function.prototype.apply.call(console.log, console, arguments);
        };
    }
    else {
        /* IE <= 9 when dev tools are closed - window.console not even defined */
        consoleLogger = errorLogger = function () { };
    }
    return [consoleLogger, errorLogger].map(getHandler);
};
var Logger = /** @class */ (function () {
    function Logger() {
        Logger.logLevel = Logger.LOG_DEFAULT;
    }
    Logger.initLogHandlers = function () {
        var _a = getDefaultLoggers(), logHandler = _a[0], logErrorHandler = _a[1];
        this.logHandler = logHandler;
        this.logErrorHandler = logErrorHandler;
    };
    Logger.logLevel = LogLevels.Error; // default logLevel
    // public constants
    Logger.LOG_NONE = LogLevels.None;
    Logger.LOG_ERROR = LogLevels.Error;
    Logger.LOG_MAJOR = LogLevels.Major;
    Logger.LOG_MINOR = LogLevels.Minor;
    Logger.LOG_MICRO = LogLevels.Micro;
    // aliases
    Logger.LOG_DEFAULT = LogLevels.Error;
    Logger.LOG_DEBUG = LogLevels.Micro;
    /* public static functions */
    Logger.logAction = function (level, action, message) {
        if (Logger.shouldLog(level)) {
            (level === LogLevels.Error ? Logger.logErrorHandler : Logger.logHandler)('Ably: ' + action + ': ' + message);
        }
    };
    Logger.deprecated = function (original, replacement) {
        Logger.deprecatedWithMsg(original, "Please use '" + replacement + "' instead.");
    };
    Logger.deprecatedWithMsg = function (funcName, msg) {
        if (Logger.shouldLog(LogLevels.Error)) {
            Logger.logErrorHandler("Ably: Deprecation warning - '" + funcName + "' is deprecated and will be removed from a future version. " + msg);
        }
    };
    /* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent
         the object being serialised if the log level will not output the message */
    Logger.shouldLog = function (level) {
        return level <= Logger.logLevel;
    };
    Logger.setLog = function (level, handler) {
        if (level !== undefined)
            Logger.logLevel = level;
        if (handler !== undefined)
            Logger.logHandler = Logger.logErrorHandler = handler;
    };
    return Logger;
}());
exports.default = Logger;

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_39587__(13)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Platform = /** @class */ (function () {
    function Platform() {
    }
    return Platform;
}());
exports.default = Platform;


/***/ }),
/* 4 */
/***/ (function(module, exports, __nested_webpack_require_45001__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PartialErrorInfo = void 0;
var tslib_1 = __nested_webpack_require_45001__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_45001__(3));
var Utils = tslib_1.__importStar(__nested_webpack_require_45001__(1));
function toString(err) {
    var result = '[' + err.constructor.name;
    if (err.message)
        result += ': ' + err.message;
    if (err.statusCode)
        result += '; statusCode=' + err.statusCode;
    if (err.code)
        result += '; code=' + err.code;
    if (err.cause)
        result += '; cause=' + Utils.inspectError(err.cause);
    if (err.href && !(err.message && err.message.indexOf('help.ably.io') > -1))
        result += '; see ' + err.href + ' ';
    result += ']';
    return result;
}
var ErrorInfo = /** @class */ (function (_super) {
    tslib_1.__extends(ErrorInfo, _super);
    function ErrorInfo(message, code, statusCode, cause) {
        var _this = _super.call(this, message) || this;
        if (typeof Object.setPrototypeOf !== 'undefined') {
            Object.setPrototypeOf(_this, ErrorInfo.prototype);
        }
        _this.code = code;
        _this.statusCode = statusCode;
        _this.cause = cause;
        return _this;
    }
    ErrorInfo.prototype.toString = function () {
        return toString(this);
    };
    ErrorInfo.fromValues = function (values) {
        var _a = values, message = _a.message, code = _a.code, statusCode = _a.statusCode;
        if (typeof message !== 'string' || typeof code !== 'number' || typeof statusCode !== 'number') {
            throw new Error('ErrorInfo.fromValues(): invalid values: ' + platform_1.default.Config.inspect(values));
        }
        var result = Object.assign(new ErrorInfo(message, code, statusCode), values);
        if (result.code && !result.href) {
            result.href = 'https://help.ably.io/error/' + result.code;
        }
        return result;
    };
    return ErrorInfo;
}(Error));
exports.default = ErrorInfo;
var PartialErrorInfo = /** @class */ (function (_super) {
    tslib_1.__extends(PartialErrorInfo, _super);
    function PartialErrorInfo(message, code, statusCode, cause) {
        var _this = _super.call(this, message) || this;
        if (typeof Object.setPrototypeOf !== 'undefined') {
            Object.setPrototypeOf(_this, PartialErrorInfo.prototype);
        }
        _this.code = code;
        _this.statusCode = statusCode;
        _this.cause = cause;
        return _this;
    }
    PartialErrorInfo.prototype.toString = function () {
        return toString(this);
    };
    return PartialErrorInfo;
}(Error));
exports.PartialErrorInfo = PartialErrorInfo;


/***/ }),
/* 5 */
/***/ (function(module, exports, __nested_webpack_require_47756__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_47756__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));

/***/ }),
/* 6 */
/***/ (function(module, exports, __nested_webpack_require_49894__) {

/* WEBPACK VAR INJECTION */(function(global) {;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof global !== 'undefined' && global.crypto) {
	        crypto = global.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __nested_webpack_require_49894__(44);
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_49894__(13)))

/***/ }),
/* 7 */
/***/ (function(module, exports, __nested_webpack_require_73260__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_73260__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_73260__(1));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_73260__(2));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_73260__(3));
/* Call the listener, catch any exceptions and log, but continue operation*/
function callListener(eventThis, listener, args) {
    try {
        listener.apply(eventThis, args);
    }
    catch (e) {
        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'EventEmitter.emit()', 'Unexpected listener exception: ' + e + '; stack = ' + (e && e.stack));
    }
}
/**
 * Remove listeners that match listener
 * @param targetListeners is an array of listener arrays or event objects with arrays of listeners
 * @param listener the listener callback to remove
 * @param eventFilter (optional) event name instructing the function to only remove listeners for the specified event
 */
function removeListener(targetListeners, listener, eventFilter) {
    var listeners;
    var index;
    var eventName;
    for (var targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {
        listeners = targetListeners[targetListenersIndex];
        if (eventFilter) {
            listeners = listeners[eventFilter];
        }
        if (Utils.isArray(listeners)) {
            while ((index = Utils.arrIndexOf(listeners, listener)) !== -1) {
                listeners.splice(index, 1);
            }
            /* If events object has an event name key with no listeners then
                          remove the key to stop the list growing indefinitely */
            if (eventFilter && listeners.length === 0) {
                delete targetListeners[targetListenersIndex][eventFilter];
            }
        }
        else if (Utils.isObject(listeners)) {
            /* events */
            for (eventName in listeners) {
                if (Object.prototype.hasOwnProperty.call(listeners, eventName) && Utils.isArray(listeners[eventName])) {
                    removeListener([listeners], listener, eventName);
                }
            }
        }
    }
}
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        this.any = [];
        this.events = Object.create(null);
        this.anyOnce = [];
        this.eventsOnce = Object.create(null);
    }
    EventEmitter.prototype.on = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            var listener = args[0];
            if (typeof listener === 'function') {
                this.any.push(listener);
            }
            else {
                throw new Error('EventListener.on(): Invalid arguments: ' + platform_1.default.Config.inspect(args));
            }
        }
        if (args.length === 2) {
            var event_1 = args[0], listener_1 = args[1];
            if (typeof listener_1 !== 'function') {
                throw new Error('EventListener.on(): Invalid arguments: ' + platform_1.default.Config.inspect(args));
            }
            if (Utils.isEmptyArg(event_1)) {
                this.any.push(listener_1);
            }
            else if (Utils.isArray(event_1)) {
                event_1.forEach(function (eventName) {
                    _this.on(eventName, listener_1);
                });
            }
            else {
                if (typeof event_1 !== 'string') {
                    throw new Error('EventListener.on(): Invalid arguments: ' + platform_1.default.Config.inspect(args));
                }
                var listeners = this.events[event_1] || (this.events[event_1] = []);
                listeners.push(listener_1);
            }
        }
    };
    EventEmitter.prototype.off = function () {
        var _a;
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length == 0 || (Utils.isEmptyArg(args[0]) && Utils.isEmptyArg(args[1]))) {
            this.any = [];
            this.events = Object.create(null);
            this.anyOnce = [];
            this.eventsOnce = Object.create(null);
            return;
        }
        var firstArg = args[0], secondArg = args[1];
        var listener = null;
        var event = null;
        if (args.length === 1 || !secondArg) {
            if (typeof firstArg === 'function') {
                /* we take this to be the listener and treat the event as "any" .. */
                listener = firstArg;
            }
            else {
                event = firstArg;
            }
            /* ... or we take event to be the actual event name and listener to be all */
        }
        else {
            if (typeof secondArg !== 'function') {
                throw new Error('EventEmitter.off(): invalid arguments:' + platform_1.default.Config.inspect(args));
            }
            _a = [firstArg, secondArg], event = _a[0], listener = _a[1];
        }
        if (listener && Utils.isEmptyArg(event)) {
            removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);
            return;
        }
        if (Utils.isArray(event)) {
            event.forEach(function (eventName) {
                _this.off(eventName, listener);
            });
            return;
        }
        /* "normal" case where event is an actual event */
        if (typeof event !== 'string') {
            throw new Error('EventEmitter.off(): invalid arguments:' + platform_1.default.Config.inspect(args));
        }
        if (listener) {
            removeListener([this.events, this.eventsOnce], listener, event);
        }
        else {
            delete this.events[event];
            delete this.eventsOnce[event];
        }
    };
    /**
     * Get the array of listeners for a given event; excludes once events
     * @param event (optional) the name of the event, or none for 'any'
     * @return array of events, or null if none
     */
    EventEmitter.prototype.listeners = function (event) {
        if (event) {
            var listeners = this.events[event] || [];
            if (this.eventsOnce[event])
                Array.prototype.push.apply(listeners, this.eventsOnce[event]);
            return listeners.length ? listeners : null;
        }
        return this.any.length ? this.any : null;
    };
    /**
     * Emit an event
     * @param event the event name
     * @param args the arguments to pass to the listener
     */
    EventEmitter.prototype.emit = function (event) {
        var args = []; /* , args... */
        for (var _i = 1 /* , args... */; _i < arguments.length /* , args... */; _i++ /* , args... */) {
            args[_i - 1] = arguments[_i]; /* , args... */
        }
        var eventThis = { event: event };
        var listeners = [];
        if (this.anyOnce.length) {
            Array.prototype.push.apply(listeners, this.anyOnce);
            this.anyOnce = [];
        }
        if (this.any.length) {
            Array.prototype.push.apply(listeners, this.any);
        }
        var eventsOnceListeners = this.eventsOnce[event];
        if (eventsOnceListeners) {
            Array.prototype.push.apply(listeners, eventsOnceListeners);
            delete this.eventsOnce[event];
        }
        var eventsListeners = this.events[event];
        if (eventsListeners) {
            Array.prototype.push.apply(listeners, eventsListeners);
        }
        Utils.arrForEach(listeners, function (listener) {
            callListener(eventThis, listener, args);
        });
    };
    EventEmitter.prototype.once = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var argCount = args.length;
        if ((argCount === 0 || (argCount === 1 && typeof args[0] !== 'function')) && platform_1.default.Config.Promise) {
            var event_2 = args[0];
            return new platform_1.default.Config.Promise(function (resolve) {
                _this.once(event_2, resolve);
            });
        }
        var firstArg = args[0], secondArg = args[1];
        if (args.length === 1 && typeof firstArg === 'function') {
            this.anyOnce.push(firstArg);
        }
        else if (Utils.isEmptyArg(firstArg)) {
            if (typeof secondArg !== 'function') {
                throw new Error('EventEmitter.once(): Invalid arguments:' + platform_1.default.Config.inspect(args));
            }
            this.anyOnce.push(secondArg);
        }
        else if (Utils.isArray(firstArg)) {
            var self_1 = this;
            var listenerWrapper_1 = function () {
                var innerArgs = Array.prototype.slice.call(arguments);
                Utils.arrForEach(firstArg, function (eventName) {
                    self_1.off(eventName, listenerWrapper_1);
                });
                if (typeof secondArg !== 'function') {
                    throw new Error('EventEmitter.once(): Invalid arguments:' + platform_1.default.Config.inspect(args));
                }
                secondArg.apply(this, innerArgs);
            };
            Utils.arrForEach(firstArg, function (eventName) {
                self_1.on(eventName, listenerWrapper_1);
            });
        }
        else {
            if (typeof firstArg !== 'string') {
                throw new Error('EventEmitter.once(): Invalid arguments:' + platform_1.default.Config.inspect(args));
            }
            var listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);
            if (secondArg) {
                if (typeof secondArg !== 'function') {
                    throw new Error('EventEmitter.once(): Invalid arguments:' + platform_1.default.Config.inspect(args));
                }
                listeners.push(secondArg);
            }
        }
    };
    /**
     * Private API
     *
     * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState
     * @param targetState the name of the state event to listen to
     * @param currentState the name of the current state of this object
     * @param listener the listener to be called
     * @param listenerArgs
     */
    EventEmitter.prototype.whenState = function (targetState, currentState, listener) {
        var _this = this;
        var listenerArgs = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            listenerArgs[_i - 3] = arguments[_i];
        }
        var eventThis = { event: targetState };
        if (typeof targetState !== 'string' || typeof currentState !== 'string') {
            throw 'whenState requires a valid event String argument';
        }
        if (typeof listener !== 'function' && platform_1.default.Config.Promise) {
            return new platform_1.default.Config.Promise(function (resolve) {
                EventEmitter.prototype.whenState.apply(_this, [targetState, currentState, resolve].concat(listenerArgs));
            });
        }
        if (targetState === currentState) {
            callListener(eventThis, listener, listenerArgs);
        }
        else {
            this.once(targetState, listener);
        }
    };
    return EventEmitter;
}());
exports.default = EventEmitter;


/***/ }),
/* 8 */
/***/ (function(module, exports, __nested_webpack_require_84856__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaults = exports.normaliseOptions = exports.objectifyOptions = exports.getAgentString = exports.getHosts = exports.getFallbackHosts = exports.environmentFallbackHosts = exports.getHttpScheme = exports.getPort = exports.getHost = void 0;
var tslib_1 = __nested_webpack_require_84856__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_84856__(3));
var Utils = tslib_1.__importStar(__nested_webpack_require_84856__(1));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_84856__(2));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_84856__(4));
var package_json_1 = __nested_webpack_require_84856__(43);
var agent = 'ably-js/' + package_json_1.version;
var Defaults = {
    ENVIRONMENT: '',
    REST_HOST: 'rest.ably.io',
    REALTIME_HOST: 'realtime.ably.io',
    FALLBACK_HOSTS: [
        'A.ably-realtime.com',
        'B.ably-realtime.com',
        'C.ably-realtime.com',
        'D.ably-realtime.com',
        'E.ably-realtime.com',
    ],
    PORT: 80,
    TLS_PORT: 443,
    TIMEOUTS: {
        /* Documented as options params: */
        disconnectedRetryTimeout: 15000,
        suspendedRetryTimeout: 30000,
        /* Undocumented, but part of the api and can be used by customers: */
        httpRequestTimeout: 15000,
        channelRetryTimeout: 15000,
        fallbackRetryTimeout: 600000,
        /* For internal / test use only: */
        connectionStateTtl: 120000,
        realtimeRequestTimeout: 10000,
        recvTimeout: 90000,
        preferenceConnectTimeout: 6000,
        parallelUpgradeDelay: 6000,
    },
    httpMaxRetryCount: 3,
    maxMessageSize: 65536,
    version: package_json_1.version,
    protocolVersion: 2,
    agent: agent,
    getHost: getHost,
    getPort: getPort,
    getHttpScheme: getHttpScheme,
    environmentFallbackHosts: environmentFallbackHosts,
    getFallbackHosts: getFallbackHosts,
    getHosts: getHosts,
    checkHost: checkHost,
    objectifyOptions: objectifyOptions,
    normaliseOptions: normaliseOptions,
};
function getHost(options, host, ws) {
    if (ws)
        host = (host == options.restHost && options.realtimeHost) || host || options.realtimeHost;
    else
        host = host || options.restHost;
    return host;
}
exports.getHost = getHost;
function getPort(options, tls) {
    return tls || options.tls ? options.tlsPort : options.port;
}
exports.getPort = getPort;
function getHttpScheme(options) {
    return options.tls ? 'https://' : 'http://';
}
exports.getHttpScheme = getHttpScheme;
// construct environment fallback hosts as per RSC15i
function environmentFallbackHosts(environment) {
    return [
        environment + '-a-fallback.ably-realtime.com',
        environment + '-b-fallback.ably-realtime.com',
        environment + '-c-fallback.ably-realtime.com',
        environment + '-d-fallback.ably-realtime.com',
        environment + '-e-fallback.ably-realtime.com',
    ];
}
exports.environmentFallbackHosts = environmentFallbackHosts;
function getFallbackHosts(options) {
    var fallbackHosts = options.fallbackHosts, httpMaxRetryCount = typeof options.httpMaxRetryCount !== 'undefined' ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;
    return fallbackHosts ? Utils.arrChooseN(fallbackHosts, httpMaxRetryCount) : [];
}
exports.getFallbackHosts = getFallbackHosts;
function getHosts(options) {
    return [options.restHost].concat(getFallbackHosts(options));
}
exports.getHosts = getHosts;
function checkHost(host) {
    if (typeof host !== 'string') {
        throw new errorinfo_1.default('host must be a string; was a ' + typeof host, 40000, 400);
    }
    if (!host.length) {
        throw new errorinfo_1.default('host must not be zero-length', 40000, 400);
    }
}
function getRealtimeHost(options, production, environment) {
    if (options.realtimeHost)
        return options.realtimeHost;
    /* prefer setting realtimeHost to restHost as a custom restHost typically indicates
     * a development environment is being used that can't be inferred by the library */
    if (options.restHost) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Defaults.normaliseOptions', 'restHost is set to "' +
            options.restHost +
            '" but realtimeHost is not set, so setting realtimeHost to "' +
            options.restHost +
            '" too. If this is not what you want, please set realtimeHost explicitly.');
        return options.restHost;
    }
    return production ? Defaults.REALTIME_HOST : environment + '-' + Defaults.REALTIME_HOST;
}
function getTimeouts(options) {
    /* Allow values passed in options to override default timeouts */
    var timeouts = {};
    for (var prop in Defaults.TIMEOUTS) {
        timeouts[prop] = options[prop] || Defaults.TIMEOUTS[prop];
    }
    return timeouts;
}
function getAgentString(options) {
    var agentStr = Defaults.agent;
    if (options.agents) {
        for (var agent in options.agents) {
            agentStr += ' ' + agent + '/' + options.agents[agent];
        }
    }
    return agentStr;
}
exports.getAgentString = getAgentString;
function objectifyOptions(options) {
    if (typeof options == 'string') {
        return options.indexOf(':') == -1 ? { token: options } : { key: options };
    }
    return options;
}
exports.objectifyOptions = objectifyOptions;
function normaliseOptions(options) {
    /* Deprecated options */
    if (options.host) {
        logger_1.default.deprecated('host', 'restHost');
        options.restHost = options.host;
    }
    if (options.wsHost) {
        logger_1.default.deprecated('wsHost', 'realtimeHost');
        options.realtimeHost = options.wsHost;
    }
    if (options.queueEvents) {
        logger_1.default.deprecated('queueEvents', 'queueMessages');
        options.queueMessages = options.queueEvents;
    }
    if (options.fallbackHostsUseDefault) {
        /* fallbackHostsUseDefault and fallbackHosts are mutually exclusive as per TO3k7 */
        if (options.fallbackHosts) {
            var msg = 'fallbackHosts and fallbackHostsUseDefault cannot both be set';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Defaults.normaliseOptions', msg);
            throw new errorinfo_1.default(msg, 40000, 400);
        }
        /* default fallbacks can't be used with custom ports */
        if (options.port || options.tlsPort) {
            var msg = 'fallbackHostsUseDefault cannot be set when port or tlsPort are set';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Defaults.normaliseOptions', msg);
            throw new errorinfo_1.default(msg, 40000, 400);
        }
        /* emit an appropriate deprecation warning */
        if (options.environment) {
            logger_1.default.deprecatedWithMsg('fallbackHostsUseDefault', 'There is no longer a need to set this when the environment option is also set since the library will now generate the correct fallback hosts using the environment option.');
        }
        else {
            logger_1.default.deprecated('fallbackHostsUseDefault', 'fallbackHosts: Ably.Defaults.FALLBACK_HOSTS');
        }
        /* use the default fallback hosts as requested */
        options.fallbackHosts = Defaults.FALLBACK_HOSTS;
    }
    /* options.recover as a boolean is deprecated, and therefore is not part of the public typing */
    if (options.recover === true) {
        logger_1.default.deprecated('{recover: true}', '{recover: function(lastConnectionDetails, cb) { cb(true); }}');
        options.recover = function (lastConnectionDetails, cb) {
            cb(true);
        };
    }
    if (typeof options.recover === 'function' && options.closeOnUnload === true) {
        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Defaults.normaliseOptions', 'closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter');
        options.recover = undefined;
    }
    if (!('closeOnUnload' in options)) {
        /* Have closeOnUnload default to true unless we have any indication that
         * the user may want to recover the connection */
        options.closeOnUnload = !options.recover;
    }
    if (options.transports && Utils.arrIn(options.transports, 'xhr')) {
        logger_1.default.deprecated('transports: ["xhr"]', 'transports: ["xhr_streaming"]');
        Utils.arrDeleteValue(options.transports, 'xhr');
        options.transports.push('xhr_streaming');
    }
    if (!('queueMessages' in options))
        options.queueMessages = true;
    /* infer hosts and fallbacks based on the configured environment */
    var environment = (options.environment && String(options.environment).toLowerCase()) || Defaults.ENVIRONMENT;
    var production = !environment || environment === 'production';
    if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {
        options.fallbackHosts = production ? Defaults.FALLBACK_HOSTS : environmentFallbackHosts(environment);
    }
    var restHost = options.restHost || (production ? Defaults.REST_HOST : environment + '-' + Defaults.REST_HOST);
    var realtimeHost = getRealtimeHost(options, production, environment);
    Utils.arrForEach((options.fallbackHosts || []).concat(restHost, realtimeHost), checkHost);
    options.port = options.port || Defaults.PORT;
    options.tlsPort = options.tlsPort || Defaults.TLS_PORT;
    if (!('tls' in options))
        options.tls = true;
    var timeouts = getTimeouts(options);
    if ('useBinaryProtocol' in options) {
        options.useBinaryProtocol = platform_1.default.Config.supportsBinary && options.useBinaryProtocol;
    }
    else {
        options.useBinaryProtocol = platform_1.default.Config.preferBinary;
    }
    if (options.clientId) {
        var headers = (options.headers = options.headers || {});
        headers['X-Ably-ClientId'] = platform_1.default.BufferUtils.base64Encode(platform_1.default.BufferUtils.utf8Encode(options.clientId));
    }
    if (!('idempotentRestPublishing' in options)) {
        options.idempotentRestPublishing = true;
    }
    if (options.promises && !platform_1.default.Config.Promise) {
        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Defaults.normaliseOptions', '{promises: true} was specified, but no Promise constructor found; disabling promises');
        options.promises = false;
    }
    var connectivityCheckParams = null;
    var connectivityCheckUrl = options.connectivityCheckUrl;
    if (options.connectivityCheckUrl) {
        var _a = options.connectivityCheckUrl.split('?'), uri = _a[0], qs = _a[1];
        connectivityCheckParams = qs ? Utils.parseQueryString(qs) : {};
        if (uri.indexOf('://') === -1) {
            uri = 'https://' + uri;
        }
        connectivityCheckUrl = uri;
    }
    return tslib_1.__assign(tslib_1.__assign({}, options), { useBinaryProtocol: 'useBinaryProtocol' in options
            ? platform_1.default.Config.supportsBinary && options.useBinaryProtocol
            : platform_1.default.Config.preferBinary, realtimeHost: realtimeHost, restHost: restHost, maxMessageSize: options.maxMessageSize || Defaults.maxMessageSize, timeouts: timeouts, connectivityCheckParams: connectivityCheckParams, connectivityCheckUrl: connectivityCheckUrl });
}
exports.normaliseOptions = normaliseOptions;
exports.default = Defaults;
function getDefaults(platformDefaults) {
    return Object.assign(Defaults, platformDefaults);
}
exports.getDefaults = getDefaults;


/***/ }),
/* 9 */
/***/ (function(module, exports, __nested_webpack_require_96442__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_96442__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_96442__(3));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_96442__(2));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_96442__(4));
var Utils = tslib_1.__importStar(__nested_webpack_require_96442__(1));
function normaliseContext(context) {
    if (!context || !context.channelOptions) {
        return {
            channelOptions: context,
            plugins: {},
            baseEncodedPreviousPayload: undefined,
        };
    }
    return context;
}
function normalizeCipherOptions(options) {
    if (options && options.cipher) {
        if (!platform_1.default.Crypto)
            throw new Error('Encryption not enabled; use ably.encryption.js instead');
        var cipher = platform_1.default.Crypto.getCipher(options.cipher);
        return {
            cipher: cipher.cipherParams,
            channelCipher: cipher.cipher,
        };
    }
    return options !== null && options !== void 0 ? options : {};
}
function getMessageSize(msg) {
    var size = 0;
    if (msg.name) {
        size += msg.name.length;
    }
    if (msg.clientId) {
        size += msg.clientId.length;
    }
    if (msg.extras) {
        size += JSON.stringify(msg.extras).length;
    }
    if (msg.data) {
        size += Utils.dataSizeBytes(msg.data);
    }
    return size;
}
var Message = /** @class */ (function () {
    function Message() {
    }
    /**
     * Overload toJSON() to intercept JSON.stringify()
     * @return {*}
     */
    Message.prototype.toJSON = function () {
        /* encode data to base64 if present and we're returning real JSON;
         * although msgpack calls toJSON(), we know it is a stringify()
         * call if it has a non-empty arguments list */
        var encoding = this.encoding;
        var data = this.data;
        if (data && platform_1.default.BufferUtils.isBuffer(data)) {
            if (arguments.length > 0) {
                /* stringify call */
                encoding = encoding ? encoding + '/base64' : 'base64';
                data = platform_1.default.BufferUtils.base64Encode(data);
            }
            else {
                /* Called by msgpack. toBuffer returns a datatype understandable by
                 * that platform's msgpack implementation (Buffer in node, Uint8Array
                 * in browsers) */
                data = platform_1.default.BufferUtils.toBuffer(data);
            }
        }
        return {
            name: this.name,
            id: this.id,
            clientId: this.clientId,
            connectionId: this.connectionId,
            connectionKey: this.connectionKey,
            extras: this.extras,
            encoding: encoding,
            data: data,
        };
    };
    Message.prototype.toString = function () {
        var result = '[Message';
        if (this.name)
            result += '; name=' + this.name;
        if (this.id)
            result += '; id=' + this.id;
        if (this.timestamp)
            result += '; timestamp=' + this.timestamp;
        if (this.clientId)
            result += '; clientId=' + this.clientId;
        if (this.connectionId)
            result += '; connectionId=' + this.connectionId;
        if (this.encoding)
            result += '; encoding=' + this.encoding;
        if (this.extras)
            result += '; extras =' + JSON.stringify(this.extras);
        if (this.data) {
            if (typeof this.data == 'string')
                result += '; data=' + this.data;
            else if (platform_1.default.BufferUtils.isBuffer(this.data))
                result += '; data (buffer)=' + platform_1.default.BufferUtils.base64Encode(this.data);
            else
                result += '; data (json)=' + JSON.stringify(this.data);
        }
        if (this.extras)
            result += '; extras=' + JSON.stringify(this.extras);
        result += ']';
        return result;
    };
    Message.encrypt = function (msg, options, callback) {
        var data = msg.data, encoding = msg.encoding, cipher = options.channelCipher;
        encoding = encoding ? encoding + '/' : '';
        if (!platform_1.default.BufferUtils.isBuffer(data)) {
            data = platform_1.default.BufferUtils.utf8Encode(String(data));
            encoding = encoding + 'utf-8/';
        }
        cipher.encrypt(data, function (err, data) {
            if (err) {
                callback(err);
                return;
            }
            msg.data = data;
            msg.encoding = encoding + 'cipher+' + cipher.algorithm;
            callback(null, msg);
        });
    };
    Message.encode = function (msg, options, callback) {
        var data = msg.data;
        var nativeDataType = typeof data == 'string' || platform_1.default.BufferUtils.isBuffer(data) || data === null || data === undefined;
        if (!nativeDataType) {
            if (Utils.isObject(data) || Utils.isArray(data)) {
                msg.data = JSON.stringify(data);
                msg.encoding = msg.encoding ? msg.encoding + '/json' : 'json';
            }
            else {
                throw new errorinfo_1.default('Data type is unsupported', 40013, 400);
            }
        }
        if (options != null && options.cipher) {
            Message.encrypt(msg, options, callback);
        }
        else {
            callback(null, msg);
        }
    };
    Message.encodeArray = function (messages, options, callback) {
        var processed = 0;
        for (var i = 0; i < messages.length; i++) {
            Message.encode(messages[i], options, function (err) {
                if (err) {
                    callback(err);
                    return;
                }
                processed++;
                if (processed == messages.length) {
                    callback(null, messages);
                }
            });
        }
    };
    Message.decode = function (message, inputContext) {
        var context = normaliseContext(inputContext);
        var lastPayload = message.data;
        var encoding = message.encoding;
        if (encoding) {
            var xforms = encoding.split('/');
            var lastProcessedEncodingIndex = void 0, encodingsToProcess = xforms.length, data = message.data;
            var xform = '';
            try {
                while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {
                    // eslint-disable-next-line security/detect-unsafe-regex
                    var match = xforms[--encodingsToProcess].match(/([-\w]+)(\+([\w-]+))?/);
                    if (!match)
                        break;
                    xform = match[1];
                    switch (xform) {
                        case 'base64':
                            data = platform_1.default.BufferUtils.base64Decode(String(data));
                            if (lastProcessedEncodingIndex == xforms.length) {
                                lastPayload = data;
                            }
                            continue;
                        case 'utf-8':
                            data = platform_1.default.BufferUtils.utf8Decode(data);
                            continue;
                        case 'json':
                            data = JSON.parse(data);
                            continue;
                        case 'cipher':
                            if (context.channelOptions != null &&
                                context.channelOptions.cipher &&
                                context.channelOptions.channelCipher) {
                                var xformAlgorithm = match[3], cipher = context.channelOptions.channelCipher;
                                /* don't attempt to decrypt unless the cipher params are compatible */
                                if (xformAlgorithm != cipher.algorithm) {
                                    throw new Error('Unable to decrypt message with given cipher; incompatible cipher params');
                                }
                                data = cipher.decrypt(data);
                                continue;
                            }
                            else {
                                throw new Error('Unable to decrypt message; not an encrypted channel');
                            }
                        case 'vcdiff':
                            if (!context.plugins || !context.plugins.vcdiff) {
                                throw new errorinfo_1.default('Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)', 40019, 400);
                            }
                            if (typeof Uint8Array === 'undefined') {
                                throw new errorinfo_1.default('Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)', 40020, 400);
                            }
                            try {
                                var deltaBase = context.baseEncodedPreviousPayload;
                                if (typeof deltaBase === 'string') {
                                    deltaBase = platform_1.default.BufferUtils.utf8Encode(deltaBase);
                                }
                                /* vcdiff expects Uint8Arrays, can't copy with ArrayBuffers. (also, if we
                                 * don't have a TextDecoder, deltaBase might be a WordArray here, so need
                                 * to process it into a buffer anyway) */
                                deltaBase = platform_1.default.BufferUtils.toBuffer(deltaBase);
                                data = platform_1.default.BufferUtils.toBuffer(data);
                                data = platform_1.default.BufferUtils.typedArrayToBuffer(context.plugins.vcdiff.decode(data, deltaBase));
                                lastPayload = data;
                            }
                            catch (e) {
                                throw new errorinfo_1.default('Vcdiff delta decode failed with ' + e, 40018, 400);
                            }
                            continue;
                        default:
                            throw new Error('Unknown encoding');
                    }
                }
            }
            catch (e) {
                var err = e;
                throw new errorinfo_1.default('Error processing the ' + xform + ' encoding, decoder returned ‘' + err.message + '’', err.code || 40013, 400);
            }
            finally {
                message.encoding =
                    lastProcessedEncodingIndex <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join('/');
                message.data = data;
            }
        }
        context.baseEncodedPreviousPayload = lastPayload;
    };
    Message.fromResponseBody = function (body, options, format) {
        if (format) {
            body = Utils.decodeBody(body, format);
        }
        for (var i = 0; i < body.length; i++) {
            var msg = (body[i] = Message.fromValues(body[i]));
            try {
                Message.decode(msg, options);
            }
            catch (e) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Message.fromResponseBody()', e.toString());
            }
        }
        return body;
    };
    Message.fromValues = function (values) {
        return Object.assign(new Message(), values);
    };
    Message.fromValuesArray = function (values) {
        var count = values.length, result = new Array(count);
        for (var i = 0; i < count; i++)
            result[i] = Message.fromValues(values[i]);
        return result;
    };
    Message.fromEncoded = function (encoded, inputOptions) {
        var msg = Message.fromValues(encoded);
        var options = normalizeCipherOptions(inputOptions !== null && inputOptions !== void 0 ? inputOptions : null);
        /* if decoding fails at any point, catch and return the message decoded to
         * the fullest extent possible */
        try {
            Message.decode(msg, options);
        }
        catch (e) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Message.fromEncoded()', e.toString());
        }
        return msg;
    };
    Message.fromEncodedArray = function (encodedArray, options) {
        return encodedArray.map(function (encoded) {
            return Message.fromEncoded(encoded, options);
        });
    };
    /* This should be called on encode()d (and encrypt()d) Messages (as it
     * assumes the data is a string or buffer) */
    Message.getMessagesSize = function (messages) {
        var msg, total = 0;
        for (var i = 0; i < messages.length; i++) {
            msg = messages[i];
            total += msg.size || (msg.size = getMessageSize(msg));
        }
        return total;
    };
    Message.serialize = Utils.encodeBody;
    return Message;
}());
exports.default = Message;


/***/ }),
/* 10 */
/***/ (function(module, exports, __nested_webpack_require_109505__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_109505__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_109505__(1));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_109505__(4));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_109505__(9));
var presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_109505__(15));
var actions = {
    HEARTBEAT: 0,
    ACK: 1,
    NACK: 2,
    CONNECT: 3,
    CONNECTED: 4,
    DISCONNECT: 5,
    DISCONNECTED: 6,
    CLOSE: 7,
    CLOSED: 8,
    ERROR: 9,
    ATTACH: 10,
    ATTACHED: 11,
    DETACH: 12,
    DETACHED: 13,
    PRESENCE: 14,
    MESSAGE: 15,
    SYNC: 16,
    AUTH: 17,
    ACTIVATE: 18,
};
var ActionName = [];
Object.keys(actions).forEach(function (name) {
    ActionName[actions[name]] = name;
});
var flags = {
    /* Channel attach state flags */
    HAS_PRESENCE: 1 << 0,
    HAS_BACKLOG: 1 << 1,
    RESUMED: 1 << 2,
    TRANSIENT: 1 << 4,
    ATTACH_RESUME: 1 << 5,
    /* Channel mode flags */
    PRESENCE: 1 << 16,
    PUBLISH: 1 << 17,
    SUBSCRIBE: 1 << 18,
    PRESENCE_SUBSCRIBE: 1 << 19,
};
var flagNames = Object.keys(flags);
flags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;
function toStringArray(array) {
    var result = [];
    if (array) {
        for (var i = 0; i < array.length; i++) {
            result.push(array[i].toString());
        }
    }
    return '[ ' + result.join(', ') + ' ]';
}
var simpleAttributes = 'id channel channelSerial connectionId count msgSerial timestamp'.split(' ');
var ProtocolMessage = /** @class */ (function () {
    function ProtocolMessage() {
        var _this = this;
        this.hasFlag = function (flag) {
            return (_this.flags & flags[flag]) > 0;
        };
    }
    ProtocolMessage.prototype.setFlag = function (flag) {
        return (this.flags = this.flags | flags[flag]);
    };
    ProtocolMessage.prototype.getMode = function () {
        return this.flags && this.flags & flags.MODE_ALL;
    };
    ProtocolMessage.prototype.encodeModesToFlags = function (modes) {
        var _this = this;
        modes.forEach(function (mode) { return _this.setFlag(mode); });
    };
    ProtocolMessage.prototype.decodeModesFromFlags = function () {
        var _this = this;
        var modes = [];
        ProtocolMessage.channelModes.forEach(function (mode) {
            if (_this.hasFlag(mode)) {
                modes.push(mode);
            }
        });
        return modes.length > 0 ? modes : undefined;
    };
    ProtocolMessage.fromValues = function (values) {
        return Object.assign(new ProtocolMessage(), values);
    };
    ProtocolMessage.Action = actions;
    ProtocolMessage.channelModes = ['PRESENCE', 'PUBLISH', 'SUBSCRIBE', 'PRESENCE_SUBSCRIBE'];
    ProtocolMessage.ActionName = ActionName;
    ProtocolMessage.serialize = Utils.encodeBody;
    ProtocolMessage.deserialize = function (serialized, format) {
        var deserialized = Utils.decodeBody(serialized, format);
        return ProtocolMessage.fromDeserialized(deserialized);
    };
    ProtocolMessage.fromDeserialized = function (deserialized) {
        var error = deserialized.error;
        if (error)
            deserialized.error = errorinfo_1.default.fromValues(error);
        var messages = deserialized.messages;
        if (messages)
            for (var i = 0; i < messages.length; i++)
                messages[i] = message_1.default.fromValues(messages[i]);
        var presence = deserialized.presence;
        if (presence)
            for (var i = 0; i < presence.length; i++)
                presence[i] = presencemessage_1.default.fromValues(presence[i], true);
        return Object.assign(new ProtocolMessage(), deserialized);
    };
    ProtocolMessage.stringify = function (msg) {
        var result = '[ProtocolMessage';
        if (msg.action !== undefined)
            result += '; action=' + ProtocolMessage.ActionName[msg.action] || 0;
        var attribute;
        for (var attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {
            attribute = simpleAttributes[attribIndex];
            if (msg[attribute] !== undefined)
                result += '; ' + attribute + '=' + msg[attribute];
        }
        if (msg.messages)
            result += '; messages=' + toStringArray(message_1.default.fromValuesArray(msg.messages));
        if (msg.presence)
            result += '; presence=' + toStringArray(presencemessage_1.default.fromValuesArray(msg.presence));
        if (msg.error)
            result += '; error=' + errorinfo_1.default.fromValues(msg.error).toString();
        if (msg.auth && msg.auth.accessToken)
            result += '; token=' + msg.auth.accessToken;
        if (msg.flags)
            result += '; flags=' + flagNames.filter(msg.hasFlag).join(',');
        if (msg.params) {
            var stringifiedParams_1 = '';
            Utils.forInOwnNonNullProperties(msg.params, function (prop) {
                if (stringifiedParams_1.length > 0) {
                    stringifiedParams_1 += '; ';
                }
                stringifiedParams_1 += prop + '=' + msg.params[prop];
            });
            if (stringifiedParams_1.length > 0) {
                result += '; params=[' + stringifiedParams_1 + ']';
            }
        }
        result += ']';
        return result;
    };
    return ProtocolMessage;
}());
exports.default = ProtocolMessage;


/***/ }),
/* 11 */
/***/ (function(module, exports, __nested_webpack_require_115059__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_115059__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        }
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              var bitsCombined = bits1 | bits2;
	              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),
/* 12 */
/***/ (function(module, exports, __nested_webpack_require_119082__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_119082__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_119082__(1));
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(10));
var transport_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(26));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(2));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(8));
var connectionerrors_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(20));
var auth_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(17));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(4));
var XHRStates_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(21));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(3));
/* TODO: can remove once realtime sends protocol message responses for comet errors */
function shouldBeErrorAction(err) {
    var UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];
    if (err.code) {
        if (auth_1.default.isTokenErr(err))
            return false;
        if (Utils.arrIn(UNRESOLVABLE_ERROR_CODES, err.code))
            return true;
        return err.code >= 40000 && err.code < 50000;
    }
    else {
        /* Likely a network or transport error of some kind. Certainly not fatal to the connection */
        return false;
    }
}
function protocolMessageFromRawError(err) {
    /* err will be either a legacy (non-protocolmessage) comet error response
     * (which will have an err.code), or a xhr/network error (which won't). */
    if (shouldBeErrorAction(err)) {
        return [protocolmessage_1.default.fromValues({ action: protocolmessage_1.default.Action.ERROR, error: err })];
    }
    else {
        return [protocolmessage_1.default.fromValues({ action: protocolmessage_1.default.Action.DISCONNECTED, error: err })];
    }
}
/*
 * A base comet transport class
 */
var CometTransport = /** @class */ (function (_super) {
    tslib_1.__extends(CometTransport, _super);
    function CometTransport(connectionManager, auth, params) {
        var _this = _super.call(this, connectionManager, auth, params, /* binary not supported for comet so force JSON protocol */ true) || this;
        /* For comet, we could do the auth update by aborting the current recv and
         * starting a new one with the new token, that'd be sufficient for realtime.
         * Problem is JSONP - you can't cancel truly abort a recv once started. So
         * we need to send an AUTH for jsonp. In which case it's simpler to keep all
         * comet transports the same and do it for all of them. So we send the AUTH
         * instead, and don't need to abort the recv */
        _this.onAuthUpdated = function (tokenDetails) {
            _this.authParams = { access_token: tokenDetails.token };
        };
        _this.stream = 'stream' in params ? params.stream : true;
        _this.sendRequest = null;
        _this.recvRequest = null;
        _this.pendingCallback = null;
        _this.pendingItems = null;
        return _this;
    }
    CometTransport.prototype.connect = function () {
        var _this = this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.connect()', 'starting');
        transport_1.default.prototype.connect.call(this);
        var params = this.params;
        var options = params.options;
        var host = defaults_1.default.getHost(options, params.host);
        var port = defaults_1.default.getPort(options);
        var cometScheme = options.tls ? 'https://' : 'http://';
        this.baseUri = cometScheme + host + ':' + port + '/comet/';
        var connectUri = this.baseUri + 'connect';
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.connect()', 'uri: ' + connectUri);
        this.auth.getAuthParams(function (err, authParams) {
            if (err) {
                _this.disconnect(err);
                return;
            }
            if (_this.isDisposed) {
                return;
            }
            _this.authParams = authParams;
            var connectParams = _this.params.getConnectParams(authParams);
            if ('stream' in connectParams)
                _this.stream = connectParams.stream;
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.connect()', 'connectParams:' + Utils.toQueryString(connectParams));
            /* this will be the 'recvRequest' so this connection can stream messages */
            var preconnected = false;
            var connectRequest = (_this.recvRequest = _this.createRequest(connectUri, null, connectParams, null, _this.stream ? XHRStates_1.default.REQ_RECV_STREAM : XHRStates_1.default.REQ_RECV));
            connectRequest.on('data', function (data) {
                if (!_this.recvRequest) {
                    /* the transport was disposed before we connected */
                    return;
                }
                if (!preconnected) {
                    preconnected = true;
                    _this.emit('preconnect');
                }
                _this.onData(data);
            });
            connectRequest.on('complete', function (err) {
                if (!_this.recvRequest) {
                    /* the transport was disposed before we connected */
                    err = err || new errorinfo_1.default('Request cancelled', 80003, 400);
                }
                _this.recvRequest = null;
                /* Connect request may complete without a emitting 'data' event since that is not
                 * emitted for e.g. a non-streamed error response. Still implies preconnect. */
                if (!preconnected && !err) {
                    preconnected = true;
                    _this.emit('preconnect');
                }
                _this.onActivity();
                if (err) {
                    if (err.code) {
                        /* A protocol error received from realtime. TODO: once realtime
                         * consistendly sends errors wrapped in protocol messages, should be
                         * able to remove this */
                        _this.onData(protocolMessageFromRawError(err));
                    }
                    else {
                        /* A network/xhr error. Don't bother wrapping in a protocol message,
                         * just disconnect the transport */
                        _this.disconnect(err);
                    }
                    return;
                }
                platform_1.default.Config.nextTick(function () {
                    _this.recv();
                });
            });
            connectRequest.exec();
        });
    };
    CometTransport.prototype.requestClose = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.requestClose()');
        this._requestCloseOrDisconnect(true);
    };
    CometTransport.prototype.requestDisconnect = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.requestDisconnect()');
        this._requestCloseOrDisconnect(false);
    };
    CometTransport.prototype._requestCloseOrDisconnect = function (closing) {
        var _this = this;
        var closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;
        if (closeOrDisconnectUri) {
            var request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, XHRStates_1.default.REQ_SEND);
            request.on('complete', function (err) {
                if (err) {
                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'CometTransport.request' + (closing ? 'Close()' : 'Disconnect()'), 'request returned err = ' + Utils.inspectError(err));
                    _this.finish('disconnected', err);
                }
            });
            request.exec();
        }
    };
    CometTransport.prototype.dispose = function () {
        var _this = this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.dispose()', '');
        if (!this.isDisposed) {
            this.isDisposed = true;
            if (this.recvRequest) {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.dispose()', 'aborting recv request');
                this.recvRequest.abort();
                this.recvRequest = null;
            }
            /* In almost all cases the transport will be finished before it's
             * disposed. Finish here just to make sure. */
            this.finish('disconnected', connectionerrors_1.default.disconnected());
            platform_1.default.Config.nextTick(function () {
                _this.emit('disposed');
            });
        }
    };
    CometTransport.prototype.onConnect = function (message) {
        var _a;
        /* if this transport has been disposed whilst awaiting connection, do nothing */
        if (this.isDisposed) {
            return;
        }
        /* the connectionKey in a comet connected response is really
         * <instId>-<connectionKey> */
        var connectionStr = (_a = message.connectionDetails) === null || _a === void 0 ? void 0 : _a.connectionKey;
        transport_1.default.prototype.onConnect.call(this, message);
        var baseConnectionUri = this.baseUri + connectionStr;
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'CometTransport.onConnect()', 'baseUri = ' + baseConnectionUri);
        this.sendUri = baseConnectionUri + '/send';
        this.recvUri = baseConnectionUri + '/recv';
        this.closeUri = baseConnectionUri + '/close';
        this.disconnectUri = baseConnectionUri + '/disconnect';
    };
    CometTransport.prototype.send = function (message) {
        if (this.sendRequest) {
            /* there is a pending send, so queue this message */
            this.pendingItems = this.pendingItems || [];
            this.pendingItems.push(message);
            return;
        }
        /* send this, plus any pending, now */
        var pendingItems = this.pendingItems || [];
        pendingItems.push(message);
        this.pendingItems = null;
        this.sendItems(pendingItems);
    };
    CometTransport.prototype.sendAnyPending = function () {
        var pendingItems = this.pendingItems;
        if (!pendingItems) {
            return;
        }
        this.pendingItems = null;
        this.sendItems(pendingItems);
    };
    CometTransport.prototype.sendItems = function (items) {
        var _this = this;
        var sendRequest = (this.sendRequest = this.createRequest(this.sendUri, null, this.authParams, this.encodeRequest(items), XHRStates_1.default.REQ_SEND));
        sendRequest.on('complete', function (err, data) {
            if (err)
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'CometTransport.sendItems()', 'on complete: err = ' + Utils.inspectError(err));
            _this.sendRequest = null;
            /* the result of the request, even if a nack, is usually a protocol response
             * contained in the data. An err is anomolous, and indicates some issue with the
             * network,transport, or connection */
            if (err) {
                if (err.code) {
                    /* A protocol error received from realtime. TODO: once realtime
                     * consistendly sends errors wrapped in protocol messages, should be
                     * able to remove this */
                    _this.onData(protocolMessageFromRawError(err));
                }
                else {
                    /* A network/xhr error. Don't bother wrapping in a protocol message,
                     * just disconnect the transport */
                    _this.disconnect(err);
                }
                return;
            }
            if (data) {
                _this.onData(data);
            }
            if (_this.pendingItems) {
                platform_1.default.Config.nextTick(function () {
                    /* If there's a new send request by now, any pending items will have
                     * been picked up by that; any new ones added since then will be
                     * picked up after that one completes */
                    if (!_this.sendRequest) {
                        _this.sendAnyPending();
                    }
                });
            }
        });
        sendRequest.exec();
    };
    CometTransport.prototype.recv = function () {
        var _this = this;
        /* do nothing if there is an active request, which might be streaming */
        if (this.recvRequest)
            return;
        /* If we're no longer connected, do nothing */
        if (!this.isConnected)
            return;
        var recvRequest = (this.recvRequest = this.createRequest(this.recvUri, null, this.authParams, null, this.stream ? XHRStates_1.default.REQ_RECV_STREAM : XHRStates_1.default.REQ_RECV_POLL));
        recvRequest.on('data', function (data) {
            _this.onData(data);
        });
        recvRequest.on('complete', function (err) {
            _this.recvRequest = null;
            /* A request completing must be considered activity, as realtime sends
             * heartbeats every 15s since a request began, not every 15s absolutely */
            _this.onActivity();
            if (err) {
                if (err.code) {
                    /* A protocol error received from realtime. TODO: once realtime
                     * consistently sends errors wrapped in protocol messages, should be
                     * able to remove this */
                    _this.onData(protocolMessageFromRawError(err));
                }
                else {
                    /* A network/xhr error. Don't bother wrapping in a protocol message,
                     * just disconnect the transport */
                    _this.disconnect(err);
                }
                return;
            }
            platform_1.default.Config.nextTick(function () {
                _this.recv();
            });
        });
        recvRequest.exec();
    };
    CometTransport.prototype.onData = function (responseData) {
        try {
            var items = this.decodeResponse(responseData);
            if (items && items.length)
                for (var i = 0; i < items.length; i++)
                    this.onProtocolMessage(protocolmessage_1.default.fromDeserialized(items[i]));
        }
        catch (e) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'CometTransport.onData()', 'Unexpected exception handing channel event: ' + e.stack);
        }
    };
    CometTransport.prototype.encodeRequest = function (requestItems) {
        return JSON.stringify(requestItems);
    };
    CometTransport.prototype.decodeResponse = function (responseData) {
        if (typeof responseData == 'string')
            return JSON.parse(responseData);
        return responseData;
    };
    return CometTransport;
}(transport_1.default));
exports.default = CometTransport;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 14 */
/***/ (function(module, exports, __nested_webpack_require_134706__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_134706__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_134706__(3));
var Utils = tslib_1.__importStar(__nested_webpack_require_134706__(1));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_134706__(2));
var auth_1 = tslib_1.__importDefault(__nested_webpack_require_134706__(17));
var HttpMethods_1 = tslib_1.__importDefault(__nested_webpack_require_134706__(18));
var errorinfo_1 = __nested_webpack_require_134706__(4);
function withAuthDetails(rest, headers, params, errCallback, opCallback) {
    if (rest.http.supportsAuthHeaders) {
        rest.auth.getAuthHeaders(function (err, authHeaders) {
            if (err)
                errCallback(err);
            else
                opCallback(Utils.mixin(authHeaders, headers), params);
        });
    }
    else {
        rest.auth.getAuthParams(function (err, authParams) {
            if (err)
                errCallback(err);
            else
                opCallback(headers, Utils.mixin(authParams, params));
        });
    }
}
function unenvelope(callback, format) {
    return function (err, body, outerHeaders, unpacked, outerStatusCode) {
        if (err && !body) {
            callback(err);
            return;
        }
        if (!unpacked) {
            try {
                body = Utils.decodeBody(body, format);
            }
            catch (e) {
                if (Utils.isErrorInfoOrPartialErrorInfo(e)) {
                    callback(e);
                }
                else {
                    callback(new errorinfo_1.PartialErrorInfo(Utils.inspectError(e), null));
                }
                return;
            }
        }
        if (!body) {
            callback(new errorinfo_1.PartialErrorInfo('unenvelope(): Response body is missing', null));
            return;
        }
        var _a = body, wrappedStatusCode = _a.statusCode, response = _a.response, wrappedHeaders = _a.headers;
        if (wrappedStatusCode === undefined) {
            /* Envelope already unwrapped by the transport */
            callback(err, body, outerHeaders, true, outerStatusCode);
            return;
        }
        if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {
            /* handle wrapped errors */
            var wrappedErr = (response && response.error) || err;
            if (!wrappedErr) {
                wrappedErr = new Error('Error in unenveloping ' + body);
                wrappedErr.statusCode = wrappedStatusCode;
            }
            callback(wrappedErr, response, wrappedHeaders, true, wrappedStatusCode);
            return;
        }
        callback(err, response, wrappedHeaders, true, wrappedStatusCode);
    };
}
function paramString(params) {
    var paramPairs = [];
    if (params) {
        for (var needle in params) {
            paramPairs.push(needle + '=' + params[needle]);
        }
    }
    return paramPairs.join('&');
}
function urlFromPathAndParams(path, params) {
    return path + (params ? '?' : '') + paramString(params);
}
function logResponseHandler(callback, method, path, params) {
    return function (err, body, headers, unpacked, statusCode) {
        if (err) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Received Error; ' + urlFromPathAndParams(path, params) + '; Error: ' + Utils.inspectError(err));
        }
        else {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Received; ' +
                urlFromPathAndParams(path, params) +
                '; Headers: ' +
                paramString(headers) +
                '; StatusCode: ' +
                statusCode +
                '; Body: ' +
                (platform_1.default.BufferUtils.isBuffer(body) ? body.toString() : body));
        }
        if (callback) {
            callback(err, body, headers, unpacked, statusCode);
        }
    };
}
var Resource = /** @class */ (function () {
    function Resource() {
    }
    Resource.get = function (rest, path, headers, params, envelope, callback) {
        Resource.do(HttpMethods_1.default.Get, rest, path, null, headers, params, envelope, callback);
    };
    Resource.delete = function (rest, path, headers, params, envelope, callback) {
        Resource.do(HttpMethods_1.default.Delete, rest, path, null, headers, params, envelope, callback);
    };
    Resource.post = function (rest, path, body, headers, params, envelope, callback) {
        Resource.do(HttpMethods_1.default.Post, rest, path, body, headers, params, envelope, callback);
    };
    Resource.patch = function (rest, path, body, headers, params, envelope, callback) {
        Resource.do(HttpMethods_1.default.Patch, rest, path, body, headers, params, envelope, callback);
    };
    Resource.put = function (rest, path, body, headers, params, envelope, callback) {
        Resource.do(HttpMethods_1.default.Put, rest, path, body, headers, params, envelope, callback);
    };
    Resource.do = function (method, rest, path, body, headers, params, envelope, callback) {
        if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {
            callback = logResponseHandler(callback, method, path, params);
        }
        if (envelope) {
            callback = callback && unenvelope(callback, envelope);
            (params = params || {})['envelope'] = envelope;
        }
        function doRequest(headers, params) {
            var _a;
            if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Sending; ' + urlFromPathAndParams(path, params));
            }
            if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {
                var decodedBody = body;
                if (((_a = headers['content-type']) === null || _a === void 0 ? void 0 : _a.indexOf('msgpack')) > 0) {
                    try {
                        decodedBody = platform_1.default.Config.msgpack.decode(body);
                    }
                    catch (decodeErr) {
                        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Sending MsgPack Decoding Error: ' + Utils.inspectError(decodeErr));
                    }
                }
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Sending; ' + urlFromPathAndParams(path, params) + '; Body: ' + decodedBody);
            }
            rest.http.do(method, rest, path, headers, body, params, function (err, res, headers, unpacked, statusCode) {
                if (err && auth_1.default.isTokenErr(err)) {
                    /* token has expired, so get a new one */
                    rest.auth.authorize(null, null, function (err) {
                        if (err) {
                            callback(err);
                            return;
                        }
                        /* retry ... */
                        withAuthDetails(rest, headers, params, callback, doRequest);
                    });
                    return;
                }
                callback(err, res, headers, unpacked, statusCode);
            });
        }
        withAuthDetails(rest, headers, params, callback, doRequest);
    };
    return Resource;
}());
exports.default = Resource;


/***/ }),
/* 15 */
/***/ (function(module, exports, __nested_webpack_require_142181__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_142181__(0);
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_142181__(2));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_142181__(3));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_142181__(9));
var Utils = tslib_1.__importStar(__nested_webpack_require_142181__(1));
function toActionValue(actionString) {
    return PresenceMessage.Actions.indexOf(actionString);
}
var PresenceMessage = /** @class */ (function () {
    function PresenceMessage() {
    }
    /* Returns whether this presenceMessage is synthesized, i.e. was not actually
     * sent by the connection (usually means a leave event sent 15s after a
     * disconnection). This is useful because synthesized messages cannot be
     * compared for newness by id lexicographically - RTP2b1
     */
    PresenceMessage.prototype.isSynthesized = function () {
        if (!this.id || !this.connectionId) {
            return true;
        }
        return this.id.substring(this.connectionId.length, 0) !== this.connectionId;
    };
    /* RTP2b2 */
    PresenceMessage.prototype.parseId = function () {
        if (!this.id)
            throw new Error('parseId(): Presence message does not contain an id');
        var parts = this.id.split(':');
        return {
            connectionId: parts[0],
            msgSerial: parseInt(parts[1], 10),
            index: parseInt(parts[2], 10),
        };
    };
    /**
     * Overload toJSON() to intercept JSON.stringify()
     * @return {*}
     */
    PresenceMessage.prototype.toJSON = function () {
        /* encode data to base64 if present and we're returning real JSON;
         * although msgpack calls toJSON(), we know it is a stringify()
         * call if it has a non-empty arguments list */
        var data = this.data;
        var encoding = this.encoding;
        if (data && platform_1.default.BufferUtils.isBuffer(data)) {
            if (arguments.length > 0) {
                /* stringify call */
                encoding = encoding ? encoding + '/base64' : 'base64';
                data = platform_1.default.BufferUtils.base64Encode(data);
            }
            else {
                /* Called by msgpack. toBuffer returns a datatype understandable by
                 * that platform's msgpack implementation (Buffer in node, Uint8Array
                 * in browsers) */
                data = platform_1.default.BufferUtils.toBuffer(data);
            }
        }
        return {
            id: this.id,
            clientId: this.clientId,
            /* Convert presence action back to an int for sending to Ably */
            action: toActionValue(this.action),
            data: data,
            encoding: encoding,
            extras: this.extras,
        };
    };
    PresenceMessage.prototype.toString = function () {
        var result = '[PresenceMessage';
        result += '; action=' + this.action;
        if (this.id)
            result += '; id=' + this.id;
        if (this.timestamp)
            result += '; timestamp=' + this.timestamp;
        if (this.clientId)
            result += '; clientId=' + this.clientId;
        if (this.connectionId)
            result += '; connectionId=' + this.connectionId;
        if (this.encoding)
            result += '; encoding=' + this.encoding;
        if (this.data) {
            if (typeof this.data == 'string')
                result += '; data=' + this.data;
            else if (platform_1.default.BufferUtils.isBuffer(this.data))
                result += '; data (buffer)=' + platform_1.default.BufferUtils.base64Encode(this.data);
            else
                result += '; data (json)=' + JSON.stringify(this.data);
        }
        if (this.extras) {
            result += '; extras=' + JSON.stringify(this.extras);
        }
        result += ']';
        return result;
    };
    PresenceMessage.fromResponseBody = function (body, options, format) {
        var messages = [];
        if (format) {
            body = Utils.decodeBody(body, format);
        }
        for (var i = 0; i < body.length; i++) {
            var msg = (messages[i] = PresenceMessage.fromValues(body[i], true));
            try {
                PresenceMessage.decode(msg, options);
            }
            catch (e) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'PresenceMessage.fromResponseBody()', e.toString());
            }
        }
        return messages;
    };
    PresenceMessage.fromValues = function (values, stringifyAction) {
        if (stringifyAction) {
            values.action = PresenceMessage.Actions[values.action];
        }
        return Object.assign(new PresenceMessage(), values);
    };
    PresenceMessage.fromValuesArray = function (values) {
        var count = values.length, result = new Array(count);
        for (var i = 0; i < count; i++)
            result[i] = PresenceMessage.fromValues(values[i]);
        return result;
    };
    PresenceMessage.fromEncoded = function (encoded, options) {
        var msg = PresenceMessage.fromValues(encoded, true);
        /* if decoding fails at any point, catch and return the message decoded to
         * the fullest extent possible */
        try {
            PresenceMessage.decode(msg, options !== null && options !== void 0 ? options : {});
        }
        catch (e) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'PresenceMessage.fromEncoded()', e.toString());
        }
        return msg;
    };
    PresenceMessage.fromEncodedArray = function (encodedArray, options) {
        return encodedArray.map(function (encoded) {
            return PresenceMessage.fromEncoded(encoded, options);
        });
    };
    PresenceMessage.fromData = function (data) {
        if (data instanceof PresenceMessage) {
            return data;
        }
        return PresenceMessage.fromValues({
            data: data,
        });
    };
    PresenceMessage.Actions = ['absent', 'present', 'enter', 'leave', 'update'];
    PresenceMessage.encode = message_1.default.encode;
    PresenceMessage.decode = message_1.default.decode;
    PresenceMessage.getMessagesSize = message_1.default.getMessagesSize;
    return PresenceMessage;
}());
exports.default = PresenceMessage;


/***/ }),
/* 16 */
/***/ (function(module, exports, __nested_webpack_require_148575__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_148575__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_148575__(1));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_148575__(7));
var errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_148575__(4));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_148575__(2));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_148575__(8));
var XHRStates_1 = tslib_1.__importDefault(__nested_webpack_require_148575__(21));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_148575__(3));
function isAblyError(responseBody, headers) {
    return Utils.arrIn(Utils.allToLowerCase(Utils.keysArray(headers)), 'x-ably-errorcode');
}
function getAblyError(responseBody, headers) {
    if (isAblyError(responseBody, headers)) {
        return responseBody.error && errorinfo_1.default.fromValues(responseBody.error);
    }
}
var noop = function () { };
var idCounter = 0;
var pendingRequests = {};
var isIE = typeof global !== 'undefined' && global.XDomainRequest;
function ieVersion() {
    var match = navigator.userAgent.toString().match(/MSIE\s([\d.]+)/);
    return match && Number(match[1]);
}
function needJsonEnvelope() {
    /* IE 10 xhr bug: http://stackoverflow.com/a/16320339 */
    var version;
    return isIE && (version = ieVersion()) && version === 10;
}
function getHeader(xhr, header) {
    return xhr.getResponseHeader && xhr.getResponseHeader(header);
}
/* Safari mysteriously returns 'Identity' for transfer-encoding when in fact
 * it is 'chunked'. So instead, decide that it is chunked when
 * transfer-encoding is present or content-length is absent.  ('or' because
 * when using http2 streaming, there's no transfer-encoding header, but can
 * still deduce streaming from lack of content-length) */
function isEncodingChunked(xhr) {
    return (xhr.getResponseHeader && (xhr.getResponseHeader('transfer-encoding') || !xhr.getResponseHeader('content-length')));
}
function getHeadersAsObject(xhr) {
    var headerPairs = Utils.trim(xhr.getAllResponseHeaders()).split('\r\n');
    var headers = {};
    for (var i = 0; i < headerPairs.length; i++) {
        var parts = headerPairs[i].split(':').map(Utils.trim);
        headers[parts[0].toLowerCase()] = parts[1];
    }
    return headers;
}
var XHRRequest = /** @class */ (function (_super) {
    tslib_1.__extends(XHRRequest, _super);
    function XHRRequest(uri, headers, params, body, requestMode, timeouts, method) {
        var _this = _super.call(this) || this;
        params = params || {};
        params.rnd = Utils.cheapRandStr();
        if (needJsonEnvelope() && !params.envelope)
            params.envelope = 'json';
        _this.uri = uri + Utils.toQueryString(params);
        _this.headers = headers || {};
        _this.body = body;
        _this.method = method ? method.toUpperCase() : Utils.isEmptyArg(body) ? 'GET' : 'POST';
        _this.requestMode = requestMode;
        _this.timeouts = timeouts;
        _this.timedOut = false;
        _this.requestComplete = false;
        _this.id = String(++idCounter);
        pendingRequests[_this.id] = _this;
        return _this;
    }
    XHRRequest.createRequest = function (uri, headers, params, body, requestMode, timeouts, method) {
        /* XHR requests are used either with the context being a realtime
         * transport, or with timeouts passed in (for when used by a rest client),
         * or completely standalone.  Use the appropriate timeouts in each case */
        var _timeouts = timeouts || defaults_1.default.TIMEOUTS;
        return new XHRRequest(uri, headers, Utils.copy(params), body, requestMode, _timeouts, method);
    };
    XHRRequest.prototype.complete = function (err, body, headers, unpacked, statusCode) {
        if (!this.requestComplete) {
            this.requestComplete = true;
            if (!err && body) {
                this.emit('data', body);
            }
            this.emit('complete', err, body, headers, unpacked, statusCode);
            this.dispose();
        }
    };
    XHRRequest.prototype.abort = function () {
        this.dispose();
    };
    XHRRequest.prototype.exec = function () {
        var _this = this;
        var headers = this.headers;
        var timeout = this.requestMode == XHRStates_1.default.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout, timer = (this.timer = setTimeout(function () {
            _this.timedOut = true;
            xhr.abort();
        }, timeout)), method = this.method, xhr = (this.xhr = new XMLHttpRequest()), accept = headers['accept'];
        var body = this.body;
        var responseType = 'text';
        if (!accept) {
            // Default to JSON
            headers['accept'] = 'application/json';
        }
        else if (accept.indexOf('application/x-msgpack') === 0) {
            // Msgpack responses will be typed as ArrayBuffer
            responseType = 'arraybuffer';
        }
        if (body) {
            var contentType = headers['content-type'] || (headers['content-type'] = 'application/json');
            if (contentType.indexOf('application/json') > -1 && typeof body != 'string')
                body = JSON.stringify(body);
        }
        // Can probably remove this directive if https://github.com/nodesecurity/eslint-plugin-security/issues/26 is resolved
        // eslint-disable-next-line security/detect-non-literal-fs-filename
        xhr.open(method, this.uri, true);
        xhr.responseType = responseType;
        if ('authorization' in headers) {
            xhr.withCredentials = true;
        }
        for (var h in headers)
            xhr.setRequestHeader(h, headers[h]);
        var errorHandler = function (errorEvent, message, code, statusCode) {
            var _a;
            var errorMessage = message + ' (event type: ' + errorEvent.type + ')';
            if ((_a = _this === null || _this === void 0 ? void 0 : _this.xhr) === null || _a === void 0 ? void 0 : _a.statusText)
                errorMessage += ', current statusText is ' + _this.xhr.statusText;
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Request.on' + errorEvent.type + '()', errorMessage);
            _this.complete(new errorinfo_1.PartialErrorInfo(errorMessage, code, statusCode));
        };
        xhr.onerror = function (errorEvent) {
            errorHandler(errorEvent, 'XHR error occurred', null, 400);
        };
        xhr.onabort = function (errorEvent) {
            if (_this.timedOut) {
                errorHandler(errorEvent, 'Request aborted due to request timeout expiring', null, 408);
            }
            else {
                errorHandler(errorEvent, 'Request cancelled', null, 400);
            }
        };
        xhr.ontimeout = function (errorEvent) {
            errorHandler(errorEvent, 'Request timed out', null, 408);
        };
        var streaming;
        var statusCode;
        var successResponse;
        var streamPos = 0;
        var unpacked = false;
        var onResponse = function () {
            clearTimeout(timer);
            successResponse = statusCode < 400;
            if (statusCode == 204) {
                _this.complete(null, null, null, null, statusCode);
                return;
            }
            streaming = _this.requestMode == XHRStates_1.default.REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr);
        };
        var onEnd = function () {
            var parsedResponse;
            try {
                var contentType = getHeader(xhr, 'content-type');
                /* Be liberal in what we accept; buggy auth servers may respond
                 * without the correct contenttype, but assume they're still
                 * responding with json */
                var json = contentType ? contentType.indexOf('application/json') >= 0 : xhr.responseType == 'text';
                if (json) {
                    /* If we requested msgpack but server responded with json, then since
                     * we set the responseType expecting msgpack, the response will be
                     * an ArrayBuffer containing json */
                    var jsonResponseBody = xhr.responseType === 'arraybuffer'
                        ? platform_1.default.BufferUtils.utf8Decode(xhr.response)
                        : String(xhr.responseText);
                    if (jsonResponseBody.length) {
                        parsedResponse = JSON.parse(jsonResponseBody);
                    }
                    else {
                        parsedResponse = jsonResponseBody;
                    }
                    unpacked = true;
                }
                else {
                    parsedResponse = xhr.response;
                }
                if (parsedResponse.response !== undefined) {
                    /* unwrap JSON envelope */
                    statusCode = parsedResponse.statusCode;
                    successResponse = statusCode < 400;
                    headers = parsedResponse.headers;
                    parsedResponse = parsedResponse.response;
                }
                else {
                    headers = getHeadersAsObject(xhr);
                }
            }
            catch (e) {
                _this.complete(new errorinfo_1.PartialErrorInfo('Malformed response body from server: ' + e.message, null, 400));
                return;
            }
            /* If response is an array, it's an array of protocol messages -- even if
             * is contains an error action (hence the nonsuccess statuscode), we can
             * consider the request to have succeeded, just pass it on to
             * onProtocolMessage to decide what to do */
            if (successResponse || Utils.isArray(parsedResponse)) {
                _this.complete(null, parsedResponse, headers, unpacked, statusCode);
                return;
            }
            var err = getAblyError(parsedResponse, headers);
            if (!err) {
                err = new errorinfo_1.PartialErrorInfo('Error response received from server: ' +
                    statusCode +
                    ' body was: ' +
                    platform_1.default.Config.inspect(parsedResponse), null, statusCode);
            }
            _this.complete(err, parsedResponse, headers, unpacked, statusCode);
        };
        function onProgress() {
            var responseText = xhr.responseText;
            var bodyEnd = responseText.length - 1;
            var idx, chunk;
            while (streamPos < bodyEnd && (idx = responseText.indexOf('\n', streamPos)) > -1) {
                chunk = responseText.slice(streamPos, idx);
                streamPos = idx + 1;
                onChunk(chunk);
            }
        }
        var onChunk = function (chunk) {
            try {
                chunk = JSON.parse(chunk);
            }
            catch (e) {
                _this.complete(new errorinfo_1.PartialErrorInfo('Malformed response body from server: ' + e.message, null, 400));
                return;
            }
            _this.emit('data', chunk);
        };
        var onStreamEnd = function () {
            onProgress();
            _this.streamComplete = true;
            platform_1.default.Config.nextTick(function () {
                _this.complete();
            });
        };
        xhr.onreadystatechange = function () {
            var readyState = xhr.readyState;
            if (readyState < 3)
                return;
            if (xhr.status !== 0) {
                if (statusCode === undefined) {
                    statusCode = xhr.status;
                    /* IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450 */
                    if (statusCode === 1223)
                        statusCode = 204;
                    onResponse();
                }
                if (readyState == 3 && streaming) {
                    onProgress();
                }
                else if (readyState == 4) {
                    if (streaming)
                        onStreamEnd();
                    else
                        onEnd();
                }
            }
        };
        xhr.send(body);
    };
    XHRRequest.prototype.dispose = function () {
        var xhr = this.xhr;
        if (xhr) {
            xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop;
            this.xhr = null;
            var timer = this.timer;
            if (timer) {
                clearTimeout(timer);
                this.timer = null;
            }
            if (!this.requestComplete)
                xhr.abort();
        }
        delete pendingRequests[this.id];
    };
    return XHRRequest;
}(eventemitter_1.default));
exports.default = XHRRequest;

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_148575__(13)))

/***/ }),
/* 17 */
/***/ (function(module, exports, __nested_webpack_require_161531__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_161531__(0);
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(2));
var Utils = tslib_1.__importStar(__nested_webpack_require_161531__(1));
var multicaster_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(23));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(4));
var hmac_sha256_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(45));
var enc_base64_1 = __nested_webpack_require_161531__(11);
var HttpMethods_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(18));
var HttpStatusCodes_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(25));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(3));
var resource_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(14));
var MAX_TOKEN_LENGTH = Math.pow(2, 17);
function noop() { }
function random() {
    return ('000000' + Math.floor(Math.random() * 1e16)).slice(-16);
}
function isRealtime(client) {
    return !!client.connection;
}
/* A client auth callback may give errors in any number of formats; normalise to an ErrorInfo or PartialErrorInfo */
function normaliseAuthcallbackError(err) {
    if (!Utils.isErrorInfoOrPartialErrorInfo(err)) {
        return new errorinfo_1.default(Utils.inspectError(err), err.code || 40170, err.statusCode || 401);
    }
    /* network errors will not have an inherent error code */
    if (!err.code) {
        if (err.statusCode === 403) {
            err.code = 40300;
        }
        else {
            err.code = 40170;
            /* normalise statusCode to 401 per RSA4e */
            err.statusCode = 401;
        }
    }
    return err;
}
var hmac = function (text, key) {
    if (platform_1.default.Config.createHmac) {
        var inst = platform_1.default.Config.createHmac('SHA256', key);
        inst.update(text);
        return inst.digest('base64');
    }
    return (0, enc_base64_1.stringify)((0, hmac_sha256_1.default)(text, key));
};
function c14n(capability) {
    if (!capability)
        return '';
    if (typeof capability == 'string')
        capability = JSON.parse(capability);
    var c14nCapability = Object.create(null);
    var keys = Utils.keysArray(capability, true);
    if (!keys)
        return '';
    keys.sort();
    for (var i = 0; i < keys.length; i++) {
        c14nCapability[keys[i]] = capability[keys[i]].sort();
    }
    return JSON.stringify(c14nCapability);
}
function logAndValidateTokenAuthMethod(authOptions) {
    if (authOptions.authCallback) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'using token auth with authCallback');
    }
    else if (authOptions.authUrl) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'using token auth with authUrl');
    }
    else if (authOptions.key) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'using token auth with client-side signing');
    }
    else if (authOptions.tokenDetails) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'using token auth with supplied token only');
    }
    else {
        var msg = 'authOptions must include valid authentication parameters';
        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', msg);
        throw new Error(msg);
    }
}
function basicAuthForced(options) {
    return 'useTokenAuth' in options && !options.useTokenAuth;
}
/* RSA4 */
function useTokenAuth(options) {
    return (options.useTokenAuth ||
        (!basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails)));
}
/* RSA4a */
function noWayToRenew(options) {
    return !options.key && !options.authCallback && !options.authUrl;
}
var trId = 0;
function getTokenRequestId() {
    return trId++;
}
var Auth = /** @class */ (function () {
    function Auth(client, options) {
        // This initialization is always overwritten and only used to prevent a TypeScript compiler error
        this.authOptions = {};
        this.client = client;
        this.tokenParams = options.defaultTokenParams || {};
        /* The id of the current token request if one is in progress, else null */
        this.currentTokenRequestId = null;
        this.waitingForTokenRequest = null;
        if (useTokenAuth(options)) {
            /* Token auth */
            if (options.key && !hmac) {
                var msg = 'client-side token request signing not supported';
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', msg);
                throw new Error(msg);
            }
            if (noWayToRenew(options)) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', 'Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help');
            }
            this._saveTokenOptions(options.defaultTokenParams, options);
            logAndValidateTokenAuthMethod(this.authOptions);
        }
        else {
            /* Basic auth */
            if (!options.key) {
                var msg = 'No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)';
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', msg);
                throw new errorinfo_1.default(msg, 40160, 401);
            }
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'anonymous, using basic auth');
            this._saveBasicOptions(options);
        }
    }
    Auth.prototype.authorize = function (tokenParams, authOptions, callback) {
        var _this = this;
        var _authOptions;
        /* shuffle and normalise arguments as necessary */
        if (typeof tokenParams == 'function' && !callback) {
            callback = tokenParams;
            _authOptions = tokenParams = null;
        }
        else if (typeof authOptions == 'function' && !callback) {
            callback = authOptions;
            _authOptions = null;
        }
        else {
            _authOptions = authOptions;
        }
        if (!callback) {
            if (this.client.options.promises) {
                return Utils.promisify(this, 'authorize', arguments);
            }
        }
        /* RSA10a: authorize() call implies token auth. If a key is passed it, we
         * just check if it doesn't clash and assume we're generating a token from it */
        if (_authOptions && _authOptions.key && this.authOptions.key !== _authOptions.key) {
            throw new errorinfo_1.default('Unable to update auth options with incompatible key', 40102, 401);
        }
        if (_authOptions && 'force' in _authOptions) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.authorize', 'Deprecation warning: specifying {force: true} in authOptions is no longer necessary, authorize() now always gets a new token. Please remove this, as in version 1.0 and later, having a non-null authOptions will overwrite stored library authOptions, which may not be what you want');
            /* Emulate the old behaviour: if 'force' was the only member of authOptions,
             * set it to null so it doesn't overwrite stored. TODO: remove in version 1.0 */
            if (Utils.isOnlyPropIn(_authOptions, 'force')) {
                _authOptions = null;
            }
        }
        this._forceNewToken(tokenParams, _authOptions, function (err, tokenDetails) {
            if (err) {
                if (_this.client.connection && err.statusCode === HttpStatusCodes_1.default.Forbidden) {
                    /* Per RSA4d & RSA4d1, if the auth server explicitly repudiates our right to
                     * stay connecticed by returning a 403, we actively disconnect the connection
                     * even though we may well still have time left in the old token. */
                    _this.client.connection.connectionManager.actOnErrorFromAuthorize(err);
                }
                callback === null || callback === void 0 ? void 0 : callback(err);
                return;
            }
            /* RTC8
             * - When authorize called by an end user and have a realtime connection,
             * don't call back till new token has taken effect.
             * - Use this.client.connection as a proxy for (this.client instanceof Realtime),
             * which doesn't work in node as Realtime isn't part of the vm context for Rest clients */
            if (isRealtime(_this.client)) {
                _this.client.connection.connectionManager.onAuthUpdated(tokenDetails, callback || noop);
            }
            else {
                callback === null || callback === void 0 ? void 0 : callback(null, tokenDetails);
            }
        });
    };
    Auth.prototype.authorise = function (tokenParams, authOptions, callback) {
        logger_1.default.deprecated('Auth.authorise', 'Auth.authorize');
        this.authorize(tokenParams, authOptions, callback);
    };
    /* For internal use, eg by connectionManager - useful when want to call back
     * as soon as we have the new token, rather than waiting for it to take
     * effect on the connection as #authorize does */
    Auth.prototype._forceNewToken = function (tokenParams, authOptions, callback) {
        var _this = this;
        /* get rid of current token even if still valid */
        this.tokenDetails = null;
        /* _save normalises the tokenParams and authOptions and updates the auth
         * object. All subsequent operations should use the values on `this`,
         * not the passed in ones. */
        this._saveTokenOptions(tokenParams, authOptions);
        logAndValidateTokenAuthMethod(this.authOptions);
        this._ensureValidAuthCredentials(true, function (err, tokenDetails) {
            /* RSA10g */
            delete _this.tokenParams.timestamp;
            delete _this.authOptions.queryTime;
            callback(err, tokenDetails);
        });
    };
    Auth.prototype.requestToken = function (tokenParams, authOptions, callback) {
        var _this = this;
        /* shuffle and normalise arguments as necessary */
        if (typeof tokenParams == 'function' && !callback) {
            callback = tokenParams;
            authOptions = tokenParams = null;
        }
        else if (typeof authOptions == 'function' && !callback) {
            callback = authOptions;
            authOptions = null;
        }
        if (!callback && this.client.options.promises) {
            return Utils.promisify(this, 'requestToken', arguments);
        }
        /* RSA8e: if authOptions passed in, they're used instead of stored, don't merge them */
        authOptions = authOptions || this.authOptions;
        tokenParams = tokenParams || Utils.copy(this.tokenParams);
        var _callback = callback || noop;
        /* first set up whatever callback will be used to get signed
         * token requests */
        var tokenRequestCallback, client = this.client;
        if (authOptions.authCallback) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authCallback');
            tokenRequestCallback = authOptions.authCallback;
        }
        else if (authOptions.authUrl) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authUrl');
            tokenRequestCallback = function (params, cb) {
                var authHeaders = Utils.mixin({ accept: 'application/json, text/plain' }, authOptions.authHeaders);
                var usePost = authOptions.authMethod && authOptions.authMethod.toLowerCase() === 'post';
                var providedQsParams;
                /* Combine authParams with any qs params given in the authUrl */
                var queryIdx = authOptions.authUrl.indexOf('?');
                if (queryIdx > -1) {
                    providedQsParams = Utils.parseQueryString(authOptions.authUrl.slice(queryIdx));
                    authOptions.authUrl = authOptions.authUrl.slice(0, queryIdx);
                    if (!usePost) {
                        /* In case of conflict, authParams take precedence over qs params in the authUrl */
                        authOptions.authParams = Utils.mixin(providedQsParams, authOptions.authParams);
                    }
                }
                /* RSA8c2 */
                var authParams = Utils.mixin({}, authOptions.authParams || {}, params);
                var authUrlRequestCallback = function (err, body, headers, unpacked) {
                    var contentType;
                    if (err) {
                        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received Error: ' + Utils.inspectError(err));
                    }
                    else {
                        contentType = headers['content-type'];
                        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received; content-type: ' + contentType + '; body: ' + Utils.inspectBody(body));
                    }
                    if (err || unpacked)
                        return cb(err, body);
                    if (platform_1.default.BufferUtils.isBuffer(body))
                        body = body.toString();
                    if (!contentType) {
                        cb(new errorinfo_1.default('authUrl response is missing a content-type header', 40170, 401));
                        return;
                    }
                    var json = contentType.indexOf('application/json') > -1, text = contentType.indexOf('text/plain') > -1 || contentType.indexOf('application/jwt') > -1;
                    if (!json && !text) {
                        cb(new errorinfo_1.default('authUrl responded with unacceptable content-type ' +
                            contentType +
                            ', should be either text/plain, application/jwt or application/json', 40170, 401));
                        return;
                    }
                    if (json) {
                        if (body.length > MAX_TOKEN_LENGTH) {
                            cb(new errorinfo_1.default('authUrl response exceeded max permitted length', 40170, 401));
                            return;
                        }
                        try {
                            body = JSON.parse(body);
                        }
                        catch (e) {
                            cb(new errorinfo_1.default('Unexpected error processing authURL response; err = ' + e.message, 40170, 401));
                            return;
                        }
                    }
                    cb(null, body, contentType);
                };
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Requesting token from ' +
                    authOptions.authUrl +
                    '; Params: ' +
                    JSON.stringify(authParams) +
                    '; method: ' +
                    (usePost ? 'POST' : 'GET'));
                if (usePost) {
                    /* send body form-encoded */
                    var headers = authHeaders || {};
                    headers['content-type'] = 'application/x-www-form-urlencoded';
                    var body = Utils.toQueryString(authParams).slice(1); /* slice is to remove the initial '?' */
                    _this.client.http.doUri(HttpMethods_1.default.Post, client, authOptions.authUrl, headers, body, providedQsParams, authUrlRequestCallback);
                }
                else {
                    _this.client.http.doUri(HttpMethods_1.default.Get, client, authOptions.authUrl, authHeaders || {}, null, authParams, authUrlRequestCallback);
                }
            };
        }
        else if (authOptions.key) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.requestToken()', 'using token auth with client-side signing');
            tokenRequestCallback = function (params, cb) {
                _this.createTokenRequest(params, authOptions, cb);
            };
        }
        else {
            var msg = 'Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', 'library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help');
            _callback(new errorinfo_1.default(msg, 40171, 403));
            return;
        }
        /* normalise token params */
        if ('capability' in tokenParams)
            tokenParams.capability = c14n(tokenParams.capability);
        var tokenRequest = function (signedTokenParams, tokenCb) {
            var keyName = signedTokenParams.keyName, path = '/keys/' + keyName + '/requestToken', tokenUri = function (host) {
                return client.baseUri(host) + path;
            };
            var requestHeaders = Utils.defaultPostHeaders(_this.client.options);
            if (authOptions.requestHeaders)
                Utils.mixin(requestHeaders, authOptions.requestHeaders);
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Auth.requestToken().requestToken', 'Sending POST to ' + path + '; Token params: ' + JSON.stringify(signedTokenParams));
            _this.client.http.do(HttpMethods_1.default.Post, client, tokenUri, requestHeaders, JSON.stringify(signedTokenParams), null, tokenCb);
        };
        var tokenRequestCallbackTimeoutExpired = false, timeoutLength = this.client.options.timeouts.realtimeRequestTimeout, tokenRequestCallbackTimeout = setTimeout(function () {
            tokenRequestCallbackTimeoutExpired = true;
            var msg = 'Token request callback timed out after ' + timeoutLength / 1000 + ' seconds';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', msg);
            _callback(new errorinfo_1.default(msg, 40170, 401));
        }, timeoutLength);
        tokenRequestCallback(tokenParams, function (err, tokenRequestOrDetails, contentType) {
            if (tokenRequestCallbackTimeoutExpired)
                return;
            clearTimeout(tokenRequestCallbackTimeout);
            if (err) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', 'token request signing call returned error; err = ' + Utils.inspectError(err));
                _callback(normaliseAuthcallbackError(err));
                return;
            }
            /* the response from the callback might be a token string, a signed request or a token details */
            if (typeof tokenRequestOrDetails === 'string') {
                if (tokenRequestOrDetails.length === 0) {
                    _callback(new errorinfo_1.default('Token string is empty', 40170, 401));
                }
                else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {
                    _callback(new errorinfo_1.default('Token string exceeded max permitted length (was ' + tokenRequestOrDetails.length + ' bytes)', 40170, 401));
                }
                else if (tokenRequestOrDetails === 'undefined' || tokenRequestOrDetails === 'null') {
                    /* common failure mode with poorly-implemented authCallbacks */
                    _callback(new errorinfo_1.default('Token string was literal null/undefined', 40170, 401));
                }
                else if (tokenRequestOrDetails[0] === '{' && !(contentType && contentType.indexOf('application/jwt') > -1)) {
                    _callback(new errorinfo_1.default("Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details", 40170, 401));
                }
                else {
                    _callback(null, { token: tokenRequestOrDetails });
                }
                return;
            }
            if (typeof tokenRequestOrDetails !== 'object') {
                var msg = 'Expected token request callback to call back with a token string or token request/details object, but got a ' +
                    typeof tokenRequestOrDetails;
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', msg);
                _callback(new errorinfo_1.default(msg, 40170, 401));
                return;
            }
            var objectSize = JSON.stringify(tokenRequestOrDetails).length;
            if (objectSize > MAX_TOKEN_LENGTH && !authOptions.suppressMaxLengthCheck) {
                _callback(new errorinfo_1.default('Token request/details object exceeded max permitted stringified size (was ' + objectSize + ' bytes)', 40170, 401));
                return;
            }
            if ('issued' in tokenRequestOrDetails) {
                /* a tokenDetails object */
                _callback(null, tokenRequestOrDetails);
                return;
            }
            if (!('keyName' in tokenRequestOrDetails)) {
                var msg = 'Expected token request callback to call back with a token string, token request object, or token details object';
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', msg);
                _callback(new errorinfo_1.default(msg, 40170, 401));
                return;
            }
            /* it's a token request, so make the request */
            tokenRequest(tokenRequestOrDetails, function (err, tokenResponse, headers, unpacked) {
                if (err) {
                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', 'token request API call returned error; err = ' + Utils.inspectError(err));
                    _callback(normaliseAuthcallbackError(err));
                    return;
                }
                if (!unpacked)
                    tokenResponse = JSON.parse(tokenResponse);
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.getToken()', 'token received');
                _callback(null, tokenResponse);
            });
        });
    };
    /**
     * Create and sign a token request based on the given options.
     * NOTE this can only be used when the key value is available locally.
     * Otherwise, signed token requests must be obtained from the key
     * owner (either using the token request callback or url).
     *
     * @param authOptions
     * an object containing the request options:
     * - key:           the key to use. If not specified, a key passed in constructing
     *                  the Rest interface will be used
     *
     * - queryTime      (optional) boolean indicating that the ably system should be
     *                  queried for the current time when none is specified explicitly
     *
     * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
     *                  requestToken request
     *
     * @param tokenParams
     * an object containing the parameters for the requested token:
     * - ttl:       (optional) the requested life of the token in ms. If none is specified
     *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request
     *                  exceeding that lifetime will be rejected with an error.
     *
     * - capability:    (optional) the capability to associate with the access token.
     *                  If none is specified, a token will be requested with all of the
     *                  capabilities of the specified key.
     *
     * - clientId:      (optional) a client ID to associate with the token; if not
     *                  specified, a clientId passed in constructing the Rest interface will be used
     *
     * - timestamp:     (optional) the time in ms since the epoch. If none is specified,
     *                  the system will be queried for a time value to use.
     *
     * @param callback
     */
    Auth.prototype.createTokenRequest = function (tokenParams, authOptions, callback) {
        var _this = this;
        /* shuffle and normalise arguments as necessary */
        if (typeof tokenParams == 'function' && !callback) {
            callback = tokenParams;
            authOptions = tokenParams = null;
        }
        else if (typeof authOptions == 'function' && !callback) {
            callback = authOptions;
            authOptions = null;
        }
        if (!callback && this.client.options.promises) {
            return Utils.promisify(this, 'createTokenRequest', arguments);
        }
        /* RSA9h: if authOptions passed in, they're used instead of stored, don't merge them */
        authOptions = authOptions || this.authOptions;
        tokenParams = tokenParams || Utils.copy(this.tokenParams);
        var key = authOptions.key;
        if (!key) {
            callback(new errorinfo_1.default('No key specified', 40101, 403));
            return;
        }
        var keyParts = key.split(':'), keyName = keyParts[0], keySecret = keyParts[1];
        if (!keySecret) {
            callback(new errorinfo_1.default('Invalid key specified', 40101, 403));
            return;
        }
        if (tokenParams.clientId === '') {
            callback(new errorinfo_1.default('clientId can’t be an empty string', 40012, 400));
            return;
        }
        if ('capability' in tokenParams) {
            tokenParams.capability = c14n(tokenParams.capability);
        }
        var request = Utils.mixin({ keyName: keyName }, tokenParams), clientId = tokenParams.clientId || '', ttl = tokenParams.ttl || '', capability = tokenParams.capability || '';
        (function (authoriseCb) {
            if (request.timestamp) {
                authoriseCb();
                return;
            }
            _this.getTimestamp(authOptions && authOptions.queryTime, function (err, time) {
                if (err) {
                    callback(err);
                    return;
                }
                request.timestamp = time;
                authoriseCb();
            });
        })(function () {
            /* nonce */
            /* NOTE: there is no expectation that the client
             * specifies the nonce; this is done by the library
             * However, this can be overridden by the client
             * simply for testing purposes. */
            var nonce = request.nonce || (request.nonce = random()), timestamp = request.timestamp;
            var signText = request.keyName + '\n' + ttl + '\n' + capability + '\n' + clientId + '\n' + timestamp + '\n' + nonce + '\n';
            /* mac */
            /* NOTE: there is no expectation that the client
             * specifies the mac; this is done by the library
             * However, this can be overridden by the client
             * simply for testing purposes. */
            request.mac = request.mac || hmac(signText, keySecret);
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.getTokenRequest()', 'generated signed request');
            callback(null, request);
        });
    };
    /**
     * Get the auth query params to use for a websocket connection,
     * based on the current auth parameters
     */
    Auth.prototype.getAuthParams = function (callback) {
        if (this.method == 'basic')
            callback(null, { key: this.key });
        else
            this._ensureValidAuthCredentials(false, function (err, tokenDetails) {
                if (err) {
                    callback(err);
                    return;
                }
                if (!tokenDetails) {
                    throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');
                }
                callback(null, { access_token: tokenDetails.token });
            });
    };
    /**
     * Get the authorization header to use for a REST or comet request,
     * based on the current auth parameters
     */
    Auth.prototype.getAuthHeaders = function (callback) {
        if (this.method == 'basic') {
            callback(null, { authorization: 'Basic ' + this.basicKey });
        }
        else {
            this._ensureValidAuthCredentials(false, function (err, tokenDetails) {
                if (err) {
                    callback(err);
                    return;
                }
                if (!tokenDetails) {
                    throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');
                }
                callback(null, { authorization: 'Bearer ' + Utils.toBase64(tokenDetails.token) });
            });
        }
    };
    /**
     * Get the current time based on the local clock,
     * or if the option queryTime is true, return the server time.
     * The server time offset from the local time is stored so that
     * only one request to the server to get the time is ever needed
     */
    Auth.prototype.getTimestamp = function (queryTime, callback) {
        if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {
            this.client.time(callback);
        }
        else {
            callback(null, this.getTimestampUsingOffset());
        }
    };
    Auth.prototype.getTimestampUsingOffset = function () {
        return Utils.now() + (this.client.serverTimeOffset || 0);
    };
    Auth.prototype.isTimeOffsetSet = function () {
        return this.client.serverTimeOffset !== null;
    };
    Auth.prototype._saveBasicOptions = function (authOptions) {
        this.method = 'basic';
        this.key = authOptions.key;
        this.basicKey = Utils.toBase64(authOptions.key);
        this.authOptions = authOptions || {};
        if ('clientId' in authOptions) {
            this._userSetClientId(authOptions.clientId);
        }
    };
    Auth.prototype._saveTokenOptions = function (tokenParams, authOptions) {
        this.method = 'token';
        if (tokenParams) {
            /* We temporarily persist tokenParams.timestamp in case a new token needs
             * to be requested, then null it out in the callback of
             * _ensureValidAuthCredentials for RSA10g compliance */
            this.tokenParams = tokenParams;
        }
        if (authOptions) {
            /* normalise */
            if (authOptions.token) {
                /* options.token may contain a token string or, for convenience, a TokenDetails */
                authOptions.tokenDetails =
                    typeof authOptions.token === 'string'
                        ? { token: authOptions.token }
                        : authOptions.token;
            }
            if (authOptions.tokenDetails) {
                this.tokenDetails = authOptions.tokenDetails;
            }
            if ('clientId' in authOptions) {
                this._userSetClientId(authOptions.clientId);
            }
            this.authOptions = authOptions;
        }
    };
    /* @param forceSupersede: force a new token request even if there's one in
     * progress, making all pending callbacks wait for the new one */
    Auth.prototype._ensureValidAuthCredentials = function (forceSupersede, callback) {
        var _this = this;
        var token = this.tokenDetails;
        if (token) {
            if (this._tokenClientIdMismatch(token.clientId)) {
                /* 403 to trigger a permanently failed client - RSA15c */
                callback(new errorinfo_1.default('Mismatch between clientId in token (' + token.clientId + ') and current clientId (' + this.clientId + ')', 40102, 403));
                return;
            }
            /* RSA4b1 -- if we have a server time offset set already, we can
             * automatically remove expired tokens. Else just use the cached token. If it is
             * expired Ably will tell us and we'll discard it then. */
            if (!this.isTimeOffsetSet() || !token.expires || token.expires >= this.getTimestampUsingOffset()) {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.getToken()', 'using cached token; expires = ' + token.expires);
                callback(null, token);
                return;
            }
            /* expired, so remove and fallthrough to getting a new one */
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.getToken()', 'deleting expired token');
            this.tokenDetails = null;
        }
        (this.waitingForTokenRequest || (this.waitingForTokenRequest = multicaster_1.default.create())).push(callback);
        if (this.currentTokenRequestId !== null && !forceSupersede) {
            return;
        }
        /* Request a new token */
        var tokenRequestId = (this.currentTokenRequestId = getTokenRequestId());
        this.requestToken(this.tokenParams, this.authOptions, function (err, tokenResponse) {
            if (_this.currentTokenRequestId > tokenRequestId) {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth._ensureValidAuthCredentials()', 'Discarding token request response; overtaken by newer one');
                return;
            }
            _this.currentTokenRequestId = null;
            var callbacks = _this.waitingForTokenRequest || noop;
            _this.waitingForTokenRequest = null;
            if (err) {
                callbacks(err);
                return;
            }
            callbacks(null, (_this.tokenDetails = tokenResponse));
        });
    };
    /* User-set: check types, '*' is disallowed, throw any errors */
    Auth.prototype._userSetClientId = function (clientId) {
        if (!(typeof clientId === 'string' || clientId === null)) {
            throw new errorinfo_1.default('clientId must be either a string or null', 40012, 400);
        }
        else if (clientId === '*') {
            throw new errorinfo_1.default('Can’t use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: "*"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: "*"}, authOptions)', 40012, 400);
        }
        else {
            var err = this._uncheckedSetClientId(clientId);
            if (err)
                throw err;
        }
    };
    /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */
    Auth.prototype._uncheckedSetClientId = function (clientId) {
        if (this._tokenClientIdMismatch(clientId)) {
            /* Should never happen in normal circumstances as realtime should
             * recognise mismatch and return an error */
            var msg = 'Unexpected clientId mismatch: client has ' + this.clientId + ', requested ' + clientId;
            var err = new errorinfo_1.default(msg, 40102, 401);
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth._uncheckedSetClientId()', msg);
            return err;
        }
        else {
            /* RSA7a4: if options.clientId is provided and is not
             * null, it overrides defaultTokenParams.clientId */
            this.clientId = this.tokenParams.clientId = clientId;
            return null;
        }
    };
    Auth.prototype._tokenClientIdMismatch = function (tokenClientId) {
        return !!(this.clientId &&
            this.clientId !== '*' &&
            tokenClientId &&
            tokenClientId !== '*' &&
            this.clientId !== tokenClientId);
    };
    Auth.isTokenErr = function (error) {
        return error.code && error.code >= 40140 && error.code < 40150;
    };
    Auth.prototype.revokeTokens = function (specifiers, optionsOrCallbackArg, callbackArg) {
        if (useTokenAuth(this.client.options)) {
            throw new errorinfo_1.default('Cannot revoke tokens when using token auth', 40162, 401);
        }
        var keyName = this.client.options.keyName;
        var resolvedOptions;
        if (typeof optionsOrCallbackArg === 'function') {
            callbackArg = optionsOrCallbackArg;
            resolvedOptions = {};
        }
        else {
            resolvedOptions = optionsOrCallbackArg !== null && optionsOrCallbackArg !== void 0 ? optionsOrCallbackArg : {};
        }
        if (callbackArg === undefined) {
            if (this.client.options.promises) {
                return Utils.promisify(this, 'revokeTokens', [specifiers, resolvedOptions]);
            }
            callbackArg = noop;
        }
        var callback = callbackArg;
        var requestBodyDTO = tslib_1.__assign({ targets: specifiers.map(function (specifier) { return "".concat(specifier.type, ":").concat(specifier.value); }) }, resolvedOptions);
        var format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(this.client.options, format);
        if (this.client.options.headers)
            Utils.mixin(headers, this.client.options.headers);
        var requestBody = Utils.encodeBody(requestBodyDTO, format);
        resource_1.default.post(this.client, "/keys/".concat(keyName, "/revokeTokens"), requestBody, headers, { newBatchResponse: 'true' }, null, function (err, body, headers, unpacked) {
            if (err) {
                // TODO remove this type assertion after fixing https://github.com/ably/ably-js/issues/1405
                callback(err);
                return;
            }
            var batchResult = (unpacked ? body : Utils.decodeBody(body, format));
            callback(null, batchResult);
        });
    };
    return Auth;
}());
exports.default = Auth;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var HttpMethods;
(function (HttpMethods) {
    HttpMethods["Get"] = "get";
    HttpMethods["Delete"] = "delete";
    HttpMethods["Post"] = "post";
    HttpMethods["Put"] = "put";
    HttpMethods["Patch"] = "patch";
})(HttpMethods || (HttpMethods = {}));
exports.default = HttpMethods;


/***/ }),
/* 19 */
/***/ (function(module, exports, __nested_webpack_require_199902__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpPaginatedResponse = exports.PaginatedResult = void 0;
var tslib_1 = __nested_webpack_require_199902__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_199902__(1));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_199902__(2));
var resource_1 = tslib_1.__importDefault(__nested_webpack_require_199902__(14));
function getRelParams(linkUrl) {
    var urlMatch = linkUrl.match(/^\.\/(\w+)\?(.*)$/);
    return urlMatch && urlMatch[2] && Utils.parseQueryString(urlMatch[2]);
}
function parseRelLinks(linkHeader) {
    if (typeof linkHeader == 'string')
        linkHeader = linkHeader.split(',');
    var relParams = {};
    for (var i = 0; i < linkHeader.length; i++) {
        var linkMatch = linkHeader[i].match(/^\s*<(.+)>;\s*rel="(\w+)"$/);
        if (linkMatch) {
            var params = getRelParams(linkMatch[1]);
            if (params)
                relParams[linkMatch[2]] = params;
        }
    }
    return relParams;
}
function returnErrOnly(err, body, useHPR) {
    /* If using httpPaginatedResponse, errors from Ably are returned as part of
     * the HPR, only do callback(err) for network errors etc. which don't
     * return a body and/or have no ably-originated error code (non-numeric
     * error codes originate from node) */
    return !(useHPR && (body || typeof err.code === 'number'));
}
var PaginatedResource = /** @class */ (function () {
    function PaginatedResource(rest, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {
        this.rest = rest;
        this.path = path;
        this.headers = headers;
        this.envelope = envelope !== null && envelope !== void 0 ? envelope : null;
        this.bodyHandler = bodyHandler;
        this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;
    }
    PaginatedResource.prototype.get = function (params, callback) {
        var _this = this;
        resource_1.default.get(this.rest, this.path, this.headers, params, this.envelope, function (err, body, headers, unpacked, statusCode) {
            _this.handlePage(err, body, headers, unpacked, statusCode, callback);
        });
    };
    PaginatedResource.prototype.delete = function (params, callback) {
        var _this = this;
        resource_1.default.delete(this.rest, this.path, this.headers, params, this.envelope, function (err, body, headers, unpacked, statusCode) {
            _this.handlePage(err, body, headers, unpacked, statusCode, callback);
        });
    };
    PaginatedResource.prototype.post = function (params, body, callback) {
        var _this = this;
        resource_1.default.post(this.rest, this.path, body, this.headers, params, this.envelope, function (err, responseBody, headers, unpacked, statusCode) {
            if (callback) {
                _this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);
            }
        });
    };
    PaginatedResource.prototype.put = function (params, body, callback) {
        var _this = this;
        resource_1.default.put(this.rest, this.path, body, this.headers, params, this.envelope, function (err, responseBody, headers, unpacked, statusCode) {
            if (callback) {
                _this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);
            }
        });
    };
    PaginatedResource.prototype.patch = function (params, body, callback) {
        var _this = this;
        resource_1.default.patch(this.rest, this.path, body, this.headers, params, this.envelope, function (err, responseBody, headers, unpacked, statusCode) {
            if (callback) {
                _this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);
            }
        });
    };
    PaginatedResource.prototype.handlePage = function (err, body, headers, unpacked, statusCode, callback) {
        if (err && returnErrOnly(err, body, this.useHttpPaginatedResponse)) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'PaginatedResource.handlePage()', 'Unexpected error getting resource: err = ' + Utils.inspectError(err));
            callback === null || callback === void 0 ? void 0 : callback(err);
            return;
        }
        var items, linkHeader, relParams;
        try {
            items = this.bodyHandler(body, headers || {}, unpacked);
        }
        catch (e) {
            /* If we got an error, the failure to parse the body is almost certainly
             * due to that, so callback with that in preference over the parse error */
            callback === null || callback === void 0 ? void 0 : callback(err || e);
            return;
        }
        if (headers && (linkHeader = headers['Link'] || headers['link'])) {
            relParams = parseRelLinks(linkHeader);
        }
        if (this.useHttpPaginatedResponse) {
            callback(null, new HttpPaginatedResponse(this, items, headers || {}, statusCode, relParams, err));
        }
        else {
            callback(null, new PaginatedResult(this, items, relParams));
        }
    };
    return PaginatedResource;
}());
var PaginatedResult = /** @class */ (function () {
    function PaginatedResult(resource, items, relParams) {
        var _this = this;
        this.resource = resource;
        this.items = items;
        var self = this;
        if (relParams) {
            if ('first' in relParams) {
                this.first = function (callback) {
                    if (!callback && self.resource.rest.options.promises) {
                        return Utils.promisify(self, 'first', []);
                    }
                    self.get(relParams.first, callback);
                };
            }
            if ('current' in relParams) {
                this.current = function (callback) {
                    if (!callback && self.resource.rest.options.promises) {
                        return Utils.promisify(self, 'current', []);
                    }
                    self.get(relParams.current, callback);
                };
            }
            this.next = function (callback) {
                if (!callback && self.resource.rest.options.promises) {
                    return Utils.promisify(self, 'next', []);
                }
                if ('next' in relParams) {
                    self.get(relParams.next, callback);
                }
                else {
                    callback(null);
                }
            };
            this.hasNext = function () {
                return 'next' in relParams;
            };
            this.isLast = function () {
                var _a;
                return !((_a = _this.hasNext) === null || _a === void 0 ? void 0 : _a.call(_this));
            };
        }
    }
    /* We assume that only the initial request can be a POST, and that accessing
     * the rest of a multipage set of results can always be done with GET */
    PaginatedResult.prototype.get = function (params, callback) {
        var res = this.resource;
        resource_1.default.get(res.rest, res.path, res.headers, params, res.envelope, function (err, body, headers, unpacked, statusCode) {
            res.handlePage(err, body, headers, unpacked, statusCode, callback);
        });
    };
    return PaginatedResult;
}());
exports.PaginatedResult = PaginatedResult;
var HttpPaginatedResponse = /** @class */ (function (_super) {
    tslib_1.__extends(HttpPaginatedResponse, _super);
    function HttpPaginatedResponse(resource, items, headers, statusCode, relParams, err) {
        var _this = _super.call(this, resource, items, relParams) || this;
        _this.statusCode = statusCode;
        _this.success = statusCode < 300 && statusCode >= 200;
        _this.headers = headers;
        _this.errorCode = err && err.code;
        _this.errorMessage = err && err.message;
        return _this;
    }
    HttpPaginatedResponse.prototype.toJSON = function () {
        return {
            items: this.items,
            statusCode: this.statusCode,
            success: this.success,
            headers: this.headers,
            errorCode: this.errorCode,
            errorMessage: this.errorMessage,
        };
    };
    return HttpPaginatedResponse;
}(PaginatedResult));
exports.HttpPaginatedResponse = HttpPaginatedResponse;
exports.default = PaginatedResource;


/***/ }),
/* 20 */
/***/ (function(module, exports, __nested_webpack_require_208317__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isRetriable = void 0;
var tslib_1 = __nested_webpack_require_208317__(0);
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_208317__(4));
var ConnectionErrorCodes = {
    DISCONNECTED: 80003,
    SUSPENDED: 80002,
    FAILED: 80000,
    CLOSING: 80017,
    CLOSED: 80017,
    UNKNOWN_CONNECTION_ERR: 50002,
    UNKNOWN_CHANNEL_ERR: 50001,
};
var ConnectionErrors = {
    disconnected: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 400,
            code: ConnectionErrorCodes.DISCONNECTED,
            message: 'Connection to server temporarily unavailable',
        });
    },
    suspended: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 400,
            code: ConnectionErrorCodes.SUSPENDED,
            message: 'Connection to server unavailable',
        });
    },
    failed: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 400,
            code: ConnectionErrorCodes.FAILED,
            message: 'Connection failed or disconnected by server',
        });
    },
    closing: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 400,
            code: ConnectionErrorCodes.CLOSING,
            message: 'Connection closing',
        });
    },
    closed: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 400,
            code: ConnectionErrorCodes.CLOSED,
            message: 'Connection closed',
        });
    },
    unknownConnectionErr: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 500,
            code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,
            message: 'Internal connection error',
        });
    },
    unknownChannelErr: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 500,
            code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,
            message: 'Internal channel error',
        });
    },
};
function isRetriable(err) {
    if (!err.statusCode || !err.code || err.statusCode >= 500) {
        return true;
    }
    return Object.values(ConnectionErrorCodes).includes(err.code);
}
exports.isRetriable = isRetriable;
exports.default = ConnectionErrors;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var XHRStates;
(function (XHRStates) {
    XHRStates[XHRStates["REQ_SEND"] = 0] = "REQ_SEND";
    XHRStates[XHRStates["REQ_RECV"] = 1] = "REQ_RECV";
    XHRStates[XHRStates["REQ_RECV_POLL"] = 2] = "REQ_RECV_POLL";
    XHRStates[XHRStates["REQ_RECV_STREAM"] = 3] = "REQ_RECV_STREAM";
})(XHRStates || (XHRStates = {}));
exports.default = XHRStates;


/***/ }),
/* 22 */
/***/ (function(module, exports, __nested_webpack_require_211239__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_211239__(6), __nested_webpack_require_211239__(5), __nested_webpack_require_211239__(58), __nested_webpack_require_211239__(11), __nested_webpack_require_211239__(40), __nested_webpack_require_211239__(32), __nested_webpack_require_211239__(24), __nested_webpack_require_211239__(27), __nested_webpack_require_211239__(28), __nested_webpack_require_211239__(59), __nested_webpack_require_211239__(60));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS;

}));

/***/ }),
/* 23 */
/***/ (function(module, exports, __nested_webpack_require_211750__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_211750__(0);
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_211750__(2));
var Multicaster = /** @class */ (function () {
    // Private constructor; use static Multicaster.create instead
    function Multicaster(members) {
        this.members = members || [];
    }
    Multicaster.prototype.call = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        for (var _a = 0, _b = this.members; _a < _b.length; _a++) {
            var member = _b[_a];
            if (member) {
                try {
                    member.apply(void 0, args);
                }
                catch (e) {
                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Multicaster multiple callback handler', 'Unexpected exception: ' + e + '; stack = ' + e.stack);
                }
            }
        }
    };
    Multicaster.prototype.push = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        (_a = this.members).push.apply(_a, args);
    };
    Multicaster.create = function (members) {
        var instance = new Multicaster(members);
        return Object.assign(function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return instance.call.apply(instance, args);
        }, {
            push: function (fn) { return instance.push(fn); },
        });
    };
    return Multicaster;
}());
exports.default = Multicaster;


/***/ }),
/* 24 */
/***/ (function(module, exports, __nested_webpack_require_213579__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_213579__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isSuccessCode = void 0;
var HttpStatusCodes;
(function (HttpStatusCodes) {
    HttpStatusCodes[HttpStatusCodes["Success"] = 200] = "Success";
    HttpStatusCodes[HttpStatusCodes["NoContent"] = 204] = "NoContent";
    HttpStatusCodes[HttpStatusCodes["BadRequest"] = 400] = "BadRequest";
    HttpStatusCodes[HttpStatusCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpStatusCodes[HttpStatusCodes["Forbidden"] = 403] = "Forbidden";
    HttpStatusCodes[HttpStatusCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpStatusCodes[HttpStatusCodes["InternalServerError"] = 500] = "InternalServerError";
})(HttpStatusCodes || (HttpStatusCodes = {}));
function isSuccessCode(statusCode) {
    return statusCode >= HttpStatusCodes.Success && statusCode < HttpStatusCodes.BadRequest;
}
exports.isSuccessCode = isSuccessCode;
exports.default = HttpStatusCodes;


/***/ }),
/* 26 */
/***/ (function(module, exports, __nested_webpack_require_218497__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_218497__(0);
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_218497__(10));
var Utils = tslib_1.__importStar(__nested_webpack_require_218497__(1));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_218497__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_218497__(2));
var connectionerrors_1 = tslib_1.__importDefault(__nested_webpack_require_218497__(20));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_218497__(4));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_218497__(3));
var actions = protocolmessage_1.default.Action;
var closeMessage = protocolmessage_1.default.fromValues({ action: actions.CLOSE });
var disconnectMessage = protocolmessage_1.default.fromValues({ action: actions.DISCONNECT });
/*
 * Transport instances inherit from EventEmitter and emit the following events:
 *
 * event name       data
 * closed           error
 * failed           error
 * disposed
 * connected        null error, connectionSerial, connectionId, connectionDetails
 * event            channel message object
 */
var Transport = /** @class */ (function (_super) {
    tslib_1.__extends(Transport, _super);
    function Transport(connectionManager, auth, params, forceJsonProtocol) {
        var _this = _super.call(this) || this;
        if (forceJsonProtocol) {
            params.format = undefined;
            params.heartbeats = true;
        }
        _this.connectionManager = connectionManager;
        connectionManager.registerProposedTransport(_this);
        _this.auth = auth;
        _this.params = params;
        _this.timeouts = params.options.timeouts;
        _this.format = params.format;
        _this.isConnected = false;
        _this.isFinished = false;
        _this.isDisposed = false;
        _this.maxIdleInterval = null;
        _this.idleTimer = null;
        _this.lastActivity = null;
        return _this;
    }
    Transport.prototype.connect = function () { };
    Transport.prototype.close = function () {
        if (this.isConnected) {
            this.requestClose();
        }
        this.finish('closed', connectionerrors_1.default.closed());
    };
    Transport.prototype.disconnect = function (err) {
        /* Used for network/transport issues that need to result in the transport
         * being disconnected, but should not transition the connection to 'failed' */
        if (this.isConnected) {
            this.requestDisconnect();
        }
        this.finish('disconnected', err || connectionerrors_1.default.disconnected());
    };
    Transport.prototype.fail = function (err) {
        /* Used for client-side-detected fatal connection issues */
        if (this.isConnected) {
            this.requestDisconnect();
        }
        this.finish('failed', err || connectionerrors_1.default.failed());
    };
    Transport.prototype.finish = function (event, err) {
        var _a;
        if (this.isFinished) {
            return;
        }
        this.isFinished = true;
        this.isConnected = false;
        this.maxIdleInterval = null;
        clearTimeout((_a = this.idleTimer) !== null && _a !== void 0 ? _a : undefined);
        this.idleTimer = null;
        this.emit(event, err);
        this.dispose();
    };
    Transport.prototype.onProtocolMessage = function (message) {
        if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Transport.onProtocolMessage()', 'received on ' +
                this.shortName +
                ': ' +
                protocolmessage_1.default.stringify(message) +
                '; connectionId = ' +
                this.connectionManager.connectionId);
        }
        this.onActivity();
        switch (message.action) {
            case actions.HEARTBEAT:
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Transport.onProtocolMessage()', this.shortName + ' heartbeat; connectionId = ' + this.connectionManager.connectionId);
                this.emit('heartbeat', message.id);
                break;
            case actions.CONNECTED:
                this.onConnect(message);
                this.emit('connected', message.error, message.connectionId, message.connectionDetails, message);
                break;
            case actions.CLOSED:
                this.onClose(message);
                break;
            case actions.DISCONNECTED:
                this.onDisconnect(message);
                break;
            case actions.ACK:
                this.emit('ack', message.msgSerial, message.count);
                break;
            case actions.NACK:
                this.emit('nack', message.msgSerial, message.count, message.error);
                break;
            case actions.SYNC:
                this.connectionManager.onChannelMessage(message, this);
                break;
            case actions.ACTIVATE:
                // Ignored.
                break;
            case actions.AUTH:
                this.auth.authorize(function (err) {
                    if (err) {
                        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Transport.onProtocolMessage()', 'Ably requested re-authentication, but unable to obtain a new token: ' + Utils.inspectError(err));
                    }
                });
                break;
            case actions.ERROR:
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.onProtocolMessage()', 'received error action; connectionId = ' +
                    this.connectionManager.connectionId +
                    '; err = ' +
                    platform_1.default.Config.inspect(message.error) +
                    (message.channel ? ', channel: ' + message.channel : ''));
                if (message.channel === undefined) {
                    this.onFatalError(message);
                    break;
                }
                /* otherwise it's a channel-specific error, so handle it in the channel */
                this.connectionManager.onChannelMessage(message, this);
                break;
            default:
                /* all other actions are channel-specific */
                this.connectionManager.onChannelMessage(message, this);
        }
    };
    Transport.prototype.onConnect = function (message) {
        this.isConnected = true;
        if (!message.connectionDetails) {
            throw new Error('Transport.onConnect(): Connect message recieved without connectionDetails');
        }
        var maxPromisedIdle = message.connectionDetails.maxIdleInterval;
        if (maxPromisedIdle) {
            this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;
            this.onActivity();
        }
        /* else Realtime declines to guarantee any maximum idle interval - CD2h */
    };
    Transport.prototype.onDisconnect = function (message) {
        /* Used for when the server has disconnected the client (usually with a
         * DISCONNECTED action) */
        var err = message && message.error;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.onDisconnect()', 'err = ' + Utils.inspectError(err));
        this.finish('disconnected', err);
    };
    Transport.prototype.onFatalError = function (message) {
        /* On receipt of a fatal connection error, we can assume that the server
         * will close the connection and the transport, and do not need to request
         * a disconnection - RTN15i */
        var err = message && message.error;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.onFatalError()', 'err = ' + Utils.inspectError(err));
        this.finish('failed', err);
    };
    Transport.prototype.onClose = function (message) {
        var err = message && message.error;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.onClose()', 'err = ' + Utils.inspectError(err));
        this.finish('closed', err);
    };
    Transport.prototype.requestClose = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.requestClose()', '');
        this.send(closeMessage);
    };
    Transport.prototype.requestDisconnect = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.requestDisconnect()', '');
        this.send(disconnectMessage);
    };
    Transport.prototype.ping = function (id) {
        var msg = { action: protocolmessage_1.default.Action.HEARTBEAT };
        if (id)
            msg.id = id;
        this.send(protocolmessage_1.default.fromValues(msg));
    };
    Transport.prototype.dispose = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.dispose()', '');
        this.isDisposed = true;
        this.off();
    };
    Transport.prototype.onActivity = function () {
        if (!this.maxIdleInterval) {
            return;
        }
        this.lastActivity = this.connectionManager.lastActivity = Utils.now();
        this.setIdleTimer(this.maxIdleInterval + 100);
    };
    Transport.prototype.setIdleTimer = function (timeout) {
        var _this = this;
        if (!this.idleTimer) {
            this.idleTimer = setTimeout(function () {
                _this.onIdleTimerExpire();
            }, timeout);
        }
    };
    Transport.prototype.onIdleTimerExpire = function () {
        if (!this.lastActivity || !this.maxIdleInterval) {
            throw new Error('Transport.onIdleTimerExpire(): lastActivity/maxIdleInterval not set');
        }
        this.idleTimer = null;
        var sinceLast = Utils.now() - this.lastActivity;
        var timeRemaining = this.maxIdleInterval - sinceLast;
        if (timeRemaining <= 0) {
            var msg = 'No activity seen from realtime in ' + sinceLast + 'ms; assuming connection has dropped';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Transport.onIdleTimerExpire()', msg);
            this.disconnect(new errorinfo_1.default(msg, 80003, 408));
        }
        else {
            this.setIdleTimer(timeRemaining + 100);
        }
    };
    Transport.tryConnect = function (transportCtor, connectionManager, auth, transportParams, callback) {
        var transport = new transportCtor(connectionManager, auth, transportParams);
        var transportAttemptTimer;
        var errorCb = function (err) {
            clearTimeout(transportAttemptTimer);
            callback({ event: this.event, error: err });
        };
        var realtimeRequestTimeout = connectionManager.options.timeouts.realtimeRequestTimeout;
        transportAttemptTimer = setTimeout(function () {
            transport.off(['preconnect', 'disconnected', 'failed']);
            transport.dispose();
            errorCb.call({ event: 'disconnected' }, new errorinfo_1.default('Timeout waiting for transport to indicate itself viable', 50000, 500));
        }, realtimeRequestTimeout);
        transport.on(['failed', 'disconnected'], errorCb);
        transport.on('preconnect', function () {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.tryConnect()', 'viable transport ' + transport);
            clearTimeout(transportAttemptTimer);
            transport.off(['failed', 'disconnected'], errorCb);
            callback(null, transport);
        });
        transport.connect();
    };
    return Transport;
}(eventemitter_1.default));
exports.default = Transport;


/***/ }),
/* 27 */
/***/ (function(module, exports, __nested_webpack_require_230082__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_230082__(6), __nested_webpack_require_230082__(40), __nested_webpack_require_230082__(24));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            var block;

	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));

/***/ }),
/* 28 */
/***/ (function(module, exports, __nested_webpack_require_233971__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_233971__(6), __nested_webpack_require_233971__(27));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            var block;

	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            var modeCreator;

	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            var finalProcessedBlocks;

	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            var wordArray;

	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            var salt;

	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));

/***/ }),
/* 29 */
/***/ (function(module, exports, __nested_webpack_require_263517__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Request = exports.createRequest = void 0;
var tslib_1 = __nested_webpack_require_263517__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_263517__(1));
var comettransport_1 = tslib_1.__importDefault(__nested_webpack_require_263517__(12));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_263517__(3));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_263517__(7));
var errorinfo_1 = __nested_webpack_require_263517__(4);
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_263517__(8));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_263517__(2));
var XHRStates_1 = tslib_1.__importDefault(__nested_webpack_require_263517__(21));
// Workaround for salesforce lightning locker compatibility
var globalObject = Utils.getGlobalObject();
var noop = function () { };
/* Can't just use window.Ably, as that won't exist if using the commonjs version. */
var _ = (globalObject._ablyjs_jsonp = {});
/* express strips out parantheses from the callback!
 * Kludge to still alow its responses to work, while not keeping the
 * function form for normal use and not cluttering window.Ably
 * https://github.com/expressjs/express/blob/5b4d4b4ab1324743534fbcd4709f4e75bb4b4e9d/lib/response.js#L305
 */
_._ = function (id) {
    return _['_' + id] || noop;
};
var idCounter = 1;
var shortName = 'jsonp';
function createRequest(uri, headers, params, body, requestMode, timeouts, method) {
    /* JSONP requests are used either with the context being a realtime
     * transport, or with timeouts passed in (for when used by a rest client),
     * or completely standalone.  Use the appropriate timeouts in each case */
    timeouts = timeouts || defaults_1.default.TIMEOUTS;
    return new Request(undefined, uri, headers, Utils.copy(params), body, requestMode, timeouts, method);
}
exports.createRequest = createRequest;
var JSONPTransport = /** @class */ (function (_super) {
    tslib_1.__extends(JSONPTransport, _super);
    function JSONPTransport(connectionManager, auth, params) {
        var _this = _super.call(this, connectionManager, auth, params) || this;
        _this.shortName = shortName;
        params.stream = false;
        return _this;
    }
    JSONPTransport.isAvailable = function () {
        return platform_1.default.Config.jsonpSupported && platform_1.default.Config.allowComet;
    };
    JSONPTransport.prototype.toString = function () {
        return 'JSONPTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
    };
    JSONPTransport.prototype.createRequest = function (uri, headers, params, body, requestMode, timeouts, method) {
        /* JSONP requests are used either with the context being a realtime
         * transport, or with timeouts passed in (for when used by a rest client),
         * or completely standalone.  Use the appropriate timeouts in each case */
        timeouts = (this === null || this === void 0 ? void 0 : this.timeouts) || timeouts || defaults_1.default.TIMEOUTS;
        return createRequest(uri, headers, params, body, requestMode, timeouts, method);
    };
    return JSONPTransport;
}(comettransport_1.default));
var Request = /** @class */ (function (_super) {
    tslib_1.__extends(Request, _super);
    function Request(id, uri, headers, params, body, requestMode, timeouts, method) {
        var _this = _super.call(this) || this;
        if (id === undefined)
            id = idCounter++;
        _this.id = id;
        _this.uri = uri;
        _this.params = params || {};
        _this.params.rnd = Utils.cheapRandStr();
        if (headers) {
            /* JSONP doesn't allow headers. Cherry-pick a couple to turn into qs params */
            if (headers['X-Ably-Version'])
                _this.params.v = headers['X-Ably-Version'];
            if (headers['X-Ably-Lib'])
                _this.params.lib = headers['X-Ably-Lib'];
        }
        _this.body = body;
        _this.method = method;
        _this.requestMode = requestMode;
        _this.timeouts = timeouts;
        _this.requestComplete = false;
        return _this;
    }
    Request.prototype.exec = function () {
        var _this = this;
        var id = this.id, body = this.body, method = this.method, uri = this.uri, params = this.params;
        params.callback = '_ablyjs_jsonp._(' + id + ')';
        params.envelope = 'jsonp';
        if (body) {
            params.body = body;
        }
        if (method && method !== 'get') {
            params.method = method;
        }
        var script = (this.script = document.createElement('script'));
        var src = uri + Utils.toQueryString(params);
        script.src = src;
        if (script.src.split('/').slice(-1)[0] !== src.split('/').slice(-1)[0]) {
            /* The src has been truncated. Can't abort, but can at least emit an
             * error so the user knows what's gone wrong. (Can't compare strings
             * directly as src may have a port, script.src won't) */
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'JSONP Request.exec()', 'Warning: the browser appears to have truncated the script URI. This will likely result in the request failing due to an unparseable body param');
        }
        script.async = true;
        script.type = 'text/javascript';
        script.charset = 'UTF-8';
        script.onerror = function (err) {
            _this.complete(new errorinfo_1.PartialErrorInfo('JSONP script error (event: ' + platform_1.default.Config.inspect(err) + ')', null, 400));
        };
        _['_' + id] = function (message) {
            if (message.statusCode) {
                /* Handle as enveloped jsonp, as all jsonp transport uses should be */
                var response = message.response;
                if (message.statusCode == 204) {
                    _this.complete(null, null, null, message.statusCode);
                }
                else if (!response) {
                    _this.complete(new errorinfo_1.PartialErrorInfo('Invalid server response: no envelope detected', null, 500));
                }
                else if (message.statusCode < 400 || Utils.isArray(response)) {
                    /* If response is an array, it's an array of protocol messages -- even if
                     * it contains an error action (hence the nonsuccess statuscode), we can
                     * consider the request to have succeeded, just pass it on to
                     * onProtocolMessage to decide what to do */
                    _this.complete(null, response, message.headers, message.statusCode);
                }
                else {
                    var err = response.error || new errorinfo_1.PartialErrorInfo('Error response received from server', null, message.statusCode);
                    _this.complete(err);
                }
            }
            else {
                /* Handle as non-enveloped -- as will be eg from a customer's authUrl server */
                _this.complete(null, message);
            }
        };
        var timeout = this.requestMode == XHRStates_1.default.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout;
        this.timer = setTimeout(this.abort.bind(this), timeout);
        var head = document.getElementsByTagName('head')[0];
        head.insertBefore(script, head.firstChild);
    };
    Request.prototype.complete = function (err, body, headers, statusCode) {
        headers = headers || {};
        if (!this.requestComplete) {
            this.requestComplete = true;
            var contentType = void 0;
            if (body) {
                contentType = typeof body == 'string' ? 'text/plain' : 'application/json';
                headers['content-type'] = contentType;
                this.emit('data', body);
            }
            this.emit('complete', err, body, headers, /* unpacked: */ true, statusCode);
            this.dispose();
        }
    };
    Request.prototype.abort = function () {
        this.dispose();
    };
    Request.prototype.dispose = function () {
        var timer = this.timer;
        if (timer) {
            clearTimeout(timer);
            this.timer = null;
        }
        var script = this.script;
        if (script.parentNode)
            script.parentNode.removeChild(script);
        delete _[this.id];
        this.emit('disposed');
    };
    return Request;
}(eventemitter_1.default));
exports.Request = Request;
function default_1(connectionManager) {
    globalObject.JSONPTransport = JSONPTransport;
    if (JSONPTransport.isAvailable()) {
        connectionManager.supportedTransports[shortName] = JSONPTransport;
    }
    return JSONPTransport;
}
exports.default = default_1;


/***/ }),
/* 30 */
/***/ (function(module, exports, __nested_webpack_require_272270__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_272270__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_272270__(1));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(2));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(8));
var auth_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(17));
var push_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(46));
var paginatedresource_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(19));
var channel_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(33));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(4));
var stats_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(49));
var HttpMethods_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(18));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(3));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(9));
var presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(15));
var resource_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(14));
var noop = function () { };
var Rest = /** @class */ (function () {
    function Rest(options) {
        if (!options) {
            var msg = 'no options provided';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Rest()', msg);
            throw new Error(msg);
        }
        var optionsObj = defaults_1.default.objectifyOptions(options);
        if (optionsObj.log) {
            logger_1.default.setLog(optionsObj.log.level, optionsObj.log.handler);
        }
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Rest()', 'initialized with clientOptions ' + platform_1.default.Config.inspect(options));
        var normalOptions = (this.options = defaults_1.default.normaliseOptions(optionsObj));
        /* process options */
        if (normalOptions.key) {
            var keyMatch = normalOptions.key.match(/^([^:\s]+):([^:.\s]+)$/);
            if (!keyMatch) {
                var msg = 'invalid key parameter';
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Rest()', msg);
                throw new errorinfo_1.default(msg, 40400, 404);
            }
            normalOptions.keyName = keyMatch[1];
            normalOptions.keySecret = keyMatch[2];
        }
        if ('clientId' in normalOptions) {
            if (!(typeof normalOptions.clientId === 'string' || normalOptions.clientId === null))
                throw new errorinfo_1.default('clientId must be either a string or null', 40012, 400);
            else if (normalOptions.clientId === '*')
                throw new errorinfo_1.default('Can’t use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: "*"}})', 40012, 400);
        }
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Rest()', 'started; version = ' + defaults_1.default.version);
        this.baseUri = this.authority = function (host) {
            return defaults_1.default.getHttpScheme(normalOptions) + host + ':' + defaults_1.default.getPort(normalOptions, false);
        };
        this._currentFallback = null;
        this.serverTimeOffset = null;
        this.http = new platform_1.default.Http(normalOptions);
        this.auth = new auth_1.default(this, normalOptions);
        this.channels = new Channels(this);
        this.push = new push_1.default(this);
    }
    Rest.prototype.stats = function (params, callback) {
        /* params and callback are optional; see if params contains the callback */
        if (callback === undefined) {
            if (typeof params == 'function') {
                callback = params;
                params = null;
            }
            else {
                if (this.options.promises) {
                    return Utils.promisify(this, 'stats', [params]);
                }
                callback = noop;
            }
        }
        var headers = Utils.defaultGetHeaders(this.options), format = this.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.http.supportsLinkHeaders ? undefined : format;
        if (this.options.headers)
            Utils.mixin(headers, this.options.headers);
        new paginatedresource_1.default(this, '/stats', headers, envelope, function (body, headers, unpacked) {
            var statsValues = unpacked ? body : JSON.parse(body);
            for (var i = 0; i < statsValues.length; i++)
                statsValues[i] = stats_1.default.fromValues(statsValues[i]);
            return statsValues;
        }).get(params, callback);
    };
    Rest.prototype.time = function (params, callback) {
        var _this = this;
        /* params and callback are optional; see if params contains the callback */
        if (callback === undefined) {
            if (typeof params == 'function') {
                callback = params;
                params = null;
            }
            else {
                if (this.options.promises) {
                    return Utils.promisify(this, 'time', [params]);
                }
            }
        }
        var _callback = callback || noop;
        var headers = Utils.defaultGetHeaders(this.options);
        if (this.options.headers)
            Utils.mixin(headers, this.options.headers);
        var timeUri = function (host) {
            return _this.authority(host) + '/time';
        };
        this.http.do(HttpMethods_1.default.Get, this, timeUri, headers, null, params, function (err, res, headers, unpacked) {
            if (err) {
                _callback(err);
                return;
            }
            if (!unpacked)
                res = JSON.parse(res);
            var time = res[0];
            if (!time) {
                _callback(new errorinfo_1.default('Internal error (unexpected result type from GET /time)', 50000, 500));
                return;
            }
            /* calculate time offset only once for this device by adding to the prototype */
            _this.serverTimeOffset = time - Utils.now();
            _callback(null, time);
        });
    };
    Rest.prototype.request = function (method, path, params, body, customHeaders, callback) {
        var useBinary = this.options.useBinaryProtocol, encoder = useBinary ? platform_1.default.Config.msgpack.encode : JSON.stringify, decoder = useBinary ? platform_1.default.Config.msgpack.decode : JSON.parse, format = useBinary ? Utils.Format.msgpack : Utils.Format.json, envelope = this.http.supportsLinkHeaders ? undefined : format;
        params = params || {};
        var _method = method.toLowerCase();
        var headers = _method == 'get' ? Utils.defaultGetHeaders(this.options, format) : Utils.defaultPostHeaders(this.options, format);
        if (callback === undefined) {
            if (this.options.promises) {
                return Utils.promisify(this, 'request', [method, path, params, body, customHeaders]);
            }
            callback = noop;
        }
        if (typeof body !== 'string') {
            body = encoder(body);
        }
        if (this.options.headers) {
            Utils.mixin(headers, this.options.headers);
        }
        if (customHeaders) {
            Utils.mixin(headers, customHeaders);
        }
        var paginatedResource = new paginatedresource_1.default(this, path, headers, envelope, function (resbody, headers, unpacked) {
            return Utils.ensureArray(unpacked ? resbody : decoder(resbody));
        }, 
        /* useHttpPaginatedResponse: */ true);
        if (!Utils.arrIn(platform_1.default.Http.methods, _method)) {
            throw new errorinfo_1.default('Unsupported method ' + _method, 40500, 405);
        }
        if (Utils.arrIn(platform_1.default.Http.methodsWithBody, _method)) {
            paginatedResource[_method](params, body, callback);
        }
        else {
            paginatedResource[_method](params, callback);
        }
    };
    Rest.prototype.batchPublish = function (specOrSpecs, callbackArg) {
        if (callbackArg === undefined) {
            if (this.options.promises) {
                return Utils.promisify(this, 'batchPublish', [specOrSpecs]);
            }
            callbackArg = noop;
        }
        var callback = callbackArg;
        var requestBodyDTO;
        var singleSpecMode;
        if (Utils.isArray(specOrSpecs)) {
            requestBodyDTO = specOrSpecs;
            singleSpecMode = false;
        }
        else {
            requestBodyDTO = [specOrSpecs];
            singleSpecMode = true;
        }
        var format = this.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(this.options, format);
        if (this.options.headers)
            Utils.mixin(headers, this.options.headers);
        var requestBody = Utils.encodeBody(requestBodyDTO, format);
        resource_1.default.post(this, '/messages', requestBody, headers, { newBatchResponse: 'true' }, null, function (err, body, headers, unpacked) {
            if (err) {
                // TODO remove this type assertion after fixing https://github.com/ably/ably-js/issues/1405
                callback(err);
                return;
            }
            var batchResults = (unpacked ? body : Utils.decodeBody(body, format));
            // I don't love the below type assertions for `callback` but not sure how to avoid them
            if (singleSpecMode) {
                callback(null, batchResults[0]);
            }
            else {
                callback(null, batchResults);
            }
        });
    };
    Rest.prototype.batchPresence = function (channels, callbackArg) {
        if (callbackArg === undefined) {
            if (this.options.promises) {
                return Utils.promisify(this, 'batchPresence', [channels]);
            }
            callbackArg = noop;
        }
        var callback = callbackArg;
        var format = this.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(this.options, format);
        if (this.options.headers)
            Utils.mixin(headers, this.options.headers);
        var channelsParam = channels.join(',');
        resource_1.default.get(this, '/presence', headers, { newBatchResponse: 'true', channels: channelsParam }, null, function (err, body, headers, unpacked) {
            if (err) {
                // TODO remove this type assertion after fixing https://github.com/ably/ably-js/issues/1405
                callback(err);
                return;
            }
            var batchResult = (unpacked ? body : Utils.decodeBody(body, format));
            callback(null, batchResult);
        });
    };
    Rest.prototype.setLog = function (logOptions) {
        logger_1.default.setLog(logOptions.level, logOptions.handler);
    };
    Rest.Promise = function (options) {
        options = defaults_1.default.objectifyOptions(options);
        options.promises = true;
        return new Rest(options);
    };
    Rest.Callbacks = Rest;
    Rest.Platform = platform_1.default;
    Rest.Message = message_1.default;
    Rest.PresenceMessage = presencemessage_1.default;
    return Rest;
}());
var Channels = /** @class */ (function () {
    function Channels(rest) {
        this.rest = rest;
        this.all = Object.create(null);
    }
    Channels.prototype.get = function (name, channelOptions) {
        name = String(name);
        var channel = this.all[name];
        if (!channel) {
            this.all[name] = channel = new channel_1.default(this.rest, name, channelOptions);
        }
        else if (channelOptions) {
            channel.setOptions(channelOptions);
        }
        return channel;
    };
    /* Included to support certain niche use-cases; most users should ignore this.
     * Please do not use this unless you know what you're doing */
    Channels.prototype.release = function (name) {
        delete this.all[String(name)];
    };
    return Channels;
}());
exports.default = Rest;


/***/ }),
/* 31 */
/***/ (function(module, exports, __nested_webpack_require_284415__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_284415__(6));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Utf8;

}));

/***/ }),
/* 32 */
/***/ (function(module, exports, __nested_webpack_require_284686__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_284686__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));

/***/ }),
/* 33 */
/***/ (function(module, exports, __nested_webpack_require_290135__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_290135__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_290135__(1));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(2));
var presence_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(34));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(9));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(4));
var paginatedresource_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(19));
var resource_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(14));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(3));
function noop() { }
var MSG_ID_ENTROPY_BYTES = 9;
function allEmptyIds(messages) {
    return Utils.arrEvery(messages, function (message) {
        return !message.id;
    });
}
function normaliseChannelOptions(options) {
    var channelOptions = options || {};
    if (channelOptions.cipher) {
        if (!platform_1.default.Crypto)
            throw new Error('Encryption not enabled; use ably.encryption.js instead');
        var cipher = platform_1.default.Crypto.getCipher(channelOptions.cipher);
        channelOptions.cipher = cipher.cipherParams;
        channelOptions.channelCipher = cipher.cipher;
    }
    else if ('cipher' in channelOptions) {
        /* Don't deactivate an existing cipher unless options
         * has a 'cipher' key that's falsey */
        channelOptions.cipher = undefined;
        channelOptions.channelCipher = null;
    }
    return channelOptions;
}
var Channel = /** @class */ (function (_super) {
    tslib_1.__extends(Channel, _super);
    function Channel(rest, name, channelOptions) {
        var _this = _super.call(this) || this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Channel()', 'started; name = ' + name);
        _this.rest = rest;
        _this.name = name;
        _this.basePath = '/channels/' + encodeURIComponent(name);
        _this.presence = new presence_1.default(_this);
        _this.channelOptions = normaliseChannelOptions(channelOptions);
        return _this;
    }
    Channel.prototype.setOptions = function (options) {
        this.channelOptions = normaliseChannelOptions(options);
    };
    Channel.prototype.history = function (params, callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Channel.history()', 'channel = ' + this.name);
        /* params and callback are optional; see if params contains the callback */
        if (callback === undefined) {
            if (typeof params == 'function') {
                callback = params;
                params = null;
            }
            else {
                if (this.rest.options.promises) {
                    return Utils.promisify(this, 'history', arguments);
                }
                callback = noop;
            }
        }
        this._history(params, callback);
    };
    Channel.prototype._history = function (params, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        var options = this.channelOptions;
        new paginatedresource_1.default(rest, this.basePath + '/messages', headers, envelope, function (body, headers, unpacked) {
            return message_1.default.fromResponseBody(body, options, unpacked ? undefined : format);
        }).get(params, callback);
    };
    Channel.prototype.publish = function () {
        var _this = this;
        var argCount = arguments.length, first = arguments[0], second = arguments[1];
        var callback = arguments[argCount - 1];
        var messages;
        var params;
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'publish', arguments);
            }
            callback = noop;
        }
        if (typeof first === 'string' || first === null) {
            /* (name, data, ...) */
            messages = [message_1.default.fromValues({ name: first, data: second })];
            params = arguments[2];
        }
        else if (Utils.isObject(first)) {
            messages = [message_1.default.fromValues(first)];
            params = arguments[1];
        }
        else if (Utils.isArray(first)) {
            messages = message_1.default.fromValuesArray(first);
            params = arguments[1];
        }
        else {
            throw new errorinfo_1.default('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);
        }
        if (typeof params !== 'object' || !params) {
            /* No params supplied (so after-message argument is just the callback or undefined) */
            params = {};
        }
        var rest = this.rest, options = rest.options, format = options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, idempotentRestPublishing = rest.options.idempotentRestPublishing, headers = Utils.defaultPostHeaders(rest.options, format);
        if (options.headers)
            Utils.mixin(headers, options.headers);
        if (idempotentRestPublishing && allEmptyIds(messages)) {
            var msgIdBase_1 = Utils.randomString(MSG_ID_ENTROPY_BYTES);
            Utils.arrForEach(messages, function (message, index) {
                message.id = msgIdBase_1 + ':' + index.toString();
            });
        }
        message_1.default.encodeArray(messages, this.channelOptions, function (err) {
            if (err) {
                callback(err);
                return;
            }
            /* RSL1i */
            var size = message_1.default.getMessagesSize(messages), maxMessageSize = options.maxMessageSize;
            if (size > maxMessageSize) {
                callback(new errorinfo_1.default('Maximum size of messages that can be published at once exceeded ( was ' +
                    size +
                    ' bytes; limit is ' +
                    maxMessageSize +
                    ' bytes)', 40009, 400));
                return;
            }
            _this._publish(message_1.default.serialize(messages, format), headers, params, callback);
        });
    };
    Channel.prototype._publish = function (requestBody, headers, params, callback) {
        resource_1.default.post(this.rest, this.basePath + '/messages', requestBody, headers, params, null, callback);
    };
    Channel.prototype.status = function (callback) {
        if (typeof callback !== 'function' && this.rest.options.promises) {
            return Utils.promisify(this, 'status', []);
        }
        var format = this.rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json;
        var headers = Utils.defaultPostHeaders(this.rest.options, format);
        resource_1.default.get(this.rest, this.basePath, headers, {}, format, callback || noop);
    };
    return Channel;
}(eventemitter_1.default));
exports.default = Channel;


/***/ }),
/* 34 */
/***/ (function(module, exports, __nested_webpack_require_297440__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_297440__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_297440__(1));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_297440__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_297440__(2));
var paginatedresource_1 = tslib_1.__importDefault(__nested_webpack_require_297440__(19));
var presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_297440__(15));
function noop() { }
var Presence = /** @class */ (function (_super) {
    tslib_1.__extends(Presence, _super);
    function Presence(channel) {
        var _this = _super.call(this) || this;
        _this.channel = channel;
        _this.basePath = channel.basePath + '/presence';
        return _this;
    }
    Presence.prototype.get = function (params, callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Presence.get()', 'channel = ' + this.channel.name);
        /* params and callback are optional; see if params contains the callback */
        if (callback === undefined) {
            if (typeof params == 'function') {
                callback = params;
                params = null;
            }
            else {
                if (this.channel.rest.options.promises) {
                    return Utils.promisify(this, 'get', arguments);
                }
                callback = noop;
            }
        }
        var rest = this.channel.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.channel.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        var options = this.channel.channelOptions;
        new paginatedresource_1.default(rest, this.basePath, headers, envelope, function (body, headers, unpacked) {
            return presencemessage_1.default.fromResponseBody(body, options, unpacked ? undefined : format);
        }).get(params, callback);
    };
    Presence.prototype.history = function (params, callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Presence.history()', 'channel = ' + this.channel.name);
        return this._history(params, callback);
    };
    Presence.prototype._history = function (params, callback) {
        /* params and callback are optional; see if params contains the callback */
        if (callback === undefined) {
            if (typeof params == 'function') {
                callback = params;
                params = null;
            }
            else {
                if (this.channel.rest.options.promises) {
                    return Utils.promisify(this, '_history', [params]);
                }
                callback = noop;
            }
        }
        var rest = this.channel.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.channel.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        var options = this.channel.channelOptions;
        new paginatedresource_1.default(rest, this.basePath + '/history', headers, envelope, function (body, headers, unpacked) {
            return presencemessage_1.default.fromResponseBody(body, options, unpacked ? undefined : format);
        }).get(params, callback);
    };
    return Presence;
}(eventemitter_1.default));
exports.default = Presence;


/***/ }),
/* 35 */
/***/ (function(module, exports, __nested_webpack_require_301120__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransportParams = void 0;
var tslib_1 = __nested_webpack_require_301120__(0);
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(10));
var Utils = tslib_1.__importStar(__nested_webpack_require_301120__(1));
var protocol_1 = tslib_1.__importStar(__nested_webpack_require_301120__(52));
var defaults_1 = tslib_1.__importStar(__nested_webpack_require_301120__(8));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(3));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(7));
var messagequeue_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(36));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(2));
var connectionstatechange_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(37));
var connectionerrors_1 = tslib_1.__importStar(__nested_webpack_require_301120__(20));
var errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_301120__(4));
var auth_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(17));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(9));
var multicaster_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(23));
var websockettransport_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(53));
var transport_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(26));
var HttpStatusCodes_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(25));
var haveWebStorage = function () { var _a; return typeof platform_1.default.WebStorage !== 'undefined' && ((_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.localSupported); };
var haveSessionStorage = function () { var _a; return typeof platform_1.default.WebStorage !== 'undefined' && ((_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.sessionSupported); };
var actions = protocolmessage_1.default.Action;
var noop = function () { };
var transportPreferenceName = 'ably-transport-preference';
var sessionRecoveryName = 'ably-connection-recovery';
function getSessionRecoverData() {
    var _a, _b;
    return haveSessionStorage() && ((_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.getSession) === null || _b === void 0 ? void 0 : _b.call(_a, sessionRecoveryName));
}
function setSessionRecoverData(value) {
    var _a, _b;
    return haveSessionStorage() && ((_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.setSession) === null || _b === void 0 ? void 0 : _b.call(_a, sessionRecoveryName, value));
}
function clearSessionRecoverData() {
    var _a, _b;
    return haveSessionStorage() && ((_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.removeSession) === null || _b === void 0 ? void 0 : _b.call(_a, sessionRecoveryName));
}
function betterTransportThan(a, b) {
    return (Utils.arrIndexOf(platform_1.default.Defaults.transportPreferenceOrder, a.shortName) >
        Utils.arrIndexOf(platform_1.default.Defaults.transportPreferenceOrder, b.shortName));
}
function bundleWith(dest, src, maxSize) {
    var action;
    if (dest.channel !== src.channel) {
        /* RTL6d3 */
        return false;
    }
    if ((action = dest.action) !== actions.PRESENCE && action !== actions.MESSAGE) {
        /* RTL6d - can only bundle messages or presence */
        return false;
    }
    if (action !== src.action) {
        /* RTL6d4 */
        return false;
    }
    var kind = action === actions.PRESENCE ? 'presence' : 'messages', proposed = dest[kind].concat(src[kind]), size = message_1.default.getMessagesSize(proposed);
    if (size > maxSize) {
        /* RTL6d1 */
        return false;
    }
    if (!Utils.allSame(proposed, 'clientId')) {
        /* RTL6d2 */
        return false;
    }
    if (!Utils.arrEvery(proposed, function (msg) {
        return !msg.id;
    })) {
        /* RTL6d7 */
        return false;
    }
    /* we're good to go! */
    dest[kind] = proposed;
    return true;
}
function decodeRecoveryKey(recoveryKey) {
    try {
        return JSON.parse(recoveryKey);
    }
    catch (e) {
        return null;
    }
}
var TransportParams = /** @class */ (function () {
    function TransportParams(options, host, mode, connectionKey) {
        this.options = options;
        this.host = host;
        this.mode = mode;
        this.connectionKey = connectionKey;
        this.format = options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json;
    }
    TransportParams.prototype.getConnectParams = function (authParams) {
        var params = authParams ? Utils.copy(authParams) : {};
        var options = this.options;
        switch (this.mode) {
            case 'upgrade':
                params.upgrade = this.connectionKey;
                break;
            case 'resume':
                params.resume = this.connectionKey;
                break;
            case 'recover': {
                var recoveryContext = decodeRecoveryKey(options.recover);
                if (recoveryContext) {
                    params.recover = recoveryContext.connectionKey;
                }
                break;
            }
            default:
        }
        if (options.clientId !== undefined) {
            params.clientId = options.clientId;
        }
        if (options.echoMessages === false) {
            params.echo = 'false';
        }
        if (this.format !== undefined) {
            params.format = this.format;
        }
        if (this.stream !== undefined) {
            params.stream = this.stream;
        }
        if (this.heartbeats !== undefined) {
            params.heartbeats = this.heartbeats;
        }
        params.v = defaults_1.default.protocolVersion;
        params.agent = encodeURIComponent((0, defaults_1.getAgentString)(this.options));
        if (options.transportParams !== undefined) {
            Utils.mixin(params, options.transportParams);
        }
        return params;
    };
    TransportParams.prototype.toString = function () {
        var result = '[mode=' + this.mode;
        if (this.host) {
            result += ',host=' + this.host;
        }
        if (this.connectionKey) {
            result += ',connectionKey=' + this.connectionKey;
        }
        if (this.format) {
            result += ',format=' + this.format;
        }
        result += ']';
        return result;
    };
    return TransportParams;
}());
exports.TransportParams = TransportParams;
var ConnectionManager = /** @class */ (function (_super) {
    tslib_1.__extends(ConnectionManager, _super);
    function ConnectionManager(realtime, options) {
        var _this = _super.call(this) || this;
        _this.disconnectedRetryCount = 0;
        ConnectionManager.initTransports();
        _this.realtime = realtime;
        _this.options = options;
        var timeouts = options.timeouts;
        /* connectingTimeout: leave preferenceConnectTimeout (~6s) to try the
         * preference transport, then realtimeRequestTimeout (~10s) to establish
         * the base transport in case that fails */
        var connectingTimeout = timeouts.preferenceConnectTimeout + timeouts.realtimeRequestTimeout;
        _this.states = {
            initialized: {
                state: 'initialized',
                terminal: false,
                queueEvents: true,
                sendEvents: false,
                failState: 'disconnected',
            },
            connecting: {
                state: 'connecting',
                terminal: false,
                queueEvents: true,
                sendEvents: false,
                retryDelay: connectingTimeout,
                failState: 'disconnected',
            },
            connected: {
                state: 'connected',
                terminal: false,
                queueEvents: false,
                sendEvents: true,
                failState: 'disconnected',
            },
            synchronizing: {
                state: 'connected',
                terminal: false,
                queueEvents: true,
                sendEvents: false,
                forceQueueEvents: true,
                failState: 'disconnected',
            },
            disconnected: {
                state: 'disconnected',
                terminal: false,
                queueEvents: true,
                sendEvents: false,
                retryDelay: timeouts.disconnectedRetryTimeout,
                failState: 'disconnected',
            },
            suspended: {
                state: 'suspended',
                terminal: false,
                queueEvents: false,
                sendEvents: false,
                retryDelay: timeouts.suspendedRetryTimeout,
                failState: 'suspended',
            },
            closing: {
                state: 'closing',
                terminal: false,
                queueEvents: false,
                sendEvents: false,
                retryDelay: timeouts.realtimeRequestTimeout,
                failState: 'closed',
            },
            closed: { state: 'closed', terminal: true, queueEvents: false, sendEvents: false, failState: 'closed' },
            failed: { state: 'failed', terminal: true, queueEvents: false, sendEvents: false, failState: 'failed' },
        };
        _this.state = _this.states.initialized;
        _this.errorReason = null;
        _this.queuedMessages = new messagequeue_1.default();
        _this.msgSerial = 0;
        _this.connectionDetails = undefined;
        _this.connectionId = undefined;
        _this.connectionKey = undefined;
        _this.connectionStateTtl = timeouts.connectionStateTtl;
        _this.maxIdleInterval = null;
        _this.transports = Utils.intersect(options.transports || defaults_1.default.defaultTransports, ConnectionManager.supportedTransports);
        /* baseTransports selects the leftmost transport in the Defaults.baseTransportOrder list
         * that's both requested and supported. Normally this will be xhr_polling;
         * if xhr isn't supported it will be jsonp. If the user has forced a
         * transport, it'll just be that one. */
        _this.baseTransport = Utils.intersect(defaults_1.default.baseTransportOrder, _this.transports)[0];
        _this.upgradeTransports = Utils.intersect(_this.transports, defaults_1.default.upgradeTransports);
        _this.transportPreference = null;
        _this.httpHosts = defaults_1.default.getHosts(options);
        _this.activeProtocol = null;
        _this.proposedTransports = [];
        _this.pendingTransports = [];
        _this.host = null;
        _this.lastAutoReconnectAttempt = null;
        _this.lastActivity = null;
        _this.forceFallbackHost = false;
        _this.connectCounter = 0;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Realtime.ConnectionManager()', 'started');
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Realtime.ConnectionManager()', 'requested transports = [' + (options.transports || defaults_1.default.defaultTransports) + ']');
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Realtime.ConnectionManager()', 'available transports = [' + _this.transports + ']');
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Realtime.ConnectionManager()', 'http hosts = [' + _this.httpHosts + ']');
        if (!_this.transports.length) {
            var msg = 'no requested transports available';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'realtime.ConnectionManager()', msg);
            throw new Error(msg);
        }
        var addEventListener = platform_1.default.Config.addEventListener;
        if (addEventListener) {
            /* intercept close event in browser to persist connection id if requested */
            if (haveSessionStorage() && typeof options.recover === 'function') {
                /* Usually can't use bind as not supported in IE8, but IE doesn't support sessionStorage, so... */
                addEventListener('beforeunload', _this.persistConnection.bind(_this));
            }
            if (options.closeOnUnload === true) {
                addEventListener('beforeunload', function () {
                    logger_1.default.logAction(logger_1.default.LOG_MAJOR, 'Realtime.ConnectionManager()', 'beforeunload event has triggered the connection to close as closeOnUnload is true');
                    _this.requestState({ state: 'closing' });
                });
            }
            /* Listen for online and offline events */
            addEventListener('online', function () {
                if (_this.state == _this.states.disconnected || _this.state == _this.states.suspended) {
                    logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager caught browser ‘online’ event', 'reattempting connection');
                    _this.requestState({ state: 'connecting' });
                }
                else if (_this.state == _this.states.connecting) {
                    // RTN20c: if 'online' event recieved while CONNECTING, abandon connection attempt and retry
                    _this.pendingTransports.forEach(function (transport) {
                        // Detach transport listeners to avoid connection state side effects from calling dispose
                        transport.off();
                    });
                    _this.disconnectAllTransports();
                    _this.startConnect();
                }
            });
            addEventListener('offline', function () {
                if (_this.state == _this.states.connected) {
                    logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager caught browser ‘offline’ event', 'disconnecting active transport');
                    // Not sufficient to just go to the 'disconnected' state, want to
                    // force all transports to reattempt the connection. Will immediately
                    // retry.
                    _this.disconnectAllTransports();
                }
            });
        }
        return _this;
    }
    ConnectionManager.initTransports = function () {
        (0, websockettransport_1.default)(ConnectionManager);
        Utils.arrForEach(platform_1.default.Transports, function (initFn) {
            initFn(ConnectionManager);
        });
    };
    ConnectionManager.prototype.createTransportParams = function (host, mode) {
        return new TransportParams(this.options, host, mode, this.connectionKey);
    };
    ConnectionManager.prototype.getTransportParams = function (callback) {
        var _this = this;
        var decideMode = function (modeCb) {
            if (_this.connectionKey) {
                modeCb('resume');
                return;
            }
            if (typeof _this.options.recover === 'string') {
                modeCb('recover');
                return;
            }
            var recoverFn = _this.options.recover, lastSessionData = getSessionRecoverData();
            if (lastSessionData && typeof recoverFn === 'function') {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Calling clientOptions-provided recover function with last session data');
                recoverFn(lastSessionData, function (shouldRecover) {
                    if (shouldRecover) {
                        _this.options.recover = lastSessionData.recoveryKey;
                        modeCb('recover');
                    }
                    else {
                        modeCb('clean');
                    }
                });
                return;
            }
            modeCb('clean');
        };
        decideMode(function (mode) {
            var transportParams = _this.createTransportParams(null, mode);
            if (mode === 'recover') {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Transport recovery mode = recover; recoveryKey = ' + _this.options.recover);
                var recoveryContext = decodeRecoveryKey(_this.options.recover);
                if (recoveryContext) {
                    _this.msgSerial = recoveryContext.msgSerial;
                }
            }
            else {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Transport params = ' + transportParams.toString());
            }
            callback(transportParams);
        });
    };
    /**
     * Attempt to connect using a given transport
     * @param transportParams
     * @param candidate, the transport to try
     * @param callback
     */
    ConnectionManager.prototype.tryATransport = function (transportParams, candidate, callback) {
        var _this = this;
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.tryATransport()', 'trying ' + candidate);
        transport_1.default.tryConnect(ConnectionManager.supportedTransports[candidate], this, this.realtime.auth, transportParams, function (wrappedErr, transport) {
            var state = _this.state;
            if (state == _this.states.closing || state == _this.states.closed || state == _this.states.failed) {
                if (transport) {
                    logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.tryATransport()', 'connection ' + state.state + ' while we were attempting the transport; closing ' + transport);
                    transport.close();
                }
                callback(true);
                return;
            }
            if (wrappedErr) {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.tryATransport()', 'transport ' + candidate + ' ' + wrappedErr.event + ', err: ' + wrappedErr.error.toString());
                /* Comet transport onconnect token errors can be dealt with here.
                 * Websocket ones only happen after the transport claims to be viable,
                 * so are dealt with as non-onconnect token errors */
                if (auth_1.default.isTokenErr(wrappedErr.error) &&
                    !(_this.errorReason && auth_1.default.isTokenErr(_this.errorReason))) {
                    _this.errorReason = wrappedErr.error;
                    /* re-get a token and try again */
                    _this.realtime.auth._forceNewToken(null, null, function (err) {
                        if (err) {
                            _this.actOnErrorFromAuthorize(err);
                            return;
                        }
                        _this.tryATransport(transportParams, candidate, callback);
                    });
                }
                else if (wrappedErr.event === 'failed') {
                    /* Error that's fatal to the connection */
                    _this.notifyState({ state: 'failed', error: wrappedErr.error });
                    callback(true);
                }
                else if (wrappedErr.event === 'disconnected') {
                    if (!(0, connectionerrors_1.isRetriable)(wrappedErr.error)) {
                        /* Error received from the server that does not call for trying a fallback host, eg a rate limit */
                        _this.notifyState({ state: _this.states.connecting.failState, error: wrappedErr.error });
                        callback(true);
                    }
                    else {
                        /* Error with that transport only; continue trying other fallback hosts */
                        callback(false);
                    }
                }
                return;
            }
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.tryATransport()', 'viable transport ' + candidate + '; setting pending');
            _this.setTransportPending(transport, transportParams);
            callback(null, transport);
        });
    };
    /**
     * Called when a transport is indicated to be viable, and the ConnectionManager
     * expects to activate this transport as soon as it is connected.
     * @param transport
     * @param transportParams
     */
    ConnectionManager.prototype.setTransportPending = function (transport, transportParams) {
        var _this = this;
        var mode = transportParams.mode;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.setTransportPending()', 'transport = ' + transport + '; mode = ' + mode);
        Utils.arrDeleteValue(this.proposedTransports, transport);
        this.pendingTransports.push(transport);
        var optimalTransport = platform_1.default.Defaults.transportPreferenceOrder[platform_1.default.Defaults.transportPreferenceOrder.length - 1];
        transport.once('connected', function (error, connectionId, connectionDetails) {
            if (mode == 'upgrade' && _this.activeProtocol) {
                /*  if ws and xhrs are connecting in parallel, delay xhrs activation to let ws go ahead */
                if (transport.shortName !== optimalTransport &&
                    Utils.arrIn(_this.getUpgradePossibilities(), optimalTransport) &&
                    _this.activeProtocol) {
                    setTimeout(function () {
                        _this.scheduleTransportActivation(error, transport, connectionId, connectionDetails);
                    }, _this.options.timeouts.parallelUpgradeDelay);
                }
                else {
                    _this.scheduleTransportActivation(error, transport, connectionId, connectionDetails);
                }
            }
            else {
                _this.activateTransport(error, transport, connectionId, connectionDetails);
                /* allow connectImpl to start the upgrade process if needed, but allow
                 * other event handlers, including activating the transport, to run first */
                platform_1.default.Config.nextTick(function () {
                    _this.connectImpl(transportParams);
                });
            }
            if (mode === 'recover' && _this.options.recover) {
                /* After a successful recovery, we unpersist, as a recovery key cannot
                 * be used more than once */
                _this.options.recover = null;
                _this.unpersistConnection();
            }
        });
        var self = this;
        transport.on(['disconnected', 'closed', 'failed'], function (error) {
            self.deactivateTransport(transport, this.event, error);
        });
        this.emit('transport.pending', transport);
    };
    /**
     * Called when an upgrade transport is connected,
     * to schedule the activation of that transport.
     * @param error
     * @param transport
     * @param connectionId
     * @param connectionDetails
     */
    ConnectionManager.prototype.scheduleTransportActivation = function (error, transport, connectionId, connectionDetails) {
        var _this = this;
        var currentTransport = this.activeProtocol && this.activeProtocol.getTransport(), abandon = function () {
            transport.disconnect();
            Utils.arrDeleteValue(_this.pendingTransports, transport);
        };
        if (this.state !== this.states.connected && this.state !== this.states.connecting) {
            /* This is most likely to happen for the delayed XHRs, when XHRs and ws are scheduled in parallel*/
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' +
                this.state.state +
                (this.state === this.states.synchronizing ? ', but with an upgrade already in progress' : '') +
                ') is not valid to upgrade in; abandoning upgrade to ' +
                transport.shortName);
            abandon();
            return;
        }
        if (currentTransport && !betterTransportThan(transport, currentTransport)) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' +
                transport.shortName +
                ' is no better than current active transport ' +
                currentTransport.shortName +
                ' - abandoning upgrade');
            abandon();
            return;
        }
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Scheduling transport upgrade; transport = ' + transport);
        var oldProtocol = null;
        if (!transport.isConnected) {
            /* This is only possible if the xhr streaming transport was disconnected during the parallelUpgradeDelay */
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' + transport.shortName + 'is no longer connected; abandoning upgrade');
            abandon();
            return;
        }
        if (this.state === this.states.connected) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Currently connected, so temporarily pausing events until the upgrade is complete');
            this.state = this.states.synchronizing;
            oldProtocol = this.activeProtocol;
        }
        else if (this.state !== this.states.connecting) {
            /* Note: upgrading from the connecting state is valid if the old active
             * transport was deactivated after the upgrade transport first connected;
             * see logic in deactivateTransport */
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' +
                this.state.state +
                (this.state === this.states.synchronizing ? ', but with an upgrade already in progress' : '') +
                ') is not valid to upgrade in; abandoning upgrade to ' +
                transport.shortName);
            abandon();
            return;
        }
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Syncing transport; transport = ' + transport);
        var finishUpgrade = function () {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Activating transport; transport = ' + transport);
            // Send ACTIVATE to tell the server to make this transport the
            // active transport, which suspends channels until we re-attach.
            transport.send(protocolmessage_1.default.fromValues({
                action: actions.ACTIVATE,
            }));
            _this.activateTransport(error, transport, connectionId, connectionDetails);
            /* Restore pre-sync state. If state has changed in the meantime,
             * don't touch it -- since the websocket transport waits a tick before
             * disposing itself, it's possible for it to have happily synced
             * without err while, unknown to it, the connection has closed in the
             * meantime and the ws transport is scheduled for death */
            if (_this.state === _this.states.synchronizing) {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, sending queued messages on upgraded transport; transport = ' + transport);
                _this.state = _this.states.connected;
            }
            else {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, but state is now ' + _this.state.state + ', so leaving unchanged');
            }
            if (_this.state.sendEvents) {
                _this.sendQueuedMessages();
            }
        };
        /* Wait until sync is done and old transport is idle before activating new transport. This
         * guarantees that messages arrive at realtime in the same order they are sent.
         *
         * If a message times out on the old transport, since it's still the active transport the
         * message will be requeued. deactivateTransport will see the pending transport and notify
         * the `connecting` state without starting a new connection, so the new transport can take
         * over once deactivateTransport clears the old protocol's queue.
         *
         * If there is no old protocol, that meant that we weren't in the connected state at the
         * beginning of the sync - likely the base transport died just before the sync. So can just
         * finish the upgrade. If we're actually in closing/failed rather than connecting, that's
         * fine, activatetransport will deal with that. */
        if (oldProtocol) {
            /* Most of the time this will be already true: the new-transport sync will have given
             * enough time for in-flight messages on the old transport to complete. */
            oldProtocol.onceIdle(finishUpgrade);
        }
        else {
            finishUpgrade();
        }
    };
    /**
     * Called when a transport is connected, and the connectionmanager decides that
     * it will now be the active transport. Returns whether or not it activated
     * the transport (if the connection is closing/closed it will choose not to).
     * @param transport the transport instance
     * @param connectionId the id of the new active connection
     * @param connectionDetails the details of the new active connection
     */
    ConnectionManager.prototype.activateTransport = function (error, transport, connectionId, connectionDetails) {
        var _this = this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.activateTransport()', 'transport = ' + transport);
        if (error) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', 'error = ' + error);
        }
        if (connectionId) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionId =  ' + connectionId);
        }
        if (connectionDetails) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionDetails =  ' + JSON.stringify(connectionDetails));
        }
        this.persistTransportPreference(transport);
        /* if the connectionmanager moved to the closing/closed state before this
         * connection event, then we won't activate this transport */
        var existingState = this.state, connectedState = this.states.connected.state;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.activateTransport()', 'current state = ' + existingState.state);
        if (existingState.state == this.states.closing.state ||
            existingState.state == this.states.closed.state ||
            existingState.state == this.states.failed.state) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.activateTransport()', 'Disconnecting transport and abandoning');
            transport.disconnect();
            return false;
        }
        /* remove this transport from pending transports */
        Utils.arrDeleteValue(this.pendingTransports, transport);
        /* if the transport is not connected then don't activate it */
        if (!transport.isConnected) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.activateTransport()', 'Declining to activate transport ' + transport + ' since it appears to no longer be connected');
            return false;
        }
        /* the given transport is connected; this will immediately
         * take over as the active transport */
        var existingActiveProtocol = this.activeProtocol;
        this.activeProtocol = new protocol_1.default(transport);
        this.host = transport.params.host;
        var connectionKey = connectionDetails.connectionKey;
        if (connectionKey && this.connectionKey != connectionKey) {
            this.setConnection(connectionId, connectionDetails, !!error);
        }
        /* Rebroadcast any new connectionDetails from the active transport, which
         * can come at any time (eg following a reauth), and emit an RTN24 UPDATE
         * event. (Listener added on nextTick because we're in a transport.on('connected')
         * callback at the moment; if we add it now we'll be adding it to the end
         * of the listeners array and it'll be called immediately) */
        this.onConnectionDetailsUpdate(connectionDetails, transport);
        platform_1.default.Config.nextTick(function () {
            transport.on('connected', function (connectedErr, _connectionId, connectionDetails) {
                _this.onConnectionDetailsUpdate(connectionDetails, transport);
                _this.emit('update', new connectionstatechange_1.default(connectedState, connectedState, null, connectedErr));
            });
        });
        /* If previously not connected, notify the state change (including any
         * error). */
        if (existingState.state === this.states.connected.state) {
            if (error) {
                /* if upgrading without error, leave any existing errorReason alone */
                this.errorReason = this.realtime.connection.errorReason = error;
                /* Only bother emitting an upgrade if there's an error; otherwise it's
                 * just a transport upgrade, so auth details won't have changed */
                this.emit('update', new connectionstatechange_1.default(connectedState, connectedState, null, error));
            }
        }
        else {
            this.notifyState({ state: 'connected', error: error });
            this.errorReason = this.realtime.connection.errorReason = error || null;
        }
        /* Send after the connection state update, as Channels hooks into this to
         * resend attaches on a new transport if necessary */
        this.emit('transport.active', transport);
        /* Gracefully terminate existing protocol */
        if (existingActiveProtocol) {
            if (existingActiveProtocol.messageQueue.count() > 0) {
                /* We could just requeue pending messages on the new transport, but
                 * actually this should never happen: transports should only take over
                 * from other active transports when upgrading, and upgrading waits for
                 * the old transport to be idle. So log an error. */
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', 'Previous active protocol (for transport ' +
                    existingActiveProtocol.transport.shortName +
                    ', new one is ' +
                    transport.shortName +
                    ') finishing with ' +
                    existingActiveProtocol.messageQueue.count() +
                    ' messages still pending');
            }
            if (existingActiveProtocol.transport === transport) {
                var msg = 'Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = ' +
                    transport.shortName +
                    '; stack = ' +
                    new Error().stack;
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
            }
            else {
                existingActiveProtocol.finish();
            }
        }
        /* Terminate any other pending transport(s), and
         * abort any not-yet-pending transport attempts */
        Utils.safeArrForEach(this.pendingTransports, function (pendingTransport) {
            if (pendingTransport === transport) {
                var msg = 'Assumption violated: activating a transport that is still marked as a pending transport; transport = ' +
                    transport.shortName +
                    '; stack = ' +
                    new Error().stack;
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
                Utils.arrDeleteValue(_this.pendingTransports, transport);
            }
            else {
                pendingTransport.disconnect();
            }
        });
        Utils.safeArrForEach(this.proposedTransports, function (proposedTransport) {
            if (proposedTransport === transport) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', 'Assumption violated: activating a transport that is still marked as a proposed transport; transport = ' +
                    transport.shortName +
                    '; stack = ' +
                    new Error().stack);
                Utils.arrDeleteValue(_this.proposedTransports, transport);
            }
            else {
                proposedTransport.dispose();
            }
        });
        return true;
    };
    /**
     * Called when a transport is no longer the active transport. This can occur
     * in any transport connection state.
     * @param transport
     */
    ConnectionManager.prototype.deactivateTransport = function (transport, state, error) {
        var currentProtocol = this.activeProtocol, wasActive = currentProtocol && currentProtocol.getTransport() === transport, wasPending = Utils.arrDeleteValue(this.pendingTransports, transport), wasProposed = Utils.arrDeleteValue(this.proposedTransports, transport), noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'transport = ' + transport);
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'state = ' +
            state +
            (wasActive ? '; was active' : wasPending ? '; was pending' : wasProposed ? '; was proposed' : '') +
            (noTransportsScheduledForActivation ? '' : '; another transport is scheduled for activation'));
        if (error && error.message)
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'reason =  ' + error.message);
        if (wasActive) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'Getting, clearing, and requeuing ' +
                this.activeProtocol.messageQueue.count() +
                ' pending messages');
            this.queuePendingMessages(currentProtocol.getPendingMessages());
            /* Clear any messages we requeue to allow the protocol to become idle.
             * In case of an upgrade, this will trigger an immediate activation of
             * the upgrade transport, so delay a tick so this transport can finish
             * deactivating */
            platform_1.default.Config.nextTick(function () {
                currentProtocol.clearPendingMessages();
            });
            this.activeProtocol = this.host = null;
        }
        this.emit('transport.inactive', transport);
        /* this transport state change is a state change for the connectionmanager if
         * - the transport was the active transport and there are no transports
         *   which are connected and scheduled for activation, just waiting for the
         *   active transport to finish what its doing; or
         * - the transport was the active transport and the error was fatal (so
         *   unhealable by another transport); or
         * - there is no active transport, and this is the last remaining
         *   pending transport (so we were in the connecting state)
         */
        if ((wasActive && noTransportsScheduledForActivation) ||
            (wasActive && state === 'failed') ||
            state === 'closed' ||
            (currentProtocol === null && wasPending && this.pendingTransports.length === 0)) {
            /* If we're disconnected with a 5xx we need to try fallback hosts
             * (RTN14d), but (a) due to how the upgrade sequence works, the
             * host/transport selection sequence only cares about getting to
             * `preconnect` (eg establishing a websocket) getting a `disconnected`
             * protocol message afterwards is too late; and (b) host retry only
             * applies to connectBase unless the stored preference transport doesn't
             * work. We solve this by unpersisting the transport preference and
             * setting an instance variable to force fallback hosts to be used (if
             * any) here. Bit of a kludge, but no real better alternatives without
             * rewriting the entire thing */
            if (state === 'disconnected' && error && error.statusCode > 500 && this.httpHosts.length > 1) {
                this.unpersistTransportPreference();
                this.forceFallbackHost = true;
                /* and try to connect again to try a fallback host without waiting for the usual 15s disconnectedRetryTimeout */
                this.notifyState({ state: state, error: error, retryImmediately: true });
                return;
            }
            /* TODO remove below line once realtime sends token errors as DISCONNECTEDs */
            var newConnectionState = state === 'failed' && auth_1.default.isTokenErr(error) ? 'disconnected' : state;
            this.notifyState({ state: newConnectionState, error: error });
            return;
        }
        if (wasActive && state === 'disconnected' && this.state !== this.states.synchronizing) {
            /* If we were active but there is another transport scheduled for
             * activation, go into to the connecting state until that transport
             * activates and sets us back to connected. (manually starting the
             * transition timers in case that never happens). (If we were in the
             * synchronizing state, then that's fine, the old transport just got its
             * disconnected before the new one got the sync -- ignore it and keep
             * waiting for the sync. If it fails we have a separate sync timer that
             * will expire). */
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'wasActive but another transport is connected and scheduled for activation, so going into the connecting state until it activates');
            this.startSuspendTimer();
            this.startTransitionTimer(this.states.connecting);
            this.notifyState({ state: 'connecting', error: error });
        }
    };
    /* Helper that returns true if there are no transports which are pending,
     * have been connected, and are just waiting for onceNoPending to fire before
     * being activated */
    ConnectionManager.prototype.noTransportsScheduledForActivation = function () {
        return (Utils.isEmpty(this.pendingTransports) ||
            this.pendingTransports.every(function (transport) {
                return !transport.isConnected;
            }));
    };
    ConnectionManager.prototype.setConnection = function (connectionId, connectionDetails, hasConnectionError) {
        /* if connectionKey changes but connectionId stays the same, then just a
         * transport change on the same connection. If connectionId changes, we're
         * on a new connection, with implications for msgSerial and channel state */
        /* If no previous connectionId, don't reset the msgSerial as it may have
         * been set by recover data (unless the recover failed) */
        var prevConnId = this.connectionId, connIdChanged = prevConnId && prevConnId !== connectionId, recoverFailure = !prevConnId && hasConnectionError;
        if (connIdChanged || recoverFailure) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.setConnection()', 'Resetting msgSerial');
            this.msgSerial = 0;
            // RTN19a2: In the event of a new connectionId, previous msgSerials are
            // meaningless.
            this.queuedMessages.resetSendAttempted();
        }
        if (this.connectionId !== connectionId) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.setConnection()', 'New connectionId; reattaching any attached channels');
        }
        this.realtime.connection.id = this.connectionId = connectionId;
        this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;
    };
    ConnectionManager.prototype.clearConnection = function () {
        this.realtime.connection.id = this.connectionId = undefined;
        this.realtime.connection.key = this.connectionKey = undefined;
        this.msgSerial = 0;
        this.unpersistConnection();
    };
    ConnectionManager.prototype.createRecoveryKey = function () {
        // RTN16g2.
        if (!this.connectionKey) {
            return null;
        }
        return JSON.stringify({
            connectionKey: this.connectionKey,
            msgSerial: this.msgSerial,
            channelSerials: this.realtime.channels.channelSerials(),
        });
    };
    ConnectionManager.prototype.checkConnectionStateFreshness = function () {
        if (!this.lastActivity || !this.connectionId) {
            return;
        }
        var sinceLast = Utils.now() - this.lastActivity;
        if (sinceLast > this.connectionStateTtl + this.maxIdleInterval) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.checkConnectionStateFreshness()', 'Last known activity from realtime was ' + sinceLast + 'ms ago; discarding connection state');
            this.clearConnection();
            this.states.connecting.failState = 'suspended';
        }
    };
    /**
     * Called when the connectionmanager wants to persist transport
     * state for later recovery. Only applicable in the browser context.
     */
    ConnectionManager.prototype.persistConnection = function () {
        if (haveSessionStorage()) {
            var recoveryKey = this.createRecoveryKey();
            if (recoveryKey) {
                setSessionRecoverData({
                    recoveryKey: recoveryKey,
                    disconnectedAt: Utils.now(),
                    location: global.location,
                    clientId: this.realtime.auth.clientId,
                });
            }
        }
    };
    /**
     * Called when the connectionmanager wants to persist transport
     * state for later recovery. Only applicable in the browser context.
     */
    ConnectionManager.prototype.unpersistConnection = function () {
        clearSessionRecoverData();
    };
    /*********************
     * state management
     *********************/
    ConnectionManager.prototype.getError = function () {
        return this.errorReason || this.getStateError();
    };
    ConnectionManager.prototype.getStateError = function () {
        var _a, _b;
        return (_b = (_a = connectionerrors_1.default)[this.state.state]) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    ConnectionManager.prototype.activeState = function () {
        return this.state.queueEvents || this.state.sendEvents;
    };
    ConnectionManager.prototype.enactStateChange = function (stateChange) {
        var logLevel = stateChange.current === 'failed' ? logger_1.default.LOG_ERROR : logger_1.default.LOG_MAJOR;
        logger_1.default.logAction(logLevel, 'Connection state', stateChange.current + (stateChange.reason ? '; reason: ' + stateChange.reason : ''));
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.enactStateChange', 'setting new state: ' +
            stateChange.current +
            '; reason = ' +
            (stateChange.reason && stateChange.reason.message));
        var newState = (this.state = this.states[stateChange.current]);
        if (stateChange.reason) {
            this.errorReason = stateChange.reason;
            this.realtime.connection.errorReason = stateChange.reason;
        }
        if (newState.terminal || newState.state === 'suspended') {
            /* suspended is nonterminal, but once in the suspended state, realtime
             * will have discarded our connection state, so futher connection
             * attempts should start from scratch */
            this.clearConnection();
        }
        this.emit('connectionstate', stateChange);
    };
    /****************************************
     * ConnectionManager connection lifecycle
     ****************************************/
    ConnectionManager.prototype.startTransitionTimer = function (transitionState) {
        var _this = this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'transitionState: ' + transitionState.state);
        if (this.transitionTimer) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'clearing already-running timer');
            clearTimeout(this.transitionTimer);
        }
        this.transitionTimer = setTimeout(function () {
            if (_this.transitionTimer) {
                _this.transitionTimer = null;
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager ' + transitionState.state + ' timer expired', 'requesting new state: ' + transitionState.failState);
                _this.notifyState({ state: transitionState.failState });
            }
        }, transitionState.retryDelay);
    };
    ConnectionManager.prototype.cancelTransitionTimer = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.cancelTransitionTimer()', '');
        if (this.transitionTimer) {
            clearTimeout(this.transitionTimer);
            this.transitionTimer = null;
        }
    };
    ConnectionManager.prototype.startSuspendTimer = function () {
        var _this = this;
        if (this.suspendTimer)
            return;
        this.suspendTimer = setTimeout(function () {
            if (_this.suspendTimer) {
                _this.suspendTimer = null;
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager suspend timer expired', 'requesting new state: suspended');
                _this.states.connecting.failState = 'suspended';
                _this.notifyState({ state: 'suspended' });
            }
        }, this.connectionStateTtl);
    };
    ConnectionManager.prototype.checkSuspendTimer = function (state) {
        if (state !== 'disconnected' && state !== 'suspended' && state !== 'connecting')
            this.cancelSuspendTimer();
    };
    ConnectionManager.prototype.cancelSuspendTimer = function () {
        this.states.connecting.failState = 'disconnected';
        if (this.suspendTimer) {
            clearTimeout(this.suspendTimer);
            this.suspendTimer = null;
        }
    };
    ConnectionManager.prototype.startRetryTimer = function (interval) {
        var _this = this;
        this.retryTimer = setTimeout(function () {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager retry timer expired', 'retrying');
            _this.retryTimer = null;
            _this.requestState({ state: 'connecting' });
        }, interval);
    };
    ConnectionManager.prototype.cancelRetryTimer = function () {
        if (this.retryTimer) {
            clearTimeout(this.retryTimer);
            this.retryTimer = null;
        }
    };
    ConnectionManager.prototype.notifyState = function (indicated) {
        var _this = this;
        var _a, _b;
        var state = indicated.state;
        /* We retry immediately if:
         * - something disconnects us while we're connected, or
         * - a viable (but not yet active) transport fails due to a token error (so
         *   this.errorReason will be set, and startConnect will do a forced
         *   authorize). If this.errorReason is already set (to a token error),
         *   then there has been at least one previous attempt to connect that also
         *   failed for a token error, so by RTN14b we go to DISCONNECTED and wait
         *   before trying again */
        var retryImmediately = state === 'disconnected' &&
            (this.state === this.states.connected ||
                this.state === this.states.synchronizing ||
                indicated.retryImmediately ||
                (this.state === this.states.connecting &&
                    indicated.error &&
                    auth_1.default.isTokenErr(indicated.error) &&
                    !(this.errorReason && auth_1.default.isTokenErr(this.errorReason))));
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.notifyState()', 'new state: ' + state + (retryImmediately ? '; will retry connection immediately' : ''));
        /* do nothing if we're already in the indicated state */
        if (state == this.state.state)
            return;
        /* kill timers (possibly excepting suspend timer depending on the notified
         * state), as these are superseded by this notification */
        this.cancelTransitionTimer();
        this.cancelRetryTimer();
        this.checkSuspendTimer(indicated.state);
        if (state === 'suspended' || state === 'connected') {
            this.disconnectedRetryCount = 0;
        }
        /* do nothing if we're unable to move from the current state */
        if (this.state.terminal)
            return;
        /* process new state */
        var newState = this.states[indicated.state];
        var retryDelay = newState.retryDelay;
        if (newState.state === 'disconnected') {
            this.disconnectedRetryCount++;
            retryDelay = Utils.getRetryTime(newState.retryDelay, this.disconnectedRetryCount);
        }
        var change = new connectionstatechange_1.default(this.state.state, newState.state, retryDelay, indicated.error || ((_b = (_a = connectionerrors_1.default)[newState.state]) === null || _b === void 0 ? void 0 : _b.call(_a)));
        if (retryImmediately) {
            var autoReconnect = function () {
                if (_this.state === _this.states.disconnected) {
                    _this.lastAutoReconnectAttempt = Utils.now();
                    _this.requestState({ state: 'connecting' });
                }
            };
            var sinceLast = this.lastAutoReconnectAttempt && Utils.now() - this.lastAutoReconnectAttempt + 1;
            if (sinceLast && sinceLast < 1000) {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.notifyState()', 'Last reconnect attempt was only ' +
                    sinceLast +
                    'ms ago, waiting another ' +
                    (1000 - sinceLast) +
                    'ms before trying again');
                setTimeout(autoReconnect, 1000 - sinceLast);
            }
            else {
                platform_1.default.Config.nextTick(autoReconnect);
            }
        }
        else if (state === 'disconnected' || state === 'suspended') {
            this.startRetryTimer(retryDelay);
        }
        /* If going into disconnect/suspended (and not retrying immediately), or a
         * terminal state, ensure there are no orphaned transports hanging around. */
        if ((state === 'disconnected' && !retryImmediately) || state === 'suspended' || newState.terminal) {
            /* Wait till the next tick so the connection state change is enacted,
             * so aborting transports doesn't trigger redundant state changes */
            platform_1.default.Config.nextTick(function () {
                _this.disconnectAllTransports();
            });
        }
        if (state == 'connected' && !this.activeProtocol) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.notifyState()', 'Broken invariant: attempted to go into connected state, but there is no active protocol');
        }
        /* implement the change and notify */
        this.enactStateChange(change);
        if (this.state.sendEvents) {
            this.sendQueuedMessages();
        }
        else if (!this.state.queueEvents) {
            this.realtime.channels.propogateConnectionInterruption(state, change.reason);
            this.failQueuedMessages(change.reason); // RTN7c
        }
    };
    ConnectionManager.prototype.requestState = function (request) {
        var _this = this;
        var _a, _b;
        var state = request.state;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.requestState()', 'requested state: ' + state + '; current state: ' + this.state.state);
        if (state == this.state.state)
            return; /* silently do nothing */
        /* kill running timers, as this request supersedes them */
        this.cancelTransitionTimer();
        this.cancelRetryTimer();
        /* for suspend timer check rather than cancel -- eg requesting a connecting
         * state should not reset the suspend timer */
        this.checkSuspendTimer(state);
        if (state == 'connecting' && this.state.state == 'connected')
            return;
        if (state == 'closing' && this.state.state == 'closed')
            return;
        var newState = this.states[state], change = new connectionstatechange_1.default(this.state.state, newState.state, null, request.error || ((_b = (_a = connectionerrors_1.default)[newState.state]) === null || _b === void 0 ? void 0 : _b.call(_a)));
        this.enactStateChange(change);
        if (state == 'connecting') {
            platform_1.default.Config.nextTick(function () {
                _this.startConnect();
            });
        }
        if (state == 'closing') {
            this.closeImpl();
        }
    };
    ConnectionManager.prototype.startConnect = function () {
        var _this = this;
        if (this.state !== this.states.connecting) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.startConnect()', 'Must be in connecting state to connect, but was ' + this.state.state);
            return;
        }
        var auth = this.realtime.auth;
        /* The point of the connectCounter mechanism is to ensure that the
         * connection procedure can be cancelled. We want disconnectAllTransports
         * to be able to stop any in-progress connection, even before it gets to
         * the stage of having a pending (or even a proposed) transport that it can
         * dispose() of. So we check that it's still current after any async stage,
         * up until the stage that is synchronous with instantiating a transport */
        var connectCount = ++this.connectCounter;
        var connect = function () {
            _this.checkConnectionStateFreshness();
            _this.getTransportParams(function (transportParams) {
                if (transportParams.mode === 'recover' && transportParams.options.recover) {
                    var recoveryContext = decodeRecoveryKey(transportParams.options.recover);
                    if (recoveryContext) {
                        _this.realtime.channels.recoverChannels(recoveryContext.channelSerials);
                    }
                }
                if (connectCount !== _this.connectCounter) {
                    return;
                }
                _this.connectImpl(transportParams, connectCount);
            });
        };
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.startConnect()', 'starting connection');
        this.startSuspendTimer();
        this.startTransitionTimer(this.states.connecting);
        if (auth.method === 'basic') {
            connect();
        }
        else {
            var authCb = function (err) {
                if (connectCount !== _this.connectCounter) {
                    return;
                }
                if (err) {
                    _this.actOnErrorFromAuthorize(err);
                }
                else {
                    connect();
                }
            };
            if (this.errorReason && auth_1.default.isTokenErr(this.errorReason)) {
                /* Force a refetch of a new token */
                auth._forceNewToken(null, null, authCb);
            }
            else {
                auth._ensureValidAuthCredentials(false, authCb);
            }
        }
    };
    /**
     * There are three stages in connecting:
     * - preference: if there is a cached transport preference, we try to connect
     *   on that. If that fails or times out we abort the attempt, remove the
     *   preference and fall back to base. If it succeeds, we try upgrading it if
     *   needed (will only be in the case where the preference is xhrs and the
     *   browser supports ws).
     * - base: we try to connect with the best transport that we think will
     *   never fail for this browser (usually this is xhr_polling; for very old
     *   browsers will be jsonp, for node will be comet). If it doesn't work, we
     *   try fallback hosts.
     * - upgrade: given a connected transport, we see if there are any better
     *   ones, and if so, try to upgrade to them.
     *
     * connectImpl works out what stage you're at (which is purely a function of
     * the current connection state and whether there are any stored preferences),
     * and dispatches accordingly. After a transport has been set pending,
     * tryATransport calls connectImpl to see if there's another stage to be done.
     * */
    ConnectionManager.prototype.connectImpl = function (transportParams, connectCount) {
        var state = this.state.state;
        if (state !== this.states.connecting.state && state !== this.states.connected.state) {
            /* Only keep trying as long as in the 'connecting' state (or 'connected'
             * for upgrading). Any operation can put us into 'disconnected' to cancel
             * connection attempts and wait before retrying, or 'failed' to fail. */
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectImpl()', 'Must be in connecting state to connect (or connected to upgrade), but was ' + state);
        }
        else if (this.pendingTransports.length) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectImpl()', 'Transports ' + this.pendingTransports[0].toString() + ' currently pending; taking no action');
        }
        else if (state == this.states.connected.state) {
            this.upgradeIfNeeded(transportParams);
        }
        else if (this.transports.length > 1 && this.getTransportPreference()) {
            this.connectPreference(transportParams, connectCount);
        }
        else {
            this.connectBase(transportParams, connectCount);
        }
    };
    ConnectionManager.prototype.connectPreference = function (transportParams, connectCount) {
        var _this = this;
        var preference = this.getTransportPreference();
        var preferenceTimeoutExpired = false;
        if (!Utils.arrIn(this.transports, preference)) {
            this.unpersistTransportPreference();
            this.connectImpl(transportParams, connectCount);
        }
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectPreference()', 'Trying to connect with stored transport preference ' + preference);
        var preferenceTimeout = setTimeout(function () {
            preferenceTimeoutExpired = true;
            if (!(_this.state.state === _this.states.connected.state)) {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectPreference()', 'Shortcircuit connection attempt with ' + preference + ' failed; clearing preference and trying from scratch');
                /* Abort all connection attempts. (This also disconnects the active
                 * protocol, but none exists if we're not in the connected state) */
                _this.disconnectAllTransports();
                /* Be quite agressive about clearing the stored preference if ever it doesn't work */
                _this.unpersistTransportPreference();
            }
            _this.connectImpl(transportParams, connectCount);
        }, this.options.timeouts.preferenceConnectTimeout);
        /* For connectPreference, just use the main host. If host fallback is needed, do it in connectBase.
         * The wstransport it will substitute the httphost for an appropriate wshost */
        transportParams.host = this.httpHosts[0];
        this.tryATransport(transportParams, preference, function (fatal, transport) {
            clearTimeout(preferenceTimeout);
            if (preferenceTimeoutExpired && transport) {
                /* Viable, but too late - connectImpl() will already be trying
                 * connectBase, and we weren't in upgrade mode. Just remove the
                 * onconnected listener and get rid of it */
                transport.off();
                transport.disconnect();
                Utils.arrDeleteValue(_this.pendingTransports, transport);
            }
            else if (!transport && !fatal) {
                /* Preference failed in a transport-specific way. Try more */
                _this.unpersistTransportPreference();
                _this.connectImpl(transportParams, connectCount);
            }
            /* If suceeded, or failed fatally, nothing to do */
        });
    };
    /**
     * Try to establish a transport on the base transport (the best transport
     * such that if it doesn't work, nothing will work) as determined through
     * static feature detection, checking for network connectivity and trying
     * fallback hosts if applicable.
     * @param transportParams
     */
    ConnectionManager.prototype.connectBase = function (transportParams, connectCount) {
        var _this = this;
        var giveUp = function (err) {
            _this.notifyState({ state: _this.states.connecting.failState, error: err });
        };
        var candidateHosts = this.httpHosts.slice();
        var hostAttemptCb = function (fatal, transport) {
            if (connectCount !== _this.connectCounter) {
                return;
            }
            if (!transport && !fatal) {
                tryFallbackHosts();
            }
        };
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectBase()', 'Trying to connect with base transport ' + this.baseTransport);
        /* first try to establish a connection with the priority host with http transport */
        var host = candidateHosts.shift();
        if (!host) {
            giveUp(new errorinfo_1.default('Unable to connect (no available host)', 80003, 404));
            return;
        }
        transportParams.host = host;
        /* this is what we'll be doing if the attempt for the main host fails */
        var tryFallbackHosts = function () {
            /* if there aren't any fallback hosts, fail */
            if (!candidateHosts.length) {
                giveUp(new errorinfo_1.default('Unable to connect (and no more fallback hosts to try)', 80003, 404));
                return;
            }
            /* before trying any fallback (or any remaining fallback) we decide if
             * there is a problem with the ably host, or there is a general connectivity
             * problem */
            if (!_this.realtime.http.checkConnectivity) {
                giveUp(new errorinfo_1.PartialErrorInfo('Internal error: Http.checkConnectivity not set', null, 500));
                return;
            }
            _this.realtime.http.checkConnectivity(function (err, connectivity) {
                if (connectCount !== _this.connectCounter) {
                    return;
                }
                /* we know err won't happen but handle it here anyway */
                if (err) {
                    giveUp(err);
                    return;
                }
                if (!connectivity) {
                    /* the internet isn't reachable, so don't try the fallback hosts */
                    giveUp(new errorinfo_1.default('Unable to connect (network unreachable)', 80003, 404));
                    return;
                }
                /* the network is there, so there's a problem with the main host, or
                 * its dns. Try the fallback hosts. We could try them simultaneously but
                 * that would potentially cause a huge spike in load on the load balancer */
                transportParams.host = Utils.arrPopRandomElement(candidateHosts);
                _this.tryATransport(transportParams, _this.baseTransport, hostAttemptCb);
            });
        };
        if (this.forceFallbackHost && candidateHosts.length) {
            this.forceFallbackHost = false;
            tryFallbackHosts();
            return;
        }
        this.tryATransport(transportParams, this.baseTransport, hostAttemptCb);
    };
    ConnectionManager.prototype.getUpgradePossibilities = function () {
        /* returns the subset of upgradeTransports to the right of the current
         * transport in upgradeTransports (if it's in there - if not, currentSerial
         * will be -1, so return upgradeTransports.slice(0) == upgradeTransports */
        var current = this.activeProtocol.getTransport().shortName;
        var currentSerial = Utils.arrIndexOf(this.upgradeTransports, current);
        return this.upgradeTransports.slice(currentSerial + 1);
    };
    ConnectionManager.prototype.upgradeIfNeeded = function (transportParams) {
        var _this = this;
        var upgradePossibilities = this.getUpgradePossibilities();
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.upgradeIfNeeded()', 'upgrade possibilities: ' + platform_1.default.Config.inspect(upgradePossibilities));
        if (!upgradePossibilities.length) {
            return;
        }
        Utils.arrForEach(upgradePossibilities, function (upgradeTransport) {
            /* Note: the transport may mutate the params, so give each transport a fresh one */
            var upgradeTransportParams = _this.createTransportParams(transportParams.host, 'upgrade');
            _this.tryATransport(upgradeTransportParams, upgradeTransport, noop);
        });
    };
    ConnectionManager.prototype.closeImpl = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.closeImpl()', 'closing connection');
        this.cancelSuspendTimer();
        this.startTransitionTimer(this.states.closing);
        Utils.safeArrForEach(this.pendingTransports, function (transport) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing pending transport: ' + transport);
            if (transport)
                transport.close();
        });
        Utils.safeArrForEach(this.proposedTransports, function (transport) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.closeImpl()', 'Disposing of proposed transport: ' + transport);
            if (transport)
                transport.dispose();
        });
        if (this.activeProtocol) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing active transport: ' + this.activeProtocol.getTransport());
            this.activeProtocol.getTransport().close();
        }
        /* If there was an active transport, this will probably be
         * preempted by the notifyState call in deactivateTransport */
        this.notifyState({ state: 'closed' });
    };
    ConnectionManager.prototype.onAuthUpdated = function (tokenDetails, callback) {
        var _this = this;
        var _a;
        switch (this.state.state) {
            case 'connected': {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.onAuthUpdated()', 'Sending AUTH message on active transport');
                /* If there are any proposed/pending transports (eg an upgrade that
                 * isn't yet scheduled for activation) that hasn't yet started syncing,
                 * just to get rid of them & restart the upgrade with the new token, to
                 * avoid a race condition. (If it has started syncing, the AUTH will be
                 * queued until the upgrade is complete, so everything's fine) */
                if ((this.pendingTransports.length || this.proposedTransports.length) &&
                    this.state !== this.states.synchronizing) {
                    this.disconnectAllTransports(/* exceptActive: */ true);
                    var transportParams_1 = this.activeProtocol.getTransport().params;
                    platform_1.default.Config.nextTick(function () {
                        if (_this.state.state === 'connected') {
                            _this.upgradeIfNeeded(transportParams_1);
                        }
                    });
                }
                /* Do any transport-specific new-token action */
                var activeTransport = (_a = this.activeProtocol) === null || _a === void 0 ? void 0 : _a.getTransport();
                if (activeTransport && activeTransport.onAuthUpdated) {
                    activeTransport.onAuthUpdated(tokenDetails);
                }
                var authMsg = protocolmessage_1.default.fromValues({
                    action: actions.AUTH,
                    auth: {
                        accessToken: tokenDetails.token,
                    },
                });
                this.send(authMsg);
                /* The answer will come back as either a connectiondetails event
                 * (realtime sends a CONNECTED to acknowledge the reauth) or a
                 * statechange to failed */
                var successListener_1 = function () {
                    _this.off(failureListener_1);
                    callback(null, tokenDetails);
                };
                var failureListener_1 = function (stateChange) {
                    if (stateChange.current === 'failed') {
                        _this.off(successListener_1);
                        _this.off(failureListener_1);
                        callback(stateChange.reason || _this.getStateError());
                    }
                };
                this.once('connectiondetails', successListener_1);
                this.on('connectionstate', failureListener_1);
                break;
            }
            case 'connecting':
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.onAuthUpdated()', 'Aborting current connection attempts in order to start again with the new auth details');
                this.disconnectAllTransports();
            /* fallthrough to add statechange listener */
            default: {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.onAuthUpdated()', 'Connection state is ' + this.state.state + '; waiting until either connected or failed');
                var listener_1 = function (stateChange) {
                    switch (stateChange.current) {
                        case 'connected':
                            _this.off(listener_1);
                            callback(null, tokenDetails);
                            break;
                        case 'failed':
                        case 'closed':
                        case 'suspended':
                            _this.off(listener_1);
                            callback(stateChange.reason || _this.getStateError());
                            break;
                        default:
                            /* ignore till we get either connected or failed */
                            break;
                    }
                };
                this.on('connectionstate', listener_1);
                if (this.state.state === 'connecting') {
                    /* can happen if in the connecting state but no transport was pending
                     * yet, so disconnectAllTransports did not trigger a disconnected state */
                    this.startConnect();
                }
                else {
                    this.requestState({ state: 'connecting' });
                }
            }
        }
    };
    ConnectionManager.prototype.disconnectAllTransports = function (exceptActive) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting all transports' + (exceptActive ? ' except the active transport' : ''));
        /* This will prevent any connection procedure in an async part of one of its early stages from continuing */
        this.connectCounter++;
        Utils.safeArrForEach(this.pendingTransports, function (transport) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting pending transport: ' + transport);
            if (transport)
                transport.disconnect();
        });
        this.pendingTransports = [];
        Utils.safeArrForEach(this.proposedTransports, function (transport) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disposing of proposed transport: ' + transport);
            if (transport)
                transport.dispose();
        });
        this.proposedTransports = [];
        if (this.activeProtocol && !exceptActive) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting active transport: ' + this.activeProtocol.getTransport());
            this.activeProtocol.getTransport().disconnect();
        }
        /* No need to notify state disconnected; disconnecting the active transport
         * will have that effect */
    };
    /******************
     * event queueing
     ******************/
    ConnectionManager.prototype.send = function (msg, queueEvent, callback) {
        callback = callback || noop;
        var state = this.state;
        if (state.sendEvents) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.send()', 'sending event');
            this.sendImpl(new protocol_1.PendingMessage(msg, callback));
            return;
        }
        var shouldQueue = (queueEvent && state.queueEvents) || state.forceQueueEvents;
        if (!shouldQueue) {
            var err = 'rejecting event, queueEvent was ' + queueEvent + ', state was ' + state.state;
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.send()', err);
            callback(this.errorReason || new errorinfo_1.default(err, 90000, 400));
            return;
        }
        if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.send()', 'queueing msg; ' + protocolmessage_1.default.stringify(msg));
        }
        this.queue(msg, callback);
    };
    ConnectionManager.prototype.sendImpl = function (pendingMessage) {
        var msg = pendingMessage.message;
        /* If have already attempted to send this, resend with the same msgSerial,
         * so Ably can dedup if the previous send succeeded */
        if (pendingMessage.ackRequired && !pendingMessage.sendAttempted) {
            msg.msgSerial = this.msgSerial++;
        }
        try {
            this.activeProtocol.send(pendingMessage);
        }
        catch (e) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.sendImpl()', 'Unexpected exception in transport.send(): ' + e.stack);
        }
    };
    ConnectionManager.prototype.queue = function (msg, callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.queue()', 'queueing event');
        var lastQueued = this.queuedMessages.last();
        var maxSize = this.options.maxMessageSize;
        /* If have already attempted to send a message, don't merge more messages
         * into it, as if the previous send actually succeeded and realtime ignores
         * the dup, they'll be lost */
        if (lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {
            if (!lastQueued.merged) {
                lastQueued.callback = multicaster_1.default.create([lastQueued.callback]);
                lastQueued.merged = true;
            }
            lastQueued.callback.push(callback);
        }
        else {
            this.queuedMessages.push(new protocol_1.PendingMessage(msg, callback));
        }
    };
    ConnectionManager.prototype.sendQueuedMessages = function () {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.sendQueuedMessages()', 'sending ' + this.queuedMessages.count() + ' queued messages');
        var pendingMessage;
        while ((pendingMessage = this.queuedMessages.shift()))
            this.sendImpl(pendingMessage);
    };
    ConnectionManager.prototype.queuePendingMessages = function (pendingMessages) {
        if (pendingMessages && pendingMessages.length) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.queuePendingMessages()', 'queueing ' + pendingMessages.length + ' pending messages');
            this.queuedMessages.prepend(pendingMessages);
        }
    };
    ConnectionManager.prototype.failQueuedMessages = function (err) {
        var numQueued = this.queuedMessages.count();
        if (numQueued > 0) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.failQueuedMessages()', 'failing ' + numQueued + ' queued messages, err = ' + Utils.inspectError(err));
            this.queuedMessages.completeAllMessages(err);
        }
    };
    ConnectionManager.prototype.onChannelMessage = function (message, transport) {
        var onActiveTransport = this.activeProtocol && transport === this.activeProtocol.getTransport(), onUpgradeTransport = Utils.arrIn(this.pendingTransports, transport) && this.state == this.states.synchronizing;
        /* As the lib now has a period where the upgrade transport is synced but
         * before it's become active (while waiting for the old one to become
         * idle), message can validly arrive on it even though it isn't active */
        if (onActiveTransport || onUpgradeTransport) {
            this.realtime.channels.onChannelMessage(message);
        }
        else {
            // Message came in on a defunct transport. Allow only acks, nacks, & errors for outstanding
            // messages,  no new messages (as sync has been sent on new transport so new messages will
            // be resent there, or connection has been closed so don't want new messages)
            if (Utils.arrIndexOf([actions.ACK, actions.NACK, actions.ERROR], message.action) > -1) {
                this.realtime.channels.onChannelMessage(message);
            }
            else {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.onChannelMessage()', 'received message ' + JSON.stringify(message) + 'on defunct transport; discarding');
            }
        }
    };
    ConnectionManager.prototype.ping = function (transport, callback) {
        var _this = this;
        /* if transport is specified, try that */
        if (transport) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.ping()', 'transport = ' + transport);
            var onTimeout = function () {
                transport.off('heartbeat', onHeartbeat_1);
                callback(new errorinfo_1.default('Timeout waiting for heartbeat response', 50000, 500));
            };
            var pingStart_1 = Utils.now(), id_1 = Utils.cheapRandStr();
            var onHeartbeat_1 = function (responseId) {
                if (responseId === id_1) {
                    transport.off('heartbeat', onHeartbeat_1);
                    clearTimeout(timer_1);
                    var responseTime = Utils.now() - pingStart_1;
                    callback(null, responseTime);
                }
            };
            var timer_1 = setTimeout(onTimeout, this.options.timeouts.realtimeRequestTimeout);
            transport.on('heartbeat', onHeartbeat_1);
            transport.ping(id_1);
            return;
        }
        /* if we're not connected, don't attempt */
        if (this.state.state !== 'connected') {
            callback(new errorinfo_1.default('Unable to ping service; not connected', 40000, 400));
            return;
        }
        /* no transport was specified, so use the current (connected) one
         * but ensure that we retry if the transport is superseded before we complete */
        var completed = false;
        var onPingComplete = function (err, responseTime) {
            _this.off('transport.active', onTransportActive);
            if (!completed) {
                completed = true;
                callback(err, responseTime);
            }
        };
        var onTransportActive = function () {
            if (!completed) {
                /* ensure that no callback happens for the currently outstanding operation */
                completed = true;
                /* repeat but picking up the new transport */
                platform_1.default.Config.nextTick(function () {
                    _this.ping(null, callback);
                });
            }
        };
        this.on('transport.active', onTransportActive);
        this.ping(this.activeProtocol.getTransport(), onPingComplete);
    };
    ConnectionManager.prototype.abort = function (error) {
        this.activeProtocol.getTransport().fail(error);
    };
    ConnectionManager.prototype.registerProposedTransport = function (transport) {
        this.proposedTransports.push(transport);
    };
    ConnectionManager.prototype.getTransportPreference = function () {
        var _a, _b;
        return this.transportPreference || (haveWebStorage() && ((_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.get) === null || _b === void 0 ? void 0 : _b.call(_a, transportPreferenceName)));
    };
    ConnectionManager.prototype.persistTransportPreference = function (transport) {
        var _a, _b;
        if (Utils.arrIn(defaults_1.default.upgradeTransports, transport.shortName)) {
            this.transportPreference = transport.shortName;
            if (haveWebStorage()) {
                (_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.set) === null || _b === void 0 ? void 0 : _b.call(_a, transportPreferenceName, transport.shortName);
            }
        }
    };
    ConnectionManager.prototype.unpersistTransportPreference = function () {
        var _a, _b;
        this.transportPreference = null;
        if (haveWebStorage()) {
            (_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.remove) === null || _b === void 0 ? void 0 : _b.call(_a, transportPreferenceName);
        }
    };
    /* This method is only used during connection attempts, so implements RSA4c1, RSA4c2,
     * and RSA4d. It is generally not invoked for serverside-triggered reauths or manual
     * reauths, so RSA4c3 does not apply, except (per per RSA4d1) in the case that the auth
     * server returns 403. */
    ConnectionManager.prototype.actOnErrorFromAuthorize = function (err) {
        if (err.code === 40171) {
            /* No way to reauth */
            this.notifyState({ state: 'failed', error: err });
        }
        else if (err.code === 40102) {
            this.notifyState({ state: 'failed', error: err });
        }
        else if (err.statusCode === HttpStatusCodes_1.default.Forbidden) {
            var msg = 'Client configured authentication provider returned 403; failing the connection';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.actOnErrorFromAuthorize()', msg);
            this.notifyState({ state: 'failed', error: new errorinfo_1.default(msg, 80019, 403, err) });
        }
        else {
            var msg = 'Client configured authentication provider request failed';
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.actOnErrorFromAuthorize', msg);
            this.notifyState({ state: this.state.failState, error: new errorinfo_1.default(msg, 80019, 401, err) });
        }
    };
    ConnectionManager.prototype.onConnectionDetailsUpdate = function (connectionDetails, transport) {
        if (!connectionDetails) {
            return;
        }
        this.connectionDetails = connectionDetails;
        if (connectionDetails.maxMessageSize) {
            this.options.maxMessageSize = connectionDetails.maxMessageSize;
        }
        var clientId = connectionDetails.clientId;
        if (clientId) {
            var err = this.realtime.auth._uncheckedSetClientId(clientId);
            if (err) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.onConnectionDetailsUpdate()', err.message);
                /* Errors setting the clientId are fatal to the connection */
                transport.fail(err);
                return;
            }
        }
        var connectionStateTtl = connectionDetails.connectionStateTtl;
        if (connectionStateTtl) {
            this.connectionStateTtl = connectionStateTtl;
        }
        this.maxIdleInterval = connectionDetails.maxIdleInterval;
        this.emit('connectiondetails', connectionDetails);
    };
    /*********************
     * transport management
     *********************/
    ConnectionManager.supportedTransports = {};
    return ConnectionManager;
}(eventemitter_1.default));
exports.default = ConnectionManager;

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_301120__(13)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __nested_webpack_require_391408__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_391408__(0);
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_391408__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_391408__(2));
var MessageQueue = /** @class */ (function (_super) {
    tslib_1.__extends(MessageQueue, _super);
    function MessageQueue() {
        var _this = _super.call(this) || this;
        _this.messages = [];
        return _this;
    }
    MessageQueue.prototype.count = function () {
        return this.messages.length;
    };
    MessageQueue.prototype.push = function (message) {
        this.messages.push(message);
    };
    MessageQueue.prototype.shift = function () {
        return this.messages.shift();
    };
    MessageQueue.prototype.last = function () {
        return this.messages[this.messages.length - 1];
    };
    MessageQueue.prototype.copyAll = function () {
        return this.messages.slice();
    };
    MessageQueue.prototype.append = function (messages) {
        this.messages.push.apply(this.messages, messages);
    };
    MessageQueue.prototype.prepend = function (messages) {
        this.messages.unshift.apply(this.messages, messages);
    };
    MessageQueue.prototype.completeMessages = function (serial, count, err) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'MessageQueue.completeMessages()', 'serial = ' + serial + '; count = ' + count);
        err = err || null;
        var messages = this.messages;
        if (messages.length === 0) {
            throw new Error('MessageQueue.completeMessages(): completeMessages called on any empty MessageQueue');
        }
        var first = messages[0];
        if (first) {
            var startSerial = first.message.msgSerial;
            var endSerial = serial + count; /* the serial of the first message that is *not* the subject of this call */
            if (endSerial > startSerial) {
                var completeMessages = messages.splice(0, endSerial - startSerial);
                for (var _i = 0, completeMessages_1 = completeMessages; _i < completeMessages_1.length; _i++) {
                    var message = completeMessages_1[_i];
                    message.callback(err);
                }
            }
            if (messages.length == 0)
                this.emit('idle');
        }
    };
    MessageQueue.prototype.completeAllMessages = function (err) {
        this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);
    };
    MessageQueue.prototype.resetSendAttempted = function () {
        for (var _i = 0, _a = this.messages; _i < _a.length; _i++) {
            var msg = _a[_i];
            msg.sendAttempted = false;
        }
    };
    MessageQueue.prototype.clear = function () {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'MessageQueue.clear()', 'clearing ' + this.messages.length + ' messages');
        this.messages = [];
        this.emit('idle');
    };
    return MessageQueue;
}(eventemitter_1.default));
exports.default = MessageQueue;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ConnectionStateChange = /** @class */ (function () {
    function ConnectionStateChange(previous, current, retryIn, reason) {
        this.previous = previous;
        this.current = current;
        if (retryIn)
            this.retryIn = retryIn;
        if (reason)
            this.reason = reason;
    }
    return ConnectionStateChange;
}());
exports.default = ConnectionStateChange;


/***/ }),
/* 38 */
/***/ (function(module, exports, __nested_webpack_require_395113__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_395113__(0);
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(10));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(7));
var Utils = tslib_1.__importStar(__nested_webpack_require_395113__(1));
var channel_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(33));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(2));
var realtimepresence_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(54));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(9));
var channelstatechange_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(39));
var errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_395113__(4));
var presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(15));
var connectionerrors_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(20));
var actions = protocolmessage_1.default.Action;
var noop = function () { };
function validateChannelOptions(options) {
    if (options && 'params' in options && !Utils.isObject(options.params)) {
        return new errorinfo_1.default('options.params must be an object', 40000, 400);
    }
    if (options && 'modes' in options) {
        if (!Utils.isArray(options.modes)) {
            return new errorinfo_1.default('options.modes must be an array', 40000, 400);
        }
        for (var i = 0; i < options.modes.length; i++) {
            var currentMode = options.modes[i];
            if (!currentMode ||
                typeof currentMode !== 'string' ||
                !Utils.arrIn(protocolmessage_1.default.channelModes, String.prototype.toUpperCase.call(currentMode))) {
                return new errorinfo_1.default('Invalid channel mode: ' + currentMode, 40000, 400);
            }
        }
    }
}
var RealtimeChannel = /** @class */ (function (_super) {
    tslib_1.__extends(RealtimeChannel, _super);
    function RealtimeChannel(realtime, name, options) {
        var _this = _super.call(this, realtime, name, options) || this;
        _this.retryCount = 0;
        _this.history = function (params, callback) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.history()', 'channel = ' + this.name);
            /* params and callback are optional; see if params contains the callback */
            if (callback === undefined) {
                if (typeof params == 'function') {
                    callback = params;
                    params = null;
                }
                else {
                    if (this.rest.options.promises) {
                        return Utils.promisify(this, 'history', arguments);
                    }
                    callback = noop;
                }
            }
            if (params && params.untilAttach) {
                if (this.state !== 'attached') {
                    callback(new errorinfo_1.default('option untilAttach requires the channel to be attached', 40000, 400));
                    return;
                }
                if (!this.properties.attachSerial) {
                    callback(new errorinfo_1.default('untilAttach was specified and channel is attached, but attachSerial is not defined', 40000, 400));
                    return;
                }
                delete params.untilAttach;
                params.from_serial = this.properties.attachSerial;
            }
            channel_1.default.prototype._history.call(this, params, callback);
        };
        _this.whenState = (function (state, listener) {
            return eventemitter_1.default.prototype.whenState.call(_this, state, _this.state, listener);
        });
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel()', 'started; name = ' + name);
        _this.realtime = realtime;
        _this.presence = new realtimepresence_1.default(_this);
        _this.connectionManager = realtime.connection.connectionManager;
        _this.state = 'initialized';
        _this.subscriptions = new eventemitter_1.default();
        _this.syncChannelSerial = undefined;
        _this.properties = {
            attachSerial: undefined,
            channelSerial: undefined,
        };
        _this.setOptions(options);
        _this.errorReason = null;
        _this._requestedFlags = null;
        _this._mode = null;
        _this._attachResume = false;
        _this._decodingContext = {
            channelOptions: _this.channelOptions,
            plugins: realtime.options.plugins || {},
            baseEncodedPreviousPayload: undefined,
        };
        _this._lastPayload = {
            messageId: null,
            protocolMessageChannelSerial: null,
            decodeFailureRecoveryInProgress: null,
        };
        /* Only differences between this and the public event emitter is that this emits an
         * update event for all ATTACHEDs, whether resumed or not */
        _this._allChannelChanges = new eventemitter_1.default();
        return _this;
    }
    RealtimeChannel.prototype.invalidStateError = function () {
        return new errorinfo_1.default('Channel operation failed as channel state is ' + this.state, 90001, 400, this.errorReason || undefined);
    };
    RealtimeChannel.processListenerArgs = function (args) {
        /* [event], listener, [callback] */
        args = Array.prototype.slice.call(args);
        if (typeof args[0] === 'function') {
            args.unshift(null);
        }
        if (args[args.length - 1] == undefined) {
            args.pop();
        }
        return args;
    };
    RealtimeChannel.prototype.setOptions = function (options, callback) {
        if (!callback) {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'setOptions', arguments);
            }
        }
        var _callback = callback ||
            function (err) {
                if (err) {
                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.setOptions()', 'Set options failed: ' + err.toString());
                }
            };
        var err = validateChannelOptions(options);
        if (err) {
            _callback(err);
            return;
        }
        channel_1.default.prototype.setOptions.call(this, options);
        if (this._decodingContext)
            this._decodingContext.channelOptions = this.channelOptions;
        if (this._shouldReattachToSetOptions(options)) {
            /* This does not just do _attach(true, null, callback) because that would put us
             * into the 'attaching' state until we receive the new attached, which is
             * conceptually incorrect: we are still attached, we just have a pending request to
             * change some channel params. Per RTL17 going into the attaching state would mean
             * rejecting messages until we have confirmation that the options have changed,
             * which would unnecessarily lose message continuity. */
            this.attachImpl();
            // Ignore 'attaching' -- could be just due to to a resume & reattach, should not
            // call back setOptions until we're definitely attached with the new options (or
            // else in a terminal state)
            this._allChannelChanges.once(['attached', 'update', 'detached', 'failed'], function (stateChange) {
                switch (this.event) {
                    case 'update':
                    case 'attached':
                        _callback === null || _callback === void 0 ? void 0 : _callback(null);
                        return;
                    default:
                        _callback === null || _callback === void 0 ? void 0 : _callback(stateChange.reason);
                        return;
                }
            });
        }
        else {
            _callback();
        }
    };
    RealtimeChannel.prototype._shouldReattachToSetOptions = function (options) {
        return (this.state === 'attached' || this.state === 'attaching') && ((options === null || options === void 0 ? void 0 : options.params) || (options === null || options === void 0 ? void 0 : options.modes));
    };
    RealtimeChannel.prototype.publish = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var messages = args[0];
        var argCount = args.length;
        var callback = args[argCount - 1];
        if (typeof callback !== 'function') {
            if (this.realtime.options.promises) {
                return Utils.promisify(this, 'publish', arguments);
            }
            callback = noop;
            ++argCount;
        }
        if (!this.connectionManager.activeState()) {
            callback(this.connectionManager.getError());
            return;
        }
        if (argCount == 2) {
            if (Utils.isObject(messages))
                messages = [message_1.default.fromValues(messages)];
            else if (Utils.isArray(messages))
                messages = message_1.default.fromValuesArray(messages);
            else
                throw new errorinfo_1.default('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);
        }
        else {
            messages = [message_1.default.fromValues({ name: args[0], data: args[1] })];
        }
        var maxMessageSize = this.realtime.options.maxMessageSize;
        message_1.default.encodeArray(messages, this.channelOptions, function (err) {
            if (err) {
                callback(err);
                return;
            }
            /* RSL1i */
            var size = message_1.default.getMessagesSize(messages);
            if (size > maxMessageSize) {
                callback(new errorinfo_1.default('Maximum size of messages that can be published at once exceeded ( was ' +
                    size +
                    ' bytes; limit is ' +
                    maxMessageSize +
                    ' bytes)', 40009, 400));
                return;
            }
            _this.__publish(messages, callback);
        });
    };
    // Double underscore used to prevent type conflict with underlying Channel._publish method
    RealtimeChannel.prototype.__publish = function (messages, callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.publish()', 'message count = ' + messages.length);
        var state = this.state;
        switch (state) {
            case 'failed':
            case 'suspended':
                callback(errorinfo_1.default.fromValues(this.invalidStateError()));
                break;
            default: {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.publish()', 'sending message; channel state is ' + state);
                var msg = new protocolmessage_1.default();
                msg.action = actions.MESSAGE;
                msg.channel = this.name;
                msg.messages = messages;
                this.sendMessage(msg, callback);
                break;
            }
        }
    };
    RealtimeChannel.prototype.onEvent = function (messages) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.onEvent()', 'received message');
        var subscriptions = this.subscriptions;
        for (var i = 0; i < messages.length; i++) {
            var message = messages[i];
            subscriptions.emit(message.name, message);
        }
    };
    RealtimeChannel.prototype.attach = function (flags, callback) {
        var _flags;
        if (typeof flags === 'function') {
            callback = flags;
            _flags = null;
        }
        else {
            _flags = flags;
        }
        if (!callback) {
            if (this.realtime.options.promises) {
                return Utils.promisify(this, 'attach', arguments);
            }
            callback = function (err) {
                if (err) {
                    logger_1.default.logAction(logger_1.default.LOG_MAJOR, 'RealtimeChannel.attach()', 'Channel attach failed: ' + err.toString());
                }
            };
        }
        if (_flags) {
            logger_1.default.deprecated('channel.attach() with flags', 'channel.setOptions() with channelOptions.params');
            /* If flags requested, always do a re-attach. TODO only do this if
             * current mode differs from requested mode */
            this._requestedFlags = _flags;
        }
        else if (this.state === 'attached') {
            callback(null, null);
            return;
        }
        this._attach(false, null, callback);
    };
    RealtimeChannel.prototype._attach = function (forceReattach, attachReason, callback) {
        if (!callback) {
            callback = function (err) {
                if (err) {
                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel._attach()', 'Channel attach failed: ' + err.toString());
                }
            };
        }
        var connectionManager = this.connectionManager;
        if (!connectionManager.activeState()) {
            callback(connectionManager.getError());
            return;
        }
        if (this.state !== 'attaching' || forceReattach) {
            this.requestState('attaching', attachReason);
        }
        this.once(function (stateChange) {
            switch (this.event) {
                case 'attached':
                    callback === null || callback === void 0 ? void 0 : callback(null, stateChange);
                    break;
                case 'detached':
                case 'suspended':
                case 'failed':
                    callback === null || callback === void 0 ? void 0 : callback(stateChange.reason ||
                        connectionManager.getError() ||
                        new errorinfo_1.default('Unable to attach; reason unknown; state = ' + this.event, 90000, 500));
                    break;
                case 'detaching':
                    callback === null || callback === void 0 ? void 0 : callback(new errorinfo_1.default('Attach request superseded by a subsequent detach request', 90000, 409));
                    break;
            }
        });
    };
    RealtimeChannel.prototype.attachImpl = function () {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.attachImpl()', 'sending ATTACH message');
        var attachMsg = protocolmessage_1.default.fromValues({
            action: actions.ATTACH,
            channel: this.name,
            params: this.channelOptions.params,
            // RTL4c1: Includes the channel serial to resume from a previous message
            // or attachment.
            channelSerial: this.properties.channelSerial,
        });
        if (this._requestedFlags) {
            attachMsg.encodeModesToFlags(this._requestedFlags);
        }
        else if (this.channelOptions.modes) {
            attachMsg.encodeModesToFlags(Utils.allToUpperCase(this.channelOptions.modes));
        }
        if (this._attachResume) {
            attachMsg.setFlag('ATTACH_RESUME');
        }
        if (this._lastPayload.decodeFailureRecoveryInProgress) {
            attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;
        }
        this.sendMessage(attachMsg, noop);
    };
    RealtimeChannel.prototype.detach = function (callback) {
        if (!callback) {
            if (this.realtime.options.promises) {
                return Utils.promisify(this, 'detach', arguments);
            }
            callback = noop;
        }
        var connectionManager = this.connectionManager;
        if (!connectionManager.activeState()) {
            callback(connectionManager.getError());
            return;
        }
        switch (this.state) {
            case 'suspended':
                this.notifyState('detached');
                callback();
                break;
            case 'detached':
                callback();
                break;
            case 'failed':
                callback(new errorinfo_1.default('Unable to detach; channel state = failed', 90001, 400));
                break;
            default:
                this.requestState('detaching');
            // eslint-disable-next-line no-fallthrough
            case 'detaching':
                this.once(function (stateChange) {
                    switch (this.event) {
                        case 'detached':
                            callback();
                            break;
                        case 'attached':
                        case 'suspended':
                        case 'failed':
                            callback(stateChange.reason ||
                                connectionManager.getError() ||
                                new errorinfo_1.default('Unable to detach; reason unknown; state = ' + this.event, 90000, 500));
                            break;
                        case 'attaching':
                            callback(new errorinfo_1.default('Detach request superseded by a subsequent attach request', 90000, 409));
                            break;
                    }
                });
        }
    };
    RealtimeChannel.prototype.detachImpl = function (callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.detach()', 'sending DETACH message');
        var msg = protocolmessage_1.default.fromValues({ action: actions.DETACH, channel: this.name });
        this.sendMessage(msg, callback || noop);
    };
    RealtimeChannel.prototype.subscribe = function () {
        var args = []; /* [event], listener, [callback] */
        for (var _i = 0 /* [event], listener, [callback] */; _i < arguments.length /* [event], listener, [callback] */; _i++ /* [event], listener, [callback] */) {
            args[_i] = arguments[_i]; /* [event], listener, [callback] */
        }
        var _a = RealtimeChannel.processListenerArgs(args), event = _a[0], listener = _a[1], callback = _a[2];
        if (!callback && this.realtime.options.promises) {
            return Utils.promisify(this, 'subscribe', [event, listener]);
        }
        if (this.state === 'failed') {
            callback === null || callback === void 0 ? void 0 : callback(errorinfo_1.default.fromValues(this.invalidStateError()));
            return;
        }
        // Filtered
        if (event && typeof event === 'object' && !Array.isArray(event)) {
            this._subscribeFilter(event, listener);
        }
        else {
            this.subscriptions.on(event, listener);
        }
        return this.attach(callback || noop);
    };
    RealtimeChannel.prototype._subscribeFilter = function (filter, listener) {
        var filteredListener = function (m) {
            var _a, _b, _c, _d, _e, _f;
            var mapping = {
                name: m.name,
                refTimeserial: (_b = (_a = m.extras) === null || _a === void 0 ? void 0 : _a.ref) === null || _b === void 0 ? void 0 : _b.timeserial,
                refType: (_d = (_c = m.extras) === null || _c === void 0 ? void 0 : _c.ref) === null || _d === void 0 ? void 0 : _d.type,
                isRef: !!((_f = (_e = m.extras) === null || _e === void 0 ? void 0 : _e.ref) === null || _f === void 0 ? void 0 : _f.timeserial),
                clientId: m.clientId,
            };
            // Check if any values are defined in the filter and if they match the value in the message object
            if (Object.entries(filter).find(function (_a) {
                var key = _a[0], value = _a[1];
                return value !== undefined ? mapping[key] !== value : false;
            })) {
                return;
            }
            listener(m);
        };
        this._addFilteredSubscription(filter, listener, filteredListener);
        this.subscriptions.on(filteredListener);
    };
    // Adds a new filtered subscription
    RealtimeChannel.prototype._addFilteredSubscription = function (filter, realListener, filteredListener) {
        var _a;
        if (!this.filteredSubscriptions) {
            this.filteredSubscriptions = new Map();
        }
        if (this.filteredSubscriptions.has(realListener)) {
            var realListenerMap = this.filteredSubscriptions.get(realListener);
            // Add the filtered listener to the map, or append to the array if this filter has already been used
            realListenerMap.set(filter, ((_a = realListenerMap === null || realListenerMap === void 0 ? void 0 : realListenerMap.get(filter)) === null || _a === void 0 ? void 0 : _a.concat(filteredListener)) || [filteredListener]);
        }
        else {
            this.filteredSubscriptions.set(realListener, new Map([[filter, [filteredListener]]]));
        }
    };
    RealtimeChannel.prototype._getAndDeleteFilteredSubscriptions = function (filter, realListener) {
        var _this = this;
        // No filtered subscriptions map means there has been no filtered subscriptions yet, so return nothing
        if (!this.filteredSubscriptions) {
            return [];
        }
        // Only a filter is passed in with no specific listener
        if (!realListener && filter) {
            // Return each listener which is attached to the specified filter object
            return Array.from(this.filteredSubscriptions.entries())
                .map(function (_a) {
                var _b;
                var key = _a[0], filterMaps = _a[1];
                // Get (then delete) the maps matching this filter
                var listenerMaps = filterMaps.get(filter);
                filterMaps.delete(filter);
                // Clear the parent if nothing is left
                if (filterMaps.size === 0) {
                    (_b = _this.filteredSubscriptions) === null || _b === void 0 ? void 0 : _b.delete(key);
                }
                return listenerMaps;
            })
                .reduce(function (prev, cur) {
                var _a;
                return (cur ? (_a = prev).concat.apply(_a, cur) : prev);
            }, []);
        }
        // No subscriptions for this listener
        if (!realListener || !this.filteredSubscriptions.has(realListener)) {
            return [];
        }
        var realListenerMap = this.filteredSubscriptions.get(realListener);
        // If no filter is specified return all listeners using that function
        if (!filter) {
            // array.flat is not available unless we support es2019 or higher
            var listeners_1 = Array.from(realListenerMap.values()).reduce(function (prev, cur) { return prev.concat.apply(prev, cur); }, []);
            // remove the listener from the map
            this.filteredSubscriptions.delete(realListener);
            return listeners_1;
        }
        var listeners = realListenerMap.get(filter);
        realListenerMap.delete(filter);
        return listeners || [];
    };
    RealtimeChannel.prototype.unsubscribe = function () {
        var _this = this;
        var _a;
        var args = []; /* [event], listener */
        for (var _i = 0 /* [event], listener */; _i < arguments.length /* [event], listener */; _i++ /* [event], listener */) {
            args[_i] = arguments[_i]; /* [event], listener */
        }
        var _b = RealtimeChannel.processListenerArgs(args), event = _b[0], listener = _b[1];
        // If we either have a filtered listener, a filter or both we need to do additional processing to find the original function(s)
        if ((typeof event === 'object' && !listener) || ((_a = this.filteredSubscriptions) === null || _a === void 0 ? void 0 : _a.has(listener))) {
            this._getAndDeleteFilteredSubscriptions(event, listener).forEach(function (l) { return _this.subscriptions.off(l); });
            return;
        }
        this.subscriptions.off(event, listener);
    };
    RealtimeChannel.prototype.sync = function () {
        /* check preconditions */
        switch (this.state) {
            case 'initialized':
            case 'detaching':
            case 'detached':
                throw new errorinfo_1.PartialErrorInfo('Unable to sync to channel; not attached', 40000);
            default:
        }
        var connectionManager = this.connectionManager;
        if (!connectionManager.activeState()) {
            throw connectionManager.getError();
        }
        /* send sync request */
        var syncMessage = protocolmessage_1.default.fromValues({ action: actions.SYNC, channel: this.name });
        if (this.syncChannelSerial) {
            syncMessage.channelSerial = this.syncChannelSerial;
        }
        connectionManager.send(syncMessage);
    };
    RealtimeChannel.prototype.sendMessage = function (msg, callback) {
        this.connectionManager.send(msg, this.realtime.options.queueMessages, callback);
    };
    RealtimeChannel.prototype.sendPresence = function (presence, callback) {
        var msg = protocolmessage_1.default.fromValues({
            action: actions.PRESENCE,
            channel: this.name,
            presence: Utils.isArray(presence)
                ? presencemessage_1.default.fromValuesArray(presence)
                : [presencemessage_1.default.fromValues(presence)],
        });
        this.sendMessage(msg, callback);
    };
    RealtimeChannel.prototype.onMessage = function (message) {
        if (message.action === actions.ATTACHED ||
            message.action === actions.MESSAGE ||
            message.action === actions.PRESENCE) {
            // RTL15b
            this.setChannelSerial(message.channelSerial);
        }
        var syncChannelSerial, isSync = false;
        switch (message.action) {
            case actions.ATTACHED: {
                this.properties.attachSerial = message.channelSerial;
                this._mode = message.getMode();
                this.params = message.params || {};
                var modesFromFlags = message.decodeModesFromFlags();
                this.modes = (modesFromFlags && Utils.allToLowerCase(modesFromFlags)) || undefined;
                var resumed = message.hasFlag('RESUMED');
                var hasPresence = message.hasFlag('HAS_PRESENCE');
                var hasBacklog = message.hasFlag('HAS_BACKLOG');
                if (this.state === 'attached') {
                    if (!resumed) {
                        /* On a loss of continuity, the presence set needs to be re-synced */
                        this.presence.onAttached(hasPresence);
                    }
                    var change = new channelstatechange_1.default(this.state, this.state, resumed, hasBacklog, message.error);
                    this._allChannelChanges.emit('update', change);
                    if (!resumed || this.channelOptions.updateOnAttached) {
                        this.emit('update', change);
                    }
                }
                else if (this.state === 'detaching') {
                    /* RTL5i: re-send DETACH and remain in the 'detaching' state */
                    this.checkPendingState();
                }
                else {
                    this.notifyState('attached', message.error, resumed, hasPresence, hasBacklog);
                }
                break;
            }
            case actions.DETACHED: {
                var detachErr = message.error
                    ? errorinfo_1.default.fromValues(message.error)
                    : new errorinfo_1.default('Channel detached', 90001, 404);
                if (this.state === 'detaching') {
                    this.notifyState('detached', detachErr);
                }
                else if (this.state === 'attaching') {
                    /* Only retry immediately if we were previously attached. If we were
                     * attaching, go into suspended, fail messages, and wait a few seconds
                     * before retrying */
                    this.notifyState('suspended', detachErr);
                }
                else {
                    this.requestState('attaching', detachErr);
                }
                break;
            }
            case actions.SYNC:
                /* syncs can have channelSerials, but might not if the sync is one page long */
                isSync = true;
                syncChannelSerial = this.syncChannelSerial = message.channelSerial;
                /* syncs can happen on channels with no presence data as part of connection
                 * resuming, in which case protocol message has no presence property */
                if (!message.presence)
                    break;
            // eslint-disable-next-line no-fallthrough
            case actions.PRESENCE: {
                var presence = message.presence;
                var id = message.id, connectionId = message.connectionId, timestamp = message.timestamp;
                var options = this.channelOptions;
                var presenceMsg = void 0;
                for (var i = 0; i < presence.length; i++) {
                    try {
                        presenceMsg = presence[i];
                        presencemessage_1.default.decode(presenceMsg, options);
                        if (!presenceMsg.connectionId)
                            presenceMsg.connectionId = connectionId;
                        if (!presenceMsg.timestamp)
                            presenceMsg.timestamp = timestamp;
                        if (!presenceMsg.id)
                            presenceMsg.id = id + ':' + i;
                    }
                    catch (e) {
                        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());
                    }
                }
                this.presence.setPresence(presence, isSync, syncChannelSerial);
                break;
            }
            case actions.MESSAGE: {
                //RTL17
                if (this.state !== 'attached') {
                    logger_1.default.logAction(logger_1.default.LOG_MAJOR, 'RealtimeChannel.onMessage()', 'Message "' +
                        message.id +
                        '" skipped as this channel "' +
                        this.name +
                        '" state is not "attached" (state is "' +
                        this.state +
                        '").');
                    return;
                }
                var messages = message.messages, firstMessage = messages[0], lastMessage = messages[messages.length - 1], id = message.id, connectionId = message.connectionId, timestamp = message.timestamp;
                if (firstMessage.extras &&
                    firstMessage.extras.delta &&
                    firstMessage.extras.delta.from !== this._lastPayload.messageId) {
                    var msg = 'Delta message decode failure - previous message not available for message "' +
                        message.id +
                        '" on this channel "' +
                        this.name +
                        '".';
                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.onMessage()', msg);
                    this._startDecodeFailureRecovery(new errorinfo_1.default(msg, 40018, 400));
                    break;
                }
                for (var i = 0; i < messages.length; i++) {
                    var msg = messages[i];
                    try {
                        message_1.default.decode(msg, this._decodingContext);
                    }
                    catch (e) {
                        /* decrypt failed .. the most likely cause is that we have the wrong key */
                        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());
                        switch (e.code) {
                            case 40018:
                                /* decode failure */
                                this._startDecodeFailureRecovery(e);
                                return;
                            case 40019:
                            /* No vcdiff plugin passed in - no point recovering, give up */
                            // eslint-disable-next-line no-fallthrough
                            case 40021:
                                /* Browser does not support deltas, similarly no point recovering */
                                this.notifyState('failed', e);
                                return;
                        }
                    }
                    if (!msg.connectionId)
                        msg.connectionId = connectionId;
                    if (!msg.timestamp)
                        msg.timestamp = timestamp;
                    if (!msg.id)
                        msg.id = id + ':' + i;
                }
                this._lastPayload.messageId = lastMessage.id;
                this._lastPayload.protocolMessageChannelSerial = message.channelSerial;
                this.onEvent(messages);
                break;
            }
            case actions.ERROR: {
                /* there was a channel-specific error */
                var err = message.error;
                if (err && err.code == 80016) {
                    /* attach/detach operation attempted on superseded transport handle */
                    this.checkPendingState();
                }
                else {
                    this.notifyState('failed', errorinfo_1.default.fromValues(err));
                }
                break;
            }
            default:
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.onMessage()', 'Fatal protocol error: unrecognised action (' + message.action + ')');
                this.connectionManager.abort(connectionerrors_1.default.unknownChannelErr());
        }
    };
    RealtimeChannel.prototype._startDecodeFailureRecovery = function (reason) {
        var _this = this;
        if (!this._lastPayload.decodeFailureRecoveryInProgress) {
            logger_1.default.logAction(logger_1.default.LOG_MAJOR, 'RealtimeChannel.onMessage()', 'Starting decode failure recovery process.');
            this._lastPayload.decodeFailureRecoveryInProgress = true;
            this._attach(true, reason, function () {
                _this._lastPayload.decodeFailureRecoveryInProgress = false;
            });
        }
    };
    RealtimeChannel.prototype.onAttached = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.onAttached', 'activating channel; name = ' + this.name);
    };
    RealtimeChannel.prototype.notifyState = function (state, reason, resumed, hasPresence, hasBacklog) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.notifyState', 'name = ' + this.name + ', current state = ' + this.state + ', notifying state ' + state);
        this.clearStateTimer();
        // RTP5a1
        if (Utils.arrIn(['detached', 'suspended', 'failed'], state)) {
            this.properties.channelSerial = null;
        }
        if (state === this.state) {
            return;
        }
        this.presence.actOnChannelState(state, hasPresence, reason);
        if (state === 'suspended' && this.connectionManager.state.sendEvents) {
            this.startRetryTimer();
        }
        else {
            this.cancelRetryTimer();
        }
        if (reason) {
            this.errorReason = reason;
        }
        var change = new channelstatechange_1.default(this.state, state, resumed, hasBacklog, reason);
        var logLevel = state === 'failed' ? logger_1.default.LOG_ERROR : logger_1.default.LOG_MAJOR;
        logger_1.default.logAction(logLevel, 'Channel state for channel "' + this.name + '"', state + (reason ? '; reason: ' + reason : ''));
        if (state !== 'attaching' && state !== 'suspended') {
            this.retryCount = 0;
        }
        /* Note: we don't set inProgress for pending states until the request is actually in progress */
        if (state === 'attached') {
            this.onAttached();
        }
        if (state === 'attached') {
            this._attachResume = true;
        }
        else if (state === 'detaching' || state === 'failed') {
            this._attachResume = false;
        }
        this.state = state;
        this._allChannelChanges.emit(state, change);
        this.emit(state, change);
    };
    RealtimeChannel.prototype.requestState = function (state, reason) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.requestState', 'name = ' + this.name + ', state = ' + state);
        this.notifyState(state, reason);
        /* send the event and await response */
        this.checkPendingState();
    };
    RealtimeChannel.prototype.checkPendingState = function () {
        /* if can't send events, do nothing */
        var cmState = this.connectionManager.state;
        /* Allow attach messages to queue up when synchronizing, since this will be
         * the state we'll be in when upgrade transport.active triggers a checkpendingstate */
        if (!(cmState.sendEvents || cmState.forceQueueEvents)) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.checkPendingState', 'sendEvents is false; state is ' + this.connectionManager.state.state);
            return;
        }
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.checkPendingState', 'name = ' + this.name + ', state = ' + this.state);
        /* Only start the state timer running when actually sending the event */
        switch (this.state) {
            case 'attaching':
                this.startStateTimerIfNotRunning();
                this.attachImpl();
                break;
            case 'detaching':
                this.startStateTimerIfNotRunning();
                this.detachImpl();
                break;
            case 'attached':
                /* resume any sync operation that was in progress */
                this.sync();
                break;
            default:
                break;
        }
    };
    RealtimeChannel.prototype.timeoutPendingState = function () {
        switch (this.state) {
            case 'attaching': {
                var err = new errorinfo_1.default('Channel attach timed out', 90007, 408);
                this.notifyState('suspended', err);
                break;
            }
            case 'detaching': {
                var err = new errorinfo_1.default('Channel detach timed out', 90007, 408);
                this.notifyState('attached', err);
                break;
            }
            default:
                this.checkPendingState();
                break;
        }
    };
    RealtimeChannel.prototype.startStateTimerIfNotRunning = function () {
        var _this = this;
        if (!this.stateTimer) {
            this.stateTimer = setTimeout(function () {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.startStateTimerIfNotRunning', 'timer expired');
                _this.stateTimer = null;
                _this.timeoutPendingState();
            }, this.realtime.options.timeouts.realtimeRequestTimeout);
        }
    };
    RealtimeChannel.prototype.clearStateTimer = function () {
        var stateTimer = this.stateTimer;
        if (stateTimer) {
            clearTimeout(stateTimer);
            this.stateTimer = null;
        }
    };
    RealtimeChannel.prototype.startRetryTimer = function () {
        var _this = this;
        if (this.retryTimer)
            return;
        this.retryCount++;
        var retryDelay = Utils.getRetryTime(this.realtime.options.timeouts.channelRetryTimeout, this.retryCount);
        this.retryTimer = setTimeout(function () {
            /* If connection is not connected, just leave in suspended, a reattach
             * will be triggered once it connects again */
            if (_this.state === 'suspended' && _this.connectionManager.state.sendEvents) {
                _this.retryTimer = null;
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel retry timer expired', 'attempting a new attach');
                _this.requestState('attaching');
            }
        }, retryDelay);
    };
    RealtimeChannel.prototype.cancelRetryTimer = function () {
        if (this.retryTimer) {
            clearTimeout(this.retryTimer);
            this.retryTimer = null;
        }
    };
    /* @returns null (if can safely be released) | ErrorInfo (if cannot) */
    RealtimeChannel.prototype.getReleaseErr = function () {
        var s = this.state;
        if (s === 'initialized' || s === 'detached' || s === 'failed') {
            return null;
        }
        return new errorinfo_1.default('Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was ' +
            s, 90001, 400);
    };
    RealtimeChannel.prototype.setChannelSerial = function (channelSerial) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.setChannelSerial()', 'Updating channel serial; serial = ' + channelSerial + '; previous = ' + this.properties.channelSerial);
        // RTP17h: Only update the channel serial if its present (it won't always
        // be set).
        if (channelSerial) {
            this.properties.channelSerial = channelSerial;
        }
    };
    return RealtimeChannel;
}(channel_1.default));
exports.default = RealtimeChannel;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ChannelStateChange = /** @class */ (function () {
    function ChannelStateChange(previous, current, resumed, hasBacklog, reason) {
        this.previous = previous;
        this.current = current;
        if (current === 'attached') {
            this.resumed = resumed;
            this.hasBacklog = hasBacklog;
        }
        if (reason)
            this.reason = reason;
    }
    return ChannelStateChange;
}());
exports.default = ChannelStateChange;


/***/ }),
/* 40 */
/***/ (function(module, exports, __nested_webpack_require_437421__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_437421__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function inspect(buffer) {
    if (buffer === undefined)
        return 'undefined';
    var view;
    var type;
    if (buffer instanceof ArrayBuffer) {
        type = 'ArrayBuffer';
        view = new DataView(buffer);
    }
    else if (buffer instanceof DataView) {
        type = 'DataView';
        view = buffer;
    }
    if (!view)
        return JSON.stringify(buffer);
    var bytes = [];
    for (var i = 0; i < buffer.byteLength; i++) {
        if (i > 20) {
            bytes.push('...');
            break;
        }
        var byte_ = view.getUint8(i).toString(16);
        if (byte_.length === 1)
            byte_ = '0' + byte_;
        bytes.push(byte_);
    }
    return '<' + type + ' ' + bytes.join(' ') + '>';
}
// Encode string as utf8 into dataview at offset
function utf8Write(view, offset, string) {
    for (var i = 0, l = string.length; i < l; i++) {
        var codePoint = string.charCodeAt(i);
        // One byte of UTF-8
        if (codePoint < 0x80) {
            view.setUint8(offset++, ((codePoint >>> 0) & 0x7f) | 0x00);
            continue;
        }
        // Two bytes of UTF-8
        if (codePoint < 0x800) {
            view.setUint8(offset++, ((codePoint >>> 6) & 0x1f) | 0xc0);
            view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);
            continue;
        }
        // Three bytes of UTF-8.
        if (codePoint < 0x10000) {
            view.setUint8(offset++, ((codePoint >>> 12) & 0x0f) | 0xe0);
            view.setUint8(offset++, ((codePoint >>> 6) & 0x3f) | 0x80);
            view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);
            continue;
        }
        // Four bytes of UTF-8
        if (codePoint < 0x110000) {
            view.setUint8(offset++, ((codePoint >>> 18) & 0x07) | 0xf0);
            view.setUint8(offset++, ((codePoint >>> 12) & 0x3f) | 0x80);
            view.setUint8(offset++, ((codePoint >>> 6) & 0x3f) | 0x80);
            view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);
            continue;
        }
        throw new Error('bad codepoint ' + codePoint);
    }
}
function utf8Read(view, offset, length) {
    var string = '';
    for (var i = offset, end = offset + length; i < end; i++) {
        var byte_ = view.getUint8(i);
        // One byte character
        if ((byte_ & 0x80) === 0x00) {
            string += String.fromCharCode(byte_);
            continue;
        }
        // Two byte character
        if ((byte_ & 0xe0) === 0xc0) {
            string += String.fromCharCode(((byte_ & 0x0f) << 6) | (view.getUint8(++i) & 0x3f));
            continue;
        }
        // Three byte character
        if ((byte_ & 0xf0) === 0xe0) {
            string += String.fromCharCode(((byte_ & 0x0f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0));
            continue;
        }
        // Four byte character
        if ((byte_ & 0xf8) === 0xf0) {
            string += String.fromCharCode(((byte_ & 0x07) << 18) |
                ((view.getUint8(++i) & 0x3f) << 12) |
                ((view.getUint8(++i) & 0x3f) << 6) |
                ((view.getUint8(++i) & 0x3f) << 0));
            continue;
        }
        throw new Error('Invalid byte ' + byte_.toString(16));
    }
    return string;
}
function utf8ByteCount(string) {
    var count = 0;
    for (var i = 0, l = string.length; i < l; i++) {
        var codePoint = string.charCodeAt(i);
        if (codePoint < 0x80) {
            count += 1;
            continue;
        }
        if (codePoint < 0x800) {
            count += 2;
            continue;
        }
        if (codePoint < 0x10000) {
            count += 3;
            continue;
        }
        if (codePoint < 0x110000) {
            count += 4;
            continue;
        }
        throw new Error('bad codepoint ' + codePoint);
    }
    return count;
}
function encode(value, sparse) {
    var size = sizeof(value, sparse);
    if (size === 0)
        return undefined;
    var buffer = new ArrayBuffer(size);
    var view = new DataView(buffer);
    _encode(value, view, 0, sparse);
    return buffer;
}
var SH_L_32 = (1 << 16) * (1 << 16), SH_R_32 = 1 / SH_L_32;
function getInt64(view, offset) {
    offset = offset || 0;
    return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);
}
function getUint64(view, offset) {
    offset = offset || 0;
    return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);
}
function setInt64(view, offset, val) {
    if (val < 0x8000000000000000) {
        view.setInt32(offset, Math.floor(val * SH_R_32));
        view.setInt32(offset + 4, val & -1);
    }
    else {
        view.setUint32(offset, 0x7fffffff);
        view.setUint32(offset + 4, 0x7fffffff);
    }
}
function setUint64(view, offset, val) {
    if (val < 0x10000000000000000) {
        view.setUint32(offset, Math.floor(val * SH_R_32));
        view.setInt32(offset + 4, val & -1);
    }
    else {
        view.setUint32(offset, 0xffffffff);
        view.setUint32(offset + 4, 0xffffffff);
    }
}
// https://gist.github.com/frsyuki/5432559 - v5 spec
//
// I've used one extension point from `fixext 1` to store `undefined`. On the wire this
// should translate to exactly 0xd40000
//
// +--------+--------+--------+
// |  0xd4  |  0x00  |  0x00  |
// +--------+--------+--------+
//    ^ fixext |        ^ value part unused (fixed to be 0)
//             ^ indicates undefined value
//
var Decoder = /** @class */ (function () {
    function Decoder(view, offset) {
        var _this = this;
        this.map = function (length) {
            var value = {};
            for (var i = 0; i < length; i++) {
                var key = _this.parse();
                value[key] = _this.parse();
            }
            return value;
        };
        this.bin = function (length) {
            var value = new ArrayBuffer(length);
            new Uint8Array(value).set(new Uint8Array(_this.view.buffer, _this.offset, length), 0);
            _this.offset += length;
            return value;
        };
        this.buf = this.bin;
        this.str = function (length) {
            var value = utf8Read(_this.view, _this.offset, length);
            _this.offset += length;
            return value;
        };
        this.array = function (length) {
            var value = new Array(length);
            for (var i = 0; i < length; i++) {
                value[i] = _this.parse();
            }
            return value;
        };
        this.ext = function (length) {
            _this.offset += length;
            return {
                type: _this.view.getInt8(_this.offset),
                data: _this.buf(length),
            };
        };
        this.parse = function () {
            var type = _this.view.getUint8(_this.offset);
            var value, length;
            // Positive FixInt - 0xxxxxxx
            if ((type & 0x80) === 0x00) {
                _this.offset++;
                return type;
            }
            // FixMap - 1000xxxx
            if ((type & 0xf0) === 0x80) {
                length = type & 0x0f;
                _this.offset++;
                return _this.map(length);
            }
            // FixArray - 1001xxxx
            if ((type & 0xf0) === 0x90) {
                length = type & 0x0f;
                _this.offset++;
                return _this.array(length);
            }
            // FixStr - 101xxxxx
            if ((type & 0xe0) === 0xa0) {
                length = type & 0x1f;
                _this.offset++;
                return _this.str(length);
            }
            // Negative FixInt - 111xxxxx
            if ((type & 0xe0) === 0xe0) {
                value = _this.view.getInt8(_this.offset);
                _this.offset++;
                return value;
            }
            switch (type) {
                // nil
                case 0xc0:
                    _this.offset++;
                    return null;
                // 0xc1 never used - use for undefined (NON-STANDARD)
                case 0xc1:
                    _this.offset++;
                    return undefined;
                // false
                case 0xc2:
                    _this.offset++;
                    return false;
                // true
                case 0xc3:
                    _this.offset++;
                    return true;
                // bin 8
                case 0xc4:
                    length = _this.view.getUint8(_this.offset + 1);
                    _this.offset += 2;
                    return _this.bin(length);
                // bin 16
                case 0xc5:
                    length = _this.view.getUint16(_this.offset + 1);
                    _this.offset += 3;
                    return _this.bin(length);
                // bin 32
                case 0xc6:
                    length = _this.view.getUint32(_this.offset + 1);
                    _this.offset += 5;
                    return _this.bin(length);
                // ext 8
                case 0xc7:
                    length = _this.view.getUint8(_this.offset + 1);
                    _this.offset += 2;
                    return _this.ext(length);
                // ext 16
                case 0xc8:
                    length = _this.view.getUint16(_this.offset + 1);
                    _this.offset += 3;
                    return _this.ext(length);
                // ext 32
                case 0xc9:
                    length = _this.view.getUint32(_this.offset + 1);
                    _this.offset += 5;
                    return _this.ext(length);
                // float 32
                case 0xca:
                    value = _this.view.getFloat32(_this.offset + 1);
                    _this.offset += 5;
                    return value;
                // float 64
                case 0xcb:
                    value = _this.view.getFloat64(_this.offset + 1);
                    _this.offset += 9;
                    return value;
                // uint8
                case 0xcc:
                    value = _this.view.getUint8(_this.offset + 1);
                    _this.offset += 2;
                    return value;
                // uint 16
                case 0xcd:
                    value = _this.view.getUint16(_this.offset + 1);
                    _this.offset += 3;
                    return value;
                // uint 32
                case 0xce:
                    value = _this.view.getUint32(_this.offset + 1);
                    _this.offset += 5;
                    return value;
                // uint 64
                case 0xcf:
                    value = getUint64(_this.view, _this.offset + 1);
                    _this.offset += 9;
                    return value;
                // int 8
                case 0xd0:
                    value = _this.view.getInt8(_this.offset + 1);
                    _this.offset += 2;
                    return value;
                // int 16
                case 0xd1:
                    value = _this.view.getInt16(_this.offset + 1);
                    _this.offset += 3;
                    return value;
                // int 32
                case 0xd2:
                    value = _this.view.getInt32(_this.offset + 1);
                    _this.offset += 5;
                    return value;
                // int 64
                case 0xd3:
                    value = getInt64(_this.view, _this.offset + 1);
                    _this.offset += 9;
                    return value;
                // fixext 1
                case 0xd4:
                    length = 1;
                    _this.offset++;
                    return _this.ext(length);
                // fixext 2
                case 0xd5:
                    length = 2;
                    _this.offset++;
                    return _this.ext(length);
                // fixext 4
                case 0xd6:
                    length = 4;
                    _this.offset++;
                    return _this.ext(length);
                // fixext 8
                case 0xd7:
                    length = 8;
                    _this.offset++;
                    return _this.ext(length);
                // fixext 16
                case 0xd8:
                    length = 16;
                    _this.offset++;
                    return _this.ext(length);
                // str8
                case 0xd9:
                    length = _this.view.getUint8(_this.offset + 1);
                    _this.offset += 2;
                    return _this.str(length);
                // str 16
                case 0xda:
                    length = _this.view.getUint16(_this.offset + 1);
                    _this.offset += 3;
                    return _this.str(length);
                // str 32
                case 0xdb:
                    length = _this.view.getUint32(_this.offset + 1);
                    _this.offset += 5;
                    return _this.str(length);
                // array 16
                case 0xdc:
                    length = _this.view.getUint16(_this.offset + 1);
                    _this.offset += 3;
                    return _this.array(length);
                // array 32
                case 0xdd:
                    length = _this.view.getUint32(_this.offset + 1);
                    _this.offset += 5;
                    return _this.array(length);
                // map 16
                case 0xde:
                    length = _this.view.getUint16(_this.offset + 1);
                    _this.offset += 3;
                    return _this.map(length);
                // map 32
                case 0xdf:
                    length = _this.view.getUint32(_this.offset + 1);
                    _this.offset += 5;
                    return _this.map(length);
            }
            throw new Error('Unknown type 0x' + type.toString(16));
        };
        this.offset = offset || 0;
        this.view = view;
    }
    return Decoder;
}());
function decode(buffer) {
    var view = new DataView(buffer);
    var decoder = new Decoder(view);
    var value = decoder.parse();
    if (decoder.offset !== buffer.byteLength)
        throw new Error(buffer.byteLength - decoder.offset + ' trailing bytes');
    return value;
}
function encodeableKeys(value, sparse) {
    return Object.keys(value).filter(function (e) {
        var val = value[e], type = typeof val;
        return (!sparse || (val !== undefined && val !== null)) && ('function' !== type || !!val.toJSON);
    });
}
function _encode(value, view, offset, sparse) {
    var type = typeof value;
    // Strings Bytes
    // There are four string types: fixstr/str8/str16/str32
    if (typeof value === 'string') {
        var length_1 = utf8ByteCount(value);
        // fixstr
        if (length_1 < 0x20) {
            view.setUint8(offset, length_1 | 0xa0);
            utf8Write(view, offset + 1, value);
            return 1 + length_1;
        }
        // str8
        if (length_1 < 0x100) {
            view.setUint8(offset, 0xd9);
            view.setUint8(offset + 1, length_1);
            utf8Write(view, offset + 2, value);
            return 2 + length_1;
        }
        // str16
        if (length_1 < 0x10000) {
            view.setUint8(offset, 0xda);
            view.setUint16(offset + 1, length_1);
            utf8Write(view, offset + 3, value);
            return 3 + length_1;
        }
        // str32
        if (length_1 < 0x100000000) {
            view.setUint8(offset, 0xdb);
            view.setUint32(offset + 1, length_1);
            utf8Write(view, offset + 5, value);
            return 5 + length_1;
        }
    }
    if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {
        // extract the arraybuffer and fallthrough
        value = value.buffer;
    }
    // There are three bin types: bin8/bin16/bin32
    if (value instanceof ArrayBuffer) {
        var length_2 = value.byteLength;
        // bin8
        if (length_2 < 0x100) {
            view.setUint8(offset, 0xc4);
            view.setUint8(offset + 1, length_2);
            new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 2);
            return 2 + length_2;
        }
        // bin16
        if (length_2 < 0x10000) {
            view.setUint8(offset, 0xc5);
            view.setUint16(offset + 1, length_2);
            new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 3);
            return 3 + length_2;
        }
        // bin 32
        if (length_2 < 0x100000000) {
            view.setUint8(offset, 0xc6);
            view.setUint32(offset + 1, length_2);
            new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 5);
            return 5 + length_2;
        }
    }
    if (typeof value === 'number') {
        // Floating Point
        // NOTE: We're always using float64
        if (Math.floor(value) !== value) {
            view.setUint8(offset, 0xcb);
            view.setFloat64(offset + 1, value);
            return 9;
        }
        // Integers
        if (value >= 0) {
            // positive fixnum
            if (value < 0x80) {
                view.setUint8(offset, value);
                return 1;
            }
            // uint 8
            if (value < 0x100) {
                view.setUint8(offset, 0xcc);
                view.setUint8(offset + 1, value);
                return 2;
            }
            // uint 16
            if (value < 0x10000) {
                view.setUint8(offset, 0xcd);
                view.setUint16(offset + 1, value);
                return 3;
            }
            // uint 32
            if (value < 0x100000000) {
                view.setUint8(offset, 0xce);
                view.setUint32(offset + 1, value);
                return 5;
            }
            // uint 64
            if (value < 0x10000000000000000) {
                view.setUint8(offset, 0xcf);
                setUint64(view, offset + 1, value);
                return 9;
            }
            throw new Error('Number too big 0x' + value.toString(16));
        }
        // negative fixnum
        if (value >= -0x20) {
            view.setInt8(offset, value);
            return 1;
        }
        // int 8
        if (value >= -0x80) {
            view.setUint8(offset, 0xd0);
            view.setInt8(offset + 1, value);
            return 2;
        }
        // int 16
        if (value >= -0x8000) {
            view.setUint8(offset, 0xd1);
            view.setInt16(offset + 1, value);
            return 3;
        }
        // int 32
        if (value >= -0x80000000) {
            view.setUint8(offset, 0xd2);
            view.setInt32(offset + 1, value);
            return 5;
        }
        // int 64
        if (value >= -0x8000000000000000) {
            view.setUint8(offset, 0xd3);
            setInt64(view, offset + 1, value);
            return 9;
        }
        throw new Error('Number too small -0x' + (-value).toString(16).substr(1));
    }
    // undefined - use d4 (NON-STANDARD)
    if (type === 'undefined') {
        if (sparse)
            return 0;
        view.setUint8(offset, 0xd4);
        view.setUint8(offset + 1, 0x00);
        view.setUint8(offset + 2, 0x00);
        return 3;
    }
    // null
    if (value === null) {
        if (sparse)
            return 0;
        view.setUint8(offset, 0xc0);
        return 1;
    }
    // Boolean
    if (type === 'boolean') {
        view.setUint8(offset, value ? 0xc3 : 0xc2);
        return 1;
    }
    if ('function' === typeof value.toJSON)
        return _encode(value.toJSON(), view, offset, sparse);
    // Container Types
    if (type === 'object') {
        var length_3, size = 0;
        var keys = void 0;
        var isArray = Array.isArray(value);
        if (isArray) {
            length_3 = value.length;
        }
        else {
            keys = encodeableKeys(value, sparse);
            length_3 = keys.length;
        }
        if (length_3 < 0x10) {
            view.setUint8(offset, length_3 | (isArray ? 0x90 : 0x80));
            size = 1;
        }
        else if (length_3 < 0x10000) {
            view.setUint8(offset, isArray ? 0xdc : 0xde);
            view.setUint16(offset + 1, length_3);
            size = 3;
        }
        else if (length_3 < 0x100000000) {
            view.setUint8(offset, isArray ? 0xdd : 0xdf);
            view.setUint32(offset + 1, length_3);
            size = 5;
        }
        if (isArray) {
            for (var i = 0; i < length_3; i++) {
                size += _encode(value[i], view, offset + size, sparse);
            }
        }
        else if (keys) {
            for (var i = 0; i < length_3; i++) {
                var key = keys[i];
                size += _encode(key, view, offset + size);
                size += _encode(value[key], view, offset + size, sparse);
            }
        }
        return size;
    }
    if (type === 'function')
        return 0;
    throw new Error('Unknown type ' + type);
}
function sizeof(value, sparse) {
    var type = typeof value;
    // fixstr or str8 or str16 or str32
    if (type === 'string') {
        var length_4 = utf8ByteCount(value);
        if (length_4 < 0x20) {
            return 1 + length_4;
        }
        if (length_4 < 0x100) {
            return 2 + length_4;
        }
        if (length_4 < 0x10000) {
            return 3 + length_4;
        }
        if (length_4 < 0x100000000) {
            return 5 + length_4;
        }
    }
    if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {
        // extract the arraybuffer and fallthrough
        value = value.buffer;
    }
    // bin8 or bin16 or bin32
    if (value instanceof ArrayBuffer) {
        var length_5 = value.byteLength;
        if (length_5 < 0x100) {
            return 2 + length_5;
        }
        if (length_5 < 0x10000) {
            return 3 + length_5;
        }
        if (length_5 < 0x100000000) {
            return 5 + length_5;
        }
    }
    if (typeof value === 'number') {
        // Floating Point (32 bits)
        // double
        if (Math.floor(value) !== value)
            return 9;
        // Integers
        if (value >= 0) {
            // positive fixint
            if (value < 0x80)
                return 1;
            // uint 8
            if (value < 0x100)
                return 2;
            // uint 16
            if (value < 0x10000)
                return 3;
            // uint 32
            if (value < 0x100000000)
                return 5;
            // uint 64
            if (value < 0x10000000000000000)
                return 9;
            // Too big
            throw new Error('Number too big 0x' + value.toString(16));
        }
        // negative fixint
        if (value >= -0x20)
            return 1;
        // int 8
        if (value >= -0x80)
            return 2;
        // int 16
        if (value >= -0x8000)
            return 3;
        // int 32
        if (value >= -0x80000000)
            return 5;
        // int 64
        if (value >= -0x8000000000000000)
            return 9;
        // Too small
        throw new Error('Number too small -0x' + value.toString(16).substr(1));
    }
    // Boolean
    if (type === 'boolean')
        return 1;
    // undefined, null
    if (value === null)
        return sparse ? 0 : 1;
    if (value === undefined)
        return sparse ? 0 : 3;
    if ('function' === typeof value.toJSON)
        return sizeof(value.toJSON(), sparse);
    // Container Types
    if (type === 'object') {
        var length_6, size = 0;
        if (Array.isArray(value)) {
            length_6 = value.length;
            for (var i = 0; i < length_6; i++) {
                size += sizeof(value[i], sparse);
            }
        }
        else {
            var keys = encodeableKeys(value, sparse);
            length_6 = keys.length;
            for (var i = 0; i < length_6; i++) {
                var key = keys[i];
                size += sizeof(key) + sizeof(value[key], sparse);
            }
        }
        if (length_6 < 0x10) {
            return 1 + size;
        }
        if (length_6 < 0x10000) {
            return 3 + size;
        }
        if (length_6 < 0x100000000) {
            return 5 + size;
        }
        throw new Error('Array or object too long 0x' + length_6.toString(16));
    }
    if (type === 'function')
        return 0;
    throw new Error('Unknown type ' + type);
}
exports.default = {
    encode: encode,
    decode: decode,
    inspect: inspect,
    utf8Write: utf8Write,
    utf8Read: utf8Read,
    utf8ByteCount: utf8ByteCount,
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __nested_webpack_require_466211__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_466211__(0);
// Common
var rest_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(30));
var realtime_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(50));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(3));
// Platform Specific
var bufferutils_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(55));
// @ts-ignore
var crypto_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(57));
var http_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(62));
var config_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(64));
// @ts-ignore
var transport_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(68));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(2));
var defaults_1 = __nested_webpack_require_466211__(8);
var webstorage_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(65));
var defaults_2 = tslib_1.__importDefault(__nested_webpack_require_466211__(66));
var msgpack_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(41));
var Crypto = (0, crypto_1.default)(config_1.default, bufferutils_1.default);
platform_1.default.Crypto = Crypto;
platform_1.default.BufferUtils = bufferutils_1.default;
platform_1.default.Http = http_1.default;
platform_1.default.Config = config_1.default;
platform_1.default.Transports = transport_1.default;
platform_1.default.WebStorage = webstorage_1.default;
rest_1.default.Crypto = Crypto;
realtime_1.default.Crypto = Crypto;
logger_1.default.initLogHandlers();
platform_1.default.Defaults = (0, defaults_1.getDefaults)(defaults_2.default);
if (platform_1.default.Config.agent) {
    // @ts-ignore
    platform_1.default.Defaults.agent += ' ' + platform_1.default.Config.agent;
}
/* If using IE8, don't attempt to upgrade from xhr_polling to xhr_streaming -
 * while it can do streaming, the low max http-connections-per-host limit means
 * that the polling transport is crippled during the upgrade process. So just
 * leave it at the base transport */
if (platform_1.default.Config.noUpgrade) {
    platform_1.default.Defaults.upgradeTransports = [];
}
exports.default = {
    Rest: rest_1.default,
    Realtime: realtime_1.default,
    msgpack: msgpack_1.default,
};


/***/ }),
/* 43 */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"ably\",\"description\":\"Realtime client library for Ably, the realtime messaging service\",\"version\":\"1.2.43\",\"license\":\"Apache-2.0\",\"bugs\":{\"url\":\"https://github.com/ably/ably-js/issues\",\"email\":\"support@ably.com\"},\"main\":\"./build/ably-node.js\",\"typings\":\"./ably.d.ts\",\"react-native\":{\"./build/ably-node.js\":\"./build/ably-reactnative.js\"},\"browser\":{\"./build/ably-node.js\":\"./build/ably-commonjs.js\"},\"files\":[\"build/**\",\"ably.d.ts\",\"callbacks.d.ts\",\"callbacks.js\",\"promises.d.ts\",\"promises.js\",\"resources/**\"],\"dependencies\":{\"@ably/msgpack-js\":\"^0.4.0\",\"got\":\"^11.8.5\",\"ws\":\"^5.1\"},\"devDependencies\":{\"@ably/vcdiff-decoder\":\"1.0.4\",\"@types/crypto-js\":\"^4.0.1\",\"@types/node\":\"^15.0.0\",\"@types/request\":\"^2.48.7\",\"@types/ws\":\"^8.2.0\",\"@typescript-eslint/eslint-plugin\":\"^5.14.0\",\"@typescript-eslint/parser\":\"^5.14.0\",\"async\":\"ably-forks/async#requirejs\",\"aws-sdk\":\"^2.1413.0\",\"chai\":\"^4.2.0\",\"copy-webpack-plugin\":\"^6.4.1\",\"cors\":\"^2.8.5\",\"crypto-js\":\"ably-forks/crypto-js#crypto-lite\",\"eslint\":\"^7.13.0\",\"eslint-plugin-jsdoc\":\"^40.0.0\",\"eslint-plugin-security\":\"^1.4.0\",\"express\":\"^4.17.1\",\"glob\":\"~4.4\",\"google-closure-compiler\":\"^20180610.0.1\",\"grunt\":\"^1.6.1\",\"grunt-bump\":\"^0.3.1\",\"grunt-cli\":\"~1.2.0\",\"grunt-closure-tools\":\"^1.0.0\",\"grunt-contrib-concat\":\"~0.5\",\"grunt-shell\":\"~1.1\",\"grunt-webpack\":\"^4.0.2\",\"hexy\":\"~0.2\",\"kexec\":\"ably-forks/node-kexec#update-for-node-12\",\"minimist\":\"^1.2.5\",\"mocha\":\"^8.1.3\",\"null-loader\":\"^4.0.1\",\"playwright\":\"^1.10.0\",\"prettier\":\"^2.5.1\",\"requirejs\":\"~2.1\",\"shelljs\":\"~0.8\",\"source-map-explorer\":\"^2.5.2\",\"ts-loader\":\"^8.2.0\",\"tsconfig-paths-webpack-plugin\":\"^4.0.1\",\"tslib\":\"^2.3.1\",\"typedoc\":\"^0.23.8\",\"typescript\":\"^4.6.4\",\"webpack\":\"^4.44.2\",\"webpack-cli\":\"^4.2.0\"},\"engines\":{\"node\":\">=5.10.x\"},\"repository\":\"ably/ably-js\",\"jspm\":{\"registry\":\"npm\",\"directories\":{\"lib\":\"build\"},\"main\":\"ably\"},\"scripts\":{\"grunt\":\"grunt\",\"test\":\"grunt test\",\"test:node\":\"grunt test:node\",\"test:node:skip-build\":\"grunt mocha\",\"test:webserver\":\"grunt test:webserver\",\"test:playwright\":\"node test/support/runPlaywrightTests.js\",\"concat\":\"grunt concat\",\"build\":\"grunt build:all\",\"build:node\":\"grunt build:node\",\"build:browser\":\"grunt build:browser\",\"requirejs\":\"grunt requirejs\",\"lint\":\"eslint .\",\"lint:fix\":\"eslint --fix .\",\"check-closure-compiler\":\"grunt check-closure-compiler\",\"prepare\":\"npm run build\",\"format\":\"prettier --write --ignore-path .gitignore --ignore-path .prettierignore src test ably.d.ts webpack.config.js Gruntfile.js scripts/cdn_deploy.js docs/chrome-mv3.md\",\"format:check\":\"prettier --check --ignore-path .gitignore --ignore-path .prettierignore src test ably.d.ts webpack.config.js Gruntfile.js scripts/cdn_deploy.js\",\"sourcemap\":\"source-map-explorer build/ably.min.js\",\"sourcemap:noencryption\":\"source-map-explorer build/ably.noencryption.min.js\",\"docs\":\"typedoc --entryPoints ably.d.ts --out docs/generated/default --readme docs/landing-pages/default.md && typedoc --entryPoints promises.d.ts --out docs/generated/promises --name \\\"ably (Promise-based)\\\" --readme docs/landing-pages/promises.md && cp docs/landing-pages/choose-library.html docs/generated/index.html\"}}");

/***/ }),
/* 44 */
/***/ (function(module, exports) {



/***/ }),
/* 45 */
/***/ (function(module, exports, __nested_webpack_require_472099__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_472099__(6), __nested_webpack_require_472099__(32), __nested_webpack_require_472099__(24));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.HmacSHA256;

}));

/***/ }),
/* 46 */
/***/ (function(module, exports, __nested_webpack_require_472422__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_472422__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_472422__(1));
var devicedetails_1 = tslib_1.__importDefault(__nested_webpack_require_472422__(47));
var resource_1 = tslib_1.__importDefault(__nested_webpack_require_472422__(14));
var paginatedresource_1 = tslib_1.__importDefault(__nested_webpack_require_472422__(19));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_472422__(4));
var pushchannelsubscription_1 = tslib_1.__importDefault(__nested_webpack_require_472422__(48));
var noop = function () { };
var Push = /** @class */ (function () {
    function Push(rest) {
        this.rest = rest;
        this.admin = new Admin(rest);
    }
    return Push;
}());
var Admin = /** @class */ (function () {
    function Admin(rest) {
        this.rest = rest;
        this.deviceRegistrations = new DeviceRegistrations(rest);
        this.channelSubscriptions = new ChannelSubscriptions(rest);
    }
    Admin.prototype.publish = function (recipient, payload, callback) {
        var rest = this.rest;
        var format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(rest.options, format), params = {};
        var body = Utils.mixin({ recipient: recipient }, payload);
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'publish', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        var requestBody = Utils.encodeBody(body, format);
        resource_1.default.post(rest, '/push/publish', requestBody, headers, params, null, function (err) { return callback(err); });
    };
    return Admin;
}());
var DeviceRegistrations = /** @class */ (function () {
    function DeviceRegistrations(rest) {
        this.rest = rest;
    }
    DeviceRegistrations.prototype.save = function (device, callback) {
        var rest = this.rest;
        var body = devicedetails_1.default.fromValues(device);
        var format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(rest.options, format), params = {};
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'save', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        var requestBody = Utils.encodeBody(body, format);
        resource_1.default.put(rest, '/push/deviceRegistrations/' + encodeURIComponent(device.id), requestBody, headers, params, null, function (err, body, headers, unpacked) {
            callback(err, !err
                ? devicedetails_1.default.fromResponseBody(body, unpacked ? undefined : format)
                : undefined);
        });
    };
    DeviceRegistrations.prototype.get = function (deviceIdOrDetails, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultGetHeaders(rest.options, format), deviceId = deviceIdOrDetails.id || deviceIdOrDetails;
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'get', arguments);
            }
            callback = noop;
        }
        if (typeof deviceId !== 'string' || !deviceId.length) {
            callback(new errorinfo_1.default('First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails', 40000, 400));
            return;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        resource_1.default.get(rest, '/push/deviceRegistrations/' + encodeURIComponent(deviceId), headers, {}, null, function (err, body, headers, unpacked) {
            callback(err, !err
                ? devicedetails_1.default.fromResponseBody(body, unpacked ? undefined : format)
                : undefined);
        });
    };
    DeviceRegistrations.prototype.list = function (params, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'list', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        new paginatedresource_1.default(rest, '/push/deviceRegistrations', headers, envelope, function (body, headers, unpacked) {
            return devicedetails_1.default.fromResponseBody(body, unpacked ? undefined : format);
        }).get(params, callback);
    };
    DeviceRegistrations.prototype.remove = function (deviceIdOrDetails, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultGetHeaders(rest.options, format), params = {}, deviceId = deviceIdOrDetails.id || deviceIdOrDetails;
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'remove', arguments);
            }
            callback = noop;
        }
        if (typeof deviceId !== 'string' || !deviceId.length) {
            callback(new errorinfo_1.default('First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails', 40000, 400));
            return;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        resource_1.default['delete'](rest, '/push/deviceRegistrations/' + encodeURIComponent(deviceId), headers, params, null, function (err) { return callback(err); });
    };
    DeviceRegistrations.prototype.removeWhere = function (params, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultGetHeaders(rest.options, format);
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'removeWhere', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        resource_1.default['delete'](rest, '/push/deviceRegistrations', headers, params, null, function (err) { return callback(err); });
    };
    return DeviceRegistrations;
}());
var ChannelSubscriptions = /** @class */ (function () {
    function ChannelSubscriptions(rest) {
        /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */
        this.remove = ChannelSubscriptions.prototype.removeWhere;
        this.rest = rest;
    }
    ChannelSubscriptions.prototype.save = function (subscription, callback) {
        var rest = this.rest;
        var body = pushchannelsubscription_1.default.fromValues(subscription);
        var format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(rest.options, format), params = {};
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'save', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        var requestBody = Utils.encodeBody(body, format);
        resource_1.default.post(rest, '/push/channelSubscriptions', requestBody, headers, params, null, function (err, body, headers, unpacked) {
            callback(err, !err && pushchannelsubscription_1.default.fromResponseBody(body, unpacked ? undefined : format));
        });
    };
    ChannelSubscriptions.prototype.list = function (params, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'list', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        new paginatedresource_1.default(rest, '/push/channelSubscriptions', headers, envelope, function (body, headers, unpacked) {
            return pushchannelsubscription_1.default.fromResponseBody(body, unpacked ? undefined : format);
        }).get(params, callback);
    };
    ChannelSubscriptions.prototype.removeWhere = function (params, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultGetHeaders(rest.options, format);
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'removeWhere', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        resource_1.default['delete'](rest, '/push/channelSubscriptions', headers, params, null, function (err) { return callback(err); });
    };
    ChannelSubscriptions.prototype.listChannels = function (params, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'listChannels', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        new paginatedresource_1.default(rest, '/push/channels', headers, envelope, function (body, headers, unpacked) {
            var parsedBody = (!unpacked && format ? Utils.decodeBody(body, format) : body);
            for (var i = 0; i < parsedBody.length; i++) {
                parsedBody[i] = String(parsedBody[i]);
            }
            return parsedBody;
        }).get(params, callback);
    };
    return ChannelSubscriptions;
}());
exports.default = Push;


/***/ }),
/* 47 */
/***/ (function(module, exports, __nested_webpack_require_484001__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_484001__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_484001__(1));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_484001__(4));
var DeviceFormFactor;
(function (DeviceFormFactor) {
    DeviceFormFactor["Phone"] = "phone";
    DeviceFormFactor["Tablet"] = "tablet";
    DeviceFormFactor["Desktop"] = "desktop";
    DeviceFormFactor["TV"] = "tv";
    DeviceFormFactor["Watch"] = "watch";
    DeviceFormFactor["Car"] = "car";
    DeviceFormFactor["Embedded"] = "embedded";
    DeviceFormFactor["Other"] = "other";
})(DeviceFormFactor || (DeviceFormFactor = {}));
var DevicePlatform;
(function (DevicePlatform) {
    DevicePlatform["Android"] = "android";
    DevicePlatform["IOS"] = "ios";
    DevicePlatform["Browser"] = "browser";
})(DevicePlatform || (DevicePlatform = {}));
var DeviceDetails = /** @class */ (function () {
    function DeviceDetails() {
    }
    DeviceDetails.prototype.toJSON = function () {
        var _a, _b, _c;
        return {
            id: this.id,
            deviceSecret: this.deviceSecret,
            platform: this.platform,
            formFactor: this.formFactor,
            clientId: this.clientId,
            metadata: this.metadata,
            deviceIdentityToken: this.deviceIdentityToken,
            push: {
                recipient: (_a = this.push) === null || _a === void 0 ? void 0 : _a.recipient,
                state: (_b = this.push) === null || _b === void 0 ? void 0 : _b.state,
                error: (_c = this.push) === null || _c === void 0 ? void 0 : _c.error,
            },
        };
    };
    DeviceDetails.prototype.toString = function () {
        var _a, _b, _c, _d;
        var result = '[DeviceDetails';
        if (this.id)
            result += '; id=' + this.id;
        if (this.platform)
            result += '; platform=' + this.platform;
        if (this.formFactor)
            result += '; formFactor=' + this.formFactor;
        if (this.clientId)
            result += '; clientId=' + this.clientId;
        if (this.metadata)
            result += '; metadata=' + this.metadata;
        if (this.deviceIdentityToken)
            result += '; deviceIdentityToken=' + JSON.stringify(this.deviceIdentityToken);
        if ((_a = this.push) === null || _a === void 0 ? void 0 : _a.recipient)
            result += '; push.recipient=' + JSON.stringify(this.push.recipient);
        if ((_b = this.push) === null || _b === void 0 ? void 0 : _b.state)
            result += '; push.state=' + this.push.state;
        if ((_c = this.push) === null || _c === void 0 ? void 0 : _c.error)
            result += '; push.error=' + JSON.stringify(this.push.error);
        if ((_d = this.push) === null || _d === void 0 ? void 0 : _d.metadata)
            result += '; push.metadata=' + this.push.metadata;
        result += ']';
        return result;
    };
    DeviceDetails.fromResponseBody = function (body, format) {
        if (format) {
            body = Utils.decodeBody(body, format);
        }
        if (Utils.isArray(body)) {
            return DeviceDetails.fromValuesArray(body);
        }
        else {
            return DeviceDetails.fromValues(body);
        }
    };
    DeviceDetails.fromValues = function (values) {
        values.error = values.error && errorinfo_1.default.fromValues(values.error);
        return Object.assign(new DeviceDetails(), values);
    };
    DeviceDetails.fromValuesArray = function (values) {
        var count = values.length, result = new Array(count);
        for (var i = 0; i < count; i++)
            result[i] = DeviceDetails.fromValues(values[i]);
        return result;
    };
    DeviceDetails.toRequestBody = Utils.encodeBody;
    return DeviceDetails;
}());
exports.default = DeviceDetails;


/***/ }),
/* 48 */
/***/ (function(module, exports, __nested_webpack_require_487921__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_487921__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_487921__(1));
var PushChannelSubscription = /** @class */ (function () {
    function PushChannelSubscription() {
    }
    /**
     * Overload toJSON() to intercept JSON.stringify()
     * @return {*}
     */
    PushChannelSubscription.prototype.toJSON = function () {
        return {
            channel: this.channel,
            deviceId: this.deviceId,
            clientId: this.clientId,
        };
    };
    PushChannelSubscription.prototype.toString = function () {
        var result = '[PushChannelSubscription';
        if (this.channel)
            result += '; channel=' + this.channel;
        if (this.deviceId)
            result += '; deviceId=' + this.deviceId;
        if (this.clientId)
            result += '; clientId=' + this.clientId;
        result += ']';
        return result;
    };
    PushChannelSubscription.fromResponseBody = function (body, format) {
        if (format) {
            body = Utils.decodeBody(body, format);
        }
        if (Utils.isArray(body)) {
            return PushChannelSubscription.fromValuesArray(body);
        }
        else {
            return PushChannelSubscription.fromValues(body);
        }
    };
    PushChannelSubscription.fromValues = function (values) {
        return Object.assign(new PushChannelSubscription(), values);
    };
    PushChannelSubscription.fromValuesArray = function (values) {
        var count = values.length, result = new Array(count);
        for (var i = 0; i < count; i++)
            result[i] = PushChannelSubscription.fromValues(values[i]);
        return result;
    };
    PushChannelSubscription.toRequestBody = Utils.encodeBody;
    return PushChannelSubscription;
}());
exports.default = PushChannelSubscription;


/***/ }),
/* 49 */
/***/ (function(module, exports, __nested_webpack_require_489889__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_489889__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_489889__(1));
var MessageCount = /** @class */ (function () {
    function MessageCount(values) {
        this.count = (values && values.count) || 0;
        this.data = (values && values.data) || 0;
        this.uncompressedData = (values && values.uncompressedData) || 0;
        this.failed = (values && values.failed) || 0;
        this.refused = (values && values.refused) || 0;
    }
    return MessageCount;
}());
var MessageCategory = /** @class */ (function (_super) {
    tslib_1.__extends(MessageCategory, _super);
    function MessageCategory(values) {
        var _this = _super.call(this, values) || this;
        if (values && values.category) {
            _this.category = {};
            Utils.forInOwnNonNullProperties(values.category, function (prop) {
                _this.category[prop] = new MessageCount(values.category[prop]);
            });
        }
        return _this;
    }
    return MessageCategory;
}(MessageCount));
var ResourceCount = /** @class */ (function () {
    function ResourceCount(values) {
        this.peak = (values && values.peak) || 0;
        this.min = (values && values.min) || 0;
        this.mean = (values && values.mean) || 0;
        this.opened = (values && values.opened) || 0;
        this.refused = (values && values.refused) || 0;
    }
    return ResourceCount;
}());
var RequestCount = /** @class */ (function () {
    function RequestCount(values) {
        this.succeeded = (values && values.succeeded) || 0;
        this.failed = (values && values.failed) || 0;
        this.refused = (values && values.refused) || 0;
    }
    return RequestCount;
}());
var ConnectionTypes = /** @class */ (function () {
    function ConnectionTypes(values) {
        this.plain = new ResourceCount(values && values.plain);
        this.tls = new ResourceCount(values && values.tls);
        this.all = new ResourceCount(values && values.all);
    }
    return ConnectionTypes;
}());
var MessageTypes = /** @class */ (function () {
    function MessageTypes(values) {
        this.messages = new MessageCategory(values && values.messages);
        this.presence = new MessageCategory(values && values.presence);
        this.all = new MessageCategory(values && values.all);
    }
    return MessageTypes;
}());
var MessageTraffic = /** @class */ (function () {
    function MessageTraffic(values) {
        this.realtime = new MessageTypes(values && values.realtime);
        this.rest = new MessageTypes(values && values.rest);
        this.webhook = new MessageTypes(values && values.webhook);
        this.sharedQueue = new MessageTypes(values && values.sharedQueue);
        this.externalQueue = new MessageTypes(values && values.externalQueue);
        this.httpEvent = new MessageTypes(values && values.httpEvent);
        this.push = new MessageTypes(values && values.push);
        this.all = new MessageTypes(values && values.all);
    }
    return MessageTraffic;
}());
var MessageDirections = /** @class */ (function () {
    function MessageDirections(values) {
        this.all = new MessageTypes(values && values.all);
        this.inbound = new MessageTraffic(values && values.inbound);
        this.outbound = new MessageTraffic(values && values.outbound);
    }
    return MessageDirections;
}());
var XchgMessages = /** @class */ (function () {
    function XchgMessages(values) {
        this.all = new MessageTypes(values && values.all);
        this.producerPaid = new MessageDirections(values && values.producerPaid);
        this.consumerPaid = new MessageDirections(values && values.consumerPaid);
    }
    return XchgMessages;
}());
var PushStats = /** @class */ (function () {
    function PushStats(values) {
        this.messages = (values && values.messages) || 0;
        var notifications = values && values.notifications;
        this.notifications = {
            invalid: (notifications && notifications.invalid) || 0,
            attempted: (notifications && notifications.attempted) || 0,
            successful: (notifications && notifications.successful) || 0,
            failed: (notifications && notifications.failed) || 0,
        };
        this.directPublishes = (values && values.directPublishes) || 0;
    }
    return PushStats;
}());
var ProcessedCount = /** @class */ (function () {
    function ProcessedCount(values) {
        this.succeeded = (values && values.succeeded) || 0;
        this.skipped = (values && values.skipped) || 0;
        this.failed = (values && values.failed) || 0;
    }
    return ProcessedCount;
}());
var ProcessedMessages = /** @class */ (function () {
    function ProcessedMessages(values) {
        var _this = this;
        this.delta = undefined;
        if (values && values.delta) {
            this.delta = {};
            Utils.forInOwnNonNullProperties(values.delta, function (prop) {
                _this.delta[prop] = new ProcessedCount(values.delta[prop]);
            });
        }
    }
    return ProcessedMessages;
}());
var Stats = /** @class */ (function (_super) {
    tslib_1.__extends(Stats, _super);
    function Stats(values) {
        var _this = _super.call(this, values) || this;
        _this.persisted = new MessageTypes(values && values.persisted);
        _this.connections = new ConnectionTypes(values && values.connections);
        _this.channels = new ResourceCount(values && values.channels);
        _this.apiRequests = new RequestCount(values && values.apiRequests);
        _this.tokenRequests = new RequestCount(values && values.tokenRequests);
        _this.xchgProducer = new XchgMessages(values && values.xchgProducer);
        _this.xchgConsumer = new XchgMessages(values && values.xchgConsumer);
        _this.push = new PushStats(values && values.pushStats);
        _this.processed = new ProcessedMessages(values && values.processed);
        _this.inProgress = (values && values.inProgress) || undefined;
        _this.unit = (values && values.unit) || undefined;
        _this.intervalId = (values && values.intervalId) || undefined;
        return _this;
    }
    Stats.fromValues = function (values) {
        return new Stats(values);
    };
    return Stats;
}(MessageDirections));
exports.default = Stats;


/***/ }),
/* 50 */
/***/ (function(module, exports, __nested_webpack_require_496325__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_496325__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_496325__(1));
var rest_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(30));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(2));
var connection_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(51));
var realtimechannel_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(38));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(8));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(4));
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(10));
var connectionmanager_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(35));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(3));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(9));
var Realtime = /** @class */ (function (_super) {
    tslib_1.__extends(Realtime, _super);
    function Realtime(options) {
        var _this = _super.call(this, options) || this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Realtime()', '');
        _this.connection = new connection_1.default(_this, _this.options);
        _this.channels = new Channels(_this);
        if (options.autoConnect !== false)
            _this.connect();
        return _this;
    }
    Realtime.prototype.connect = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Realtime.connect()', '');
        this.connection.connect();
    };
    Realtime.prototype.close = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Realtime.close()', '');
        this.connection.close();
    };
    Realtime.Promise = function (options) {
        options = defaults_1.default.objectifyOptions(options);
        options.promises = true;
        return new Realtime(options);
    };
    Realtime.Callbacks = Realtime;
    Realtime.Utils = Utils;
    Realtime.ConnectionManager = connectionmanager_1.default;
    Realtime.Platform = platform_1.default;
    Realtime.ProtocolMessage = protocolmessage_1.default;
    Realtime.Message = message_1.default;
    return Realtime;
}(rest_1.default));
var Channels = /** @class */ (function (_super) {
    tslib_1.__extends(Channels, _super);
    function Channels(realtime) {
        var _this = _super.call(this) || this;
        _this.realtime = realtime;
        _this.all = Object.create(null);
        realtime.connection.connectionManager.on('transport.active', function () {
            _this.onTransportActive();
        });
        return _this;
    }
    Channels.prototype.channelSerials = function () {
        var serials = {};
        for (var _i = 0, _a = Utils.keysArray(this.all, true); _i < _a.length; _i++) {
            var name_1 = _a[_i];
            var channel = this.all[name_1];
            if (channel.properties.channelSerial) {
                serials[name_1] = channel.properties.channelSerial;
            }
        }
        return serials;
    };
    // recoverChannels gets the given channels and sets their channel serials.
    Channels.prototype.recoverChannels = function (channelSerials) {
        for (var _i = 0, _a = Utils.keysArray(channelSerials, true); _i < _a.length; _i++) {
            var name_2 = _a[_i];
            var channel = this.get(name_2);
            channel.properties.channelSerial = channelSerials[name_2];
        }
    };
    Channels.prototype.onChannelMessage = function (msg) {
        var channelName = msg.channel;
        if (channelName === undefined) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Channels.onChannelMessage()', 'received event unspecified channel, action = ' + msg.action);
            return;
        }
        var channel = this.all[channelName];
        if (!channel) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Channels.onChannelMessage()', 'received event for non-existent channel: ' + channelName);
            return;
        }
        channel.onMessage(msg);
    };
    /* called when a transport becomes connected; reattempt attach/detach
     * for channels that are attaching or detaching. */
    Channels.prototype.onTransportActive = function () {
        for (var channelName in this.all) {
            var channel = this.all[channelName];
            if (channel.state === 'attaching' || channel.state === 'detaching') {
                channel.checkPendingState();
            }
            else if (channel.state === 'suspended') {
                channel._attach(false, null);
            }
            else if (channel.state === 'attached') {
                // Note explicity request the state, channel.attach() would do nothing
                // as its already attached.
                channel.requestState('attaching');
            }
        }
    };
    /* Connection interruptions (ie when the connection will no longer queue
     * events) imply connection state changes for any channel which is either
     * attached, pending, or will attempt to become attached in the future */
    Channels.prototype.propogateConnectionInterruption = function (connectionState, reason) {
        var connectionStateToChannelState = {
            closing: 'detached',
            closed: 'detached',
            failed: 'failed',
            suspended: 'suspended',
        };
        var fromChannelStates = ['attaching', 'attached', 'detaching', 'suspended'];
        var toChannelState = connectionStateToChannelState[connectionState];
        for (var channelId in this.all) {
            var channel = this.all[channelId];
            if (Utils.arrIn(fromChannelStates, channel.state)) {
                channel.notifyState(toChannelState, reason);
            }
        }
    };
    Channels.prototype.get = function (name, channelOptions) {
        name = String(name);
        var channel = this.all[name];
        if (!channel) {
            channel = this.all[name] = new realtimechannel_1.default(this.realtime, name, channelOptions);
        }
        else if (channelOptions) {
            if (channel._shouldReattachToSetOptions(channelOptions)) {
                throw new errorinfo_1.default('Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.', 40000, 400);
            }
            channel.setOptions(channelOptions);
        }
        return channel;
    };
    Channels.prototype.getDerived = function (name, deriveOptions, channelOptions) {
        if (deriveOptions.filter) {
            var filter = Utils.toBase64(deriveOptions.filter);
            var match = Utils.matchDerivedChannel(name);
            name = "[filter=".concat(filter).concat(match.qualifierParam, "]").concat(match.channelName);
        }
        return this.get(name, channelOptions);
    };
    /* Included to support certain niche use-cases; most users should ignore this.
     * Please do not use this unless you know what you're doing */
    Channels.prototype.release = function (name) {
        name = String(name);
        var channel = this.all[name];
        if (!channel) {
            return;
        }
        var releaseErr = channel.getReleaseErr();
        if (releaseErr) {
            throw releaseErr;
        }
        delete this.all[name];
    };
    return Channels;
}(eventemitter_1.default));
exports.default = Realtime;


/***/ }),
/* 51 */
/***/ (function(module, exports, __nested_webpack_require_503898__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_503898__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_503898__(1));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_503898__(7));
var connectionmanager_1 = tslib_1.__importDefault(__nested_webpack_require_503898__(35));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_503898__(2));
var connectionstatechange_1 = tslib_1.__importDefault(__nested_webpack_require_503898__(37));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_503898__(3));
function noop() { }
var Connection = /** @class */ (function (_super) {
    tslib_1.__extends(Connection, _super);
    function Connection(ably, options) {
        var _this = _super.call(this) || this;
        _this.whenState = (function (state, listener) {
            return eventemitter_1.default.prototype.whenState.call(_this, state, _this.state, listener, new connectionstatechange_1.default(undefined, state));
        });
        _this.ably = ably;
        _this.connectionManager = new connectionmanager_1.default(ably, options);
        _this.state = _this.connectionManager.state.state;
        _this.key = undefined;
        _this.id = undefined;
        _this.errorReason = null;
        _this.connectionManager.on('connectionstate', function (stateChange) {
            var state = (_this.state = stateChange.current);
            platform_1.default.Config.nextTick(function () {
                _this.emit(state, stateChange);
            });
        });
        _this.connectionManager.on('update', function (stateChange) {
            platform_1.default.Config.nextTick(function () {
                _this.emit('update', stateChange);
            });
        });
        return _this;
    }
    Connection.prototype.connect = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Connection.connect()', '');
        this.connectionManager.requestState({ state: 'connecting' });
    };
    Connection.prototype.ping = function (callback) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Connection.ping()', '');
        if (!callback) {
            if (this.ably.options.promises) {
                return Utils.promisify(this, 'ping', arguments);
            }
            callback = noop;
        }
        this.connectionManager.ping(null, callback);
    };
    Connection.prototype.close = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Connection.close()', 'connectionKey = ' + this.key);
        this.connectionManager.requestState({ state: 'closing' });
    };
    Object.defineProperty(Connection.prototype, "recoveryKey", {
        get: function () {
            return this.createRecoveryKey();
        },
        enumerable: false,
        configurable: true
    });
    Connection.prototype.createRecoveryKey = function () {
        return this.connectionManager.createRecoveryKey();
    };
    return Connection;
}(eventemitter_1.default));
exports.default = Connection;


/***/ }),
/* 52 */
/***/ (function(module, exports, __nested_webpack_require_506979__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PendingMessage = void 0;
var tslib_1 = __nested_webpack_require_506979__(0);
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_506979__(10));
var Utils = tslib_1.__importStar(__nested_webpack_require_506979__(1));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_506979__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_506979__(2));
var messagequeue_1 = tslib_1.__importDefault(__nested_webpack_require_506979__(36));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_506979__(4));
var actions = protocolmessage_1.default.Action;
var PendingMessage = /** @class */ (function () {
    function PendingMessage(message, callback) {
        this.message = message;
        this.callback = callback;
        this.merged = false;
        var action = message.action;
        this.sendAttempted = false;
        this.ackRequired = action == actions.MESSAGE || action == actions.PRESENCE;
    }
    return PendingMessage;
}());
exports.PendingMessage = PendingMessage;
var Protocol = /** @class */ (function (_super) {
    tslib_1.__extends(Protocol, _super);
    function Protocol(transport) {
        var _this = _super.call(this) || this;
        _this.transport = transport;
        _this.messageQueue = new messagequeue_1.default();
        transport.on('ack', function (serial, count) {
            _this.onAck(serial, count);
        });
        transport.on('nack', function (serial, count, err) {
            _this.onNack(serial, count, err);
        });
        return _this;
    }
    Protocol.prototype.onAck = function (serial, count) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Protocol.onAck()', 'serial = ' + serial + '; count = ' + count);
        this.messageQueue.completeMessages(serial, count);
    };
    Protocol.prototype.onNack = function (serial, count, err) {
        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Protocol.onNack()', 'serial = ' + serial + '; count = ' + count + '; err = ' + Utils.inspectError(err));
        if (!err) {
            err = new errorinfo_1.default('Unable to send message; channel not responding', 50001, 500);
        }
        this.messageQueue.completeMessages(serial, count, err);
    };
    Protocol.prototype.onceIdle = function (listener) {
        var messageQueue = this.messageQueue;
        if (messageQueue.count() === 0) {
            listener();
            return;
        }
        messageQueue.once('idle', listener);
    };
    Protocol.prototype.send = function (pendingMessage) {
        if (pendingMessage.ackRequired) {
            this.messageQueue.push(pendingMessage);
        }
        if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Protocol.send()', 'sending msg; ' + protocolmessage_1.default.stringify(pendingMessage.message));
        }
        pendingMessage.sendAttempted = true;
        this.transport.send(pendingMessage.message);
    };
    Protocol.prototype.getTransport = function () {
        return this.transport;
    };
    Protocol.prototype.getPendingMessages = function () {
        return this.messageQueue.copyAll();
    };
    Protocol.prototype.clearPendingMessages = function () {
        return this.messageQueue.clear();
    };
    Protocol.prototype.finish = function () {
        var transport = this.transport;
        this.onceIdle(function () {
            transport.disconnect();
        });
    };
    return Protocol;
}(eventemitter_1.default));
exports.default = Protocol;


/***/ }),
/* 53 */
/***/ (function(module, exports, __nested_webpack_require_510629__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_510629__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_510629__(3));
var Utils = tslib_1.__importStar(__nested_webpack_require_510629__(1));
var transport_1 = tslib_1.__importDefault(__nested_webpack_require_510629__(26));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_510629__(8));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_510629__(2));
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_510629__(10));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_510629__(4));
var shortName = 'web_socket';
function isNodeWebSocket(ws) {
    return !!ws.on;
}
var WebSocketTransport = /** @class */ (function (_super) {
    tslib_1.__extends(WebSocketTransport, _super);
    function WebSocketTransport(connectionManager, auth, params) {
        var _this = _super.call(this, connectionManager, auth, params) || this;
        _this.shortName = shortName;
        /* If is a browser, can't detect pings, so request protocol heartbeats */
        params.heartbeats = platform_1.default.Config.useProtocolHeartbeats;
        _this.wsHost = defaults_1.default.getHost(params.options, params.host, true);
        return _this;
    }
    WebSocketTransport.isAvailable = function () {
        return !!platform_1.default.Config.WebSocket;
    };
    WebSocketTransport.prototype.createWebSocket = function (uri, connectParams) {
        this.uri = uri + Utils.toQueryString(connectParams);
        return new platform_1.default.Config.WebSocket(this.uri);
    };
    WebSocketTransport.prototype.toString = function () {
        return 'WebSocketTransport; uri=' + this.uri;
    };
    WebSocketTransport.prototype.connect = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.connect()', 'starting');
        transport_1.default.prototype.connect.call(this);
        var self = this, params = this.params, options = params.options;
        var wsScheme = options.tls ? 'wss://' : 'ws://';
        var wsUri = wsScheme + this.wsHost + ':' + defaults_1.default.getPort(options) + '/';
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.connect()', 'uri: ' + wsUri);
        this.auth.getAuthParams(function (err, authParams) {
            if (self.isDisposed) {
                return;
            }
            var paramStr = '';
            for (var param in authParams)
                paramStr += ' ' + param + ': ' + authParams[param] + ';';
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.connect()', 'authParams:' + paramStr + ' err: ' + err);
            if (err) {
                self.disconnect(err);
                return;
            }
            var connectParams = params.getConnectParams(authParams);
            try {
                var wsConnection = (self.wsConnection = self.createWebSocket(wsUri, connectParams));
                wsConnection.binaryType = platform_1.default.Config.binaryType;
                wsConnection.onopen = function () {
                    self.onWsOpen();
                };
                wsConnection.onclose = function (ev) {
                    self.onWsClose(ev);
                };
                wsConnection.onmessage = function (ev) {
                    self.onWsData(ev.data);
                };
                wsConnection.onerror = function (ev) {
                    self.onWsError(ev);
                };
                if (isNodeWebSocket(wsConnection)) {
                    /* node; browsers currently don't have a general eventemitter and can't detect
                     * pings. Also, no need to reply with a pong explicitly, ws lib handles that */
                    wsConnection.on('ping', function () {
                        self.onActivity();
                    });
                }
            }
            catch (e) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'WebSocketTransport.connect()', 'Unexpected exception creating websocket: err = ' + (e.stack || e.message));
                self.disconnect(e);
            }
        });
    };
    WebSocketTransport.prototype.send = function (message) {
        var wsConnection = this.wsConnection;
        if (!wsConnection) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'WebSocketTransport.send()', 'No socket connection');
            return;
        }
        try {
            wsConnection.send(protocolmessage_1.default.serialize(message, this.params.format));
        }
        catch (e) {
            var msg = 'Exception from ws connection when trying to send: ' + Utils.inspectError(e);
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'WebSocketTransport.send()', msg);
            /* Don't try to request a disconnect, that'll just involve sending data
             * down the websocket again. Just finish the transport. */
            this.finish('disconnected', new errorinfo_1.default(msg, 50000, 500));
        }
    };
    WebSocketTransport.prototype.onWsData = function (data) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'WebSocketTransport.onWsData()', 'data received; length = ' + data.length + '; type = ' + typeof data);
        try {
            this.onProtocolMessage(protocolmessage_1.default.deserialize(data, this.format));
        }
        catch (e) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'WebSocketTransport.onWsData()', 'Unexpected exception handing channel message: ' + e.stack);
        }
    };
    WebSocketTransport.prototype.onWsOpen = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.onWsOpen()', 'opened WebSocket');
        this.emit('preconnect');
    };
    WebSocketTransport.prototype.onWsClose = function (ev) {
        var wasClean, code;
        if (typeof ev == 'object') {
            /* W3C spec-compatible */
            code = ev.code;
            // ev.wasClean is undefined in reactnative
            wasClean = ev.wasClean || code === 1000;
        } /*if(typeof(ev) == 'number')*/
        else {
            /* ws in node */
            code = ev;
            wasClean = code == 1000;
        }
        delete this.wsConnection;
        if (wasClean) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.onWsClose()', 'Cleanly closed WebSocket');
            var err = new errorinfo_1.default('Websocket closed', 80003, 400);
            this.finish('disconnected', err);
        }
        else {
            var msg = 'Unclean disconnection of WebSocket ; code = ' + code, err = new errorinfo_1.default(msg, 80003, 400);
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.onWsClose()', msg);
            this.finish('disconnected', err);
        }
        this.emit('disposed');
    };
    WebSocketTransport.prototype.onWsError = function (err) {
        var _this = this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.onError()', 'Error from WebSocket: ' + err.message);
        /* Wait a tick before aborting: if the websocket was connected, this event
         * will be immediately followed by an onclose event with a close code. Allow
         * that to close it (so we see the close code) rather than anticipating it */
        platform_1.default.Config.nextTick(function () {
            _this.disconnect(Error(err.message));
        });
    };
    WebSocketTransport.prototype.dispose = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.dispose()', '');
        this.isDisposed = true;
        var wsConnection = this.wsConnection;
        if (wsConnection) {
            /* Ignore any messages that come through after dispose() is called but before
             * websocket is actually closed. (mostly would be harmless, but if it's a
             * CONNECTED, it'll re-tick isConnected and cause all sorts of havoc) */
            wsConnection.onmessage = function () { };
            delete this.wsConnection;
            /* defer until the next event loop cycle before closing the socket,
             * giving some implementations the opportunity to send any outstanding close message */
            platform_1.default.Config.nextTick(function () {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'WebSocketTransport.dispose()', 'closing websocket');
                if (!wsConnection) {
                    throw new Error('WebSocketTransport.dispose(): wsConnection is not defined');
                }
                wsConnection.close();
            });
        }
    };
    return WebSocketTransport;
}(transport_1.default));
function initialiseTransport(connectionManager) {
    if (WebSocketTransport.isAvailable())
        connectionManager.supportedTransports[shortName] = WebSocketTransport;
    return WebSocketTransport;
}
exports.default = initialiseTransport;


/***/ }),
/* 54 */
/***/ (function(module, exports, __nested_webpack_require_519747__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_519747__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_519747__(1));
var presence_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(34));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(2));
var presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(15));
var errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_519747__(4));
var realtimechannel_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(38));
var multicaster_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(23));
var channelstatechange_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(39));
var noop = function () { };
function getClientId(realtimePresence) {
    return realtimePresence.channel.realtime.auth.clientId;
}
function isAnonymousOrWildcard(realtimePresence) {
    var realtime = realtimePresence.channel.realtime;
    /* If not currently connected, we can't assume that we're an anonymous
     * client, as realtime may inform us of our clientId in the CONNECTED
     * message. So assume we're not anonymous and leave it to realtime to
     * return an error if we are */
    var clientId = realtime.auth.clientId;
    return (!clientId || clientId === '*') && realtime.connection.state === 'connected';
}
/* Callback is called only in the event of an error */
function waitAttached(channel, callback, action) {
    switch (channel.state) {
        case 'attached':
        case 'suspended':
            action();
            break;
        case 'initialized':
        case 'detached':
        case 'detaching':
        case 'attaching':
            channel.attach(function (err) {
                if (err)
                    callback(err);
                else
                    action();
            });
            break;
        default:
            callback(errorinfo_1.default.fromValues(channel.invalidStateError()));
    }
}
function newerThan(item, existing) {
    /* RTP2b1: if either is synthesised, compare by timestamp */
    if (item.isSynthesized() || existing.isSynthesized()) {
        // RTP2b1a: if equal, prefer the newly-arrived one
        return item.timestamp >= existing.timestamp;
    }
    /* RTP2b2 */
    var itemOrderings = item.parseId(), existingOrderings = existing.parseId();
    if (itemOrderings.msgSerial === existingOrderings.msgSerial) {
        return itemOrderings.index > existingOrderings.index;
    }
    else {
        return itemOrderings.msgSerial > existingOrderings.msgSerial;
    }
}
var RealtimePresence = /** @class */ (function (_super) {
    tslib_1.__extends(RealtimePresence, _super);
    function RealtimePresence(channel) {
        var _this = _super.call(this, channel) || this;
        _this.channel = channel;
        _this.syncComplete = false;
        _this.members = new PresenceMap(_this, function (item) { return item.clientId + ':' + item.connectionId; });
        // RTP17h: Store own members by clientId only.
        _this._myMembers = new PresenceMap(_this, function (item) { return item.clientId; });
        _this.subscriptions = new eventemitter_1.default();
        _this.pendingPresence = [];
        return _this;
    }
    RealtimePresence.prototype.enter = function (data, callback) {
        if (isAnonymousOrWildcard(this)) {
            throw new errorinfo_1.default('clientId must be specified to enter a presence channel', 40012, 400);
        }
        return this._enterOrUpdateClient(undefined, undefined, data, 'enter', callback);
    };
    RealtimePresence.prototype.update = function (data, callback) {
        if (isAnonymousOrWildcard(this)) {
            throw new errorinfo_1.default('clientId must be specified to update presence data', 40012, 400);
        }
        return this._enterOrUpdateClient(undefined, undefined, data, 'update', callback);
    };
    RealtimePresence.prototype.enterClient = function (clientId, data, callback) {
        return this._enterOrUpdateClient(undefined, clientId, data, 'enter', callback);
    };
    RealtimePresence.prototype.updateClient = function (clientId, data, callback) {
        return this._enterOrUpdateClient(undefined, clientId, data, 'update', callback);
    };
    RealtimePresence.prototype._enterOrUpdateClient = function (id, clientId, data, action, callback) {
        var _this = this;
        if (!callback) {
            if (typeof data === 'function') {
                callback = data;
                data = null;
            }
            else {
                if (this.channel.realtime.options.promises) {
                    return Utils.promisify(this, '_enterOrUpdateClient', [id, clientId, data, action]);
                }
                callback = noop;
            }
        }
        var channel = this.channel;
        if (!channel.connectionManager.activeState()) {
            callback(channel.connectionManager.getError());
            return;
        }
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.' + action + 'Client()', 'channel = ' + channel.name + ', id = ' + id + ', client = ' + (clientId || '(implicit) ' + getClientId(this)));
        var presence = presencemessage_1.default.fromData(data);
        presence.action = action;
        if (id) {
            presence.id = id;
        }
        if (clientId) {
            presence.clientId = clientId;
        }
        presencemessage_1.default.encode(presence, channel.channelOptions, function (err) {
            if (err) {
                callback(err);
                return;
            }
            switch (channel.state) {
                case 'attached':
                    channel.sendPresence(presence, callback);
                    break;
                case 'initialized':
                case 'detached':
                    channel.attach();
                // eslint-disable-next-line no-fallthrough
                case 'attaching':
                    _this.pendingPresence.push({
                        presence: presence,
                        callback: callback,
                    });
                    break;
                default:
                    err = new errorinfo_1.PartialErrorInfo('Unable to ' + action + ' presence channel while in ' + channel.state + ' state', 90001);
                    err.code = 90001;
                    callback(err);
            }
        });
    };
    RealtimePresence.prototype.leave = function (data, callback) {
        if (isAnonymousOrWildcard(this)) {
            throw new errorinfo_1.default('clientId must have been specified to enter or leave a presence channel', 40012, 400);
        }
        return this.leaveClient(undefined, data, callback);
    };
    RealtimePresence.prototype.leaveClient = function (clientId, data, callback) {
        if (!callback) {
            if (typeof data === 'function') {
                callback = data;
                data = null;
            }
            else {
                if (this.channel.realtime.options.promises) {
                    return Utils.promisify(this, 'leaveClient', [clientId, data]);
                }
                callback = noop;
            }
        }
        var channel = this.channel;
        if (!channel.connectionManager.activeState()) {
            callback === null || callback === void 0 ? void 0 : callback(channel.connectionManager.getError());
            return;
        }
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.leaveClient()', 'leaving; channel = ' + this.channel.name + ', client = ' + clientId);
        var presence = presencemessage_1.default.fromValues({
            action: 'leave',
            data: data,
        });
        if (clientId) {
            presence.clientId = clientId;
        }
        switch (channel.state) {
            case 'attached':
                channel.sendPresence(presence, callback);
                break;
            case 'attaching':
                this.pendingPresence.push({
                    presence: presence,
                    callback: callback,
                });
                break;
            case 'initialized':
            case 'failed': {
                /* we're not attached; therefore we let any entered status
                 * timeout by itself instead of attaching just in order to leave */
                var err = new errorinfo_1.PartialErrorInfo('Unable to leave presence channel (incompatible state)', 90001);
                callback === null || callback === void 0 ? void 0 : callback(err);
                break;
            }
            default:
                callback === null || callback === void 0 ? void 0 : callback(channel.invalidStateError());
        }
    };
    // Return type is any to avoid conflict with base Presence class
    RealtimePresence.prototype.get = function (params, callback) {
        var _this = this;
        var args = Array.prototype.slice.call(arguments);
        if (args.length == 1 && typeof args[0] == 'function')
            args.unshift(null);
        params = args[0];
        callback = args[1];
        var waitForSync = !params || ('waitForSync' in params ? params.waitForSync : true);
        if (!callback) {
            if (this.channel.realtime.options.promises) {
                return Utils.promisify(this, 'get', args);
            }
            callback = noop;
        }
        function returnMembers(members) {
            callback(null, params ? members.list(params) : members.values());
        }
        /* Special-case the suspended state: can still get (stale) presence set if waitForSync is false */
        if (this.channel.state === 'suspended') {
            if (waitForSync) {
                callback(errorinfo_1.default.fromValues({
                    statusCode: 400,
                    code: 91005,
                    message: 'Presence state is out of sync due to channel being in the SUSPENDED state',
                }));
            }
            else {
                returnMembers(this.members);
            }
            return;
        }
        waitAttached(this.channel, callback, function () {
            var members = _this.members;
            if (waitForSync) {
                members.waitSync(function () {
                    returnMembers(members);
                });
            }
            else {
                returnMembers(members);
            }
        });
    };
    RealtimePresence.prototype.history = function (params, callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.history()', 'channel = ' + this.name);
        /* params and callback are optional; see if params contains the callback */
        if (callback === undefined) {
            if (typeof params == 'function') {
                callback = params;
                params = null;
            }
            else {
                if (this.channel.realtime.options.promises) {
                    return Utils.promisify(this, 'history', arguments);
                }
                callback = noop;
            }
        }
        if (params && params.untilAttach) {
            if (this.channel.state === 'attached') {
                delete params.untilAttach;
                params.from_serial = this.channel.properties.attachSerial;
            }
            else {
                callback(new errorinfo_1.default('option untilAttach requires the channel to be attached, was: ' + this.channel.state, 40000, 400));
            }
        }
        presence_1.default.prototype._history.call(this, params, callback);
    };
    RealtimePresence.prototype.setPresence = function (presenceSet, isSync, syncChannelSerial) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.setPresence()', 'received presence for ' + presenceSet.length + ' participants; syncChannelSerial = ' + syncChannelSerial);
        var syncCursor, match;
        var members = this.members, myMembers = this._myMembers, broadcastMessages = [], connId = this.channel.connectionManager.connectionId;
        if (isSync) {
            this.members.startSync();
            if (syncChannelSerial && (match = syncChannelSerial.match(/^[\w-]+:(.*)$/))) {
                syncCursor = match[1];
            }
        }
        for (var i = 0; i < presenceSet.length; i++) {
            var presence = presencemessage_1.default.fromValues(presenceSet[i]);
            switch (presence.action) {
                case 'leave':
                    if (members.remove(presence)) {
                        broadcastMessages.push(presence);
                    }
                    if (presence.connectionId === connId && !presence.isSynthesized()) {
                        myMembers.remove(presence);
                    }
                    break;
                case 'enter':
                case 'present':
                case 'update':
                    if (members.put(presence)) {
                        broadcastMessages.push(presence);
                    }
                    if (presence.connectionId === connId) {
                        myMembers.put(presence);
                    }
                    break;
            }
        }
        /* if this is the last (or only) message in a sequence of sync updates, end the sync */
        if (isSync && !syncCursor) {
            members.endSync();
            this.channel.syncChannelSerial = null;
        }
        /* broadcast to listeners */
        for (var i = 0; i < broadcastMessages.length; i++) {
            var presence = broadcastMessages[i];
            this.subscriptions.emit(presence.action, presence);
        }
    };
    RealtimePresence.prototype.onAttached = function (hasPresence) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimePresence.onAttached()', 'channel = ' + this.channel.name + ', hasPresence = ' + hasPresence);
        if (hasPresence) {
            this.members.startSync();
        }
        else {
            this._synthesizeLeaves(this.members.values());
            this.members.clear();
        }
        // RTP17f: Re-enter own members when moving into the attached state.
        this._ensureMyMembersPresent();
        /* NB this must be after the _ensureMyMembersPresent call, which may add items to pendingPresence */
        var pendingPresence = this.pendingPresence, pendingPresCount = pendingPresence.length;
        if (pendingPresCount) {
            this.pendingPresence = [];
            var presenceArray = [];
            var multicaster = multicaster_1.default.create();
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.onAttached', 'sending ' + pendingPresCount + ' queued presence messages');
            for (var i = 0; i < pendingPresCount; i++) {
                var event_1 = pendingPresence[i];
                presenceArray.push(event_1.presence);
                multicaster.push(event_1.callback);
            }
            this.channel.sendPresence(presenceArray, multicaster);
        }
    };
    RealtimePresence.prototype.actOnChannelState = function (state, hasPresence, err) {
        switch (state) {
            case 'attached':
                this.onAttached(hasPresence);
                break;
            case 'detached':
            case 'failed':
                this._clearMyMembers();
                this.members.clear();
            /* falls through */
            case 'suspended':
                this.failPendingPresence(err);
                break;
        }
    };
    RealtimePresence.prototype.failPendingPresence = function (err) {
        if (this.pendingPresence.length) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.failPendingPresence', 'channel; name = ' + this.channel.name + ', err = ' + Utils.inspectError(err));
            for (var i = 0; i < this.pendingPresence.length; i++)
                try {
                    this.pendingPresence[i].callback(err);
                    // eslint-disable-next-line no-empty
                }
                catch (e) { }
            this.pendingPresence = [];
        }
    };
    RealtimePresence.prototype._clearMyMembers = function () {
        this._myMembers.clear();
    };
    RealtimePresence.prototype._ensureMyMembersPresent = function () {
        var _this = this;
        var myMembers = this._myMembers, reenterCb = function (err) {
            if (err) {
                var msg = 'Presence auto-re-enter failed: ' + err.toString();
                var wrappedErr = new errorinfo_1.default(msg, 91004, 400);
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimePresence._ensureMyMembersPresent()', msg);
                var change = new channelstatechange_1.default(_this.channel.state, _this.channel.state, true, false, wrappedErr);
                _this.channel.emit('update', change);
            }
        };
        for (var memberKey in myMembers.map) {
            var entry = myMembers.map[memberKey];
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence._ensureMyMembersPresent()', 'Auto-reentering clientId "' + entry.clientId + '" into the presence set');
            // RTP17g: Send ENTER containing the member id, clientId and data
            // attributes.
            this._enterOrUpdateClient(entry.id, entry.clientId, entry.data, 'enter', reenterCb);
        }
    };
    RealtimePresence.prototype._synthesizeLeaves = function (items) {
        var subscriptions = this.subscriptions;
        Utils.arrForEach(items, function (item) {
            var presence = presencemessage_1.default.fromValues({
                action: 'leave',
                connectionId: item.connectionId,
                clientId: item.clientId,
                data: item.data,
                encoding: item.encoding,
                timestamp: Utils.now(),
            });
            subscriptions.emit('leave', presence);
        });
    };
    /* Deprecated */
    RealtimePresence.prototype.on = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        logger_1.default.deprecated('presence.on', 'presence.subscribe');
        this.subscribe.apply(this, args);
    };
    /* Deprecated */
    RealtimePresence.prototype.off = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        logger_1.default.deprecated('presence.off', 'presence.unsubscribe');
        this.unsubscribe.apply(this, args);
    };
    RealtimePresence.prototype.subscribe = function () {
        var _args = []; /* [event], listener, [callback] */
        for (var _i = 0 /* [event], listener, [callback] */; _i < arguments.length /* [event], listener, [callback] */; _i++ /* [event], listener, [callback] */) {
            _args[_i] = arguments[_i]; /* [event], listener, [callback] */
        }
        var args = realtimechannel_1.default.processListenerArgs(_args);
        var event = args[0];
        var listener = args[1];
        var callback = args[2];
        var channel = this.channel;
        if (!callback) {
            if (this.channel.realtime.options.promises) {
                return Utils.promisify(this, 'subscribe', [event, listener]);
            }
            callback = noop;
        }
        if (channel.state === 'failed') {
            callback(errorinfo_1.default.fromValues(channel.invalidStateError()));
            return;
        }
        this.subscriptions.on(event, listener);
        channel.attach(callback);
    };
    RealtimePresence.prototype.unsubscribe = function () {
        var _args = []; /* [event], listener */
        for (var _i = 0 /* [event], listener */; _i < arguments.length /* [event], listener */; _i++ /* [event], listener */) {
            _args[_i] = arguments[_i]; /* [event], listener */
        }
        var args = realtimechannel_1.default.processListenerArgs(_args);
        var event = args[0];
        var listener = args[1];
        this.subscriptions.off(event, listener);
    };
    return RealtimePresence;
}(presence_1.default));
var PresenceMap = /** @class */ (function (_super) {
    tslib_1.__extends(PresenceMap, _super);
    function PresenceMap(presence, memberKey) {
        var _this = _super.call(this) || this;
        _this.presence = presence;
        _this.map = Object.create(null);
        _this.syncInProgress = false;
        _this.residualMembers = null;
        _this.memberKey = memberKey;
        return _this;
    }
    PresenceMap.prototype.get = function (key) {
        return this.map[key];
    };
    PresenceMap.prototype.getClient = function (clientId) {
        var map = this.map, result = [];
        for (var key in map) {
            var item = map[key];
            if (item.clientId == clientId && item.action != 'absent')
                result.push(item);
        }
        return result;
    };
    PresenceMap.prototype.list = function (params) {
        var map = this.map, clientId = params && params.clientId, connectionId = params && params.connectionId, result = [];
        for (var key in map) {
            var item = map[key];
            if (item.action === 'absent')
                continue;
            if (clientId && clientId != item.clientId)
                continue;
            if (connectionId && connectionId != item.connectionId)
                continue;
            result.push(item);
        }
        return result;
    };
    PresenceMap.prototype.put = function (item) {
        if (item.action === 'enter' || item.action === 'update') {
            item = presencemessage_1.default.fromValues(item);
            item.action = 'present';
        }
        var map = this.map, key = this.memberKey(item);
        /* we've seen this member, so do not remove it at the end of sync */
        if (this.residualMembers)
            delete this.residualMembers[key];
        /* compare the timestamp of the new item with any existing member (or ABSENT witness) */
        var existingItem = map[key];
        if (existingItem && !newerThan(item, existingItem)) {
            return false;
        }
        map[key] = item;
        return true;
    };
    PresenceMap.prototype.values = function () {
        var map = this.map, result = [];
        for (var key in map) {
            var item = map[key];
            if (item.action != 'absent')
                result.push(item);
        }
        return result;
    };
    PresenceMap.prototype.remove = function (item) {
        var map = this.map, key = this.memberKey(item);
        var existingItem = map[key];
        if (existingItem && !newerThan(item, existingItem)) {
            return false;
        }
        /* RTP2f */
        if (this.syncInProgress) {
            item = presencemessage_1.default.fromValues(item);
            item.action = 'absent';
            map[key] = item;
        }
        else {
            delete map[key];
        }
        return true;
    };
    PresenceMap.prototype.startSync = function () {
        var map = this.map, syncInProgress = this.syncInProgress;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'PresenceMap.startSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
        /* we might be called multiple times while a sync is in progress */
        if (!this.syncInProgress) {
            this.residualMembers = Utils.copy(map);
            this.setInProgress(true);
        }
    };
    PresenceMap.prototype.endSync = function () {
        var map = this.map, syncInProgress = this.syncInProgress;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'PresenceMap.endSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
        if (syncInProgress) {
            /* we can now strip out the ABSENT members, as we have
             * received all of the out-of-order sync messages */
            for (var memberKey in map) {
                var entry = map[memberKey];
                if (entry.action === 'absent') {
                    delete map[memberKey];
                }
            }
            /* any members that were present at the start of the sync,
             * and have not been seen in sync, can be removed, and leave events emitted */
            this.presence._synthesizeLeaves(Utils.valuesArray(this.residualMembers));
            for (var memberKey in this.residualMembers) {
                delete map[memberKey];
            }
            this.residualMembers = null;
            /* finish, notifying any waiters */
            this.setInProgress(false);
        }
        this.emit('sync');
    };
    PresenceMap.prototype.waitSync = function (callback) {
        var syncInProgress = this.syncInProgress;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'PresenceMap.waitSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
        if (!syncInProgress) {
            callback();
            return;
        }
        this.once('sync', callback);
    };
    PresenceMap.prototype.clear = function () {
        this.map = {};
        this.setInProgress(false);
        this.residualMembers = null;
    };
    PresenceMap.prototype.setInProgress = function (inProgress) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'PresenceMap.setInProgress()', 'inProgress = ' + inProgress);
        this.syncInProgress = inProgress;
        this.presence.syncComplete = !inProgress;
    };
    return PresenceMap;
}(eventemitter_1.default));
exports.default = RealtimePresence;


/***/ }),
/* 55 */
/***/ (function(module, exports, __nested_webpack_require_545633__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_545633__(0);
var enc_hex_1 = __nested_webpack_require_545633__(56);
var enc_utf8_1 = __nested_webpack_require_545633__(31);
var enc_base64_1 = __nested_webpack_require_545633__(11);
var lib_typedarrays_1 = tslib_1.__importDefault(__nested_webpack_require_545633__(5));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_545633__(3));
var BufferUtils = /** @class */ (function () {
    function BufferUtils() {
        this.base64CharSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        this.hexCharSet = '0123456789abcdef';
    }
    BufferUtils.prototype.isWordArray = function (ob) {
        return ob !== null && ob !== undefined && ob.sigBytes !== undefined;
    };
    BufferUtils.prototype.isArrayBuffer = function (ob) {
        return ob !== null && ob !== undefined && ob.constructor === ArrayBuffer;
    };
    BufferUtils.prototype.isTypedArray = function (ob) {
        return !!ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(ob);
    };
    // // https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js
    BufferUtils.prototype.uint8ViewToBase64 = function (bytes) {
        var base64 = '';
        var encodings = this.base64CharSet;
        var byteLength = bytes.byteLength;
        var byteRemainder = byteLength % 3;
        var mainLength = byteLength - byteRemainder;
        var a, b, c, d;
        var chunk;
        // Main loop deals with bytes in chunks of 3
        for (var i = 0; i < mainLength; i = i + 3) {
            // Combine the three bytes into a single integer
            chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
            // Use bitmasks to extract 6-bit segments from the triplet
            a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
            b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12
            c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6
            d = chunk & 63; // 63       = 2^6 - 1
            // Convert the raw binary segments to the appropriate ASCII encoding
            base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
        }
        // Deal with the remaining bytes and padding
        if (byteRemainder == 1) {
            chunk = bytes[mainLength];
            a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2
            // Set the 4 least significant bits to zero
            b = (chunk & 3) << 4; // 3   = 2^2 - 1
            base64 += encodings[a] + encodings[b] + '==';
        }
        else if (byteRemainder == 2) {
            chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];
            a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
            b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4
            // Set the 2 least significant bits to zero
            c = (chunk & 15) << 2; // 15    = 2^4 - 1
            base64 += encodings[a] + encodings[b] + encodings[c] + '=';
        }
        return base64;
    };
    BufferUtils.prototype.base64ToArrayBuffer = function (base64) {
        var binary_string = atob === null || atob === void 0 ? void 0 : atob(base64); // this will always be defined in browser so it's safe to cast
        var len = binary_string.length;
        var bytes = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
            var ascii = binary_string.charCodeAt(i);
            bytes[i] = ascii;
        }
        return bytes.buffer;
    };
    BufferUtils.prototype.isBuffer = function (buffer) {
        return this.isArrayBuffer(buffer) || this.isWordArray(buffer) || this.isTypedArray(buffer);
    };
    /* In browsers, returns a Uint8Array */
    BufferUtils.prototype.toBuffer = function (buffer) {
        if (!ArrayBuffer) {
            throw new Error("Can't convert to Buffer: browser does not support the necessary types");
        }
        if (this.isArrayBuffer(buffer)) {
            return new Uint8Array(buffer);
        }
        if (this.isTypedArray(buffer)) {
            return new Uint8Array(buffer.buffer);
        }
        if (this.isWordArray(buffer)) {
            /* Backported from unreleased CryptoJS
             * https://code.google.com/p/crypto-js/source/browse/branches/3.x/src/lib-typedarrays.js?r=661 */
            var arrayBuffer = new ArrayBuffer(buffer.sigBytes);
            var uint8View = new Uint8Array(arrayBuffer);
            for (var i = 0; i < buffer.sigBytes; i++) {
                uint8View[i] = (buffer.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
            }
            return uint8View;
        }
        throw new Error('BufferUtils.toBuffer expected an arraybuffer, typed array, or CryptoJS wordarray');
    };
    BufferUtils.prototype.toArrayBuffer = function (buffer) {
        if (this.isArrayBuffer(buffer)) {
            return buffer;
        }
        return this.toBuffer(buffer).buffer;
    };
    BufferUtils.prototype.toWordArray = function (buffer) {
        if (this.isTypedArray(buffer)) {
            buffer = buffer.buffer;
        }
        return this.isWordArray(buffer) ? buffer : lib_typedarrays_1.default.create(buffer);
    };
    BufferUtils.prototype.base64Encode = function (buffer) {
        if (this.isWordArray(buffer)) {
            return (0, enc_base64_1.stringify)(buffer);
        }
        return this.uint8ViewToBase64(this.toBuffer(buffer));
    };
    BufferUtils.prototype.base64Decode = function (str) {
        if (ArrayBuffer && platform_1.default.Config.atob) {
            return this.base64ToArrayBuffer(str);
        }
        return (0, enc_base64_1.parse)(str);
    };
    BufferUtils.prototype.hexEncode = function (buffer) {
        return (0, enc_hex_1.stringify)(this.toWordArray(buffer));
    };
    BufferUtils.prototype.hexDecode = function (string) {
        var wordArray = (0, enc_hex_1.parse)(string);
        return ArrayBuffer ? this.toArrayBuffer(wordArray) : wordArray;
    };
    BufferUtils.prototype.utf8Encode = function (string) {
        if (platform_1.default.Config.TextEncoder) {
            return new platform_1.default.Config.TextEncoder().encode(string).buffer;
        }
        return (0, enc_utf8_1.parse)(string);
    };
    /* For utf8 decoding we apply slightly stricter input validation than to
     * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from
     * can take (in particular allowing strings, which are just interpreted as
     * binary); here we ensure that the input is actually a buffer since trying
     * to utf8-decode a string to another string is almost certainly a mistake */
    BufferUtils.prototype.utf8Decode = function (buffer) {
        if (!this.isBuffer(buffer)) {
            throw new Error('Expected input of utf8decode to be an arraybuffer, typed array, or CryptoJS wordarray');
        }
        if (TextDecoder && !this.isWordArray(buffer)) {
            return new TextDecoder().decode(buffer);
        }
        buffer = this.toWordArray(buffer);
        return (0, enc_utf8_1.stringify)(buffer);
    };
    BufferUtils.prototype.bufferCompare = function (buffer1, buffer2) {
        if (!buffer1)
            return -1;
        if (!buffer2)
            return 1;
        var wordArray1 = this.toWordArray(buffer1);
        var wordArray2 = this.toWordArray(buffer2);
        wordArray1.clamp();
        wordArray2.clamp();
        var cmp = wordArray1.sigBytes - wordArray2.sigBytes;
        if (cmp != 0)
            return cmp;
        var words1 = wordArray1.words;
        var words2 = wordArray2.words;
        for (var i = 0; i < words1.length; i++) {
            cmp = words1[i] - words2[i];
            if (cmp != 0)
                return cmp;
        }
        return 0;
    };
    BufferUtils.prototype.byteLength = function (buffer) {
        if (this.isArrayBuffer(buffer) || this.isTypedArray(buffer)) {
            return buffer.byteLength;
        }
        else if (this.isWordArray(buffer)) {
            return buffer.sigBytes;
        }
        return -1;
    };
    /* Returns ArrayBuffer on browser and Buffer on Node.js */
    BufferUtils.prototype.typedArrayToBuffer = function (typedArray) {
        return typedArray.buffer;
    };
    return BufferUtils;
}());
exports.default = new BufferUtils();


/***/ }),
/* 56 */
/***/ (function(module, exports, __nested_webpack_require_554008__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_554008__(6));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Hex;

}));

/***/ }),
/* 57 */
/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_554290__) {

"use strict";
__nested_webpack_require_554290__.r(__nested_webpack_exports__);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_554290__(5);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_554290__.n(crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_554290__(11);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_554290__.n(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crypto_js_build__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_554290__(22);
/* harmony import */ var crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_554290__.n(crypto_js_build__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_554290__(2);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_554290__.n(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_554290__(4);
/* harmony import */ var common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__nested_webpack_require_554290__.n(common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_4__);






var CryptoFactory = function (config, bufferUtils) {
  var DEFAULT_ALGORITHM = 'aes';
  var DEFAULT_KEYLENGTH = 256; // bits
  var DEFAULT_MODE = 'cbc';
  var DEFAULT_BLOCKLENGTH = 16; // bytes
  var DEFAULT_BLOCKLENGTH_WORDS = 4; // 32-bit words
  var UINT32_SUP = 0x100000000;
  var INT32_SUP = 0x80000000;

  /**
   * Internal: generate an array of secure random words corresponding to the given length of bytes
   * @param bytes
   * @param callback
   */
  var generateRandom;
  if (config.getRandomWordArray) {
    generateRandom = config.getRandomWordArray;
  } else if (typeof Uint32Array !== 'undefined' && config.getRandomValues) {
    var blockRandomArray = new Uint32Array(DEFAULT_BLOCKLENGTH_WORDS);
    generateRandom = function (bytes, callback) {
      var words = bytes / 4,
        nativeArray = words == DEFAULT_BLOCKLENGTH_WORDS ? blockRandomArray : new Uint32Array(words);
      config.getRandomValues(nativeArray, function (err) {
        if (typeof callback !== 'undefined') {
          callback(err, bufferUtils.toWordArray(nativeArray));
        }
      });
    };
  } else {
    generateRandom = function (bytes, callback) {
      _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.logAction(
        _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.LOG_MAJOR,
        'Ably.Crypto.generateRandom()',
        'Warning: the browser you are using does not support secure cryptographically secure randomness generation; falling back to insecure Math.random()'
      );
      var words = bytes / 4,
        array = new Array(words);
      for (var i = 0; i < words; i++) {
        /* cryptojs wordarrays use signed ints. When WordArray.create is fed a
         * Uint32Array unsigned are converted to signed automatically, but when
         * fed a normal array they aren't, so need to do so ourselves by
         * subtracting INT32_SUP */
        array[i] = Math.floor(Math.random() * UINT32_SUP) - INT32_SUP;
      }

      callback(null, crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(array));
    };
  }

  /**
   * Internal: calculate the padded length of a given plaintext
   * using PKCS5.
   * @param plaintextLength
   * @return
   */
  function getPaddedLength(plaintextLength) {
    return (plaintextLength + DEFAULT_BLOCKLENGTH) & -DEFAULT_BLOCKLENGTH;
  }

  /**
   * Internal: checks that the cipherParams are a valid combination. Currently
   * just checks that the calculated keyLength is a valid one for aes-cbc
   */
  function validateCipherParams(params) {
    if (params.algorithm === 'aes' && params.mode === 'cbc') {
      if (params.keyLength === 128 || params.keyLength === 256) {
        return;
      }
      throw new Error(
        'Unsupported key length ' +
          params.keyLength +
          ' for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)'
      );
    }
  }

  function normaliseBase64(string) {
    /* url-safe base64 strings use _ and - instread of / and + */
    return string.replace('_', '/').replace('-', '+');
  }

  /**
   * Internal: obtain the pkcs5 padding string for a given padded length;
   */
  var pkcs5Padding = [
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x10101010, 0x10101010, 0x10101010, 0x10101010], 16),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x01000000], 1),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x02020000], 2),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x03030300], 3),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x04040404], 4),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x05050505, 0x05000000], 5),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x06060606, 0x06060000], 6),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x07070707, 0x07070700], 7),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x08080808, 0x08080808], 8),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x09090909, 0x09090909, 0x09000000], 9),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0a0a0a0a, 0x0a0a0a0a, 0x0a0a0000], 10),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0b0b0b0b, 0x0b0b0b0b, 0x0b0b0b00], 11),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0c0c0c0c, 0x0c0c0c0c, 0x0c0c0c0c], 12),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0d0d0d0d, 0x0d0d0d0d, 0x0d0d0d0d, 0x0d000000], 13),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0e0e0e0e, 0x0e0e0e0e, 0x0e0e0e0e, 0x0e0e0000], 14),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f], 15),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x10101010, 0x10101010, 0x10101010, 0x10101010], 16),
  ];

  /**
   * Utility classes and interfaces for message payload encryption.
   *
   * This class supports AES/CBC/PKCS5 with a default keylength of 128 bits
   * but supporting other keylengths. Other algorithms and chaining modes are
   * not supported directly, but supportable by extending/implementing the base
   * classes and interfaces here.
   *-
   * Secure random data for creation of Initialization Vectors (IVs) and keys
   * is obtained from window.crypto.getRandomValues if available, or from
   * Math.random() if not. Clients who do not want to depend on Math.random()
   * should polyfill window.crypto.getRandomValues with a library that seeds
   * a PRNG with real entropy.
   *
   * Each message payload is encrypted with an IV in CBC mode, and the IV is
   * concatenated with the resulting raw ciphertext to construct the "ciphertext"
   * data passed to the recipient.
   */
  function Crypto() {}

  /**
   * A class encapsulating the client-specifiable parameters for
   * the cipher.
   *
   * algorithm is the name of the algorithm in the default system provider,
   * or the lower-cased version of it; eg "aes" or "AES".
   *
   * Clients are recommended to not call this directly, but instead to use the
   * Crypto.getDefaultParams helper, which will fill in any fields not supplied
   * with default values and validation the result.
   */
  function CipherParams() {
    this.algorithm = null;
    this.keyLength = null;
    this.mode = null;
    this.key = null;
  }
  Crypto.CipherParams = CipherParams;

  /**
   * Obtain a complete CipherParams instance from the provided params, filling
   * in any not provided with default values, calculating a keyLength from
   * the supplied key, and validating the result.
   * @param params an object containing at a minimum a `key` key with value the
   * key, as either a binary (ArrayBuffer, Array, WordArray) or a
   * base64-encoded string. May optionally also contain: algorithm (defaults to
   * AES), mode (defaults to 'cbc')
   */
  Crypto.getDefaultParams = function (params) {
    var key;
    /* Backward compatibility */
    if (typeof params === 'function' || typeof params === 'string') {
      _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.deprecated('Crypto.getDefaultParams(key, callback)', 'Crypto.getDefaultParams({key: key})');
      if (typeof params === 'function') {
        Crypto.generateRandomKey(function (key) {
          params(null, Crypto.getDefaultParams({ key: key }));
        });
      } else if (typeof arguments[1] === 'function') {
        arguments[1](null, Crypto.getDefaultParams({ key: params }));
      } else {
        throw new Error('Invalid arguments for Crypto.getDefaultParams');
      }
      return;
    }

    if (!params.key) {
      throw new Error('Crypto.getDefaultParams: a key is required');
    }

    if (typeof params.key === 'string') {
      key = Object(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__["parse"])(normaliseBase64(params.key));
    } else {
      key = bufferUtils.toWordArray(params.key); // Expect key to be an Array, ArrayBuffer, or WordArray at this point
    }

    var cipherParams = new CipherParams();
    cipherParams.key = key;
    cipherParams.algorithm = params.algorithm || DEFAULT_ALGORITHM;
    cipherParams.keyLength = key.words.length * (4 * 8);
    cipherParams.mode = params.mode || DEFAULT_MODE;

    if (params.keyLength && params.keyLength !== cipherParams.keyLength) {
      throw new Error(
        'Crypto.getDefaultParams: a keyLength of ' +
          params.keyLength +
          ' was specified, but the key actually has length ' +
          cipherParams.keyLength
      );
    }

    validateCipherParams(cipherParams);
    return cipherParams;
  };

  /**
   * Generate a random encryption key from the supplied keylength (or the
   * default keyLength if none supplied) as a CryptoJS WordArray
   * @param keyLength (optional) the required keyLength in bits
   * @param callback (optional) (err, key)
   */
  Crypto.generateRandomKey = function (keyLength, callback) {
    if (arguments.length == 1 && typeof keyLength == 'function') {
      callback = keyLength;
      keyLength = undefined;
    }

    generateRandom((keyLength || DEFAULT_KEYLENGTH) / 8, function (err, buf) {
      if (callback !== undefined) {
        callback(err ? common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_4___default.a.fromValues(err) : null, buf);
      }
    });
  };

  /**
   * Internal; get a ChannelCipher instance based on the given cipherParams
   * @param params either a CipherParams instance or some subset of its
   * fields that includes a key
   */
  Crypto.getCipher = function (params) {
    var cipherParams = params instanceof CipherParams ? params : Crypto.getDefaultParams(params);

    return { cipherParams: cipherParams, cipher: new CBCCipher(cipherParams, DEFAULT_BLOCKLENGTH_WORDS, params.iv) };
  };

  function CBCCipher(params, blockLengthWords, iv) {
    this.algorithm = params.algorithm + '-' + String(params.keyLength) + '-' + params.mode;
    this.cjsAlgorithm = params.algorithm.toUpperCase().replace(/-\d+$/, '');
    this.key = bufferUtils.toWordArray(params.key);
    if (iv) {
      this.iv = bufferUtils.toWordArray(iv).clone();
    }
    this.blockLengthWords = blockLengthWords;
  }

  CBCCipher.prototype.encrypt = function (plaintext, callback) {
    _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.LOG_MICRO, 'CBCCipher.encrypt()', '');
    plaintext = bufferUtils.toWordArray(plaintext);
    var plaintextLength = plaintext.sigBytes,
      paddedLength = getPaddedLength(plaintextLength),
      self = this;

    var then = function () {
      self.getIv(function (err, iv) {
        if (err) {
          callback(err);
          return;
        }
        var cipherOut = self.encryptCipher.process(plaintext.concat(pkcs5Padding[paddedLength - plaintextLength]));
        var ciphertext = iv.concat(cipherOut);
        callback(null, ciphertext);
      });
    };

    if (!this.encryptCipher) {
      if (this.iv) {
        this.encryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[this.cjsAlgorithm].createEncryptor(this.key, { iv: this.iv });
        then();
      } else {
        generateRandom(DEFAULT_BLOCKLENGTH, function (err, iv) {
          if (err) {
            callback(err);
            return;
          }
          self.encryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[self.cjsAlgorithm].createEncryptor(self.key, { iv: iv });
          self.iv = iv;
          then();
        });
      }
    } else {
      then();
    }
  };

  CBCCipher.prototype.decrypt = function (ciphertext) {
    _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.LOG_MICRO, 'CBCCipher.decrypt()', '');
    ciphertext = bufferUtils.toWordArray(ciphertext);
    var blockLengthWords = this.blockLengthWords,
      ciphertextWords = ciphertext.words,
      iv = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(ciphertextWords.slice(0, blockLengthWords)),
      ciphertextBody = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(ciphertextWords.slice(blockLengthWords));

    var decryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[this.cjsAlgorithm].createDecryptor(this.key, { iv: iv });
    var plaintext = decryptCipher.process(ciphertextBody);
    var epilogue = decryptCipher.finalize();
    decryptCipher.reset();
    if (epilogue && epilogue.sigBytes) plaintext.concat(epilogue);
    return plaintext;
  };

  CBCCipher.prototype.getIv = function (callback) {
    if (this.iv) {
      var iv = this.iv;
      this.iv = null;
      callback(null, iv);
      return;
    }

    /* Since the iv for a new block is the ciphertext of the last, this
     * sets a new iv (= aes(randomBlock XOR lastCipherText)) as well as
     * returning it */
    var self = this;
    generateRandom(DEFAULT_BLOCKLENGTH, function (err, randomBlock) {
      if (err) {
        callback(err);
        return;
      }
      callback(null, self.encryptCipher.process(randomBlock));
    });
  };

  return Crypto;
};

/* harmony default export */ __nested_webpack_exports__["default"] = (CryptoFactory);


/***/ }),
/* 58 */
/***/ (function(module, exports, __nested_webpack_require_569507__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_569507__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	return CryptoJS.enc.Utf16;

}));

/***/ }),
/* 59 */
/***/ (function(module, exports, __nested_webpack_require_573504__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_573504__(6), __nested_webpack_require_573504__(28));
	}
	else {}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	return CryptoJS.format.Hex;

}));

/***/ }),
/* 60 */
/***/ (function(module, exports, __nested_webpack_require_575212__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_575212__(6), __nested_webpack_require_575212__(11), __nested_webpack_require_575212__(61), __nested_webpack_require_575212__(27), __nested_webpack_require_575212__(28));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            var t;

	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));

/***/ }),
/* 61 */
/***/ (function(module, exports, __nested_webpack_require_583721__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_583721__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),
/* 62 */
/***/ (function(module, exports, __nested_webpack_require_593050__) {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_593050__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(3));
var Utils = tslib_1.__importStar(__nested_webpack_require_593050__(1));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(8));
var errorinfo_1 = __nested_webpack_require_593050__(4);
var HttpMethods_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(18));
var xhrrequest_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(16));
var XHRStates_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(21));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(2));
var jsonptransport_1 = __nested_webpack_require_593050__(29);
var fetchrequest_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(63));
var HttpStatusCodes_1 = __nested_webpack_require_593050__(25);
function shouldFallback(errorInfo) {
    var statusCode = errorInfo.statusCode;
    /* 400 + no code = a generic xhr onerror. Browser doesn't give us enough
     * detail to know whether it's fallback-fixable, but it may be (eg if a
     * network issue), so try just in case */
    return ((statusCode === 408 && !errorInfo.code) ||
        (statusCode === 400 && !errorInfo.code) ||
        (statusCode >= 500 && statusCode <= 504));
}
function getHosts(client) {
    /* If we're a connected realtime client, try the endpoint we're connected
     * to first -- but still have fallbacks, being connected is not an absolute
     * guarantee that a datacenter has free capacity to service REST requests. */
    var connection = client.connection, connectionHost = connection && connection.connectionManager.host;
    if (connectionHost) {
        return [connectionHost].concat(defaults_1.default.getFallbackHosts(client.options));
    }
    return defaults_1.default.getHosts(client.options);
}
var Http = (_a = /** @class */ (function () {
        function class_1(options) {
            this.checksInProgress = null;
            this.checkConnectivity = undefined;
            this.supportsAuthHeaders = false;
            this.supportsLinkHeaders = false;
            this._getHosts = getHosts;
            this.options = options || {};
            var connectivityCheckUrl = this.options.connectivityCheckUrl || defaults_1.default.connectivityCheckUrl;
            var connectivityCheckParams = this.options.connectivityCheckParams;
            var connectivityUrlIsDefault = !this.options.connectivityCheckUrl;
            if (platform_1.default.Config.xhrSupported) {
                this.supportsAuthHeaders = true;
                this.Request = function (method, rest, uri, headers, params, body, callback) {
                    var req = xhrrequest_1.default.createRequest(uri, headers, params, body, XHRStates_1.default.REQ_SEND, rest && rest.options.timeouts, method);
                    req.once('complete', callback);
                    req.exec();
                    return req;
                };
                if (this.options.disableConnectivityCheck) {
                    this.checkConnectivity = function (callback) {
                        callback(null, true);
                    };
                }
                else {
                    this.checkConnectivity = function (callback) {
                        logger_1.default.logAction(logger_1.default.LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Sending; ' + connectivityCheckUrl);
                        this.doUri(HttpMethods_1.default.Get, null, connectivityCheckUrl, null, null, connectivityCheckParams, function (err, responseText, headers, unpacked, statusCode) {
                            var result = false;
                            if (!connectivityUrlIsDefault) {
                                result = !err && (0, HttpStatusCodes_1.isSuccessCode)(statusCode);
                            }
                            else {
                                result = !err && (responseText === null || responseText === void 0 ? void 0 : responseText.replace(/\n/, '')) == 'yes';
                            }
                            logger_1.default.logAction(logger_1.default.LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Result: ' + result);
                            callback(null, result);
                        });
                    };
                }
            }
            else if (platform_1.default.Config.jsonpSupported) {
                this.Request = function (method, rest, uri, headers, params, body, callback) {
                    var req = (0, jsonptransport_1.createRequest)(uri, headers, params, body, XHRStates_1.default.REQ_SEND, rest && rest.options.timeouts, method);
                    req.once('complete', callback);
                    platform_1.default.Config.nextTick(function () {
                        req.exec();
                    });
                    return req;
                };
                if (this.options.disableConnectivityCheck) {
                    this.checkConnectivity = function (callback) {
                        callback(null, true);
                    };
                }
                else {
                    this.checkConnectivity = function (callback) {
                        var _this = this;
                        var upUrl = defaults_1.default.jsonpInternetUpUrl;
                        if (this.checksInProgress) {
                            this.checksInProgress.push(callback);
                            return;
                        }
                        this.checksInProgress = [callback];
                        logger_1.default.logAction(logger_1.default.LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Sending; ' + upUrl);
                        var req = new jsonptransport_1.Request('isTheInternetUp', upUrl, null, null, null, XHRStates_1.default.REQ_SEND, defaults_1.default.TIMEOUTS);
                        req.once('complete', function (err, response) {
                            var result = !err && response;
                            logger_1.default.logAction(logger_1.default.LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Result: ' + result);
                            for (var i = 0; i < _this.checksInProgress.length; i++)
                                _this.checksInProgress[i](null, result);
                            _this.checksInProgress = null;
                        });
                        platform_1.default.Config.nextTick(function () {
                            req.exec();
                        });
                    };
                }
            }
            else if (platform_1.default.Config.fetchSupported) {
                this.supportsAuthHeaders = true;
                this.Request = fetchrequest_1.default;
                this.checkConnectivity = function (callback) {
                    logger_1.default.logAction(logger_1.default.LOG_MICRO, '(Fetch)Http.checkConnectivity()', 'Sending; ' + connectivityCheckUrl);
                    this.doUri(HttpMethods_1.default.Get, null, connectivityCheckUrl, null, null, null, function (err, responseText) {
                        var result = !err && (responseText === null || responseText === void 0 ? void 0 : responseText.replace(/\n/, '')) == 'yes';
                        logger_1.default.logAction(logger_1.default.LOG_MICRO, '(Fetch)Http.checkConnectivity()', 'Result: ' + result);
                        callback(null, result);
                    });
                };
            }
            else {
                this.Request = function (method, rest, uri, headers, params, body, callback) {
                    callback(new errorinfo_1.PartialErrorInfo('no supported HTTP transports available', null, 400), null);
                };
            }
        }
        /* Unlike for doUri, the 'rest' param here is mandatory, as it's used to generate the hosts */
        class_1.prototype.do = function (method, rest, path, headers, body, params, callback) {
            var _this = this;
            var uriFromHost = typeof path == 'function'
                ? path
                : function (host) {
                    return rest.baseUri(host) + path;
                };
            var currentFallback = rest._currentFallback;
            if (currentFallback) {
                if (currentFallback.validUntil > Utils.now()) {
                    /* Use stored fallback */
                    if (!this.Request) {
                        callback === null || callback === void 0 ? void 0 : callback(new errorinfo_1.PartialErrorInfo('Request invoked before assigned to', null, 500));
                        return;
                    }
                    this.Request(method, rest, uriFromHost(currentFallback.host), headers, params, body, function (err) {
                        var args = [];
                        for (var _i = 1; _i < arguments.length; _i++) {
                            args[_i - 1] = arguments[_i];
                        }
                        // This typecast is safe because ErrnoExceptions are only thrown in NodeJS
                        if (err && shouldFallback(err)) {
                            /* unstore the fallback and start from the top with the default sequence */
                            rest._currentFallback = null;
                            _this.do(method, rest, path, headers, body, params, callback);
                            return;
                        }
                        callback === null || callback === void 0 ? void 0 : callback.apply(void 0, tslib_1.__spreadArray([err], args, false));
                    });
                    return;
                }
                else {
                    /* Fallback expired; remove it and fallthrough to normal sequence */
                    rest._currentFallback = null;
                }
            }
            var hosts = getHosts(rest);
            /* if there is only one host do it */
            if (hosts.length === 1) {
                this.doUri(method, rest, uriFromHost(hosts[0]), headers, body, params, callback);
                return;
            }
            /* hosts is an array with preferred host plus at least one fallback */
            var tryAHost = function (candidateHosts, persistOnSuccess) {
                var host = candidateHosts.shift();
                _this.doUri(method, rest, uriFromHost(host), headers, body, params, function (err) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    // This typecast is safe because ErrnoExceptions are only thrown in NodeJS
                    if (err && shouldFallback(err) && candidateHosts.length) {
                        tryAHost(candidateHosts, true);
                        return;
                    }
                    if (persistOnSuccess) {
                        /* RSC15f */
                        rest._currentFallback = {
                            host: host,
                            validUntil: Utils.now() + rest.options.timeouts.fallbackRetryTimeout,
                        };
                    }
                    callback === null || callback === void 0 ? void 0 : callback.apply(void 0, tslib_1.__spreadArray([err], args, false));
                });
            };
            tryAHost(hosts);
        };
        class_1.prototype.doUri = function (method, rest, uri, headers, body, params, callback) {
            if (!this.Request) {
                callback(new errorinfo_1.PartialErrorInfo('Request invoked before assigned to', null, 500));
                return;
            }
            this.Request(method, rest, uri, headers, params, body, callback);
        };
        return class_1;
    }()),
    _a.methods = [HttpMethods_1.default.Get, HttpMethods_1.default.Delete, HttpMethods_1.default.Post, HttpMethods_1.default.Put, HttpMethods_1.default.Patch],
    _a.methodsWithoutBody = [HttpMethods_1.default.Get, HttpMethods_1.default.Delete],
    _a.methodsWithBody = [HttpMethods_1.default.Post, HttpMethods_1.default.Put, HttpMethods_1.default.Patch],
    _a);
exports.default = Http;


/***/ }),
/* 63 */
/***/ (function(module, exports, __nested_webpack_require_605278__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_605278__(0);
var errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_605278__(4));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_605278__(3));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_605278__(8));
var Utils = tslib_1.__importStar(__nested_webpack_require_605278__(1));
var utils_1 = __nested_webpack_require_605278__(1);
function isAblyError(responseBody, headers) {
    return !!headers.get('x-ably-errorcode');
}
function getAblyError(responseBody, headers) {
    if (isAblyError(responseBody, headers)) {
        return responseBody.error && errorinfo_1.default.fromValues(responseBody.error);
    }
}
function fetchRequest(method, rest, uri, headers, params, body, callback) {
    var fetchHeaders = new Headers(headers || {});
    var _method = method ? method.toUpperCase() : Utils.isEmptyArg(body) ? 'GET' : 'POST';
    var controller = new AbortController();
    var timeout = setTimeout(function () {
        controller.abort();
        callback(new errorinfo_1.PartialErrorInfo('Request timed out', null, 408));
    }, rest ? rest.options.timeouts.httpRequestTimeout : defaults_1.default.TIMEOUTS.httpRequestTimeout);
    var requestInit = {
        method: _method,
        headers: fetchHeaders,
        body: body,
    };
    if (!platform_1.default.Config.isWebworker) {
        requestInit.credentials = fetchHeaders.has('authorization') ? 'include' : 'same-origin';
    }
    (0, utils_1.getGlobalObject)()
        .fetch(uri + '?' + new URLSearchParams(params || {}), requestInit)
        .then(function (res) {
        clearTimeout(timeout);
        var contentType = res.headers.get('Content-Type');
        var prom;
        if (contentType && contentType.indexOf('application/x-msgpack') > -1) {
            prom = res.arrayBuffer();
        }
        else if (contentType && contentType.indexOf('application/json') > -1) {
            prom = res.json();
        }
        else {
            prom = res.text();
        }
        prom.then(function (body) {
            var unpacked = !!contentType && contentType.indexOf('application/x-msgpack') === -1;
            if (!res.ok) {
                var err = getAblyError(body, res.headers) ||
                    new errorinfo_1.PartialErrorInfo('Error response received from server: ' + res.status + ' body was: ' + platform_1.default.Config.inspect(body), null, res.status);
                callback(err, body, res.headers, unpacked, res.status);
            }
            else {
                callback(null, body, res.headers, unpacked, res.status);
            }
        });
    })
        .catch(function (err) {
        clearTimeout(timeout);
        callback(err);
    });
}
exports.default = fetchRequest;


/***/ }),
/* 64 */
/***/ (function(module, exports, __nested_webpack_require_608129__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_608129__(0);
var msgpack_1 = tslib_1.__importDefault(__nested_webpack_require_608129__(41));
var Utils = tslib_1.__importStar(__nested_webpack_require_608129__(1));
// Workaround for salesforce lightning locker compat
var globalObject = Utils.getGlobalObject();
if (typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') {
    console.log("Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm");
}
function allowComet() {
    /* xhr requests from local files are unreliable in some browsers, such as Chrome 65 and higher -- see eg
     * https://stackoverflow.com/questions/49256429/chrome-65-unable-to-make-post-requests-from-local-files-to-flask
     * So if websockets are supported, then just forget about comet transports and use that */
    var loc = globalObject.location;
    return !globalObject.WebSocket || !loc || !loc.origin || loc.origin.indexOf('http') > -1;
}
var userAgent = globalObject.navigator && globalObject.navigator.userAgent.toString();
var currentUrl = globalObject.location && globalObject.location.href;
var Config = {
    agent: 'browser',
    logTimestamps: true,
    userAgent: userAgent,
    currentUrl: currentUrl,
    noUpgrade: userAgent && !!userAgent.match(/MSIE\s8\.0/),
    binaryType: 'arraybuffer',
    WebSocket: globalObject.WebSocket,
    fetchSupported: !!globalObject.fetch,
    xhrSupported: globalObject.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest(),
    jsonpSupported: typeof document !== 'undefined',
    allowComet: allowComet(),
    streamingSupported: true,
    useProtocolHeartbeats: true,
    createHmac: null,
    msgpack: msgpack_1.default,
    supportsBinary: !!globalObject.TextDecoder,
    preferBinary: false,
    ArrayBuffer: globalObject.ArrayBuffer,
    atob: globalObject.atob,
    nextTick: typeof globalObject.setImmediate !== 'undefined'
        ? globalObject.setImmediate.bind(globalObject)
        : function (f) {
            setTimeout(f, 0);
        },
    addEventListener: globalObject.addEventListener,
    inspect: JSON.stringify,
    stringByteSize: function (str) {
        /* str.length will be an underestimate for non-ascii strings. But if we're
         * in a browser too old to support TextDecoder, not much we can do. Better
         * to underestimate, so if we do go over-size, the server will reject the
         * message */
        return (globalObject.TextDecoder && new globalObject.TextEncoder().encode(str).length) || str.length;
    },
    TextEncoder: globalObject.TextEncoder,
    TextDecoder: globalObject.TextDecoder,
    Promise: globalObject.Promise,
    getRandomValues: (function (crypto) {
        if (crypto === undefined) {
            return undefined;
        }
        return function (arr, callback) {
            crypto.getRandomValues(arr);
            if (callback) {
                callback(null);
            }
        };
    })(globalObject.crypto || msCrypto),
};
exports.default = Config;


/***/ }),
/* 65 */
/***/ (function(module, exports, __nested_webpack_require_611284__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_611284__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_611284__(1));
var test = 'ablyjs-storage-test';
var Webstorage = /** @class */ (function () {
    function Webstorage() {
        /* Even just accessing the session/localStorage object can throw a
         * security exception in some circumstances with some browsers. In
         * others, calling setItem will throw. So have to check in this
         * somewhat roundabout way. (If unsupported or no global object,
         * will throw on accessing a property of undefined) */
        try {
            global.sessionStorage.setItem(test, test);
            global.sessionStorage.removeItem(test);
            this.sessionSupported = true;
        }
        catch (e) {
            this.sessionSupported = false;
        }
        try {
            global.localStorage.setItem(test, test);
            global.localStorage.removeItem(test);
            this.localSupported = true;
        }
        catch (e) {
            this.localSupported = false;
        }
    }
    Webstorage.prototype.get = function (name) {
        return this._get(name, false);
    };
    Webstorage.prototype.getSession = function (name) {
        return this._get(name, true);
    };
    Webstorage.prototype.remove = function (name) {
        return this._remove(name, false);
    };
    Webstorage.prototype.removeSession = function (name) {
        return this._remove(name, true);
    };
    Webstorage.prototype.set = function (name, value, ttl) {
        return this._set(name, value, ttl, false);
    };
    Webstorage.prototype.setSession = function (name, value, ttl) {
        return this._set(name, value, ttl, true);
    };
    Webstorage.prototype._set = function (name, value, ttl, session) {
        var wrappedValue = { value: value };
        if (ttl) {
            wrappedValue.expires = Utils.now() + ttl;
        }
        return this.storageInterface(session).setItem(name, JSON.stringify(wrappedValue));
    };
    Webstorage.prototype._get = function (name, session) {
        if (session && !this.sessionSupported)
            throw new Error('Session Storage not supported');
        if (!session && !this.localSupported)
            throw new Error('Local Storage not supported');
        var rawItem = this.storageInterface(session).getItem(name);
        if (!rawItem)
            return null;
        var wrappedValue = JSON.parse(rawItem);
        if (wrappedValue.expires && wrappedValue.expires < Utils.now()) {
            this.storageInterface(session).removeItem(name);
            return null;
        }
        return wrappedValue.value;
    };
    Webstorage.prototype._remove = function (name, session) {
        return this.storageInterface(session).removeItem(name);
    };
    Webstorage.prototype.storageInterface = function (session) {
        return session ? global.sessionStorage : global.localStorage;
    };
    return Webstorage;
}());
exports.default = new Webstorage();

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_611284__(13)))

/***/ }),
/* 66 */
/***/ (function(module, exports, __nested_webpack_require_614538__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_614538__(0);
var TransportNames_1 = tslib_1.__importDefault(__nested_webpack_require_614538__(67));
var Defaults = {
    connectivityCheckUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up.txt',
    jsonpInternetUpUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up-0-9.js',
    /* Order matters here: the base transport is the leftmost one in the
     * intersection of baseTransportOrder and the transports clientOption that's
     * supported.  This is not quite the same as the preference order -- e.g.
     * xhr_polling is preferred to jsonp, but for browsers that support it we want
     * the base transport to be xhr_polling, not jsonp */
    defaultTransports: [
        TransportNames_1.default.XhrPolling,
        TransportNames_1.default.XhrStreaming,
        TransportNames_1.default.JsonP,
        TransportNames_1.default.WebSocket,
    ],
    baseTransportOrder: [
        TransportNames_1.default.XhrPolling,
        TransportNames_1.default.XhrStreaming,
        TransportNames_1.default.JsonP,
        TransportNames_1.default.WebSocket,
    ],
    transportPreferenceOrder: [
        TransportNames_1.default.JsonP,
        TransportNames_1.default.XhrPolling,
        TransportNames_1.default.XhrStreaming,
        TransportNames_1.default.WebSocket,
    ],
    upgradeTransports: [TransportNames_1.default.XhrStreaming, TransportNames_1.default.WebSocket],
};
exports.default = Defaults;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var TransportNames;
(function (TransportNames) {
    TransportNames["WebSocket"] = "web_socket";
    TransportNames["Comet"] = "comet";
    TransportNames["XhrStreaming"] = "xhr_streaming";
    TransportNames["XhrPolling"] = "xhr_polling";
    TransportNames["JsonP"] = "jsonp";
})(TransportNames || (TransportNames = {}));
exports.default = TransportNames;


/***/ }),
/* 68 */
/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_616665__) {

"use strict";
// ESM COMPAT FLAG
__nested_webpack_require_616665__.r(__nested_webpack_exports__);

// EXTERNAL MODULE: ./src/platform/web/lib/transport/jsonptransport.ts
var jsonptransport = __nested_webpack_require_616665__(29);
var jsonptransport_default = /*#__PURE__*/__nested_webpack_require_616665__.n(jsonptransport);

// EXTERNAL MODULE: ./src/common/lib/util/utils.ts
var utils = __nested_webpack_require_616665__(1);

// EXTERNAL MODULE: ./src/common/platform.ts
var platform = __nested_webpack_require_616665__(3);
var platform_default = /*#__PURE__*/__nested_webpack_require_616665__.n(platform);

// EXTERNAL MODULE: ./src/common/lib/transport/comettransport.ts
var comettransport = __nested_webpack_require_616665__(12);
var comettransport_default = /*#__PURE__*/__nested_webpack_require_616665__.n(comettransport);

// EXTERNAL MODULE: ./src/platform/web/lib/transport/xhrrequest.ts
var xhrrequest = __nested_webpack_require_616665__(16);
var xhrrequest_default = /*#__PURE__*/__nested_webpack_require_616665__.n(xhrrequest);

// CONCATENATED MODULE: ./src/platform/web/lib/transport/xhrpollingtransport.js





var xhrpollingtransport_XHRPollingTransport = function (connectionManager) {
  var shortName = 'xhr_polling';

  function XHRPollingTransport(connectionManager, auth, params) {
    params.stream = false;
    comettransport_default.a.call(this, connectionManager, auth, params);
    this.shortName = shortName;
  }
  utils["inherits"](XHRPollingTransport, comettransport_default.a);

  XHRPollingTransport.isAvailable = function () {
    return platform_default.a.Config.xhrSupported && platform_default.a.Config.allowComet;
  };

  XHRPollingTransport.prototype.toString = function () {
    return 'XHRPollingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
  };

  XHRPollingTransport.prototype.createRequest = function (uri, headers, params, body, requestMode) {
    return xhrrequest_default.a.createRequest(uri, headers, params, body, requestMode, this.timeouts);
  };

  if (typeof connectionManager !== 'undefined' && XHRPollingTransport.isAvailable()) {
    connectionManager.supportedTransports[shortName] = XHRPollingTransport;
  }

  return XHRPollingTransport;
};

/* harmony default export */ var xhrpollingtransport = (xhrpollingtransport_XHRPollingTransport);

// CONCATENATED MODULE: ./src/platform/web/lib/transport/xhrstreamingtransport.js





var xhrstreamingtransport_XHRStreamingTransport = function (connectionManager) {
  var shortName = 'xhr_streaming';

  /* public constructor */
  function XHRStreamingTransport(connectionManager, auth, params) {
    comettransport_default.a.call(this, connectionManager, auth, params);
    this.shortName = shortName;
  }
  utils["inherits"](XHRStreamingTransport, comettransport_default.a);

  XHRStreamingTransport.isAvailable = function () {
    return platform_default.a.Config.xhrSupported && platform_default.a.Config.streamingSupported && platform_default.a.Config.allowComet;
  };

  XHRStreamingTransport.prototype.toString = function () {
    return 'XHRStreamingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
  };

  XHRStreamingTransport.prototype.createRequest = function (uri, headers, params, body, requestMode) {
    return xhrrequest_default.a.createRequest(uri, headers, params, body, requestMode, this.timeouts);
  };

  if (typeof connectionManager !== 'undefined' && XHRStreamingTransport.isAvailable()) {
    connectionManager.supportedTransports[shortName] = XHRStreamingTransport;
  }

  return XHRStreamingTransport;
};

/* harmony default export */ var xhrstreamingtransport = (xhrstreamingtransport_XHRStreamingTransport);

// CONCATENATED MODULE: ./src/platform/web/lib/transport/index.js




/* harmony default export */ var transport = __nested_webpack_exports__["default"] = ([jsonptransport_default.a, xhrpollingtransport, xhrstreamingtransport]);


/***/ })
/******/ ])["default"];
});

/***/ }),

/***/ "./node_modules/ably/promises.js":
/*!***************************************!*\
  !*** ./node_modules/ably/promises.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

function promisifyOptions(options) {
  if (typeof options == 'string') {
    options = options.indexOf(':') == -1 ? { token: options } : { key: options };
  }
  options.promises = true;
  return options;
}

/* Please note that the file imported below is only generated after running
 * the build task. */
// eslint-disable-next-line @typescript-eslint/no-var-requires
var Ably = __webpack_require__(/*! ./build/ably-node */ "./node_modules/ably/build/ably-commonjs.js");

var RestPromise = function (options) {
  return new Ably.Rest(promisifyOptions(options));
};
Object.assign(RestPromise, Ably.Rest);

var RealtimePromise = function (options) {
  return new Ably.Realtime(promisifyOptions(options));
};
Object.assign(RealtimePromise, Ably.Realtime);

module.exports = {
  Rest: RestPromise,
  Realtime: RealtimePromise,
};


/***/ }),

/***/ "./src/server.js":
/*!***********************!*\
  !*** ./src/server.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   server: () => (/* binding */ server)
/* harmony export */ });
/* harmony import */ var ably_promises__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ably/promises */ "./node_modules/ably/promises.js");
/* harmony import */ var ably_promises__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ably_promises__WEBPACK_IMPORTED_MODULE_0__);


const API_KEY = "Z9oq-w.SeC0sA:RWchQVoe5OW6HCx_ogk-pRt_g2qoBkzE3huhxdsSI_A";

const messages = {
  move: "move",
  message: "message",
};

class Server {
  async init() {
    this.server = await this.connect();
    await this.createChannel("game");
  }

  async connect() {
    // For the full code sample see here: https://github.com/ably/quickstart-js
    const server = new (ably_promises__WEBPACK_IMPORTED_MODULE_0___default().Realtime).Promise(API_KEY);

    await server.connection.once("connected");
    console.log("Connected to Ably!");

    window.addEventListener("beforeunload", () => ably_promises__WEBPACK_IMPORTED_MODULE_0___default().close());

    return server;
  }

  async createChannel(channelName) {
    this.channel = this.server.channels.get(channelName);

    await this.channel.subscribe(messages.move, (message) =>
      this.onServerMessage(message)
    );
  }

  async makeMove(data) {
    await this.channel.publish(messages.move, JSON.stringify(data));
  }
}

const server = new Server();


/***/ }),

/***/ "./src/view.js":
/*!*********************!*\
  !*** ./src/view.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   View: () => (/* binding */ View),
/* harmony export */   view: () => (/* binding */ view)
/* harmony export */ });
class View {
  allCellsFull = 0;
  cells = [];


  constructor() {
    this.parent = document.getElementById("parent");

    const ticTacToeDiv = this.createDiv("tictactoeDiv");
    this.parent.appendChild(ticTacToeDiv);

    this.buttonTopic = this.createButton("buttonTopic");
    ticTacToeDiv.appendChild(this.buttonTopic);

    const playerDiv = this.createDiv("playerDiv");
    ticTacToeDiv.appendChild(playerDiv);

    this.player = this.createDiv("player");
    this.player.innerHTML = "X Turn";
    playerDiv.appendChild(this.player);

    this.comments = this.createDiv("playerP");
    playerDiv.appendChild(this.comments);

    const cellDiv = this.createDiv("cellDiv");
    ticTacToeDiv.appendChild(cellDiv);

    this.createCells(cellDiv);

    // this.buttonPlayAgain = this.createButton("button");
    // ticTacToeDiv.appendChild(this.buttonPlayAgain);
  }

  createDiv(className) {
    const div = document.createElement("div");
    div.classList.add(className);

    return div;
  }

  createCells(cellsDiv) {
    for (let cellNum = 0; cellNum < 9; cellNum++) {
      const cell = this.createButton("cell full");

      cell.onclick = () => this.onCellPress(cell);

      cellsDiv.appendChild(cell);

      this.cells.push(cell);
    }
  }

  createButton(className, onclick) {
    const button = document.createElement("button");
    button.className = className;

    return button;
  }

  setStyle(style) {
    if (style === "dark") {
      this.parent.classList.add("dark");
    } else if (style === "light") {
      this.parent.classList.remove("dark");
    }
  }

  updateCell(cell, step) {
    if (step === "x") {
      cell.classList.add("x", "empty", "stepX");
      cell.classList.remove("full");
      this.player.innerHTML = "O Turn";
    } else if (step === "o") {
      cell.classList.add("o", "empty", "stepO");
      cell.classList.remove("cellWait", "full");

      this.player.innerHTML = "X Turn";
    }
  }

  setWin(winSymbol) {
    if (winSymbol === "x") {
      this.player.innerHTML = `X Won!`;
      this.parent.classList.add("win");
      this.comments.innerHTML = "Next turn O";
    }

    if (winSymbol === "o") {
      this.player.innerHTML = "O Won!";
      this.parent.classList.add("win");
      this.comments.innerHTML = "Next turn X";
    }
  }

  setDraw(nextTurn) {
    this.player.innerHTML = "Draw!";
    this.parent.classList.add("draw");

    if (nextTurn === "x") {
      this.comments.innerHTML = "Next turn X";
    } else if (nextTurn === "o") {
      this.comments.innerHTML = "Next turn O";
    }
  }

  clearCells(nextTurn) {
    for (const cell of this.cells) {
      cell.classList.add("full");
      cell.classList.remove("o", "x", "stepX", "stepO", "empty");
    }

    if (nextTurn === "x") {
      this.player.innerHTML = "X Turn";
    } else if (nextTurn === "o") {
      this.player.innerHTML = "O Turn";
    }

    this.parent.classList.remove("win", "draw");
    this.comments.innerHTML = "";

    console.log("clear");
  }
}

const view = new View();


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!***************************!*\
  !*** ./src/controller.js ***!
  \***************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   controller: () => (/* binding */ controller)
/* harmony export */ });
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./server */ "./src/server.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view */ "./src/view.js");



class Controller {
    style = localStorage.getItem("style") ?? "light";
    step = "x";
    cellsData = ["empty", "empty", "empty", "empty", "empty", "empty", "empty", "empty", "empty"];
    cells = _view__WEBPACK_IMPORTED_MODULE_1__.view.cells;

    constructor() {
        _server__WEBPACK_IMPORTED_MODULE_0__.server.init();

        _server__WEBPACK_IMPORTED_MODULE_0__.server.onServerMessage = (message) => this.onServerMessage(message);

        _view__WEBPACK_IMPORTED_MODULE_1__.view.setStyle(this.style);

        _view__WEBPACK_IMPORTED_MODULE_1__.view.buttonTopic.onclick = () => {
            if (this.style === "light") {
                _view__WEBPACK_IMPORTED_MODULE_1__.view.setStyle("dark");
                this.style = "dark";
            } else {
                _view__WEBPACK_IMPORTED_MODULE_1__.view.setStyle("light");
                this.style = "light";
            }
            // view.setStyle(this.style === "light" ? "dark" : "light");
            localStorage.setItem("style", this.style);
        };

        // view.buttonPlayAgain.onclick = () => this.resetGame();

        _view__WEBPACK_IMPORTED_MODULE_1__.view.onCellPress = (cell) => this.onCellPress(cell);
    }

    resetGame() {
        this.cellsData.fill("empty");
        _view__WEBPACK_IMPORTED_MODULE_1__.view.clearCells(this.step);
    }

    onServerMessage(message) {
        const data = JSON.parse(message.data);

        this.step = data.step;
        this.cell = this.cells[data.cell];

        if (this.step === "x" && this.cellsData[data.cell] === "empty") {
            _view__WEBPACK_IMPORTED_MODULE_1__.view.updateCell(this.cells[data.cell], this.step);

            this.cellsData[data.cell] = "x";

            this.step = "o";
        } else if (this.step === "o" && this.cellsData[data.cell] === "empty") {
            _view__WEBPACK_IMPORTED_MODULE_1__.view.updateCell(this.cells[data.cell], this.step);

            this.cellsData[data.cell] = "o";

            this.step = "x";
        }

        this.checkDraw();
        this.checkWin();
    }

    onCellPress(cell) {
        _server__WEBPACK_IMPORTED_MODULE_0__.server.makeMove({
            cell: this.cells.indexOf(cell),
            step: this.step,
        });
    }

    checkWin() {
        if (this.checkWinningPositions("x")) {
            _view__WEBPACK_IMPORTED_MODULE_1__.view.setWin("x");

            this.cellsData.fill("full");
            console.log(this.step);
            
            setTimeout(() => this.resetGame(), 5000);

            console.log("win!!X");
        } else if (this.checkWinningPositions("o")) {
            _view__WEBPACK_IMPORTED_MODULE_1__.view.setWin("o");

            this.cellsData.fill("full");

            setTimeout(() => this.resetGame(), 5000);

            console.log("win!!O");
        }
    }

    checkWinningPositions(winningMark) {
        let winningPositions = [
            [0, 1, 2],
            [3, 4, 5],
            [6, 7, 8],
            [0, 3, 6],
            [1, 4, 7],
            [2, 5, 8],
            [0, 4, 8],
            [2, 4, 6],
        ];

        for (let i = 0; i < winningPositions.length; i++) {
            const [pos1, pos2, pos3] = winningPositions[i];

            if (
                this.cellsData[pos1] === winningMark &&
                this.cellsData[pos2] === winningMark &&
                this.cellsData[pos3] === winningMark
            ) {
                return true;
            }
        }

        return false;
    }

    checkDraw() {
        for (let i = 0; i < this.cellsData.length; i++) {
            if (this.cellsData[i] !== "x" && this.cellsData[i] !== "o") {
                return false;
            }
        }
        console.log("DRAW");

        _view__WEBPACK_IMPORTED_MODULE_1__.view.setDraw(this.step);

        setTimeout(() => this.resetGame(), 5000);
    }
}

const controller = new Controller();
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELG1CQUFtQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlEQUFpRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxxQ0FBcUM7QUFDNUYsbURBQW1ELHFDQUFxQztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLFlBQVksZ0NBQW1COztBQUUzRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRDtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQsY0FBYyxnQ0FBbUI7QUFDakMseUNBQXlDLGdDQUFtQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLDRCQUE0QixZQUFZLGdDQUFtQjs7QUFFM0QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsK0NBQStDLGFBQWE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBEOztBQUVBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0EsY0FBYyxnQ0FBbUI7QUFDakMseUNBQXlDLGdDQUFtQjtBQUM1RCxpQ0FBaUMsZ0NBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBELENBQUM7QUFDRCxLQUFLLElBQUk7QUFDVDtBQUNBLHFDQUFxQyxnQ0FBbUI7QUFDeEQ7QUFDQSxNQUFNLEVBQUU7QUFDUixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QiwwQkFBMEI7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRCwrQ0FBK0M7QUFDL0MsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBTSxFQUFFO0FBQ1IsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQW1CO0FBQ3pDLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLFlBQVk7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQztBQUNELDRCQUE0QixZQUFZLGdDQUFtQjs7QUFFM0QsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQ7O0FBRUEsK0NBQStDLGFBQWE7QUFDNUQsY0FBYyxnQ0FBbUI7QUFDakMsaUNBQWlDLGdDQUFtQjtBQUNwRCx1Q0FBdUMsZ0NBQW1CO0FBQzFELHlDQUF5QyxnQ0FBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUlBQWlJO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywrQ0FBK0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix5Q0FBeUMsdUNBQXVDO0FBQ2hGLDBDQUEwQztBQUMxQztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBEOztBQUVBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0EsY0FBYyxnQ0FBbUI7QUFDakMseUNBQXlDLGdDQUFtQjtBQUM1RCxpQ0FBaUMsZ0NBQW1CO0FBQ3BELHVDQUF1QyxnQ0FBbUI7QUFDMUQsMENBQTBDLGdDQUFtQjtBQUM3RCxxQkFBcUIsZ0NBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsaUJBQWlCLElBQUk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYyxLQUFLLCtDQUErQyxZQUFZO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGdCQUFnQixpREFBaUQ7QUFDL0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQSwyUkFBMlI7QUFDM1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBEOztBQUVBLCtDQUErQyxhQUFhO0FBQzVELGNBQWMsZ0NBQW1CO0FBQ2pDLHlDQUF5QyxnQ0FBbUI7QUFDNUQsdUNBQXVDLGdDQUFtQjtBQUMxRCwwQ0FBMEMsZ0NBQW1CO0FBQzdELGlDQUFpQyxnQ0FBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFh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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLDRCQUE0QixZQUFZLGlDQUFtQjs7QUFFM0QsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7O0FBRUEsK0NBQStDLGFBQWE7QUFDNUQsY0FBYyxpQ0FBbUI7QUFDakMsdUNBQXVDLGlDQUFtQjtBQUMxRCxpQ0FBaUMsaUNBQW1CO0FBQ3BELDRDQUE0QyxpQ0FBbUI7QUFDL0QsMENBQTBDLGlDQUFtQjtBQUM3RCw0Q0FBNEMsaUNBQW1CO0FBQy9ELG1CQUFtQixpQ0FBbUI7QUFDdEMsNENBQTRDLGlDQUFtQjtBQUMvRCxnREFBZ0QsaUNBQW1CO0FBQ25FLHlDQUF5QyxpQ0FBbUI7QUFDNUQseUNBQXlDLGlDQUFtQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SCxhQUFhO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCLDZGQUE2RjtBQUNuSCxzQkFBc0IsNkZBQTZGO0FBQ25I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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSTtBQUNwSTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrTEFBa0w7QUFDbEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlMQUFpTDtBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNEQUFzRDtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJKQUEySjtBQUMzSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MscUJBQXFCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw4QkFBOEI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNIQUFzSDtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGdCQUFnQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGdCQUFnQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDRDQUE0QztBQUNyRztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsNkRBQTZELDJEQUEyRDtBQUN4SCxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLHNDQUFzQztBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLGlEQUFpRCwrQ0FBK0M7QUFDaEcsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLG9DQUFvQztBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwwQ0FBMEM7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esa0hBQWtIO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSEFBbUg7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SDtBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7O0FBRUEsK0NBQStDLGFBQWE7QUFDNUQsY0FBYyxpQ0FBbUI7QUFDakM7QUFDQSxxQ0FBcUMsaUNBQW1CO0FBQ3hELHlDQUF5QyxpQ0FBbUI7QUFDNUQseUNBQXlDLGlDQUFtQjtBQUM1RDtBQUNBLDRDQUE0QyxpQ0FBbUI7QUFDL0Q7QUFDQSx1Q0FBdUMsaUNBQW1CO0FBQzFELHFDQUFxQyxpQ0FBbUI7QUFDeEQsdUNBQXVDLGlDQUFtQjtBQUMxRDtBQUNBLDBDQUEwQyxpQ0FBbUI7QUFDN0QsdUNBQXVDLGlDQUFtQjtBQUMxRCxpQkFBaUIsaUNBQW1CO0FBQ3BDLDJDQUEyQyxpQ0FBbUI7QUFDOUQseUNBQXlDLGlDQUFtQjtBQUM1RCx3Q0FBd0MsaUNBQW1CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOEJBQThCLG1LQUFtSyxrRkFBa0YsaUZBQWlGLHlEQUF5RCxjQUFjLHNEQUFzRCxpSkFBaUosb0VBQW9FLHNCQUFzQixrd0NBQWt3QyxjQUFjLHNCQUFzQiwyQ0FBMkMsc0NBQXNDLGtCQUFrQixtQkFBbUIsY0FBYyx3MENBQXcwQzs7QUFFOTdHLE9BQU87QUFDUDtBQUNBOzs7O0FBSUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQsQ0FBQztBQUNELEtBQUssSUFBSTtBQUNUO0FBQ0EscUNBQXFDLGlDQUFtQixLQUFLLGlDQUFtQixNQUFNLGlDQUFtQjtBQUN6RztBQUNBLE1BQU0sRUFBRTtBQUNSLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7QUFFQSwrQ0FBK0MsYUFBYTtBQUM1RCxjQUFjLGlDQUFtQjtBQUNqQyxpQ0FBaUMsaUNBQW1CO0FBQ3BELDhDQUE4QyxpQ0FBbUI7QUFDakUseUNBQXlDLGlDQUFtQjtBQUM1RCxrREFBa0QsaUNBQW1CO0FBQ3JFLDBDQUEwQyxpQ0FBbUI7QUFDN0Qsd0RBQXdELGlDQUFtQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0JBQXNCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQSw0R0FBNEcsdUJBQXVCO0FBQ25JO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkc7QUFDN0c7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzTEFBc0w7QUFDdEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BELGdKQUFnSix1QkFBdUI7QUFDdks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRCxnSEFBZ0gsdUJBQXVCO0FBQ3ZJO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7QUFDcEQsaUhBQWlILHVCQUF1QjtBQUN4STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7QUFFQSwrQ0FBK0MsYUFBYTtBQUM1RCxjQUFjLGlDQUFtQjtBQUNqQyxpQ0FBaUMsaUNBQW1CO0FBQ3BELDBDQUEwQyxpQ0FBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOztBQUVBLCtDQUErQyxhQUFhO0FBQzVELGNBQWMsaUNBQW1CO0FBQ2pDLGlDQUFpQyxpQ0FBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7O0FBRUEsK0NBQStDLGFBQWE7QUFDNUQsY0FBYyxpQ0FBbUI7QUFDakMsaUNBQWlDLGlDQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7QUFFQSwrQ0FBK0MsYUFBYTtBQUM1RCxjQUFjLGlDQUFtQjtBQUNqQyxpQ0FBaUMsaUNBQW1CO0FBQ3BELHFDQUFxQyxpQ0FBbUI7QUFDeEQsNkNBQTZDLGlDQUFtQjtBQUNoRSx1Q0FBdUMsaUNBQW1CO0FBQzFELDJDQUEyQyxpQ0FBbUI7QUFDOUQsZ0RBQWdELGlDQUFtQjtBQUNuRSx5Q0FBeUMsaUNBQW1CO0FBQzVELDBDQUEwQyxpQ0FBbUI7QUFDN0QsZ0RBQWdELGlDQUFtQjtBQUNuRSxrREFBa0QsaUNBQW1CO0FBQ3JFLHlDQUF5QyxpQ0FBbUI7QUFDNUQsd0NBQXdDLGlDQUFtQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGdCQUFnQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxnQkFBZ0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOztBQUVBLCtDQUErQyxhQUFhO0FBQzVELGNBQWMsaUNBQW1CO0FBQ2pDLGlDQUFpQyxpQ0FBbUI7QUFDcEQsNkNBQTZDLGlDQUFtQjtBQUNoRSxrREFBa0QsaUNBQW1CO0FBQ3JFLHVDQUF1QyxpQ0FBbUI7QUFDMUQsc0RBQXNELGlDQUFtQjtBQUN6RSx5Q0FBeUMsaUNBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFCQUFxQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQkFBa0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7O0FBRUEsK0NBQStDLGFBQWE7QUFDNUQ7QUFDQSxjQUFjLGlDQUFtQjtBQUNqQyxnREFBZ0QsaUNBQW1CO0FBQ25FLGlDQUFpQyxpQ0FBbUI7QUFDcEQsNkNBQTZDLGlDQUFtQjtBQUNoRSx1Q0FBdUMsaUNBQW1CO0FBQzFELDZDQUE2QyxpQ0FBbUI7QUFDaEUsMENBQTBDLGlDQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBO0FBQ0E7QUFDQSw4R0FBOEcsdUJBQXVCO0FBQ3JJO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7O0FBRUEsK0NBQStDLGFBQWE7QUFDNUQsY0FBYyxpQ0FBbUI7QUFDakMseUNBQXlDLGlDQUFtQjtBQUM1RCxpQ0FBaUMsaUNBQW1CO0FBQ3BELDBDQUEwQyxpQ0FBbUI7QUFDN0QseUNBQXlDLGlDQUFtQjtBQUM1RCx1Q0FBdUMsaUNBQW1CO0FBQzFELGdEQUFnRCxpQ0FBbUI7QUFDbkUsMENBQTBDLGlDQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSEFBZ0gsOEJBQThCO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7O0FBRUEsK0NBQStDLGFBQWE7QUFDNUQsY0FBYyxpQ0FBbUI7QUFDakMsaUNBQWlDLGlDQUFtQjtBQUNwRCx5Q0FBeUMsaUNBQW1CO0FBQzVELDZDQUE2QyxpQ0FBbUI7QUFDaEUsdUNBQXVDLGlDQUFtQjtBQUMxRCxnREFBZ0QsaUNBQW1CO0FBQ25FLHVDQUF1QyxpQ0FBbUI7QUFDMUQsZ0RBQWdELGlDQUFtQjtBQUNuRSw0Q0FBNEMsaUNBQW1CO0FBQy9ELG1EQUFtRCxpQ0FBbUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGlEQUFpRDtBQUNsSDtBQUNBLG9FQUFvRSx1QkFBdUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QSxVQUFVOztBQUVWO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Es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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOzs7Ozs7O1VDNUhQO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUMsV0FBVztXQUM1QztXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7Ozs7Ozs7Ozs7Ozs7OztBQ05rQztBQUNKO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVDQUFJO0FBQ2hCO0FBQ0E7QUFDQSxRQUFRLDJDQUFNO0FBQ2Q7QUFDQSxRQUFRLDJDQUFNO0FBQ2Q7QUFDQSxRQUFRLHVDQUFJO0FBQ1o7QUFDQSxRQUFRLHVDQUFJO0FBQ1o7QUFDQSxnQkFBZ0IsdUNBQUk7QUFDcEI7QUFDQSxjQUFjO0FBQ2QsZ0JBQWdCLHVDQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVDQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVDQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1Q0FBSTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixZQUFZLHVDQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJDQUFNO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUNBQUk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsWUFBWSx1Q0FBSTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1Q0FBSTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RpY3R0YWMtdG9lLy4vbm9kZV9tb2R1bGVzL2FibHkvYnVpbGQvYWJseS1jb21tb25qcy5qcyIsIndlYnBhY2s6Ly90aWN0dGFjLXRvZS8uL25vZGVfbW9kdWxlcy9hYmx5L3Byb21pc2VzLmpzIiwid2VicGFjazovL3RpY3R0YWMtdG9lLy4vc3JjL3NlcnZlci5qcyIsIndlYnBhY2s6Ly90aWN0dGFjLXRvZS8uL3NyYy92aWV3LmpzIiwid2VicGFjazovL3RpY3R0YWMtdG9lL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3RpY3R0YWMtdG9lL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3RpY3R0YWMtdG9lL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly90aWN0dGFjLXRvZS93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3RpY3R0YWMtdG9lL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vdGljdHRhYy10b2UvLi9zcmMvY29udHJvbGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDE1LTIwMjIgQWJseSBSZWFsLXRpbWUgTHRkIChhYmx5LmNvbSlcbiAqIFxuICogQWJseSBKYXZhU2NyaXB0IExpYnJhcnkgdjEuMi40M1xuICogaHR0cHM6Ly9naXRodWIuY29tL2FibHkvYWJseS1qc1xuICogXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2VuY2UgdjIuMFxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJBYmx5XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkFibHlcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNDIpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2V4dGVuZHNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2V4dGVuZHM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fYXNzaWduXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19hc3NpZ247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fcmVzdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fcmVzdDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19kZWNvcmF0ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fZGVjb3JhdGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fcGFyYW1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX3BhcmFtOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX21ldGFkYXRhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19tZXRhZGF0YTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19hd2FpdGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19hd2FpdGVyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2dlbmVyYXRvclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fZ2VuZXJhdG9yOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2NyZWF0ZUJpbmRpbmdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2NyZWF0ZUJpbmRpbmc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXhwb3J0U3RhclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fZXhwb3J0U3RhcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX192YWx1ZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX3ZhbHVlczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19yZWFkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19yZWFkOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX3NwcmVhZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fc3ByZWFkOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX3NwcmVhZEFycmF5c1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fc3ByZWFkQXJyYXlzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX3NwcmVhZEFycmF5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19zcHJlYWRBcnJheTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19hd2FpdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fYXdhaXQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fYXN5bmNHZW5lcmF0b3JcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2FzeW5jR2VuZXJhdG9yOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2FzeW5jRGVsZWdhdG9yXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19hc3luY0RlbGVnYXRvcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19hc3luY1ZhbHVlc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fYXN5bmNWYWx1ZXM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fbWFrZVRlbXBsYXRlT2JqZWN0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19tYWtlVGVtcGxhdGVPYmplY3Q7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9faW1wb3J0U3RhclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9faW1wb3J0U3RhcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19pbXBvcnREZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19pbXBvcnREZWZhdWx0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19jbGFzc1ByaXZhdGVGaWVsZFNldFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRTZXQ7IH0pO1xuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5mdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxufVxyXG5cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hbGxUb1VwcGVyQ2FzZSA9IGV4cG9ydHMuYWxsVG9Mb3dlckNhc2UgPSBleHBvcnRzLmVuY29kZUJvZHkgPSBleHBvcnRzLmRlY29kZUJvZHkgPSBleHBvcnRzLkZvcm1hdCA9IGV4cG9ydHMucHJvbWlzaWZ5ID0gZXhwb3J0cy50cmltID0gZXhwb3J0cy5hcnJDaG9vc2VOID0gZXhwb3J0cy5yYW5kb21IZXhTdHJpbmcgPSBleHBvcnRzLnJhbmRvbVN0cmluZyA9IGV4cG9ydHMuY2hlYXBSYW5kU3RyID0gZXhwb3J0cy5kYXRhU2l6ZUJ5dGVzID0gZXhwb3J0cy5pbnNwZWN0Qm9keSA9IGV4cG9ydHMuaW5zcGVjdEVycm9yID0gZXhwb3J0cy5pc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbyA9IGV4cG9ydHMubm93ID0gZXhwb3J0cy5wYXJzZVF1ZXJ5U3RyaW5nID0gZXhwb3J0cy50b1F1ZXJ5U3RyaW5nID0gZXhwb3J0cy5hcnJQb3BSYW5kb21FbGVtZW50ID0gZXhwb3J0cy5kZWZhdWx0UG9zdEhlYWRlcnMgPSBleHBvcnRzLmRlZmF1bHRHZXRIZWFkZXJzID0gZXhwb3J0cy5hbGxTYW1lID0gZXhwb3J0cy5hcnJFdmVyeSA9IGV4cG9ydHMuYXJyRmlsdGVyID0gZXhwb3J0cy5hcnJNYXAgPSBleHBvcnRzLnNhZmVBcnJGb3JFYWNoID0gZXhwb3J0cy5hcnJGb3JFYWNoID0gZXhwb3J0cy5mb3JJbk93bk5vbk51bGxQcm9wZXJ0aWVzID0gZXhwb3J0cy52YWx1ZXNBcnJheSA9IGV4cG9ydHMua2V5c0FycmF5ID0gZXhwb3J0cy5hcnJXaXRob3V0VmFsdWUgPSBleHBvcnRzLmFyckRlbGV0ZVZhbHVlID0gZXhwb3J0cy5hcnJJbiA9IGV4cG9ydHMuYXJySW5kZXhPZiA9IGV4cG9ydHMuYXJyU3VidHJhY3QgPSBleHBvcnRzLmFyckludGVyc2VjdE9iID0gZXhwb3J0cy5hcnJJbnRlcnNlY3QgPSBleHBvcnRzLmludGVyc2VjdCA9IGV4cG9ydHMuY29udGFpbnNWYWx1ZSA9IGV4cG9ydHMuaW5oZXJpdHMgPSBleHBvcnRzLnByb3RvdHlwaWNhbENsb25lID0gZXhwb3J0cy5zaGFsbG93Q2xvbmUgPSBleHBvcnRzLmlzRW1wdHlBcmcgPSBleHBvcnRzLmlzT25seVByb3BJbiA9IGV4cG9ydHMuaXNFbXB0eSA9IGV4cG9ydHMuaXNPYmplY3QgPSBleHBvcnRzLmVuc3VyZUFycmF5ID0gZXhwb3J0cy5pc0FycmF5ID0gZXhwb3J0cy5jb3B5ID0gZXhwb3J0cy5taXhpbiA9IHZvaWQgMDtcbmV4cG9ydHMudG9CYXNlNjQgPSBleHBvcnRzLm1hdGNoRGVyaXZlZENoYW5uZWwgPSBleHBvcnRzLnNoYWxsb3dFcXVhbHMgPSBleHBvcnRzLmdldEdsb2JhbE9iamVjdCA9IGV4cG9ydHMuZ2V0UmV0cnlUaW1lID0gZXhwb3J0cy5nZXRKaXR0ZXJDb2VmZmljaWVudCA9IGV4cG9ydHMuZ2V0QmFja29mZkNvZWZmaWNpZW50ID0gdm9pZCAwO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciBkZWZhdWx0c18xID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg4KSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBlbmNfYmFzZTY0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbnZhciBlbmNfdXRmOF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG5mdW5jdGlvbiByYW5kb21Qb3NuKGFyck9yU3RyKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFyck9yU3RyLmxlbmd0aCk7XG59XG4vKlxuICogQWRkIGEgc2V0IG9mIHByb3BlcnRpZXMgdG8gYSB0YXJnZXQgb2JqZWN0XG4gKiB0YXJnZXQ6IHRoZSB0YXJnZXQgb2JqZWN0XG4gKiBwcm9wczogIGFuIG9iamVjdCB3aG9zZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlXG4gKiAgICAgICAgIGFkZGVkLCBieSByZWZlcmVuY2Ugb25seVxuICovXG5mdW5jdGlvbiBtaXhpbih0YXJnZXQpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJnc1tpXTtcbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkgfHwgaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5leHBvcnRzLm1peGluID0gbWl4aW47XG4vKlxuICogQWRkIGEgc2V0IG9mIHByb3BlcnRpZXMgdG8gYSB0YXJnZXQgb2JqZWN0XG4gKiB0YXJnZXQ6IHRoZSB0YXJnZXQgb2JqZWN0XG4gKiBwcm9wczogIGFuIG9iamVjdCB3aG9zZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlXG4gKiAgICAgICAgIGFkZGVkLCBieSByZWZlcmVuY2Ugb25seVxuICovXG5mdW5jdGlvbiBjb3B5KHNyYykge1xuICAgIHJldHVybiBtaXhpbih7fSwgc3JjKTtcbn1cbmV4cG9ydHMuY29weSA9IGNvcHk7XG4vKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGEgZ2l2ZW4gb2JqZWN0IGlzXG4gKiBhbiBhcnJheS5cbiAqL1xuZXhwb3J0cy5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fFxuICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG4vKlxuICogRW5zdXJlcyB0aGF0IGFuIEFycmF5IG9iamVjdCBpcyBhbHdheXMgcmV0dXJuZWRcbiAqIHJldHVybmluZyB0aGUgb3JpZ2luYWwgQXJyYXkgb2Ygb2JqIGlzIGFuIEFycmF5XG4gKiBlbHNlIHdyYXBwaW5nIHRoZSBvYmogaW4gYSBzaW5nbGUgZWxlbWVudCBBcnJheVxuICovXG5mdW5jdGlvbiBlbnN1cmVBcnJheShvYmopIHtcbiAgICBpZiAoaXNFbXB0eUFyZyhvYmopKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKCgwLCBleHBvcnRzLmlzQXJyYXkpKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgcmV0dXJuIFtvYmpdO1xufVxuZXhwb3J0cy5lbnN1cmVBcnJheSA9IGVuc3VyZUFycmF5O1xuZnVuY3Rpb24gaXNPYmplY3Qob2IpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iKSA9PSAnW29iamVjdCBPYmplY3RdJztcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbi8qXG4gKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGNvbnRhaW5zXG4gKiBhbnkgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICogb2I6IHRoZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eShvYikge1xuICAgIGZvciAodmFyIHByb3AgaW4gb2IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuaXNFbXB0eSA9IGlzRW1wdHk7XG5mdW5jdGlvbiBpc09ubHlQcm9wSW4ob2IsIHByb3BlcnR5KSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYikge1xuICAgICAgICBpZiAocHJvcCAhPT0gcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuaXNPbmx5UHJvcEluID0gaXNPbmx5UHJvcEluO1xuLypcbiAqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhbiBhcmd1bWVudCB0byBhbiBvdmVybG9hZGVkIGZ1bmN0aW9uIGlzXG4gKiB1bmRlZmluZWQgKG1pc3NpbmcpIG9yIG51bGwuXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgd2hlbiBjb25zdHJ1Y3RpbmcgZnVuY3Rpb25zIHN1Y2ggYXMgKFdlYklETCB0ZXJtaW5vbG9neSk6XG4gKiAgIG9mZihbVHJlYXRVbmRlZmluZWRBcz1OdWxsXSBET01TdHJpbmc/IGV2ZW50KVxuICogYXMgeW91IGNhbiB0aGVuIGNvbmZpcm0gdGhlIGFyZ3VtZW50IHVzaW5nOlxuICogICBVdGlscy5pc0VtcHR5QXJnKGV2ZW50KVxuICovXG5mdW5jdGlvbiBpc0VtcHR5QXJnKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGwgfHwgYXJnID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzRW1wdHlBcmcgPSBpc0VtcHR5QXJnO1xuLypcbiAqIFBlcmZvcm0gYSBzaW1wbGUgc2hhbGxvdyBjbG9uZSBvZiBhbiBvYmplY3QuXG4gKiBSZXN1bHQgaXMgYW4gb2JqZWN0IGlycmVzcGVjdGl2ZSBvZiB3aGV0aGVyXG4gKiB0aGUgaW5wdXQgaXMgYW4gb2JqZWN0IG9yIGFycmF5LiBBbGxcbiAqIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgY29waWVkLlxuICogb2I6IHRoZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0Nsb25lKG9iKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBPYmplY3QoKTtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iKVxuICAgICAgICByZXN1bHRbcHJvcF0gPSBvYltwcm9wXTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5zaGFsbG93Q2xvbmUgPSBzaGFsbG93Q2xvbmU7XG4vKlxuICogQ2xvbmUgYW4gb2JqZWN0IGJ5IGNyZWF0aW5nIGEgbmV3IG9iamVjdCB3aXRoIHRoZVxuICogZ2l2ZW4gb2JqZWN0IGFzIGl0cyBwcm90b3R5cGUuIE9wdGlvbmFsbHlcbiAqIGEgc2V0IG9mIGFkZGl0aW9uYWwgb3duIHByb3BlcnRpZXMgY2FuIGJlXG4gKiBzdXBwbGllZCB0byBiZSBhZGRlZCB0byB0aGUgbmV3bHkgY3JlYXRlZCBjbG9uZS5cbiAqIG9iOiAgICAgICAgICAgIHRoZSBvYmplY3QgdG8gYmUgY2xvbmVkXG4gKiBvd25Qcm9wZXJ0aWVzOiBvcHRpb25hbCBvYmplY3Qgd2l0aCBhZGRpdGlvbmFsXG4gKiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzIHRvIGFkZFxuICovXG5mdW5jdGlvbiBwcm90b3R5cGljYWxDbG9uZShvYiwgb3duUHJvcGVydGllcykge1xuICAgIHZhciBGID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBGKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGO1xuICAgIH0oKSk7XG4gICAgRi5wcm90b3R5cGUgPSBvYjtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEYoKTtcbiAgICBpZiAob3duUHJvcGVydGllcylcbiAgICAgICAgbWl4aW4ocmVzdWx0LCBvd25Qcm9wZXJ0aWVzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5wcm90b3R5cGljYWxDbG9uZSA9IHByb3RvdHlwaWNhbENsb25lO1xuLypcbiAqIERlY2xhcmUgYSBjb25zdHJ1Y3RvciB0byByZXByZXNlbnQgYSBzdWJjbGFzc1xuICogb2YgYW5vdGhlciBjb25zdHJ1Y3RvclxuICogSWYgcGxhdGZvcm0gaGFzIGEgYnVpbHQtaW4gdmVyc2lvbiB3ZSB1c2UgdGhhdCBmcm9tIFBsYXRmb3JtLCBlbHNlIHdlXG4gKiBkZWZpbmUgaGVyZSAoc28gY2FuIG1ha2UgdXNlIG9mIG90aGVyIFV0aWxzIGZucylcbiAqIFNlZSBub2RlLmpzIHV0aWwuaW5oZXJpdHNcbiAqL1xudmFyIGluaGVyaXRzID0gZnVuY3Rpb24gKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluaGVyaXRzKSB7XG4gICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICBjdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwaWNhbENsb25lKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IGN0b3IgfSk7XG59O1xuZXhwb3J0cy5pbmhlcml0cyA9IGluaGVyaXRzO1xuLypcbiAqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgaGFzIGFuIGVudW1lcmFibGVcbiAqIHByb3BlcnR5IHdob3NlIHZhbHVlIGVxdWFscyBhIGdpdmVuIHZhbHVlLlxuICogb2I6ICB0aGUgb2JqZWN0XG4gKiB2YWw6IHRoZSB2YWx1ZSB0byBmaW5kXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zVmFsdWUob2IsIHZhbCkge1xuICAgIGZvciAodmFyIGkgaW4gb2IpIHtcbiAgICAgICAgaWYgKG9iW2ldID09IHZhbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmNvbnRhaW5zVmFsdWUgPSBjb250YWluc1ZhbHVlO1xuZnVuY3Rpb24gaW50ZXJzZWN0KGFyciwgb2IpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuaXNBcnJheSkob2IpID8gYXJySW50ZXJzZWN0KGFyciwgb2IpIDogYXJySW50ZXJzZWN0T2IoYXJyLCBvYik7XG59XG5leHBvcnRzLmludGVyc2VjdCA9IGludGVyc2VjdDtcbmZ1bmN0aW9uIGFyckludGVyc2VjdChhcnIxLCBhcnIyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbWVtYmVyID0gYXJyMVtpXTtcbiAgICAgICAgaWYgKCgwLCBleHBvcnRzLmFyckluZGV4T2YpKGFycjIsIG1lbWJlcikgIT0gLTEpXG4gICAgICAgICAgICByZXN1bHQucHVzaChtZW1iZXIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5hcnJJbnRlcnNlY3QgPSBhcnJJbnRlcnNlY3Q7XG5mdW5jdGlvbiBhcnJJbnRlcnNlY3RPYihhcnIsIG9iKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBtZW1iZXIgPSBhcnJbaV07XG4gICAgICAgIGlmIChtZW1iZXIgaW4gb2IpXG4gICAgICAgICAgICByZXN1bHQucHVzaChtZW1iZXIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5hcnJJbnRlcnNlY3RPYiA9IGFyckludGVyc2VjdE9iO1xuZnVuY3Rpb24gYXJyU3VidHJhY3QoYXJyMSwgYXJyMikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycjEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBhcnIxW2ldO1xuICAgICAgICBpZiAoKDAsIGV4cG9ydHMuYXJySW5kZXhPZikoYXJyMiwgZWxlbWVudCkgPT0gLTEpXG4gICAgICAgICAgICByZXN1bHQucHVzaChlbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuYXJyU3VidHJhY3QgPSBhcnJTdWJ0cmFjdDtcbmV4cG9ydHMuYXJySW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mXG4gICAgPyBmdW5jdGlvbiAoYXJyLCBlbGVtLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFyci5pbmRleE9mKGVsZW0sIGZyb21JbmRleCk7XG4gICAgfVxuICAgIDogZnVuY3Rpb24gKGFyciwgZWxlbSwgZnJvbUluZGV4KSB7XG4gICAgICAgIGZyb21JbmRleCA9IGZyb21JbmRleCB8fCAwO1xuICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IGZyb21JbmRleCA8IGxlbjsgZnJvbUluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbZnJvbUluZGV4XSA9PT0gZWxlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5mdW5jdGlvbiBhcnJJbihhcnIsIHZhbCkge1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5hcnJJbmRleE9mKShhcnIsIHZhbCkgIT09IC0xO1xufVxuZXhwb3J0cy5hcnJJbiA9IGFyckluO1xuZnVuY3Rpb24gYXJyRGVsZXRlVmFsdWUoYXJyLCB2YWwpIHtcbiAgICB2YXIgaWR4ID0gKDAsIGV4cG9ydHMuYXJySW5kZXhPZikoYXJyLCB2YWwpO1xuICAgIHZhciByZXMgPSBpZHggIT0gLTE7XG4gICAgaWYgKHJlcylcbiAgICAgICAgYXJyLnNwbGljZShpZHgsIDEpO1xuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLmFyckRlbGV0ZVZhbHVlID0gYXJyRGVsZXRlVmFsdWU7XG5mdW5jdGlvbiBhcnJXaXRob3V0VmFsdWUoYXJyLCB2YWwpIHtcbiAgICB2YXIgbmV3QXJyID0gYXJyLnNsaWNlKCk7XG4gICAgYXJyRGVsZXRlVmFsdWUobmV3QXJyLCB2YWwpO1xuICAgIHJldHVybiBuZXdBcnI7XG59XG5leHBvcnRzLmFycldpdGhvdXRWYWx1ZSA9IGFycldpdGhvdXRWYWx1ZTtcbi8qXG4gKiBDb25zdHJ1Y3QgYW4gYXJyYXkgb2YgdGhlIGtleXMgb2YgdGhlIGVudW1lcmFibGVcbiAqIHByb3BlcnRpZXMgb2YgYSBnaXZlbiBvYmplY3QsIG9wdGlvbmFsbHkgbGltaXRlZFxuICogdG8gb25seSB0aGUgb3duIHByb3BlcnRpZXMuXG4gKiBvYjogICAgICB0aGUgb2JqZWN0XG4gKiBvd25Pbmx5OiBib29sZWFuLCBnZXQgb3duIHByb3BlcnRpZXMgb25seVxuICovXG5mdW5jdGlvbiBrZXlzQXJyYXkob2IsIG93bk9ubHkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYikge1xuICAgICAgICBpZiAob3duT25seSAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iLCBwcm9wKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICByZXN1bHQucHVzaChwcm9wKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMua2V5c0FycmF5ID0ga2V5c0FycmF5O1xuLypcbiAqIENvbnN0cnVjdCBhbiBhcnJheSBvZiB0aGUgdmFsdWVzIG9mIHRoZSBlbnVtZXJhYmxlXG4gKiBwcm9wZXJ0aWVzIG9mIGEgZ2l2ZW4gb2JqZWN0LCBvcHRpb25hbGx5IGxpbWl0ZWRcbiAqIHRvIG9ubHkgdGhlIG93biBwcm9wZXJ0aWVzLlxuICogb2I6ICAgICAgdGhlIG9iamVjdFxuICogb3duT25seTogYm9vbGVhbiwgZ2V0IG93biBwcm9wZXJ0aWVzIG9ubHlcbiAqL1xuZnVuY3Rpb24gdmFsdWVzQXJyYXkob2IsIG93bk9ubHkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYikge1xuICAgICAgICBpZiAob3duT25seSAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iLCBwcm9wKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICByZXN1bHQucHVzaChvYltwcm9wXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnZhbHVlc0FycmF5ID0gdmFsdWVzQXJyYXk7XG5mdW5jdGlvbiBmb3JJbk93bk5vbk51bGxQcm9wZXJ0aWVzKG9iLCBmbikge1xuICAgIGZvciAodmFyIHByb3AgaW4gb2IpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYiwgcHJvcCkgJiYgb2JbcHJvcF0pIHtcbiAgICAgICAgICAgIGZuKHByb3ApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5mb3JJbk93bk5vbk51bGxQcm9wZXJ0aWVzID0gZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllcztcbmV4cG9ydHMuYXJyRm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoXG4gICAgPyBmdW5jdGlvbiAoYXJyLCBmbikge1xuICAgICAgICBhcnIuZm9yRWFjaChmbik7XG4gICAgfVxuICAgIDogZnVuY3Rpb24gKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGZuKGFycltpXSwgaSwgYXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4vKiBVc2VmdWwgd2hlbiB0aGUgZnVuY3Rpb24gbWF5IG11dGF0ZSB0aGUgYXJyYXkgKi9cbmZ1bmN0aW9uIHNhZmVBcnJGb3JFYWNoKGFyciwgZm4pIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuYXJyRm9yRWFjaCkoYXJyLnNsaWNlKCksIGZuKTtcbn1cbmV4cG9ydHMuc2FmZUFyckZvckVhY2ggPSBzYWZlQXJyRm9yRWFjaDtcbmV4cG9ydHMuYXJyTWFwID0gQXJyYXkucHJvdG90eXBlLm1hcFxuICAgID8gZnVuY3Rpb24gKGFyciwgZm4pIHtcbiAgICAgICAgcmV0dXJuIGFyci5tYXAoZm4pO1xuICAgIH1cbiAgICA6IGZ1bmN0aW9uIChhcnIsIGZuKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZuKGFycltpXSwgaSwgYXJyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuZXhwb3J0cy5hcnJGaWx0ZXIgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyXG4gICAgPyBmdW5jdGlvbiAoYXJyLCBmbikge1xuICAgICAgICByZXR1cm4gYXJyLmZpbHRlcihmbik7XG4gICAgfVxuICAgIDogZnVuY3Rpb24gKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm4oYXJyW2ldKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuZXhwb3J0cy5hcnJFdmVyeSA9IEFycmF5LnByb3RvdHlwZS5ldmVyeVxuICAgID8gZnVuY3Rpb24gKGFyciwgZm4pIHtcbiAgICAgICAgcmV0dXJuIGFyci5ldmVyeShmbik7XG4gICAgfVxuICAgIDogZnVuY3Rpb24gKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZm4oYXJyW2ldLCBpLCBhcnIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5mdW5jdGlvbiBhbGxTYW1lKGFyciwgcHJvcCkge1xuICAgIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgZmlyc3QgPSBhcnJbMF1bcHJvcF07XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmFyckV2ZXJ5KShhcnIsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtW3Byb3BdID09PSBmaXJzdDtcbiAgICB9KTtcbn1cbmV4cG9ydHMuYWxsU2FtZSA9IGFsbFNhbWU7XG52YXIgY29udGVudFR5cGVzID0ge1xuICAgIGpzb246ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICBqc29ucDogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxuICAgIHhtbDogJ2FwcGxpY2F0aW9uL3htbCcsXG4gICAgaHRtbDogJ3RleHQvaHRtbCcsXG4gICAgbXNncGFjazogJ2FwcGxpY2F0aW9uL3gtbXNncGFjaycsXG59O1xuZnVuY3Rpb24gZGVmYXVsdEdldEhlYWRlcnMob3B0aW9ucywgZm9ybWF0KSB7XG4gICAgdmFyIGFjY2VwdCA9IGNvbnRlbnRUeXBlc1tmb3JtYXQgfHwgRm9ybWF0Lmpzb25dO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFjY2VwdDogYWNjZXB0LFxuICAgICAgICAnWC1BYmx5LVZlcnNpb24nOiBkZWZhdWx0c18xLmRlZmF1bHQucHJvdG9jb2xWZXJzaW9uLnRvU3RyaW5nKCksXG4gICAgICAgICdBYmx5LUFnZW50JzogKDAsIGRlZmF1bHRzXzEuZ2V0QWdlbnRTdHJpbmcpKG9wdGlvbnMpLFxuICAgIH07XG59XG5leHBvcnRzLmRlZmF1bHRHZXRIZWFkZXJzID0gZGVmYXVsdEdldEhlYWRlcnM7XG5mdW5jdGlvbiBkZWZhdWx0UG9zdEhlYWRlcnMob3B0aW9ucywgZm9ybWF0KSB7XG4gICAgdmFyIGNvbnRlbnRUeXBlO1xuICAgIHZhciBhY2NlcHQgPSAoY29udGVudFR5cGUgPSBjb250ZW50VHlwZXNbZm9ybWF0IHx8IEZvcm1hdC5qc29uXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWNjZXB0OiBhY2NlcHQsXG4gICAgICAgICdjb250ZW50LXR5cGUnOiBjb250ZW50VHlwZSxcbiAgICAgICAgJ1gtQWJseS1WZXJzaW9uJzogZGVmYXVsdHNfMS5kZWZhdWx0LnByb3RvY29sVmVyc2lvbi50b1N0cmluZygpLFxuICAgICAgICAnQWJseS1BZ2VudCc6ICgwLCBkZWZhdWx0c18xLmdldEFnZW50U3RyaW5nKShvcHRpb25zKSxcbiAgICB9O1xufVxuZXhwb3J0cy5kZWZhdWx0UG9zdEhlYWRlcnMgPSBkZWZhdWx0UG9zdEhlYWRlcnM7XG5mdW5jdGlvbiBhcnJQb3BSYW5kb21FbGVtZW50KGFycikge1xuICAgIHJldHVybiBhcnIuc3BsaWNlKHJhbmRvbVBvc24oYXJyKSwgMSlbMF07XG59XG5leHBvcnRzLmFyclBvcFJhbmRvbUVsZW1lbnQgPSBhcnJQb3BSYW5kb21FbGVtZW50O1xuZnVuY3Rpb24gdG9RdWVyeVN0cmluZyhwYXJhbXMpIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwYXJhbXMpXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtc1trZXldKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPyAnPycgKyBwYXJ0cy5qb2luKCcmJykgOiAnJztcbn1cbmV4cG9ydHMudG9RdWVyeVN0cmluZyA9IHRvUXVlcnlTdHJpbmc7XG5mdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nKHF1ZXJ5KSB7XG4gICAgdmFyIG1hdGNoO1xuICAgIHZhciBzZWFyY2ggPSAvKFtePyY9XSspPT8oW14mXSopL2c7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHdoaWxlICgobWF0Y2ggPSBzZWFyY2guZXhlYyhxdWVyeSkpKVxuICAgICAgICByZXN1bHRbZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzFdKV0gPSBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMl0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnBhcnNlUXVlcnlTdHJpbmcgPSBwYXJzZVF1ZXJ5U3RyaW5nO1xuZXhwb3J0cy5ub3cgPSBEYXRlLm5vdyB8fFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyogSUUgOCAqL1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcbmZ1bmN0aW9uIGlzRXJyb3JJbmZvT3JQYXJ0aWFsRXJyb3JJbmZvKGVycikge1xuICAgIHJldHVybiAodHlwZW9mIGVyciA9PSAnb2JqZWN0JyAmJlxuICAgICAgICBlcnIgIT09IG51bGwgJiZcbiAgICAgICAgKGVyci5jb25zdHJ1Y3Rvci5uYW1lID09ICdFcnJvckluZm8nIHx8IGVyci5jb25zdHJ1Y3Rvci5uYW1lID09ICdQYXJ0aWFsRXJyb3JJbmZvJykpO1xufVxuZXhwb3J0cy5pc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbyA9IGlzRXJyb3JJbmZvT3JQYXJ0aWFsRXJyb3JJbmZvO1xuZnVuY3Rpb24gaW5zcGVjdEVycm9yKGVycikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yIHx8XG4gICAgICAgICgoX2EgPSBlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSA9PT0gJ0Vycm9ySW5mbycgfHxcbiAgICAgICAgKChfYiA9IGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5hbWUpID09PSAnUGFydGlhbEVycm9ySW5mbycpXG4gICAgICAgIHJldHVybiBlcnIudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KGVycik7XG59XG5leHBvcnRzLmluc3BlY3RFcnJvciA9IGluc3BlY3RFcnJvcjtcbmZ1bmN0aW9uIGluc3BlY3RCb2R5KGJvZHkpIHtcbiAgICBpZiAocGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgICAgIHJldHVybiBib2R5LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYm9keTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QoYm9keSk7XG4gICAgfVxufVxuZXhwb3J0cy5pbnNwZWN0Qm9keSA9IGluc3BlY3RCb2R5O1xuLyogRGF0YSBpcyBhc3N1bWVkIHRvIGJlIGVpdGhlciBhIHN0cmluZyBvciBhIGJ1ZmZlci4gKi9cbmZ1bmN0aW9uIGRhdGFTaXplQnl0ZXMoZGF0YSkge1xuICAgIGlmIChwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLnN0cmluZ0J5dGVTaXplKGRhdGEpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGlucHV0IG9mIFV0aWxzLmRhdGFTaXplQnl0ZXMgdG8gYmUgYSBidWZmZXIgb3Igc3RyaW5nLCBidXQgd2FzOiAnICsgdHlwZW9mIGRhdGEpO1xufVxuZXhwb3J0cy5kYXRhU2l6ZUJ5dGVzID0gZGF0YVNpemVCeXRlcztcbmZ1bmN0aW9uIGNoZWFwUmFuZFN0cigpIHtcbiAgICByZXR1cm4gU3RyaW5nKE1hdGgucmFuZG9tKCkpLnN1YnN0cigyKTtcbn1cbmV4cG9ydHMuY2hlYXBSYW5kU3RyID0gY2hlYXBSYW5kU3RyO1xuLyogVGFrZXMgcGFyYW0gdGhlIG1pbmltdW0gbnVtYmVyIG9mIGJ5dGVzIG9mIGVudHJvcHkgdGhlIHN0cmluZyBtdXN0XG4gKiBpbmNsdWRlLCBub3QgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nLiBTdHJpbmcgbGVuZ3RoIHByb2R1Y2VkIGlzIG5vdFxuICogZ3VhcmFudGVlZC4gKi9cbnZhciByYW5kb21TdHJpbmcgPSBmdW5jdGlvbiAobnVtQnl0ZXMpIHtcbiAgICBpZiAocGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5nZXRSYW5kb21WYWx1ZXMgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciB1SW50QXJyID0gbmV3IFVpbnQ4QXJyYXkobnVtQnl0ZXMpO1xuICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmdldFJhbmRvbVZhbHVlcyh1SW50QXJyKTtcbiAgICAgICAgcmV0dXJuIHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUodUludEFycik7XG4gICAgfVxuICAgIC8qIE9sZCBicm93c2VyOyBmYWxsIGJhY2sgdG8gTWF0aC5yYW5kb20uIENvdWxkIGp1c3QgdXNlIGFcbiAgICAgKiBDcnlwdG9KUyB2ZXJzaW9uIG9mIHRoZSBhYm92ZSwgYnV0IHdhbnQgdGhpcyB0byBzdGlsbCB3b3JrIGluIG5vY3J5cHRvXG4gICAgICogdmVyc2lvbnMgb2YgdGhlIGxpYnJhcnkgKi9cbiAgICB2YXIgY2hhcnNldCA9IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5iYXNlNjRDaGFyU2V0O1xuICAgIC8qIGJhc2U2NCBoYXMgMzMlIG92ZXJoZWFkOyByb3VuZCBsZW5ndGggdXAgKi9cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5yb3VuZCgobnVtQnl0ZXMgKiA0KSAvIDMpO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCArPSBjaGFyc2V0W3JhbmRvbVBvc24oY2hhcnNldCldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMucmFuZG9tU3RyaW5nID0gcmFuZG9tU3RyaW5nO1xudmFyIHJhbmRvbUhleFN0cmluZyA9IGZ1bmN0aW9uIChudW1CeXRlcykge1xuICAgIGlmIChwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmdldFJhbmRvbVZhbHVlcyAmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIHVJbnRBcnIgPSBuZXcgVWludDhBcnJheShudW1CeXRlcyk7XG4gICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuZ2V0UmFuZG9tVmFsdWVzKHVJbnRBcnIpO1xuICAgICAgICByZXR1cm4gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmhleEVuY29kZSh1SW50QXJyKTtcbiAgICB9XG4gICAgdmFyIGNoYXJzZXQgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuaGV4Q2hhclNldDtcbiAgICB2YXIgbGVuZ3RoID0gbnVtQnl0ZXMgKiAyO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCArPSBjaGFyc2V0W3JhbmRvbVBvc24oY2hhcnNldCldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMucmFuZG9tSGV4U3RyaW5nID0gcmFuZG9tSGV4U3RyaW5nO1xuLyogUGljayBuIGVsZW1lbnRzIGF0IHJhbmRvbSB3aXRob3V0IHJlcGxhY2VtZW50IGZyb20gYW4gYXJyYXkgKi9cbmZ1bmN0aW9uIGFyckNob29zZU4oYXJyLCBuKSB7XG4gICAgdmFyIG51bUl0ZW1zID0gTWF0aC5taW4obiwgYXJyLmxlbmd0aCksIG11dGFibGVBcnIgPSBhcnIuc2xpY2UoKSwgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1JdGVtczsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGFyclBvcFJhbmRvbUVsZW1lbnQobXV0YWJsZUFycikpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5hcnJDaG9vc2VOID0gYXJyQ2hvb3NlTjtcbmV4cG9ydHMudHJpbSA9IFN0cmluZy5wcm90b3R5cGUudHJpbVxuICAgID8gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnRyaW0oKTtcbiAgICB9XG4gICAgOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcbiAgICB9O1xuZnVuY3Rpb24gcHJvbWlzaWZ5KG9iLCBmbk5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBvYltmbk5hbWVdLmFwcGx5KG9iLCB0c2xpYl8xLl9fc3ByZWFkQXJyYXkodHNsaWJfMS5fX3NwcmVhZEFycmF5KFtdLCBhcmdzLCBmYWxzZSksIFtmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgICBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgIH1dLCBmYWxzZSkpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5wcm9taXNpZnkgPSBwcm9taXNpZnk7XG52YXIgRm9ybWF0O1xuKGZ1bmN0aW9uIChGb3JtYXQpIHtcbiAgICBGb3JtYXRbXCJtc2dwYWNrXCJdID0gXCJtc2dwYWNrXCI7XG4gICAgRm9ybWF0W1wianNvblwiXSA9IFwianNvblwiO1xufSkoRm9ybWF0ID0gZXhwb3J0cy5Gb3JtYXQgfHwgKGV4cG9ydHMuRm9ybWF0ID0ge30pKTtcbmZ1bmN0aW9uIGRlY29kZUJvZHkoYm9keSwgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZvcm1hdCA9PSAnbXNncGFjaycgPyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm1zZ3BhY2suZGVjb2RlKGJvZHkpIDogSlNPTi5wYXJzZShTdHJpbmcoYm9keSkpO1xufVxuZXhwb3J0cy5kZWNvZGVCb2R5ID0gZGVjb2RlQm9keTtcbmZ1bmN0aW9uIGVuY29kZUJvZHkoYm9keSwgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZvcm1hdCA9PSAnbXNncGFjaycgPyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm1zZ3BhY2suZW5jb2RlKGJvZHksIHRydWUpIDogSlNPTi5zdHJpbmdpZnkoYm9keSk7XG59XG5leHBvcnRzLmVuY29kZUJvZHkgPSBlbmNvZGVCb2R5O1xuZnVuY3Rpb24gYWxsVG9Mb3dlckNhc2UoYXJyKSB7XG4gICAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQgJiYgZWxlbWVudC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5hbGxUb0xvd2VyQ2FzZSA9IGFsbFRvTG93ZXJDYXNlO1xuZnVuY3Rpb24gYWxsVG9VcHBlckNhc2UoYXJyKSB7XG4gICAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQgJiYgZWxlbWVudC50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5hbGxUb1VwcGVyQ2FzZSA9IGFsbFRvVXBwZXJDYXNlO1xuZnVuY3Rpb24gZ2V0QmFja29mZkNvZWZmaWNpZW50KGNvdW50KSB7XG4gICAgcmV0dXJuIE1hdGgubWluKChjb3VudCArIDIpIC8gMywgMik7XG59XG5leHBvcnRzLmdldEJhY2tvZmZDb2VmZmljaWVudCA9IGdldEJhY2tvZmZDb2VmZmljaWVudDtcbmZ1bmN0aW9uIGdldEppdHRlckNvZWZmaWNpZW50KCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5yYW5kb20oKSAqIDAuMjtcbn1cbmV4cG9ydHMuZ2V0Sml0dGVyQ29lZmZpY2llbnQgPSBnZXRKaXR0ZXJDb2VmZmljaWVudDtcbi8qKlxuICpcbiAqIEBwYXJhbSBpbml0aWFsVGltZW91dCBpbml0aWFsIHRpbWVvdXQgdmFsdWVcbiAqIEBwYXJhbSByZXRyeUF0dGVtcHQgaW50ZWdlciBpbmRpY2F0aW5nIHJldHJ5QXR0ZW1wdFxuICogQHJldHVybnMgUmV0cnlUaW1lb3V0IHZhbHVlIGZvciBnaXZlbiB0aW1lb3V0IGFuZCByZXRyeUF0dGVtcHQuXG4gKiBJZiB4IGlzIHRoZSB2YWx1ZSBnZW5lcmF0ZWQgdGhlbixcbiAqIFVwcGVyIGJvdW5kID0gbWluKChyZXRyeUF0dGVtcHQgKyAyKSAvIDMsIDIpICogaW5pdGlhbFRpbWVvdXQsXG4gKiBMb3dlciBib3VuZCA9IDAuOCAqIFVwcGVyIGJvdW5kLFxuICogTG93ZXIgYm91bmQgPCB4IDwgVXBwZXIgYm91bmRcbiAqL1xuZnVuY3Rpb24gZ2V0UmV0cnlUaW1lKGluaXRpYWxUaW1lb3V0LCByZXRyeUF0dGVtcHQpIHtcbiAgICByZXR1cm4gaW5pdGlhbFRpbWVvdXQgKiBnZXRCYWNrb2ZmQ29lZmZpY2llbnQocmV0cnlBdHRlbXB0KSAqIGdldEppdHRlckNvZWZmaWNpZW50KCk7XG59XG5leHBvcnRzLmdldFJldHJ5VGltZSA9IGdldFJldHJ5VGltZTtcbmZ1bmN0aW9uIGdldEdsb2JhbE9iamVjdCgpIHtcbiAgICBpZiAoZ2xvYmFsKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cbmV4cG9ydHMuZ2V0R2xvYmFsT2JqZWN0ID0gZ2V0R2xvYmFsT2JqZWN0O1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFscyhzb3VyY2UsIHRhcmdldCkge1xuICAgIHJldHVybiAoT2JqZWN0LmtleXMoc291cmNlKS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBzb3VyY2Vba2V5XSA9PT0gdGFyZ2V0W2tleV07IH0pICYmXG4gICAgICAgIE9iamVjdC5rZXlzKHRhcmdldCkuZXZlcnkoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gdGFyZ2V0W2tleV0gPT09IHNvdXJjZVtrZXldOyB9KSk7XG59XG5leHBvcnRzLnNoYWxsb3dFcXVhbHMgPSBzaGFsbG93RXF1YWxzO1xuZnVuY3Rpb24gbWF0Y2hEZXJpdmVkQ2hhbm5lbChuYW1lKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyByZWdleCBjaGVjayBpcyB0byByZXRhaW4gZXhpc3RpbmcgY2hhbm5lbCBwYXJhbXMgaWYgYW55IGUuZyBbP3Jld2luZD0xXWZvbyB0b1xuICAgICAqIFtmaWx0ZXI9eHl6P3Jld2luZD0xXWZvby4gVGhpcyBpcyB0byBrZWVwIGNoYW5uZWwgY29tcGF0aWJpbGl0eSBhcm91bmQgdXNlIG9mXG4gICAgICogY2hhbm5lbCBwYXJhbXMgdGhhdCB3b3JrIHdpdGggZGVyaXZlZCBjaGFubmVscy5cbiAgICAgKlxuICAgICAqIFRoaXMgZXNsaW50IHVuc2FmZSByZWdleCB3YXJuaW5nIGlzIHRyaWdnZXJlZCBiZWNhdXNlIHRoZSBSZWdFeHAgdXNlcyBuZXN0ZWQgcXVhbnRpZmllcnMsXG4gICAgICogYnV0IGl0IGRvZXMgbm90IGNyZWF0ZSBhbnkgc2l0dWF0aW9uIHdoZXJlIHRoZSByZWdleCBlbmdpbmUgaGFzIHRvXG4gICAgICogZXhwbG9yZSBhIGxhcmdlIG51bWJlciBvZiBwb3NzaWJsZSBtYXRjaGVzIHNvIGl04oCZcyBzYWZlIHRvIGlnbm9yZVxuICAgICAqL1xuICAgIHZhciByZWdleCA9IC9eKFxcWyhbXj9dKikoPzooLiopKVxcXSk/KC4rKSQvOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChyZWdleCk7XG4gICAgaWYgKCFtYXRjaCB8fCAhbWF0Y2gubGVuZ3RoIHx8IG1hdGNoLmxlbmd0aCA8IDUpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ3JlZ2V4IG1hdGNoIGZhaWxlZCcsIDQwMCwgNDAwMTApO1xuICAgIH1cbiAgICAvLyBGYWlsIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBjaGFubmVsIHF1YWxpZmllciwgZWcgW21ldGFdZm9vIHNob3VsZCBmYWlsIGluc3RlYWQgb2YganVzdCBvdmVycmlkaW5nIHdpdGggW2ZpbHRlcj14eXpdZm9vXG4gICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KFwiY2Fubm90IHVzZSBhIGRlcml2ZWQgb3B0aW9uIHdpdGggYSBcIi5jb25jYXQobWF0Y2hbMl0sIFwiIGNoYW5uZWxcIiksIDQwMCwgNDAwMTApO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gbWF0Y2ggdmFsdWVzIHRvIGJlIGFkZGVkIHRvIGRlcml2ZSBjaGFubmVsIHF1YW50aWZpZXIuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcXVhbGlmaWVyUGFyYW06IG1hdGNoWzNdIHx8ICcnLFxuICAgICAgICBjaGFubmVsTmFtZTogbWF0Y2hbNF0sXG4gICAgfTtcbn1cbmV4cG9ydHMubWF0Y2hEZXJpdmVkQ2hhbm5lbCA9IG1hdGNoRGVyaXZlZENoYW5uZWw7XG5mdW5jdGlvbiB0b0Jhc2U2NChzdHIpIHtcbiAgICBpZiAocGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5jcmVhdGVIbWFjKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIsICdhc2NpaScpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBlbmNfYmFzZTY0XzEuc3RyaW5naWZ5KSgoMCwgZW5jX3V0ZjhfMS5wYXJzZSkoc3RyKSk7XG59XG5leHBvcnRzLnRvQmFzZTY0ID0gdG9CYXNlNjQ7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKSkpXG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG4vLyBXb3JrYXJvdW5kIGZvciBzYWxlc2ZvcmNlIGxpZ2h0bmluZyBsb2NrZXIgY29tcGF0aWJpbGl0eVxuLy8gVGhpcyBpcyBhIHNob3J0aGFuZCB2ZXJzaW9uIG9mIFV0aWxzLmdldEdsb2JhbE9iamVjdCAod2hpY2ggd2UgY2FuJ3QgdXNlIGhlcmUgd2l0aG91dCBjcmVhdGluZyBhIGNpcmN1bGFyIGltcG9ydClcbnZhciBnbG9iYWxPYmplY3QgPSBnbG9iYWwgfHwgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogc2VsZik7XG52YXIgTG9nTGV2ZWxzO1xuKGZ1bmN0aW9uIChMb2dMZXZlbHMpIHtcbiAgICBMb2dMZXZlbHNbTG9nTGV2ZWxzW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgTG9nTGV2ZWxzW0xvZ0xldmVsc1tcIkVycm9yXCJdID0gMV0gPSBcIkVycm9yXCI7XG4gICAgTG9nTGV2ZWxzW0xvZ0xldmVsc1tcIk1ham9yXCJdID0gMl0gPSBcIk1ham9yXCI7XG4gICAgTG9nTGV2ZWxzW0xvZ0xldmVsc1tcIk1pbm9yXCJdID0gM10gPSBcIk1pbm9yXCI7XG4gICAgTG9nTGV2ZWxzW0xvZ0xldmVsc1tcIk1pY3JvXCJdID0gNF0gPSBcIk1pY3JvXCI7XG59KShMb2dMZXZlbHMgfHwgKExvZ0xldmVscyA9IHt9KSk7XG5mdW5jdGlvbiBwYWQodGltZVNlZ21lbnQsIHRocmVlKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHRpbWVTZWdtZW50KS5wYWRTdGFydCh0aHJlZSA/IDMgOiAyLCAnMCcpO1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlcihsb2dnZXIpIHtcbiAgICByZXR1cm4gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5sb2dUaW1lc3RhbXBzXG4gICAgICAgID8gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgdmFyIHRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgbG9nZ2VyKHBhZCh0aW1lLmdldEhvdXJzKCkpICtcbiAgICAgICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgICAgIHBhZCh0aW1lLmdldE1pbnV0ZXMoKSkgK1xuICAgICAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICAgICAgcGFkKHRpbWUuZ2V0U2Vjb25kcygpKSArXG4gICAgICAgICAgICAgICAgJy4nICtcbiAgICAgICAgICAgICAgICBwYWQodGltZS5nZXRNaWxsaXNlY29uZHMoKSwgMSkgK1xuICAgICAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICAgICAgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICA6IGxvZ2dlcjtcbn1cbnZhciBnZXREZWZhdWx0TG9nZ2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciBjb25zb2xlTG9nZ2VyO1xuICAgIHZhciBlcnJvckxvZ2dlcjtcbiAgICAvKiBDYW4ndCBqdXN0IGNoZWNrIGZvciBjb25zb2xlICYmIGNvbnNvbGUubG9nOyBmYWlscyBpbiBJRSA8PTkgKi9cbiAgICBpZiAoKHR5cGVvZiBXaW5kb3cgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gJ3VuZGVmaW5lZCcpIC8qIG5vZGUgKi8gfHxcbiAgICAgICAgdHlwZW9mICgoX2IgPSAoX2EgPSBnbG9iYWxPYmplY3QgPT09IG51bGwgfHwgZ2xvYmFsT2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnbG9iYWxPYmplY3QuY29uc29sZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFwcGx5KSA9PT0gJ2Z1bmN0aW9uJyAvKiBzZW5zaWJsZSBicm93c2VycyAqLykge1xuICAgICAgICBjb25zb2xlTG9nZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIGVycm9yTG9nZ2VyID0gY29uc29sZS53YXJuXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBjb25zb2xlTG9nZ2VyO1xuICAgIH1cbiAgICBlbHNlIGlmIChnbG9iYWxPYmplY3QgPT09IG51bGwgfHwgZ2xvYmFsT2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnbG9iYWxPYmplY3QuY29uc29sZS5sb2cpIHtcbiAgICAgICAgLyogSUUgPD0gOSB3aXRoIHRoZSBjb25zb2xlIG9wZW4gLS0gY29uc29sZS5sb2cgZG9lcyBub3RcbiAgICAgICAgICogaW5oZXJpdCBmcm9tIEZ1bmN0aW9uLCBzbyBoYXMgbm8gYXBwbHkgbWV0aG9kICovXG4gICAgICAgIGNvbnNvbGVMb2dnZXIgPSBlcnJvckxvZ2dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLyogSUUgPD0gOSB3aGVuIGRldiB0b29scyBhcmUgY2xvc2VkIC0gd2luZG93LmNvbnNvbGUgbm90IGV2ZW4gZGVmaW5lZCAqL1xuICAgICAgICBjb25zb2xlTG9nZ2VyID0gZXJyb3JMb2dnZXIgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgfVxuICAgIHJldHVybiBbY29uc29sZUxvZ2dlciwgZXJyb3JMb2dnZXJdLm1hcChnZXRIYW5kbGVyKTtcbn07XG52YXIgTG9nZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ2dlcigpIHtcbiAgICAgICAgTG9nZ2VyLmxvZ0xldmVsID0gTG9nZ2VyLkxPR19ERUZBVUxUO1xuICAgIH1cbiAgICBMb2dnZXIuaW5pdExvZ0hhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSBnZXREZWZhdWx0TG9nZ2VycygpLCBsb2dIYW5kbGVyID0gX2FbMF0sIGxvZ0Vycm9ySGFuZGxlciA9IF9hWzFdO1xuICAgICAgICB0aGlzLmxvZ0hhbmRsZXIgPSBsb2dIYW5kbGVyO1xuICAgICAgICB0aGlzLmxvZ0Vycm9ySGFuZGxlciA9IGxvZ0Vycm9ySGFuZGxlcjtcbiAgICB9O1xuICAgIExvZ2dlci5sb2dMZXZlbCA9IExvZ0xldmVscy5FcnJvcjsgLy8gZGVmYXVsdCBsb2dMZXZlbFxuICAgIC8vIHB1YmxpYyBjb25zdGFudHNcbiAgICBMb2dnZXIuTE9HX05PTkUgPSBMb2dMZXZlbHMuTm9uZTtcbiAgICBMb2dnZXIuTE9HX0VSUk9SID0gTG9nTGV2ZWxzLkVycm9yO1xuICAgIExvZ2dlci5MT0dfTUFKT1IgPSBMb2dMZXZlbHMuTWFqb3I7XG4gICAgTG9nZ2VyLkxPR19NSU5PUiA9IExvZ0xldmVscy5NaW5vcjtcbiAgICBMb2dnZXIuTE9HX01JQ1JPID0gTG9nTGV2ZWxzLk1pY3JvO1xuICAgIC8vIGFsaWFzZXNcbiAgICBMb2dnZXIuTE9HX0RFRkFVTFQgPSBMb2dMZXZlbHMuRXJyb3I7XG4gICAgTG9nZ2VyLkxPR19ERUJVRyA9IExvZ0xldmVscy5NaWNybztcbiAgICAvKiBwdWJsaWMgc3RhdGljIGZ1bmN0aW9ucyAqL1xuICAgIExvZ2dlci5sb2dBY3Rpb24gPSBmdW5jdGlvbiAobGV2ZWwsIGFjdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoTG9nZ2VyLnNob3VsZExvZyhsZXZlbCkpIHtcbiAgICAgICAgICAgIChsZXZlbCA9PT0gTG9nTGV2ZWxzLkVycm9yID8gTG9nZ2VyLmxvZ0Vycm9ySGFuZGxlciA6IExvZ2dlci5sb2dIYW5kbGVyKSgnQWJseTogJyArIGFjdGlvbiArICc6ICcgKyBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9nZ2VyLmRlcHJlY2F0ZWQgPSBmdW5jdGlvbiAob3JpZ2luYWwsIHJlcGxhY2VtZW50KSB7XG4gICAgICAgIExvZ2dlci5kZXByZWNhdGVkV2l0aE1zZyhvcmlnaW5hbCwgXCJQbGVhc2UgdXNlICdcIiArIHJlcGxhY2VtZW50ICsgXCInIGluc3RlYWQuXCIpO1xuICAgIH07XG4gICAgTG9nZ2VyLmRlcHJlY2F0ZWRXaXRoTXNnID0gZnVuY3Rpb24gKGZ1bmNOYW1lLCBtc2cpIHtcbiAgICAgICAgaWYgKExvZ2dlci5zaG91bGRMb2coTG9nTGV2ZWxzLkVycm9yKSkge1xuICAgICAgICAgICAgTG9nZ2VyLmxvZ0Vycm9ySGFuZGxlcihcIkFibHk6IERlcHJlY2F0aW9uIHdhcm5pbmcgLSAnXCIgKyBmdW5jTmFtZSArIFwiJyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgZnJvbSBhIGZ1dHVyZSB2ZXJzaW9uLiBcIiArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qIFdoZXJlIGEgbG9nZ2luZyBvcGVyYXRpb24gaXMgZXhwZW5zaXZlLCBzdWNoIGFzIHNlcmlhbGlzYXRpb24gb2YgZGF0YSwgdXNlIHNob3VsZExvZyB3aWxsIHByZXZlbnRcbiAgICAgICAgIHRoZSBvYmplY3QgYmVpbmcgc2VyaWFsaXNlZCBpZiB0aGUgbG9nIGxldmVsIHdpbGwgbm90IG91dHB1dCB0aGUgbWVzc2FnZSAqL1xuICAgIExvZ2dlci5zaG91bGRMb2cgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIGxldmVsIDw9IExvZ2dlci5sb2dMZXZlbDtcbiAgICB9O1xuICAgIExvZ2dlci5zZXRMb2cgPSBmdW5jdGlvbiAobGV2ZWwsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBMb2dnZXIubG9nTGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIExvZ2dlci5sb2dIYW5kbGVyID0gTG9nZ2VyLmxvZ0Vycm9ySGFuZGxlciA9IGhhbmRsZXI7XG4gICAgfTtcbiAgICByZXR1cm4gTG9nZ2VyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IExvZ2dlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTMpKSlcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUGxhdGZvcm0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGxhdGZvcm0oKSB7XG4gICAgfVxuICAgIHJldHVybiBQbGF0Zm9ybTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQbGF0Zm9ybTtcblxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFydGlhbEVycm9ySW5mbyA9IHZvaWQgMDtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbmZ1bmN0aW9uIHRvU3RyaW5nKGVycikge1xuICAgIHZhciByZXN1bHQgPSAnWycgKyBlcnIuY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAoZXJyLm1lc3NhZ2UpXG4gICAgICAgIHJlc3VsdCArPSAnOiAnICsgZXJyLm1lc3NhZ2U7XG4gICAgaWYgKGVyci5zdGF0dXNDb2RlKVxuICAgICAgICByZXN1bHQgKz0gJzsgc3RhdHVzQ29kZT0nICsgZXJyLnN0YXR1c0NvZGU7XG4gICAgaWYgKGVyci5jb2RlKVxuICAgICAgICByZXN1bHQgKz0gJzsgY29kZT0nICsgZXJyLmNvZGU7XG4gICAgaWYgKGVyci5jYXVzZSlcbiAgICAgICAgcmVzdWx0ICs9ICc7IGNhdXNlPScgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyLmNhdXNlKTtcbiAgICBpZiAoZXJyLmhyZWYgJiYgIShlcnIubWVzc2FnZSAmJiBlcnIubWVzc2FnZS5pbmRleE9mKCdoZWxwLmFibHkuaW8nKSA+IC0xKSlcbiAgICAgICAgcmVzdWx0ICs9ICc7IHNlZSAnICsgZXJyLmhyZWYgKyAnICc7XG4gICAgcmVzdWx0ICs9ICddJztcbiAgICByZXR1cm4gcmVzdWx0O1xufVxudmFyIEVycm9ySW5mbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhFcnJvckluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXJyb3JJbmZvKG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUsIGNhdXNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LnNldFByb3RvdHlwZU9mICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBFcnJvckluZm8ucHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgX3RoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICAgIF90aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRXJyb3JJbmZvLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMpO1xuICAgIH07XG4gICAgRXJyb3JJbmZvLmZyb21WYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHZhciBfYSA9IHZhbHVlcywgbWVzc2FnZSA9IF9hLm1lc3NhZ2UsIGNvZGUgPSBfYS5jb2RlLCBzdGF0dXNDb2RlID0gX2Euc3RhdHVzQ29kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgY29kZSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHN0YXR1c0NvZGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9ySW5mby5mcm9tVmFsdWVzKCk6IGludmFsaWQgdmFsdWVzOiAnICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KHZhbHVlcykpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBPYmplY3QuYXNzaWduKG5ldyBFcnJvckluZm8obWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSksIHZhbHVlcyk7XG4gICAgICAgIGlmIChyZXN1bHQuY29kZSAmJiAhcmVzdWx0LmhyZWYpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ocmVmID0gJ2h0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yLycgKyByZXN1bHQuY29kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIEVycm9ySW5mbztcbn0oRXJyb3IpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEVycm9ySW5mbztcbnZhciBQYXJ0aWFsRXJyb3JJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFBhcnRpYWxFcnJvckluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFydGlhbEVycm9ySW5mbyhtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlLCBjYXVzZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5zZXRQcm90b3R5cGVPZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUGFydGlhbEVycm9ySW5mby5wcm90b3R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICBfdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICAgICAgX3RoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQYXJ0aWFsRXJyb3JJbmZvLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnRpYWxFcnJvckluZm87XG59KEVycm9yKSk7XG5leHBvcnRzLlBhcnRpYWxFcnJvckluZm8gPSBQYXJ0aWFsRXJyb3JJbmZvO1xuXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIENoZWNrIGlmIHR5cGVkIGFycmF5cyBhcmUgc3VwcG9ydGVkXG5cdCAgICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblxuXHQgICAgLy8gUmVmZXJlbmNlIG9yaWdpbmFsIGluaXRcblx0ICAgIHZhciBzdXBlckluaXQgPSBXb3JkQXJyYXkuaW5pdDtcblxuXHQgICAgLy8gQXVnbWVudCBXb3JkQXJyYXkuaW5pdCB0byBoYW5kbGUgdHlwZWQgYXJyYXlzXG5cdCAgICB2YXIgc3ViSW5pdCA9IFdvcmRBcnJheS5pbml0ID0gZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0ICAgICAgICAvLyBDb252ZXJ0IGJ1ZmZlcnMgdG8gdWludDhcblx0ICAgICAgICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0eXBlZEFycmF5KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDb252ZXJ0IG90aGVyIGFycmF5IHZpZXdzIHRvIHVpbnQ4XG5cdCAgICAgICAgaWYgKFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50OEFycmF5IHx8XG5cdCAgICAgICAgICAgICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50MTZBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheVxuXHQgICAgICAgICkge1xuXHQgICAgICAgICAgICB0eXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheS5idWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5ieXRlTGVuZ3RoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBIYW5kbGUgVWludDhBcnJheVxuXHQgICAgICAgIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgdHlwZWRBcnJheUJ5dGVMZW5ndGggPSB0eXBlZEFycmF5LmJ5dGVMZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gRXh0cmFjdCBieXRlc1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZEFycmF5Qnl0ZUxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAyXSB8PSB0eXBlZEFycmF5W2ldIDw8ICgyNCAtIChpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhpcyB3b3JkIGFycmF5XG5cdCAgICAgICAgICAgIHN1cGVySW5pdC5jYWxsKHRoaXMsIHdvcmRzLCB0eXBlZEFycmF5Qnl0ZUxlbmd0aCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gRWxzZSBjYWxsIG5vcm1hbCBpbml0XG5cdCAgICAgICAgICAgIHN1cGVySW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIHN1YkluaXQucHJvdG90eXBlID0gV29yZEFycmF5O1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmxpYi5Xb3JkQXJyYXk7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHs7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cblx0LypnbG9iYWxzIHdpbmRvdywgZ2xvYmFsLCByZXF1aXJlKi9cblxuXHQvKipcblx0ICogQ3J5cHRvSlMgY29yZSBjb21wb25lbnRzLlxuXHQgKi9cblx0dmFyIENyeXB0b0pTID0gQ3J5cHRvSlMgfHwgKGZ1bmN0aW9uIChNYXRoLCB1bmRlZmluZWQpIHtcblxuXHQgICAgdmFyIGNyeXB0bztcblxuXHQgICAgLy8gTmF0aXZlIGNyeXB0byBmcm9tIHdpbmRvdyAoQnJvd3Nlcilcblx0ICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY3J5cHRvKSB7XG5cdCAgICAgICAgY3J5cHRvID0gd2luZG93LmNyeXB0bztcblx0ICAgIH1cblxuXHQgICAgLy8gTmF0aXZlIChleHBlcmltZW50YWwgSUUgMTEpIGNyeXB0byBmcm9tIHdpbmRvdyAoQnJvd3Nlcilcblx0ICAgIGlmICghY3J5cHRvICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5tc0NyeXB0bykge1xuXHQgICAgICAgIGNyeXB0byA9IHdpbmRvdy5tc0NyeXB0bztcblx0ICAgIH1cblxuXHQgICAgLy8gTmF0aXZlIGNyeXB0byBmcm9tIGdsb2JhbCAoTm9kZUpTKVxuXHQgICAgaWYgKCFjcnlwdG8gJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLmNyeXB0bykge1xuXHQgICAgICAgIGNyeXB0byA9IGdsb2JhbC5jcnlwdG87XG5cdCAgICB9XG5cblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gaW1wb3J0IHZpYSByZXF1aXJlIChOb2RlSlMpXG5cdCAgICBpZiAoIWNyeXB0byAmJiBcImZ1bmN0aW9uXCIgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBjcnlwdG8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcblx0ICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICB9XG5cblx0ICAgIC8qXG5cdCAgICAgKiBDcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHNldWRvcmFuZG9tIG51bWJlciBnZW5lcmF0b3Jcblx0ICAgICAqXG5cdCAgICAgKiBBcyBNYXRoLnJhbmRvbSgpIGlzIGNyeXB0b2dyYXBoaWNhbGx5IG5vdCBzYWZlIHRvIHVzZVxuXHQgICAgICovXG5cdCAgICB2YXIgY3J5cHRvU2VjdXJlUmFuZG9tSW50ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmIChjcnlwdG8pIHtcblx0ICAgICAgICAgICAgLy8gVXNlIGdldFJhbmRvbVZhbHVlcyBtZXRob2QgKEJyb3dzZXIpXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMSkpWzBdO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gVXNlIHJhbmRvbUJ5dGVzIG1ldGhvZCAoTm9kZUpTKVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0by5yYW5kb21CeXRlcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKDQpLnJlYWRJbnQzMkxFKCk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05hdGl2ZSBjcnlwdG8gbW9kdWxlIGNvdWxkIG5vdCBiZSB1c2VkIHRvIGdldCBzZWN1cmUgcmFuZG9tIG51bWJlci4nKTtcblx0ICAgIH07XG5cblx0ICAgIC8qXG5cdCAgICAgKiBMb2NhbCBwb2x5ZmlsbCBvZiBPYmplY3QuY3JlYXRlXG5cblx0ICAgICAqL1xuXHQgICAgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBGKCkge31cblxuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgICAgIHZhciBzdWJ0eXBlO1xuXG5cdCAgICAgICAgICAgIEYucHJvdG90eXBlID0gb2JqO1xuXG5cdCAgICAgICAgICAgIHN1YnR5cGUgPSBuZXcgRigpO1xuXG5cdCAgICAgICAgICAgIEYucHJvdG90eXBlID0gbnVsbDtcblxuXHQgICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcblx0ICAgICAgICB9O1xuXHQgICAgfSgpKVxuXG5cdCAgICAvKipcblx0ICAgICAqIENyeXB0b0pTIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMaWJyYXJ5IG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfbGliID0gQy5saWIgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCYXNlIG9iamVjdCBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlID0gKGZ1bmN0aW9uICgpIHtcblxuXG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyBQcm9wZXJ0aWVzIHRvIGNvcHkgaW50byB0aGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZScsXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNwYXduXG5cdCAgICAgICAgICAgICAgICB2YXIgc3VidHlwZSA9IGNyZWF0ZSh0aGlzKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gQXVnbWVudFxuXHQgICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlcykge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUubWl4SW4ob3ZlcnJpZGVzKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgaW5pdGlhbGl6ZXJcblx0ICAgICAgICAgICAgICAgIGlmICghc3VidHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5pdCcpIHx8IHRoaXMuaW5pdCA9PT0gc3VidHlwZS5pbml0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlci5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZXIncyBwcm90b3R5cGUgaXMgdGhlIHN1YnR5cGUgb2JqZWN0XG5cdCAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQucHJvdG90eXBlID0gc3VidHlwZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNlIHN1cGVydHlwZVxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIgPSB0aGlzO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogRXh0ZW5kcyB0aGlzIG9iamVjdCBhbmQgcnVucyB0aGUgaW5pdCBtZXRob2QuXG5cdCAgICAgICAgICAgICAqIEFyZ3VtZW50cyB0byBjcmVhdGUoKSB3aWxsIGJlIHBhc3NlZCB0byBpbml0KCkuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBpbnN0YW5jZSA9IE15VHlwZS5jcmVhdGUoKTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5leHRlbmQoKTtcblx0ICAgICAgICAgICAgICAgIGluc3RhbmNlLmluaXQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG9iamVjdC5cblx0ICAgICAgICAgICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYWRkIHNvbWUgbG9naWMgd2hlbiB5b3VyIG9iamVjdHMgYXJlIGNyZWF0ZWQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgICAgIC8vIC4uLlxuXHQgICAgICAgICAgICAgKiAgICAgICAgIH1cblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBpbnRvIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBUaGUgcHJvcGVydGllcyB0byBtaXggaW4uXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBNeVR5cGUubWl4SW4oe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnXG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIG1peEluOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IHByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIElFIHdvbid0IGNvcHkgdG9TdHJpbmcgdXNpbmcgdGhlIGxvb3AgYWJvdmVcblx0ICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KCd0b1N0cmluZycpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b1N0cmluZyA9IHByb3BlcnRpZXMudG9TdHJpbmc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGluc3RhbmNlLmNsb25lKCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC5wcm90b3R5cGUuZXh0ZW5kKHRoaXMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHdvcmRzIFRoZSBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgKi9cblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXkgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2lnQnl0ZXMgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoZSB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKCk7XG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10pO1xuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddLCA2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAod29yZHMsIHNpZ0J5dGVzKSB7XG5cdCAgICAgICAgICAgIHdvcmRzID0gdGhpcy53b3JkcyA9IHdvcmRzIHx8IFtdO1xuXG5cdCAgICAgICAgICAgIGlmIChzaWdCeXRlcyAhPSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSB3b3Jkcy5sZW5ndGggKiA0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoaXMgd29yZCBhcnJheSB0byBhIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlciAoT3B0aW9uYWwpIFRoZSBlbmNvZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IENyeXB0b0pTLmVuYy5IZXhcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkgKyAnJztcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZygpO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGVuY29kZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChlbmNvZGVyIHx8IEhleCkuc3RyaW5naWZ5KHRoaXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25jYXRlbmF0ZXMgYSB3b3JkIGFycmF5IHRvIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheTEuY29uY2F0KHdvcmRBcnJheTIpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbmNhdDogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHRoaXNXb3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGF0V29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGlzU2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgdGhhdFNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIHRoaXMuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDb25jYXRcblx0ICAgICAgICAgICAgaWYgKHRoaXNTaWdCeXRlcyAlIDQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIGJ5dGUgYXQgYSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXRCeXRlID0gKHRoYXRXb3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gfD0gdGhhdEJ5dGUgPDwgKDI0IC0gKCh0aGlzU2lnQnl0ZXMgKyBpKSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSB3b3JkIGF0IGEgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdID0gdGhhdFdvcmRzW2kgPj4+IDJdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgKz0gdGhhdFNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVtb3ZlcyBpbnNpZ25pZmljYW50IGJpdHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsYW1wOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wXG5cdCAgICAgICAgICAgIHdvcmRzW3NpZ0J5dGVzID4+PiAyXSAmPSAweGZmZmZmZmZmIDw8ICgzMiAtIChzaWdCeXRlcyAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIHdvcmRzLmxlbmd0aCA9IE1hdGguY2VpbChzaWdCeXRlcyAvIDQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gd29yZEFycmF5LmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS53b3JkcyA9IHRoaXMud29yZHMuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgd29yZCBhcnJheSBmaWxsZWQgd2l0aCByYW5kb20gYnl0ZXMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbkJ5dGVzIFRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcmFuZG9tIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmFuZG9tOiBmdW5jdGlvbiAobkJ5dGVzKSB7XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkJ5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goY3J5cHRvU2VjdXJlUmFuZG9tSW50KCkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbkJ5dGVzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBFbmNvZGVyIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBIZXggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBIZXggPSBDX2VuYy5IZXggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGV4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkhleC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGhleENoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgJiAweDBmKS50b1N0cmluZygxNikpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhleENoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhleFN0ciBUaGUgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGhleFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChoZXhTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhleFN0ckxlbmd0aCA9IGhleFN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZXhTdHJMZW5ndGg7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gM10gfD0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cihpLCAyKSwgMTYpIDw8ICgyNCAtIChpICUgOCkgKiA0KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGhleFN0ckxlbmd0aCAvIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogTGF0aW4xIGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgTGF0aW4xID0gQ19lbmMuTGF0aW4xID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGxhdGluMVN0cmluZyA9IENyeXB0b0pTLmVuYy5MYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBsYXRpbjFDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGxhdGluMUNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiaXRlKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbGF0aW4xQ2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgTGF0aW4xIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF0aW4xU3RyIFRoZSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5MYXRpbjEucGFyc2UobGF0aW4xU3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGxhdGluMVN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xU3RyTGVuZ3RoID0gbGF0aW4xU3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGluMVN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAyXSB8PSAobGF0aW4xU3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmKSA8PCAoMjQgLSAoaSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBsYXRpbjFTdHJMZW5ndGgpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogVVRGLTggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmOCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgdXRmOFN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGY4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpKSk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFVURi04IGRhdGEnKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi04IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmOFN0ciBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKHV0ZjhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmOFN0cikge1xuXHQgICAgICAgICAgICByZXR1cm4gTGF0aW4xLnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh1dGY4U3RyKSkpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYnVmZmVyZWQgYmxvY2sgYWxnb3JpdGhtIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIFRoZSBwcm9wZXJ0eSBibG9ja1NpemUgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBhIGNvbmNyZXRlIHN1YnR5cGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9taW5CdWZmZXJTaXplIFRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgc2hvdWxkIGJlIGtlcHQgdW5wcm9jZXNzZWQgaW4gdGhlIGJ1ZmZlci4gRGVmYXVsdDogMFxuXHQgICAgICovXG5cdCAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgZGF0YSBidWZmZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLl9kYXRhID0gbmV3IFdvcmRBcnJheS5pbml0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgPSAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIG5ldyBkYXRhIHRvIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgYnVmZmVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGFwcGVuZC4gU3RyaW5ncyBhcmUgY29udmVydGVkIHRvIGEgV29yZEFycmF5IHVzaW5nIFVURi04LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2FwcGVuZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGEgPSBVdGY4LnBhcnNlKGRhdGEpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2RhdGEuY29uY2F0KGRhdGEpO1xuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzICs9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFByb2Nlc3NlcyBhdmFpbGFibGUgZGF0YSBibG9ja3MuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIF9kb1Byb2Nlc3NCbG9jayhvZmZzZXQpLCB3aGljaCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGEgY29uY3JldGUgc3VidHlwZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9GbHVzaCBXaGV0aGVyIGFsbCBibG9ja3MgYW5kIHBhcnRpYWwgYmxvY2tzIHNob3VsZCBiZSBwcm9jZXNzZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwcm9jZXNzZWQgZGF0YS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCk7XG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcyghISdmbHVzaCcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9wcm9jZXNzOiBmdW5jdGlvbiAoZG9GbHVzaCkge1xuXHQgICAgICAgICAgICB2YXIgcHJvY2Vzc2VkV29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBkYXRhU2lnQnl0ZXMgPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gdGhpcy5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYmxvY2tzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuQmxvY2tzUmVhZHkgPSBkYXRhU2lnQnl0ZXMgLyBibG9ja1NpemVCeXRlcztcblx0ICAgICAgICAgICAgaWYgKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRvIGluY2x1ZGUgcGFydGlhbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGguY2VpbChuQmxvY2tzUmVhZHkpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgZG93biB0byBpbmNsdWRlIG9ubHkgZnVsbCBibG9ja3MsXG5cdCAgICAgICAgICAgICAgICAvLyBsZXNzIHRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgbXVzdCByZW1haW4gaW4gdGhlIGJ1ZmZlclxuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5tYXgoKG5CbG9ja3NSZWFkeSB8IDApIC0gdGhpcy5fbWluQnVmZmVyU2l6ZSwgMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb3VudCB3b3JkcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbldvcmRzUmVhZHkgPSBuQmxvY2tzUmVhZHkgKiBibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYnl0ZXMgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CeXRlc1JlYWR5ID0gTWF0aC5taW4obldvcmRzUmVhZHkgKiA0LCBkYXRhU2lnQnl0ZXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgYmxvY2tzXG5cdCAgICAgICAgICAgIGlmIChuV29yZHNSZWFkeSkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbldvcmRzUmVhZHk7IG9mZnNldCArPSBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWFsZ29yaXRobSBsb2dpY1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUHJvY2Vzc0Jsb2NrKGRhdGFXb3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICAgICAgcHJvY2Vzc2VkV29yZHMgPSBkYXRhV29yZHMuc3BsaWNlKDAsIG5Xb3Jkc1JlYWR5KTtcblx0ICAgICAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gbkJ5dGVzUmVhZHk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gcHJvY2Vzc2VkIHdvcmRzXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQocHJvY2Vzc2VkV29yZHMsIG5CeXRlc1JlYWR5KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2RhdGEgPSB0aGlzLl9kYXRhLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbWluQnVmZmVyU2l6ZTogMFxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgaGFzaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBoYXNoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDE2ICg1MTIgYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBoYXNoIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaGVyID0gQ3J5cHRvSlMuYWxnby5TSEEyNTYuY3JlYXRlKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBoYXNoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG5cdCAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuXHQgICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVwZGF0ZXMgdGhpcyBoYXNoZXIgd2l0aCBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7SGFzaGVyfSBUaGlzIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaGFzaFxuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGhhc2ggY29tcHV0YXRpb24uXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBGaW5hbCBtZXNzYWdlIHVwZGF0ZVxuXHQgICAgICAgICAgICBpZiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogNTEyLzMyLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIGEgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIFNIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGNmZykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBoYXNoZXIuaW5pdChjZmcpLmZpbmFsaXplKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZSBpbiB0aGlzIEhNQUMgaGVscGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIEhtYWNTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSG1hY0hlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDX2FsZ28uSE1BQy5pbml0KGhhc2hlciwga2V5KS5maW5hbGl6ZShtZXNzYWdlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbGdvcml0aG0gbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvID0ge307XG5cblx0ICAgIHJldHVybiBDO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUztcblxufSkpO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTMpKSlcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbi8qIENhbGwgdGhlIGxpc3RlbmVyLCBjYXRjaCBhbnkgZXhjZXB0aW9ucyBhbmQgbG9nLCBidXQgY29udGludWUgb3BlcmF0aW9uKi9cbmZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihldmVudFRoaXMsIGxpc3RlbmVyLCBhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIuYXBwbHkoZXZlbnRUaGlzLCBhcmdzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdFdmVudEVtaXR0ZXIuZW1pdCgpJywgJ1VuZXhwZWN0ZWQgbGlzdGVuZXIgZXhjZXB0aW9uOiAnICsgZSArICc7IHN0YWNrID0gJyArIChlICYmIGUuc3RhY2spKTtcbiAgICB9XG59XG4vKipcbiAqIFJlbW92ZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCBsaXN0ZW5lclxuICogQHBhcmFtIHRhcmdldExpc3RlbmVycyBpcyBhbiBhcnJheSBvZiBsaXN0ZW5lciBhcnJheXMgb3IgZXZlbnQgb2JqZWN0cyB3aXRoIGFycmF5cyBvZiBsaXN0ZW5lcnNcbiAqIEBwYXJhbSBsaXN0ZW5lciB0aGUgbGlzdGVuZXIgY2FsbGJhY2sgdG8gcmVtb3ZlXG4gKiBAcGFyYW0gZXZlbnRGaWx0ZXIgKG9wdGlvbmFsKSBldmVudCBuYW1lIGluc3RydWN0aW5nIHRoZSBmdW5jdGlvbiB0byBvbmx5IHJlbW92ZSBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodGFyZ2V0TGlzdGVuZXJzLCBsaXN0ZW5lciwgZXZlbnRGaWx0ZXIpIHtcbiAgICB2YXIgbGlzdGVuZXJzO1xuICAgIHZhciBpbmRleDtcbiAgICB2YXIgZXZlbnROYW1lO1xuICAgIGZvciAodmFyIHRhcmdldExpc3RlbmVyc0luZGV4ID0gMDsgdGFyZ2V0TGlzdGVuZXJzSW5kZXggPCB0YXJnZXRMaXN0ZW5lcnMubGVuZ3RoOyB0YXJnZXRMaXN0ZW5lcnNJbmRleCsrKSB7XG4gICAgICAgIGxpc3RlbmVycyA9IHRhcmdldExpc3RlbmVyc1t0YXJnZXRMaXN0ZW5lcnNJbmRleF07XG4gICAgICAgIGlmIChldmVudEZpbHRlcikge1xuICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzW2V2ZW50RmlsdGVyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVXRpbHMuaXNBcnJheShsaXN0ZW5lcnMpKSB7XG4gICAgICAgICAgICB3aGlsZSAoKGluZGV4ID0gVXRpbHMuYXJySW5kZXhPZihsaXN0ZW5lcnMsIGxpc3RlbmVyKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBJZiBldmVudHMgb2JqZWN0IGhhcyBhbiBldmVudCBuYW1lIGtleSB3aXRoIG5vIGxpc3RlbmVycyB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUga2V5IHRvIHN0b3AgdGhlIGxpc3QgZ3Jvd2luZyBpbmRlZmluaXRlbHkgKi9cbiAgICAgICAgICAgIGlmIChldmVudEZpbHRlciAmJiBsaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRhcmdldExpc3RlbmVyc1t0YXJnZXRMaXN0ZW5lcnNJbmRleF1bZXZlbnRGaWx0ZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFV0aWxzLmlzT2JqZWN0KGxpc3RlbmVycykpIHtcbiAgICAgICAgICAgIC8qIGV2ZW50cyAqL1xuICAgICAgICAgICAgZm9yIChldmVudE5hbWUgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsaXN0ZW5lcnMsIGV2ZW50TmFtZSkgJiYgVXRpbHMuaXNBcnJheShsaXN0ZW5lcnNbZXZlbnROYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoW2xpc3RlbmVyc10sIGxpc3RlbmVyLCBldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbnZhciBFdmVudEVtaXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgICAgICB0aGlzLmFueSA9IFtdO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuYW55T25jZSA9IFtdO1xuICAgICAgICB0aGlzLmV2ZW50c09uY2UgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gYXJnc1swXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFueS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnRMaXN0ZW5lci5vbigpOiBJbnZhbGlkIGFyZ3VtZW50czogJyArIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRfMSA9IGFyZ3NbMF0sIGxpc3RlbmVyXzEgPSBhcmdzWzFdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcl8xICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudExpc3RlbmVyLm9uKCk6IEludmFsaWQgYXJndW1lbnRzOiAnICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChVdGlscy5pc0VtcHR5QXJnKGV2ZW50XzEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbnkucHVzaChsaXN0ZW5lcl8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFV0aWxzLmlzQXJyYXkoZXZlbnRfMSkpIHtcbiAgICAgICAgICAgICAgICBldmVudF8xLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbihldmVudE5hbWUsIGxpc3RlbmVyXzEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudF8xICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50TGlzdGVuZXIub24oKTogSW52YWxpZCBhcmd1bWVudHM6ICcgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5ldmVudHNbZXZlbnRfMV0gfHwgKHRoaXMuZXZlbnRzW2V2ZW50XzFdID0gW10pO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAwIHx8IChVdGlscy5pc0VtcHR5QXJnKGFyZ3NbMF0pICYmIFV0aWxzLmlzRW1wdHlBcmcoYXJnc1sxXSkpKSB7XG4gICAgICAgICAgICB0aGlzLmFueSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5hbnlPbmNlID0gW107XG4gICAgICAgICAgICB0aGlzLmV2ZW50c09uY2UgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXJzdEFyZyA9IGFyZ3NbMF0sIHNlY29uZEFyZyA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIHZhciBldmVudCA9IG51bGw7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSB8fCAhc2Vjb25kQXJnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpcnN0QXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLyogd2UgdGFrZSB0aGlzIHRvIGJlIHRoZSBsaXN0ZW5lciBhbmQgdHJlYXQgdGhlIGV2ZW50IGFzIFwiYW55XCIgLi4gKi9cbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGZpcnN0QXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBmaXJzdEFyZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIC4uLiBvciB3ZSB0YWtlIGV2ZW50IHRvIGJlIHRoZSBhY3R1YWwgZXZlbnQgbmFtZSBhbmQgbGlzdGVuZXIgdG8gYmUgYWxsICovXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnRFbWl0dGVyLm9mZigpOiBpbnZhbGlkIGFyZ3VtZW50czonICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9hID0gW2ZpcnN0QXJnLCBzZWNvbmRBcmddLCBldmVudCA9IF9hWzBdLCBsaXN0ZW5lciA9IF9hWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lciAmJiBVdGlscy5pc0VtcHR5QXJnKGV2ZW50KSkge1xuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoW3RoaXMuYW55LCB0aGlzLmV2ZW50cywgdGhpcy5hbnlPbmNlLCB0aGlzLmV2ZW50c09uY2VdLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWxzLmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBcIm5vcm1hbFwiIGNhc2Ugd2hlcmUgZXZlbnQgaXMgYW4gYWN0dWFsIGV2ZW50ICovXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50RW1pdHRlci5vZmYoKTogaW52YWxpZCBhcmd1bWVudHM6JyArIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcihbdGhpcy5ldmVudHMsIHRoaXMuZXZlbnRzT25jZV0sIGxpc3RlbmVyLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ldmVudHNbZXZlbnRdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnRzT25jZVtldmVudF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXJyYXkgb2YgbGlzdGVuZXJzIGZvciBhIGdpdmVuIGV2ZW50OyBleGNsdWRlcyBvbmNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSBldmVudCAob3B0aW9uYWwpIHRoZSBuYW1lIG9mIHRoZSBldmVudCwgb3Igbm9uZSBmb3IgJ2FueSdcbiAgICAgKiBAcmV0dXJuIGFycmF5IG9mIGV2ZW50cywgb3IgbnVsbCBpZiBub25lXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzT25jZVtldmVudF0pXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCB0aGlzLmV2ZW50c09uY2VbZXZlbnRdKTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoID8gbGlzdGVuZXJzIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hbnkubGVuZ3RoID8gdGhpcy5hbnkgOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW1pdCBhbiBldmVudFxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIHRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTsgLyogLCBhcmdzLi4uICovXG4gICAgICAgIGZvciAodmFyIF9pID0gMSAvKiAsIGFyZ3MuLi4gKi87IF9pIDwgYXJndW1lbnRzLmxlbmd0aCAvKiAsIGFyZ3MuLi4gKi87IF9pKysgLyogLCBhcmdzLi4uICovKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldOyAvKiAsIGFyZ3MuLi4gKi9cbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRUaGlzID0geyBldmVudDogZXZlbnQgfTtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5hbnlPbmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCB0aGlzLmFueU9uY2UpO1xuICAgICAgICAgICAgdGhpcy5hbnlPbmNlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYW55Lmxlbmd0aCkge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCB0aGlzLmFueSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50c09uY2VMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c09uY2VbZXZlbnRdO1xuICAgICAgICBpZiAoZXZlbnRzT25jZUxpc3RlbmVycykge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCBldmVudHNPbmNlTGlzdGVuZXJzKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c09uY2VbZXZlbnRdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudHNMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c1tldmVudF07XG4gICAgICAgIGlmIChldmVudHNMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgZXZlbnRzTGlzdGVuZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBVdGlscy5hcnJGb3JFYWNoKGxpc3RlbmVycywgZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjYWxsTGlzdGVuZXIoZXZlbnRUaGlzLCBsaXN0ZW5lciwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcmdDb3VudCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBpZiAoKGFyZ0NvdW50ID09PSAwIHx8IChhcmdDb3VudCA9PT0gMSAmJiB0eXBlb2YgYXJnc1swXSAhPT0gJ2Z1bmN0aW9uJykpICYmIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuUHJvbWlzZSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50XzIgPSBhcmdzWzBdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmNlKGV2ZW50XzIsIHJlc29sdmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0QXJnID0gYXJnc1swXSwgc2Vjb25kQXJnID0gYXJnc1sxXTtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBmaXJzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5hbnlPbmNlLnB1c2goZmlyc3RBcmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFV0aWxzLmlzRW1wdHlBcmcoZmlyc3RBcmcpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6JyArIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFueU9uY2UucHVzaChzZWNvbmRBcmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFV0aWxzLmlzQXJyYXkoZmlyc3RBcmcpKSB7XG4gICAgICAgICAgICB2YXIgc2VsZl8xID0gdGhpcztcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcldyYXBwZXJfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBVdGlscy5hcnJGb3JFYWNoKGZpcnN0QXJnLCBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGZfMS5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcldyYXBwZXJfMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRBcmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudEVtaXR0ZXIub25jZSgpOiBJbnZhbGlkIGFyZ3VtZW50czonICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2Vjb25kQXJnLmFwcGx5KHRoaXMsIGlubmVyQXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgVXRpbHMuYXJyRm9yRWFjaChmaXJzdEFyZywgZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIHNlbGZfMS5vbihldmVudE5hbWUsIGxpc3RlbmVyV3JhcHBlcl8xKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaXJzdEFyZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50RW1pdHRlci5vbmNlKCk6IEludmFsaWQgYXJndW1lbnRzOicgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuZXZlbnRzT25jZVtmaXJzdEFyZ10gfHwgKHRoaXMuZXZlbnRzT25jZVtmaXJzdEFyZ10gPSBbXSk7XG4gICAgICAgICAgICBpZiAoc2Vjb25kQXJnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRBcmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudEVtaXR0ZXIub25jZSgpOiBJbnZhbGlkIGFyZ3VtZW50czonICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goc2Vjb25kQXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBBUElcbiAgICAgKlxuICAgICAqIExpc3RlbiBmb3IgYSBzaW5nbGUgb2NjdXJyZW5jZSBvZiBhIHN0YXRlIGV2ZW50IGFuZCBmaXJlIGltbWVkaWF0ZWx5IGlmIGN1cnJlbnRTdGF0ZSBtYXRjaGVzIHRhcmdldFN0YXRlXG4gICAgICogQHBhcmFtIHRhcmdldFN0YXRlIHRoZSBuYW1lIG9mIHRoZSBzdGF0ZSBldmVudCB0byBsaXN0ZW4gdG9cbiAgICAgKiBAcGFyYW0gY3VycmVudFN0YXRlIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgb2JqZWN0XG4gICAgICogQHBhcmFtIGxpc3RlbmVyIHRoZSBsaXN0ZW5lciB0byBiZSBjYWxsZWRcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJBcmdzXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS53aGVuU3RhdGUgPSBmdW5jdGlvbiAodGFyZ2V0U3RhdGUsIGN1cnJlbnRTdGF0ZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxpc3RlbmVyQXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDM7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbGlzdGVuZXJBcmdzW19pIC0gM10gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudFRoaXMgPSB7IGV2ZW50OiB0YXJnZXRTdGF0ZSB9O1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldFN0YXRlICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgY3VycmVudFN0YXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgJ3doZW5TdGF0ZSByZXF1aXJlcyBhIHZhbGlkIGV2ZW50IFN0cmluZyBhcmd1bWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJyAmJiBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLlByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS53aGVuU3RhdGUuYXBwbHkoX3RoaXMsIFt0YXJnZXRTdGF0ZSwgY3VycmVudFN0YXRlLCByZXNvbHZlXS5jb25jYXQobGlzdGVuZXJBcmdzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0U3RhdGUgPT09IGN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgY2FsbExpc3RlbmVyKGV2ZW50VGhpcywgbGlzdGVuZXIsIGxpc3RlbmVyQXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uY2UodGFyZ2V0U3RhdGUsIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudEVtaXR0ZXI7XG5cblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldERlZmF1bHRzID0gZXhwb3J0cy5ub3JtYWxpc2VPcHRpb25zID0gZXhwb3J0cy5vYmplY3RpZnlPcHRpb25zID0gZXhwb3J0cy5nZXRBZ2VudFN0cmluZyA9IGV4cG9ydHMuZ2V0SG9zdHMgPSBleHBvcnRzLmdldEZhbGxiYWNrSG9zdHMgPSBleHBvcnRzLmVudmlyb25tZW50RmFsbGJhY2tIb3N0cyA9IGV4cG9ydHMuZ2V0SHR0cFNjaGVtZSA9IGV4cG9ydHMuZ2V0UG9ydCA9IGV4cG9ydHMuZ2V0SG9zdCA9IHZvaWQgMDtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgcGFja2FnZV9qc29uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcbnZhciBhZ2VudCA9ICdhYmx5LWpzLycgKyBwYWNrYWdlX2pzb25fMS52ZXJzaW9uO1xudmFyIERlZmF1bHRzID0ge1xuICAgIEVOVklST05NRU5UOiAnJyxcbiAgICBSRVNUX0hPU1Q6ICdyZXN0LmFibHkuaW8nLFxuICAgIFJFQUxUSU1FX0hPU1Q6ICdyZWFsdGltZS5hYmx5LmlvJyxcbiAgICBGQUxMQkFDS19IT1NUUzogW1xuICAgICAgICAnQS5hYmx5LXJlYWx0aW1lLmNvbScsXG4gICAgICAgICdCLmFibHktcmVhbHRpbWUuY29tJyxcbiAgICAgICAgJ0MuYWJseS1yZWFsdGltZS5jb20nLFxuICAgICAgICAnRC5hYmx5LXJlYWx0aW1lLmNvbScsXG4gICAgICAgICdFLmFibHktcmVhbHRpbWUuY29tJyxcbiAgICBdLFxuICAgIFBPUlQ6IDgwLFxuICAgIFRMU19QT1JUOiA0NDMsXG4gICAgVElNRU9VVFM6IHtcbiAgICAgICAgLyogRG9jdW1lbnRlZCBhcyBvcHRpb25zIHBhcmFtczogKi9cbiAgICAgICAgZGlzY29ubmVjdGVkUmV0cnlUaW1lb3V0OiAxNTAwMCxcbiAgICAgICAgc3VzcGVuZGVkUmV0cnlUaW1lb3V0OiAzMDAwMCxcbiAgICAgICAgLyogVW5kb2N1bWVudGVkLCBidXQgcGFydCBvZiB0aGUgYXBpIGFuZCBjYW4gYmUgdXNlZCBieSBjdXN0b21lcnM6ICovXG4gICAgICAgIGh0dHBSZXF1ZXN0VGltZW91dDogMTUwMDAsXG4gICAgICAgIGNoYW5uZWxSZXRyeVRpbWVvdXQ6IDE1MDAwLFxuICAgICAgICBmYWxsYmFja1JldHJ5VGltZW91dDogNjAwMDAwLFxuICAgICAgICAvKiBGb3IgaW50ZXJuYWwgLyB0ZXN0IHVzZSBvbmx5OiAqL1xuICAgICAgICBjb25uZWN0aW9uU3RhdGVUdGw6IDEyMDAwMCxcbiAgICAgICAgcmVhbHRpbWVSZXF1ZXN0VGltZW91dDogMTAwMDAsXG4gICAgICAgIHJlY3ZUaW1lb3V0OiA5MDAwMCxcbiAgICAgICAgcHJlZmVyZW5jZUNvbm5lY3RUaW1lb3V0OiA2MDAwLFxuICAgICAgICBwYXJhbGxlbFVwZ3JhZGVEZWxheTogNjAwMCxcbiAgICB9LFxuICAgIGh0dHBNYXhSZXRyeUNvdW50OiAzLFxuICAgIG1heE1lc3NhZ2VTaXplOiA2NTUzNixcbiAgICB2ZXJzaW9uOiBwYWNrYWdlX2pzb25fMS52ZXJzaW9uLFxuICAgIHByb3RvY29sVmVyc2lvbjogMixcbiAgICBhZ2VudDogYWdlbnQsXG4gICAgZ2V0SG9zdDogZ2V0SG9zdCxcbiAgICBnZXRQb3J0OiBnZXRQb3J0LFxuICAgIGdldEh0dHBTY2hlbWU6IGdldEh0dHBTY2hlbWUsXG4gICAgZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzOiBlbnZpcm9ubWVudEZhbGxiYWNrSG9zdHMsXG4gICAgZ2V0RmFsbGJhY2tIb3N0czogZ2V0RmFsbGJhY2tIb3N0cyxcbiAgICBnZXRIb3N0czogZ2V0SG9zdHMsXG4gICAgY2hlY2tIb3N0OiBjaGVja0hvc3QsXG4gICAgb2JqZWN0aWZ5T3B0aW9uczogb2JqZWN0aWZ5T3B0aW9ucyxcbiAgICBub3JtYWxpc2VPcHRpb25zOiBub3JtYWxpc2VPcHRpb25zLFxufTtcbmZ1bmN0aW9uIGdldEhvc3Qob3B0aW9ucywgaG9zdCwgd3MpIHtcbiAgICBpZiAod3MpXG4gICAgICAgIGhvc3QgPSAoaG9zdCA9PSBvcHRpb25zLnJlc3RIb3N0ICYmIG9wdGlvbnMucmVhbHRpbWVIb3N0KSB8fCBob3N0IHx8IG9wdGlvbnMucmVhbHRpbWVIb3N0O1xuICAgIGVsc2VcbiAgICAgICAgaG9zdCA9IGhvc3QgfHwgb3B0aW9ucy5yZXN0SG9zdDtcbiAgICByZXR1cm4gaG9zdDtcbn1cbmV4cG9ydHMuZ2V0SG9zdCA9IGdldEhvc3Q7XG5mdW5jdGlvbiBnZXRQb3J0KG9wdGlvbnMsIHRscykge1xuICAgIHJldHVybiB0bHMgfHwgb3B0aW9ucy50bHMgPyBvcHRpb25zLnRsc1BvcnQgOiBvcHRpb25zLnBvcnQ7XG59XG5leHBvcnRzLmdldFBvcnQgPSBnZXRQb3J0O1xuZnVuY3Rpb24gZ2V0SHR0cFNjaGVtZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMudGxzID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJztcbn1cbmV4cG9ydHMuZ2V0SHR0cFNjaGVtZSA9IGdldEh0dHBTY2hlbWU7XG4vLyBjb25zdHJ1Y3QgZW52aXJvbm1lbnQgZmFsbGJhY2sgaG9zdHMgYXMgcGVyIFJTQzE1aVxuZnVuY3Rpb24gZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzKGVudmlyb25tZW50KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZW52aXJvbm1lbnQgKyAnLWEtZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb20nLFxuICAgICAgICBlbnZpcm9ubWVudCArICctYi1mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbScsXG4gICAgICAgIGVudmlyb25tZW50ICsgJy1jLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tJyxcbiAgICAgICAgZW52aXJvbm1lbnQgKyAnLWQtZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb20nLFxuICAgICAgICBlbnZpcm9ubWVudCArICctZS1mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbScsXG4gICAgXTtcbn1cbmV4cG9ydHMuZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzID0gZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzO1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tIb3N0cyhvcHRpb25zKSB7XG4gICAgdmFyIGZhbGxiYWNrSG9zdHMgPSBvcHRpb25zLmZhbGxiYWNrSG9zdHMsIGh0dHBNYXhSZXRyeUNvdW50ID0gdHlwZW9mIG9wdGlvbnMuaHR0cE1heFJldHJ5Q291bnQgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5odHRwTWF4UmV0cnlDb3VudCA6IERlZmF1bHRzLmh0dHBNYXhSZXRyeUNvdW50O1xuICAgIHJldHVybiBmYWxsYmFja0hvc3RzID8gVXRpbHMuYXJyQ2hvb3NlTihmYWxsYmFja0hvc3RzLCBodHRwTWF4UmV0cnlDb3VudCkgOiBbXTtcbn1cbmV4cG9ydHMuZ2V0RmFsbGJhY2tIb3N0cyA9IGdldEZhbGxiYWNrSG9zdHM7XG5mdW5jdGlvbiBnZXRIb3N0cyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIFtvcHRpb25zLnJlc3RIb3N0XS5jb25jYXQoZ2V0RmFsbGJhY2tIb3N0cyhvcHRpb25zKSk7XG59XG5leHBvcnRzLmdldEhvc3RzID0gZ2V0SG9zdHM7XG5mdW5jdGlvbiBjaGVja0hvc3QoaG9zdCkge1xuICAgIGlmICh0eXBlb2YgaG9zdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ2hvc3QgbXVzdCBiZSBhIHN0cmluZzsgd2FzIGEgJyArIHR5cGVvZiBob3N0LCA0MDAwMCwgNDAwKTtcbiAgICB9XG4gICAgaWYgKCFob3N0Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnaG9zdCBtdXN0IG5vdCBiZSB6ZXJvLWxlbmd0aCcsIDQwMDAwLCA0MDApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFJlYWx0aW1lSG9zdChvcHRpb25zLCBwcm9kdWN0aW9uLCBlbnZpcm9ubWVudCkge1xuICAgIGlmIChvcHRpb25zLnJlYWx0aW1lSG9zdClcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVhbHRpbWVIb3N0O1xuICAgIC8qIHByZWZlciBzZXR0aW5nIHJlYWx0aW1lSG9zdCB0byByZXN0SG9zdCBhcyBhIGN1c3RvbSByZXN0SG9zdCB0eXBpY2FsbHkgaW5kaWNhdGVzXG4gICAgICogYSBkZXZlbG9wbWVudCBlbnZpcm9ubWVudCBpcyBiZWluZyB1c2VkIHRoYXQgY2FuJ3QgYmUgaW5mZXJyZWQgYnkgdGhlIGxpYnJhcnkgKi9cbiAgICBpZiAob3B0aW9ucy5yZXN0SG9zdCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0RlZmF1bHRzLm5vcm1hbGlzZU9wdGlvbnMnLCAncmVzdEhvc3QgaXMgc2V0IHRvIFwiJyArXG4gICAgICAgICAgICBvcHRpb25zLnJlc3RIb3N0ICtcbiAgICAgICAgICAgICdcIiBidXQgcmVhbHRpbWVIb3N0IGlzIG5vdCBzZXQsIHNvIHNldHRpbmcgcmVhbHRpbWVIb3N0IHRvIFwiJyArXG4gICAgICAgICAgICBvcHRpb25zLnJlc3RIb3N0ICtcbiAgICAgICAgICAgICdcIiB0b28uIElmIHRoaXMgaXMgbm90IHdoYXQgeW91IHdhbnQsIHBsZWFzZSBzZXQgcmVhbHRpbWVIb3N0IGV4cGxpY2l0bHkuJyk7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnJlc3RIb3N0O1xuICAgIH1cbiAgICByZXR1cm4gcHJvZHVjdGlvbiA/IERlZmF1bHRzLlJFQUxUSU1FX0hPU1QgOiBlbnZpcm9ubWVudCArICctJyArIERlZmF1bHRzLlJFQUxUSU1FX0hPU1Q7XG59XG5mdW5jdGlvbiBnZXRUaW1lb3V0cyhvcHRpb25zKSB7XG4gICAgLyogQWxsb3cgdmFsdWVzIHBhc3NlZCBpbiBvcHRpb25zIHRvIG92ZXJyaWRlIGRlZmF1bHQgdGltZW91dHMgKi9cbiAgICB2YXIgdGltZW91dHMgPSB7fTtcbiAgICBmb3IgKHZhciBwcm9wIGluIERlZmF1bHRzLlRJTUVPVVRTKSB7XG4gICAgICAgIHRpbWVvdXRzW3Byb3BdID0gb3B0aW9uc1twcm9wXSB8fCBEZWZhdWx0cy5USU1FT1VUU1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVvdXRzO1xufVxuZnVuY3Rpb24gZ2V0QWdlbnRTdHJpbmcob3B0aW9ucykge1xuICAgIHZhciBhZ2VudFN0ciA9IERlZmF1bHRzLmFnZW50O1xuICAgIGlmIChvcHRpb25zLmFnZW50cykge1xuICAgICAgICBmb3IgKHZhciBhZ2VudCBpbiBvcHRpb25zLmFnZW50cykge1xuICAgICAgICAgICAgYWdlbnRTdHIgKz0gJyAnICsgYWdlbnQgKyAnLycgKyBvcHRpb25zLmFnZW50c1thZ2VudF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFnZW50U3RyO1xufVxuZXhwb3J0cy5nZXRBZ2VudFN0cmluZyA9IGdldEFnZW50U3RyaW5nO1xuZnVuY3Rpb24gb2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmluZGV4T2YoJzonKSA9PSAtMSA/IHsgdG9rZW46IG9wdGlvbnMgfSA6IHsga2V5OiBvcHRpb25zIH07XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZXhwb3J0cy5vYmplY3RpZnlPcHRpb25zID0gb2JqZWN0aWZ5T3B0aW9ucztcbmZ1bmN0aW9uIG5vcm1hbGlzZU9wdGlvbnMob3B0aW9ucykge1xuICAgIC8qIERlcHJlY2F0ZWQgb3B0aW9ucyAqL1xuICAgIGlmIChvcHRpb25zLmhvc3QpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZXByZWNhdGVkKCdob3N0JywgJ3Jlc3RIb3N0Jyk7XG4gICAgICAgIG9wdGlvbnMucmVzdEhvc3QgPSBvcHRpb25zLmhvc3Q7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndzSG9zdCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlcHJlY2F0ZWQoJ3dzSG9zdCcsICdyZWFsdGltZUhvc3QnKTtcbiAgICAgICAgb3B0aW9ucy5yZWFsdGltZUhvc3QgPSBvcHRpb25zLndzSG9zdDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucXVldWVFdmVudHMpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZXByZWNhdGVkKCdxdWV1ZUV2ZW50cycsICdxdWV1ZU1lc3NhZ2VzJyk7XG4gICAgICAgIG9wdGlvbnMucXVldWVNZXNzYWdlcyA9IG9wdGlvbnMucXVldWVFdmVudHM7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZhbGxiYWNrSG9zdHNVc2VEZWZhdWx0KSB7XG4gICAgICAgIC8qIGZhbGxiYWNrSG9zdHNVc2VEZWZhdWx0IGFuZCBmYWxsYmFja0hvc3RzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUgYXMgcGVyIFRPM2s3ICovXG4gICAgICAgIGlmIChvcHRpb25zLmZhbGxiYWNrSG9zdHMpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnZmFsbGJhY2tIb3N0cyBhbmQgZmFsbGJhY2tIb3N0c1VzZURlZmF1bHQgY2Fubm90IGJvdGggYmUgc2V0JztcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9ucycsIG1zZyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDQwMDAwLCA0MDApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGRlZmF1bHQgZmFsbGJhY2tzIGNhbid0IGJlIHVzZWQgd2l0aCBjdXN0b20gcG9ydHMgKi9cbiAgICAgICAgaWYgKG9wdGlvbnMucG9ydCB8fCBvcHRpb25zLnRsc1BvcnQpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnZmFsbGJhY2tIb3N0c1VzZURlZmF1bHQgY2Fubm90IGJlIHNldCB3aGVuIHBvcnQgb3IgdGxzUG9ydCBhcmUgc2V0JztcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9ucycsIG1zZyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDQwMDAwLCA0MDApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGVtaXQgYW4gYXBwcm9wcmlhdGUgZGVwcmVjYXRpb24gd2FybmluZyAqL1xuICAgICAgICBpZiAob3B0aW9ucy5lbnZpcm9ubWVudCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZXByZWNhdGVkV2l0aE1zZygnZmFsbGJhY2tIb3N0c1VzZURlZmF1bHQnLCAnVGhlcmUgaXMgbm8gbG9uZ2VyIGEgbmVlZCB0byBzZXQgdGhpcyB3aGVuIHRoZSBlbnZpcm9ubWVudCBvcHRpb24gaXMgYWxzbyBzZXQgc2luY2UgdGhlIGxpYnJhcnkgd2lsbCBub3cgZ2VuZXJhdGUgdGhlIGNvcnJlY3QgZmFsbGJhY2sgaG9zdHMgdXNpbmcgdGhlIGVudmlyb25tZW50IG9wdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZGVwcmVjYXRlZCgnZmFsbGJhY2tIb3N0c1VzZURlZmF1bHQnLCAnZmFsbGJhY2tIb3N0czogQWJseS5EZWZhdWx0cy5GQUxMQkFDS19IT1NUUycpO1xuICAgICAgICB9XG4gICAgICAgIC8qIHVzZSB0aGUgZGVmYXVsdCBmYWxsYmFjayBob3N0cyBhcyByZXF1ZXN0ZWQgKi9cbiAgICAgICAgb3B0aW9ucy5mYWxsYmFja0hvc3RzID0gRGVmYXVsdHMuRkFMTEJBQ0tfSE9TVFM7XG4gICAgfVxuICAgIC8qIG9wdGlvbnMucmVjb3ZlciBhcyBhIGJvb2xlYW4gaXMgZGVwcmVjYXRlZCwgYW5kIHRoZXJlZm9yZSBpcyBub3QgcGFydCBvZiB0aGUgcHVibGljIHR5cGluZyAqL1xuICAgIGlmIChvcHRpb25zLnJlY292ZXIgPT09IHRydWUpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZXByZWNhdGVkKCd7cmVjb3ZlcjogdHJ1ZX0nLCAne3JlY292ZXI6IGZ1bmN0aW9uKGxhc3RDb25uZWN0aW9uRGV0YWlscywgY2IpIHsgY2IodHJ1ZSk7IH19Jyk7XG4gICAgICAgIG9wdGlvbnMucmVjb3ZlciA9IGZ1bmN0aW9uIChsYXN0Q29ubmVjdGlvbkRldGFpbHMsIGNiKSB7XG4gICAgICAgICAgICBjYih0cnVlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlY292ZXIgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy5jbG9zZU9uVW5sb2FkID09PSB0cnVlKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9ucycsICdjbG9zZU9uVW5sb2FkIHdhcyB0cnVlIGFuZCBhIHNlc3Npb24gcmVjb3ZlcnkgZnVuY3Rpb24gd2FzIHNldCAtIHRoZXNlIGFyZSBtdXR1YWxseSBleGNsdXNpdmUsIHNvIHVuc2V0dGluZyB0aGUgbGF0dGVyJyk7XG4gICAgICAgIG9wdGlvbnMucmVjb3ZlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCEoJ2Nsb3NlT25VbmxvYWQnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgIC8qIEhhdmUgY2xvc2VPblVubG9hZCBkZWZhdWx0IHRvIHRydWUgdW5sZXNzIHdlIGhhdmUgYW55IGluZGljYXRpb24gdGhhdFxuICAgICAgICAgKiB0aGUgdXNlciBtYXkgd2FudCB0byByZWNvdmVyIHRoZSBjb25uZWN0aW9uICovXG4gICAgICAgIG9wdGlvbnMuY2xvc2VPblVubG9hZCA9ICFvcHRpb25zLnJlY292ZXI7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRyYW5zcG9ydHMgJiYgVXRpbHMuYXJySW4ob3B0aW9ucy50cmFuc3BvcnRzLCAneGhyJykpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZXByZWNhdGVkKCd0cmFuc3BvcnRzOiBbXCJ4aHJcIl0nLCAndHJhbnNwb3J0czogW1wieGhyX3N0cmVhbWluZ1wiXScpO1xuICAgICAgICBVdGlscy5hcnJEZWxldGVWYWx1ZShvcHRpb25zLnRyYW5zcG9ydHMsICd4aHInKTtcbiAgICAgICAgb3B0aW9ucy50cmFuc3BvcnRzLnB1c2goJ3hocl9zdHJlYW1pbmcnKTtcbiAgICB9XG4gICAgaWYgKCEoJ3F1ZXVlTWVzc2FnZXMnIGluIG9wdGlvbnMpKVxuICAgICAgICBvcHRpb25zLnF1ZXVlTWVzc2FnZXMgPSB0cnVlO1xuICAgIC8qIGluZmVyIGhvc3RzIGFuZCBmYWxsYmFja3MgYmFzZWQgb24gdGhlIGNvbmZpZ3VyZWQgZW52aXJvbm1lbnQgKi9cbiAgICB2YXIgZW52aXJvbm1lbnQgPSAob3B0aW9ucy5lbnZpcm9ubWVudCAmJiBTdHJpbmcob3B0aW9ucy5lbnZpcm9ubWVudCkudG9Mb3dlckNhc2UoKSkgfHwgRGVmYXVsdHMuRU5WSVJPTk1FTlQ7XG4gICAgdmFyIHByb2R1Y3Rpb24gPSAhZW52aXJvbm1lbnQgfHwgZW52aXJvbm1lbnQgPT09ICdwcm9kdWN0aW9uJztcbiAgICBpZiAoIW9wdGlvbnMuZmFsbGJhY2tIb3N0cyAmJiAhb3B0aW9ucy5yZXN0SG9zdCAmJiAhb3B0aW9ucy5yZWFsdGltZUhvc3QgJiYgIW9wdGlvbnMucG9ydCAmJiAhb3B0aW9ucy50bHNQb3J0KSB7XG4gICAgICAgIG9wdGlvbnMuZmFsbGJhY2tIb3N0cyA9IHByb2R1Y3Rpb24gPyBEZWZhdWx0cy5GQUxMQkFDS19IT1NUUyA6IGVudmlyb25tZW50RmFsbGJhY2tIb3N0cyhlbnZpcm9ubWVudCk7XG4gICAgfVxuICAgIHZhciByZXN0SG9zdCA9IG9wdGlvbnMucmVzdEhvc3QgfHwgKHByb2R1Y3Rpb24gPyBEZWZhdWx0cy5SRVNUX0hPU1QgOiBlbnZpcm9ubWVudCArICctJyArIERlZmF1bHRzLlJFU1RfSE9TVCk7XG4gICAgdmFyIHJlYWx0aW1lSG9zdCA9IGdldFJlYWx0aW1lSG9zdChvcHRpb25zLCBwcm9kdWN0aW9uLCBlbnZpcm9ubWVudCk7XG4gICAgVXRpbHMuYXJyRm9yRWFjaCgob3B0aW9ucy5mYWxsYmFja0hvc3RzIHx8IFtdKS5jb25jYXQocmVzdEhvc3QsIHJlYWx0aW1lSG9zdCksIGNoZWNrSG9zdCk7XG4gICAgb3B0aW9ucy5wb3J0ID0gb3B0aW9ucy5wb3J0IHx8IERlZmF1bHRzLlBPUlQ7XG4gICAgb3B0aW9ucy50bHNQb3J0ID0gb3B0aW9ucy50bHNQb3J0IHx8IERlZmF1bHRzLlRMU19QT1JUO1xuICAgIGlmICghKCd0bHMnIGluIG9wdGlvbnMpKVxuICAgICAgICBvcHRpb25zLnRscyA9IHRydWU7XG4gICAgdmFyIHRpbWVvdXRzID0gZ2V0VGltZW91dHMob3B0aW9ucyk7XG4gICAgaWYgKCd1c2VCaW5hcnlQcm90b2NvbCcgaW4gb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID0gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5zdXBwb3J0c0JpbmFyeSAmJiBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA9IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcucHJlZmVyQmluYXJ5O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jbGllbnRJZCkge1xuICAgICAgICB2YXIgaGVhZGVycyA9IChvcHRpb25zLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge30pO1xuICAgICAgICBoZWFkZXJzWydYLUFibHktQ2xpZW50SWQnXSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUocGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUob3B0aW9ucy5jbGllbnRJZCkpO1xuICAgIH1cbiAgICBpZiAoISgnaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nJyBpbiBvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zLmlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnByb21pc2VzICYmICFwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLlByb21pc2UpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zJywgJ3twcm9taXNlczogdHJ1ZX0gd2FzIHNwZWNpZmllZCwgYnV0IG5vIFByb21pc2UgY29uc3RydWN0b3IgZm91bmQ7IGRpc2FibGluZyBwcm9taXNlcycpO1xuICAgICAgICBvcHRpb25zLnByb21pc2VzID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjb25uZWN0aXZpdHlDaGVja1BhcmFtcyA9IG51bGw7XG4gICAgdmFyIGNvbm5lY3Rpdml0eUNoZWNrVXJsID0gb3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybDtcbiAgICBpZiAob3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybCkge1xuICAgICAgICB2YXIgX2EgPSBvcHRpb25zLmNvbm5lY3Rpdml0eUNoZWNrVXJsLnNwbGl0KCc/JyksIHVyaSA9IF9hWzBdLCBxcyA9IF9hWzFdO1xuICAgICAgICBjb25uZWN0aXZpdHlDaGVja1BhcmFtcyA9IHFzID8gVXRpbHMucGFyc2VRdWVyeVN0cmluZyhxcykgOiB7fTtcbiAgICAgICAgaWYgKHVyaS5pbmRleE9mKCc6Ly8nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHVyaSA9ICdodHRwczovLycgKyB1cmk7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGl2aXR5Q2hlY2tVcmwgPSB1cmk7XG4gICAgfVxuICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHVzZUJpbmFyeVByb3RvY29sOiAndXNlQmluYXJ5UHJvdG9jb2wnIGluIG9wdGlvbnNcbiAgICAgICAgICAgID8gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5zdXBwb3J0c0JpbmFyeSAmJiBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sXG4gICAgICAgICAgICA6IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcucHJlZmVyQmluYXJ5LCByZWFsdGltZUhvc3Q6IHJlYWx0aW1lSG9zdCwgcmVzdEhvc3Q6IHJlc3RIb3N0LCBtYXhNZXNzYWdlU2l6ZTogb3B0aW9ucy5tYXhNZXNzYWdlU2l6ZSB8fCBEZWZhdWx0cy5tYXhNZXNzYWdlU2l6ZSwgdGltZW91dHM6IHRpbWVvdXRzLCBjb25uZWN0aXZpdHlDaGVja1BhcmFtczogY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXMsIGNvbm5lY3Rpdml0eUNoZWNrVXJsOiBjb25uZWN0aXZpdHlDaGVja1VybCB9KTtcbn1cbmV4cG9ydHMubm9ybWFsaXNlT3B0aW9ucyA9IG5vcm1hbGlzZU9wdGlvbnM7XG5leHBvcnRzLmRlZmF1bHQgPSBEZWZhdWx0cztcbmZ1bmN0aW9uIGdldERlZmF1bHRzKHBsYXRmb3JtRGVmYXVsdHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihEZWZhdWx0cywgcGxhdGZvcm1EZWZhdWx0cyk7XG59XG5leHBvcnRzLmdldERlZmF1bHRzID0gZ2V0RGVmYXVsdHM7XG5cblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xuZnVuY3Rpb24gbm9ybWFsaXNlQ29udGV4dChjb250ZXh0KSB7XG4gICAgaWYgKCFjb250ZXh0IHx8ICFjb250ZXh0LmNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFubmVsT3B0aW9uczogY29udGV4dCxcbiAgICAgICAgICAgIHBsdWdpbnM6IHt9LFxuICAgICAgICAgICAgYmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDaXBoZXJPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNpcGhlcikge1xuICAgICAgICBpZiAoIXBsYXRmb3JtXzEuZGVmYXVsdC5DcnlwdG8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gbm90IGVuYWJsZWQ7IHVzZSBhYmx5LmVuY3J5cHRpb24uanMgaW5zdGVhZCcpO1xuICAgICAgICB2YXIgY2lwaGVyID0gcGxhdGZvcm1fMS5kZWZhdWx0LkNyeXB0by5nZXRDaXBoZXIob3B0aW9ucy5jaXBoZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2lwaGVyOiBjaXBoZXIuY2lwaGVyUGFyYW1zLFxuICAgICAgICAgICAgY2hhbm5lbENpcGhlcjogY2lwaGVyLmNpcGhlcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9O1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZVNpemUobXNnKSB7XG4gICAgdmFyIHNpemUgPSAwO1xuICAgIGlmIChtc2cubmFtZSkge1xuICAgICAgICBzaXplICs9IG1zZy5uYW1lLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKG1zZy5jbGllbnRJZCkge1xuICAgICAgICBzaXplICs9IG1zZy5jbGllbnRJZC5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChtc2cuZXh0cmFzKSB7XG4gICAgICAgIHNpemUgKz0gSlNPTi5zdHJpbmdpZnkobXNnLmV4dHJhcykubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobXNnLmRhdGEpIHtcbiAgICAgICAgc2l6ZSArPSBVdGlscy5kYXRhU2l6ZUJ5dGVzKG1zZy5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG52YXIgTWVzc2FnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXNzYWdlKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVybG9hZCB0b0pTT04oKSB0byBpbnRlcmNlcHQgSlNPTi5zdHJpbmdpZnkoKVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG4gICAgTWVzc2FnZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiBlbmNvZGUgZGF0YSB0byBiYXNlNjQgaWYgcHJlc2VudCBhbmQgd2UncmUgcmV0dXJuaW5nIHJlYWwgSlNPTjtcbiAgICAgICAgICogYWx0aG91Z2ggbXNncGFjayBjYWxscyB0b0pTT04oKSwgd2Uga25vdyBpdCBpcyBhIHN0cmluZ2lmeSgpXG4gICAgICAgICAqIGNhbGwgaWYgaXQgaGFzIGEgbm9uLWVtcHR5IGFyZ3VtZW50cyBsaXN0ICovXG4gICAgICAgIHZhciBlbmNvZGluZyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBpZiAoZGF0YSAmJiBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8qIHN0cmluZ2lmeSBjYWxsICovXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyA/IGVuY29kaW5nICsgJy9iYXNlNjQnIDogJ2Jhc2U2NCc7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBDYWxsZWQgYnkgbXNncGFjay4gdG9CdWZmZXIgcmV0dXJucyBhIGRhdGF0eXBlIHVuZGVyc3RhbmRhYmxlIGJ5XG4gICAgICAgICAgICAgICAgICogdGhhdCBwbGF0Zm9ybSdzIG1zZ3BhY2sgaW1wbGVtZW50YXRpb24gKEJ1ZmZlciBpbiBub2RlLCBVaW50OEFycmF5XG4gICAgICAgICAgICAgICAgICogaW4gYnJvd3NlcnMpICovXG4gICAgICAgICAgICAgICAgZGF0YSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy50b0J1ZmZlcihkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogdGhpcy5jb25uZWN0aW9uSWQsXG4gICAgICAgICAgICBjb25uZWN0aW9uS2V5OiB0aGlzLmNvbm5lY3Rpb25LZXksXG4gICAgICAgICAgICBleHRyYXM6IHRoaXMuZXh0cmFzLFxuICAgICAgICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1lc3NhZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJ1tNZXNzYWdlJztcbiAgICAgICAgaWYgKHRoaXMubmFtZSlcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBuYW1lPScgKyB0aGlzLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLmlkKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGlkPScgKyB0aGlzLmlkO1xuICAgICAgICBpZiAodGhpcy50aW1lc3RhbXApXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgdGltZXN0YW1wPScgKyB0aGlzLnRpbWVzdGFtcDtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50SWQpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgY2xpZW50SWQ9JyArIHRoaXMuY2xpZW50SWQ7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25JZClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBjb25uZWN0aW9uSWQ9JyArIHRoaXMuY29ubmVjdGlvbklkO1xuICAgICAgICBpZiAodGhpcy5lbmNvZGluZylcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBlbmNvZGluZz0nICsgdGhpcy5lbmNvZGluZztcbiAgICAgICAgaWYgKHRoaXMuZXh0cmFzKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGV4dHJhcyA9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZXh0cmFzKTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRhdGEgPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGRhdGE9JyArIHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5pc0J1ZmZlcih0aGlzLmRhdGEpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnOyBkYXRhIChidWZmZXIpPScgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKHRoaXMuZGF0YSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGRhdGEgKGpzb24pPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4dHJhcylcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBleHRyYXM9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZXh0cmFzKTtcbiAgICAgICAgcmVzdWx0ICs9ICddJztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE1lc3NhZ2UuZW5jcnlwdCA9IGZ1bmN0aW9uIChtc2csIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkYXRhID0gbXNnLmRhdGEsIGVuY29kaW5nID0gbXNnLmVuY29kaW5nLCBjaXBoZXIgPSBvcHRpb25zLmNoYW5uZWxDaXBoZXI7XG4gICAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgPyBlbmNvZGluZyArICcvJyA6ICcnO1xuICAgICAgICBpZiAoIXBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgZGF0YSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy51dGY4RW5jb2RlKFN0cmluZyhkYXRhKSk7XG4gICAgICAgICAgICBlbmNvZGluZyA9IGVuY29kaW5nICsgJ3V0Zi04Lyc7XG4gICAgICAgIH1cbiAgICAgICAgY2lwaGVyLmVuY3J5cHQoZGF0YSwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXNnLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgbXNnLmVuY29kaW5nID0gZW5jb2RpbmcgKyAnY2lwaGVyKycgKyBjaXBoZXIuYWxnb3JpdGhtO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbXNnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNZXNzYWdlLmVuY29kZSA9IGZ1bmN0aW9uIChtc2csIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkYXRhID0gbXNnLmRhdGE7XG4gICAgICAgIHZhciBuYXRpdmVEYXRhVHlwZSA9IHR5cGVvZiBkYXRhID09ICdzdHJpbmcnIHx8IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5pc0J1ZmZlcihkYXRhKSB8fCBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFuYXRpdmVEYXRhVHlwZSkge1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0KGRhdGEpIHx8IFV0aWxzLmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBtc2cuZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICAgICAgICAgIG1zZy5lbmNvZGluZyA9IG1zZy5lbmNvZGluZyA/IG1zZy5lbmNvZGluZyArICcvanNvbicgOiAnanNvbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnRGF0YSB0eXBlIGlzIHVuc3VwcG9ydGVkJywgNDAwMTMsIDQwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmNpcGhlcikge1xuICAgICAgICAgICAgTWVzc2FnZS5lbmNyeXB0KG1zZywgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbXNnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVzc2FnZS5lbmNvZGVBcnJheSA9IGZ1bmN0aW9uIChtZXNzYWdlcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHByb2Nlc3NlZCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIE1lc3NhZ2UuZW5jb2RlKG1lc3NhZ2VzW2ldLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZCsrO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzZWQgPT0gbWVzc2FnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVzc2FnZS5kZWNvZGUgPSBmdW5jdGlvbiAobWVzc2FnZSwgaW5wdXRDb250ZXh0KSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gbm9ybWFsaXNlQ29udGV4dChpbnB1dENvbnRleHQpO1xuICAgICAgICB2YXIgbGFzdFBheWxvYWQgPSBtZXNzYWdlLmRhdGE7XG4gICAgICAgIHZhciBlbmNvZGluZyA9IG1lc3NhZ2UuZW5jb2Rpbmc7XG4gICAgICAgIGlmIChlbmNvZGluZykge1xuICAgICAgICAgICAgdmFyIHhmb3JtcyA9IGVuY29kaW5nLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICB2YXIgbGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXggPSB2b2lkIDAsIGVuY29kaW5nc1RvUHJvY2VzcyA9IHhmb3Jtcy5sZW5ndGgsIGRhdGEgPSBtZXNzYWdlLmRhdGE7XG4gICAgICAgICAgICB2YXIgeGZvcm0gPSAnJztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCA9IGVuY29kaW5nc1RvUHJvY2VzcykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzZWN1cml0eS9kZXRlY3QtdW5zYWZlLXJlZ2V4XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHhmb3Jtc1stLWVuY29kaW5nc1RvUHJvY2Vzc10ubWF0Y2goLyhbLVxcd10rKShcXCsoW1xcdy1dKykpPy8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIHhmb3JtID0gbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoeGZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5iYXNlNjREZWNvZGUoU3RyaW5nKGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXggPT0geGZvcm1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UGF5bG9hZCA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMudXRmOERlY29kZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2lwaGVyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5jaGFubmVsT3B0aW9ucyAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2hhbm5lbE9wdGlvbnMuY2lwaGVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2hhbm5lbE9wdGlvbnMuY2hhbm5lbENpcGhlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeGZvcm1BbGdvcml0aG0gPSBtYXRjaFszXSwgY2lwaGVyID0gY29udGV4dC5jaGFubmVsT3B0aW9ucy5jaGFubmVsQ2lwaGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkb24ndCBhdHRlbXB0IHRvIGRlY3J5cHQgdW5sZXNzIHRoZSBjaXBoZXIgcGFyYW1zIGFyZSBjb21wYXRpYmxlICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4Zm9ybUFsZ29yaXRobSAhPSBjaXBoZXIuYWxnb3JpdGhtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZWNyeXB0IG1lc3NhZ2Ugd2l0aCBnaXZlbiBjaXBoZXI7IGluY29tcGF0aWJsZSBjaXBoZXIgcGFyYW1zJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGNpcGhlci5kZWNyeXB0KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGRlY3J5cHQgbWVzc2FnZTsgbm90IGFuIGVuY3J5cHRlZCBjaGFubmVsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndmNkaWZmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQucGx1Z2lucyB8fCAhY29udGV4dC5wbHVnaW5zLnZjZGlmZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnTWlzc2luZyBWY2RpZmYgZGVjb2RlciAoaHR0cHM6Ly9naXRodWIuY29tL2FibHktZm9ya3MvdmNkaWZmLWRlY29kZXIpJywgNDAwMTksIDQwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0RlbHRhIGRlY29kaW5nIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyIChuZWVkIEFycmF5QnVmZmVyICYgVWludDhBcnJheSknLCA0MDAyMCwgNDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhQmFzZSA9IGNvbnRleHQuYmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVsdGFCYXNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFCYXNlID0gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUoZGVsdGFCYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiB2Y2RpZmYgZXhwZWN0cyBVaW50OEFycmF5cywgY2FuJ3QgY29weSB3aXRoIEFycmF5QnVmZmVycy4gKGFsc28sIGlmIHdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGRvbid0IGhhdmUgYSBUZXh0RGVjb2RlciwgZGVsdGFCYXNlIG1pZ2h0IGJlIGEgV29yZEFycmF5IGhlcmUsIHNvIG5lZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogdG8gcHJvY2VzcyBpdCBpbnRvIGEgYnVmZmVyIGFueXdheSkgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFCYXNlID0gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLnRvQnVmZmVyKGRlbHRhQmFzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMudG9CdWZmZXIoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMudHlwZWRBcnJheVRvQnVmZmVyKGNvbnRleHQucGx1Z2lucy52Y2RpZmYuZGVjb2RlKGRhdGEsIGRlbHRhQmFzZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UGF5bG9hZCA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdWY2RpZmYgZGVsdGEgZGVjb2RlIGZhaWxlZCB3aXRoICcgKyBlLCA0MDAxOCwgNDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnRXJyb3IgcHJvY2Vzc2luZyB0aGUgJyArIHhmb3JtICsgJyBlbmNvZGluZywgZGVjb2RlciByZXR1cm5lZCDigJgnICsgZXJyLm1lc3NhZ2UgKyAn4oCZJywgZXJyLmNvZGUgfHwgNDAwMTMsIDQwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmVuY29kaW5nID1cbiAgICAgICAgICAgICAgICAgICAgbGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXggPD0gMCA/IG51bGwgOiB4Zm9ybXMuc2xpY2UoMCwgbGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXgpLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuYmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQgPSBsYXN0UGF5bG9hZDtcbiAgICB9O1xuICAgIE1lc3NhZ2UuZnJvbVJlc3BvbnNlQm9keSA9IGZ1bmN0aW9uIChib2R5LCBvcHRpb25zLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgYm9keSA9IFV0aWxzLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAoYm9keVtpXSA9IE1lc3NhZ2UuZnJvbVZhbHVlcyhib2R5W2ldKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIE1lc3NhZ2UuZGVjb2RlKG1zZywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnTWVzc2FnZS5mcm9tUmVzcG9uc2VCb2R5KCknLCBlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib2R5O1xuICAgIH07XG4gICAgTWVzc2FnZS5mcm9tVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgTWVzc2FnZSgpLCB2YWx1ZXMpO1xuICAgIH07XG4gICAgTWVzc2FnZS5mcm9tVmFsdWVzQXJyYXkgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IE1lc3NhZ2UuZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWVzc2FnZS5mcm9tRW5jb2RlZCA9IGZ1bmN0aW9uIChlbmNvZGVkLCBpbnB1dE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1zZyA9IE1lc3NhZ2UuZnJvbVZhbHVlcyhlbmNvZGVkKTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVDaXBoZXJPcHRpb25zKGlucHV0T3B0aW9ucyAhPT0gbnVsbCAmJiBpbnB1dE9wdGlvbnMgIT09IHZvaWQgMCA/IGlucHV0T3B0aW9ucyA6IG51bGwpO1xuICAgICAgICAvKiBpZiBkZWNvZGluZyBmYWlscyBhdCBhbnkgcG9pbnQsIGNhdGNoIGFuZCByZXR1cm4gdGhlIG1lc3NhZ2UgZGVjb2RlZCB0b1xuICAgICAgICAgKiB0aGUgZnVsbGVzdCBleHRlbnQgcG9zc2libGUgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIE1lc3NhZ2UuZGVjb2RlKG1zZywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnTWVzc2FnZS5mcm9tRW5jb2RlZCgpJywgZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXNnO1xuICAgIH07XG4gICAgTWVzc2FnZS5mcm9tRW5jb2RlZEFycmF5ID0gZnVuY3Rpb24gKGVuY29kZWRBcnJheSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZW5jb2RlZEFycmF5Lm1hcChmdW5jdGlvbiAoZW5jb2RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIE1lc3NhZ2UuZnJvbUVuY29kZWQoZW5jb2RlZCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyogVGhpcyBzaG91bGQgYmUgY2FsbGVkIG9uIGVuY29kZSgpZCAoYW5kIGVuY3J5cHQoKWQpIE1lc3NhZ2VzIChhcyBpdFxuICAgICAqIGFzc3VtZXMgdGhlIGRhdGEgaXMgYSBzdHJpbmcgb3IgYnVmZmVyKSAqL1xuICAgIE1lc3NhZ2UuZ2V0TWVzc2FnZXNTaXplID0gZnVuY3Rpb24gKG1lc3NhZ2VzKSB7XG4gICAgICAgIHZhciBtc2csIHRvdGFsID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbXNnID0gbWVzc2FnZXNbaV07XG4gICAgICAgICAgICB0b3RhbCArPSBtc2cuc2l6ZSB8fCAobXNnLnNpemUgPSBnZXRNZXNzYWdlU2l6ZShtc2cpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfTtcbiAgICBNZXNzYWdlLnNlcmlhbGl6ZSA9IFV0aWxzLmVuY29kZUJvZHk7XG4gICAgcmV0dXJuIE1lc3NhZ2U7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTWVzc2FnZTtcblxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOSkpO1xudmFyIHByZXNlbmNlbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNSkpO1xudmFyIGFjdGlvbnMgPSB7XG4gICAgSEVBUlRCRUFUOiAwLFxuICAgIEFDSzogMSxcbiAgICBOQUNLOiAyLFxuICAgIENPTk5FQ1Q6IDMsXG4gICAgQ09OTkVDVEVEOiA0LFxuICAgIERJU0NPTk5FQ1Q6IDUsXG4gICAgRElTQ09OTkVDVEVEOiA2LFxuICAgIENMT1NFOiA3LFxuICAgIENMT1NFRDogOCxcbiAgICBFUlJPUjogOSxcbiAgICBBVFRBQ0g6IDEwLFxuICAgIEFUVEFDSEVEOiAxMSxcbiAgICBERVRBQ0g6IDEyLFxuICAgIERFVEFDSEVEOiAxMyxcbiAgICBQUkVTRU5DRTogMTQsXG4gICAgTUVTU0FHRTogMTUsXG4gICAgU1lOQzogMTYsXG4gICAgQVVUSDogMTcsXG4gICAgQUNUSVZBVEU6IDE4LFxufTtcbnZhciBBY3Rpb25OYW1lID0gW107XG5PYmplY3Qua2V5cyhhY3Rpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgQWN0aW9uTmFtZVthY3Rpb25zW25hbWVdXSA9IG5hbWU7XG59KTtcbnZhciBmbGFncyA9IHtcbiAgICAvKiBDaGFubmVsIGF0dGFjaCBzdGF0ZSBmbGFncyAqL1xuICAgIEhBU19QUkVTRU5DRTogMSA8PCAwLFxuICAgIEhBU19CQUNLTE9HOiAxIDw8IDEsXG4gICAgUkVTVU1FRDogMSA8PCAyLFxuICAgIFRSQU5TSUVOVDogMSA8PCA0LFxuICAgIEFUVEFDSF9SRVNVTUU6IDEgPDwgNSxcbiAgICAvKiBDaGFubmVsIG1vZGUgZmxhZ3MgKi9cbiAgICBQUkVTRU5DRTogMSA8PCAxNixcbiAgICBQVUJMSVNIOiAxIDw8IDE3LFxuICAgIFNVQlNDUklCRTogMSA8PCAxOCxcbiAgICBQUkVTRU5DRV9TVUJTQ1JJQkU6IDEgPDwgMTksXG59O1xudmFyIGZsYWdOYW1lcyA9IE9iamVjdC5rZXlzKGZsYWdzKTtcbmZsYWdzLk1PREVfQUxMID0gZmxhZ3MuUFJFU0VOQ0UgfCBmbGFncy5QVUJMSVNIIHwgZmxhZ3MuU1VCU0NSSUJFIHwgZmxhZ3MuUFJFU0VOQ0VfU1VCU0NSSUJFO1xuZnVuY3Rpb24gdG9TdHJpbmdBcnJheShhcnJheSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0udG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdbICcgKyByZXN1bHQuam9pbignLCAnKSArICcgXSc7XG59XG52YXIgc2ltcGxlQXR0cmlidXRlcyA9ICdpZCBjaGFubmVsIGNoYW5uZWxTZXJpYWwgY29ubmVjdGlvbklkIGNvdW50IG1zZ1NlcmlhbCB0aW1lc3RhbXAnLnNwbGl0KCcgJyk7XG52YXIgUHJvdG9jb2xNZXNzYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByb3RvY29sTWVzc2FnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5oYXNGbGFnID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgICAgIHJldHVybiAoX3RoaXMuZmxhZ3MgJiBmbGFnc1tmbGFnXSkgPiAwO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcm90b2NvbE1lc3NhZ2UucHJvdG90eXBlLnNldEZsYWcgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgPSB0aGlzLmZsYWdzIHwgZmxhZ3NbZmxhZ10pO1xuICAgIH07XG4gICAgUHJvdG9jb2xNZXNzYWdlLnByb3RvdHlwZS5nZXRNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGFncyAmJiB0aGlzLmZsYWdzICYgZmxhZ3MuTU9ERV9BTEw7XG4gICAgfTtcbiAgICBQcm90b2NvbE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZU1vZGVzVG9GbGFncyA9IGZ1bmN0aW9uIChtb2Rlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBtb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlKSB7IHJldHVybiBfdGhpcy5zZXRGbGFnKG1vZGUpOyB9KTtcbiAgICB9O1xuICAgIFByb3RvY29sTWVzc2FnZS5wcm90b3R5cGUuZGVjb2RlTW9kZXNGcm9tRmxhZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtb2RlcyA9IFtdO1xuICAgICAgICBQcm90b2NvbE1lc3NhZ2UuY2hhbm5lbE1vZGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZGUpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5oYXNGbGFnKG1vZGUpKSB7XG4gICAgICAgICAgICAgICAgbW9kZXMucHVzaChtb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtb2Rlcy5sZW5ndGggPiAwID8gbW9kZXMgOiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBQcm90b2NvbE1lc3NhZ2UuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFByb3RvY29sTWVzc2FnZSgpLCB2YWx1ZXMpO1xuICAgIH07XG4gICAgUHJvdG9jb2xNZXNzYWdlLkFjdGlvbiA9IGFjdGlvbnM7XG4gICAgUHJvdG9jb2xNZXNzYWdlLmNoYW5uZWxNb2RlcyA9IFsnUFJFU0VOQ0UnLCAnUFVCTElTSCcsICdTVUJTQ1JJQkUnLCAnUFJFU0VOQ0VfU1VCU0NSSUJFJ107XG4gICAgUHJvdG9jb2xNZXNzYWdlLkFjdGlvbk5hbWUgPSBBY3Rpb25OYW1lO1xuICAgIFByb3RvY29sTWVzc2FnZS5zZXJpYWxpemUgPSBVdGlscy5lbmNvZGVCb2R5O1xuICAgIFByb3RvY29sTWVzc2FnZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChzZXJpYWxpemVkLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIGRlc2VyaWFsaXplZCA9IFV0aWxzLmRlY29kZUJvZHkoc2VyaWFsaXplZCwgZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIFByb3RvY29sTWVzc2FnZS5mcm9tRGVzZXJpYWxpemVkKGRlc2VyaWFsaXplZCk7XG4gICAgfTtcbiAgICBQcm90b2NvbE1lc3NhZ2UuZnJvbURlc2VyaWFsaXplZCA9IGZ1bmN0aW9uIChkZXNlcmlhbGl6ZWQpIHtcbiAgICAgICAgdmFyIGVycm9yID0gZGVzZXJpYWxpemVkLmVycm9yO1xuICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZWQuZXJyb3IgPSBlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMoZXJyb3IpO1xuICAgICAgICB2YXIgbWVzc2FnZXMgPSBkZXNlcmlhbGl6ZWQubWVzc2FnZXM7XG4gICAgICAgIGlmIChtZXNzYWdlcylcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgbWVzc2FnZXNbaV0gPSBtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKG1lc3NhZ2VzW2ldKTtcbiAgICAgICAgdmFyIHByZXNlbmNlID0gZGVzZXJpYWxpemVkLnByZXNlbmNlO1xuICAgICAgICBpZiAocHJlc2VuY2UpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXNlbmNlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHByZXNlbmNlW2ldID0gcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHByZXNlbmNlW2ldLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFByb3RvY29sTWVzc2FnZSgpLCBkZXNlcmlhbGl6ZWQpO1xuICAgIH07XG4gICAgUHJvdG9jb2xNZXNzYWdlLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICdbUHJvdG9jb2xNZXNzYWdlJztcbiAgICAgICAgaWYgKG1zZy5hY3Rpb24gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBhY3Rpb249JyArIFByb3RvY29sTWVzc2FnZS5BY3Rpb25OYW1lW21zZy5hY3Rpb25dIHx8IGZhbHNlO1xuICAgICAgICB2YXIgYXR0cmlidXRlO1xuICAgICAgICBmb3IgKHZhciBhdHRyaWJJbmRleCA9IDA7IGF0dHJpYkluZGV4IDwgc2ltcGxlQXR0cmlidXRlcy5sZW5ndGg7IGF0dHJpYkluZGV4KyspIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZSA9IHNpbXBsZUF0dHJpYnV0ZXNbYXR0cmliSW5kZXhdO1xuICAgICAgICAgICAgaWYgKG1zZ1thdHRyaWJ1dGVdICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICc7ICcgKyBhdHRyaWJ1dGUgKyAnPScgKyBtc2dbYXR0cmlidXRlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXNnLm1lc3NhZ2VzKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IG1lc3NhZ2VzPScgKyB0b1N0cmluZ0FycmF5KG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXNBcnJheShtc2cubWVzc2FnZXMpKTtcbiAgICAgICAgaWYgKG1zZy5wcmVzZW5jZSlcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBwcmVzZW5jZT0nICsgdG9TdHJpbmdBcnJheShwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXNBcnJheShtc2cucHJlc2VuY2UpKTtcbiAgICAgICAgaWYgKG1zZy5lcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBlcnJvcj0nICsgZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKG1zZy5lcnJvcikudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKG1zZy5hdXRoICYmIG1zZy5hdXRoLmFjY2Vzc1Rva2VuKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IHRva2VuPScgKyBtc2cuYXV0aC5hY2Nlc3NUb2tlbjtcbiAgICAgICAgaWYgKG1zZy5mbGFncylcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBmbGFncz0nICsgZmxhZ05hbWVzLmZpbHRlcihtc2cuaGFzRmxhZykuam9pbignLCcpO1xuICAgICAgICBpZiAobXNnLnBhcmFtcykge1xuICAgICAgICAgICAgdmFyIHN0cmluZ2lmaWVkUGFyYW1zXzEgPSAnJztcbiAgICAgICAgICAgIFV0aWxzLmZvckluT3duTm9uTnVsbFByb3BlcnRpZXMobXNnLnBhcmFtcywgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5naWZpZWRQYXJhbXNfMS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVkUGFyYW1zXzEgKz0gJzsgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZWRQYXJhbXNfMSArPSBwcm9wICsgJz0nICsgbXNnLnBhcmFtc1twcm9wXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHN0cmluZ2lmaWVkUGFyYW1zXzEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnOyBwYXJhbXM9WycgKyBzdHJpbmdpZmllZFBhcmFtc18xICsgJ10nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnXSc7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvdG9jb2xNZXNzYWdlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFByb3RvY29sTWVzc2FnZTtcblxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQmFzZTY0IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgQmFzZTY0ID0gQ19lbmMuQmFzZTY0ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGJhc2U2NFN0cmluZyA9IENyeXB0b0pTLmVuYy5CYXNlNjQuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIG1hcCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAgd29yZEFycmF5LmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgYmFzZTY0Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTEgPSAod29yZHNbaSA+Pj4gMl0gICAgICAgPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgICAgICAgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUyID0gKHdvcmRzWyhpICsgMSkgPj4+IDJdID4+PiAoMjQgLSAoKGkgKyAxKSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMyA9ICh3b3Jkc1soaSArIDIpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMikgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0cmlwbGV0ID0gKGJ5dGUxIDw8IDE2KSB8IChieXRlMiA8PCA4KSB8IGJ5dGUzO1xuXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgKGogPCA0KSAmJiAoaSArIGogKiAwLjc1IDwgc2lnQnl0ZXMpOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKG1hcC5jaGFyQXQoKHRyaXBsZXQgPj4+ICg2ICogKDMgLSBqKSkpICYgMHgzZikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdDaGFyID0gbWFwLmNoYXJBdCg2NCk7XG5cdCAgICAgICAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKGJhc2U2NENoYXJzLmxlbmd0aCAlIDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKHBhZGRpbmdDaGFyKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBiYXNlNjRDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBCYXNlNjQgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRTdHIgVGhlIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5wYXJzZShiYXNlNjRTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoYmFzZTY0U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgYmFzZTY0U3RyTGVuZ3RoID0gYmFzZTY0U3RyLmxlbmd0aDtcblx0ICAgICAgICAgICAgdmFyIG1hcCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cdCAgICAgICAgICAgIHZhciByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcDtcblxuXHQgICAgICAgICAgICBpZiAoIXJldmVyc2VNYXApIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFwLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBbbWFwLmNoYXJDb2RlQXQoaildID0gajtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJZ25vcmUgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcblx0ICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0luZGV4ID0gYmFzZTY0U3RyLmluZGV4T2YocGFkZGluZ0NoYXIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhZGRpbmdJbmRleCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRTdHJMZW5ndGggPSBwYWRkaW5nSW5kZXg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHJldHVybiBwYXJzZUxvb3AoYmFzZTY0U3RyLCBiYXNlNjRTdHJMZW5ndGgsIHJldmVyc2VNYXApO1xuXG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gcGFyc2VMb29wKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCByZXZlcnNlTWFwKSB7XG5cdCAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICB2YXIgbkJ5dGVzID0gMDtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlNjRTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgaWYgKGkgJSA0KSB7XG5cdCAgICAgICAgICAgICAgdmFyIGJpdHMxID0gcmV2ZXJzZU1hcFtiYXNlNjRTdHIuY2hhckNvZGVBdChpIC0gMSldIDw8ICgoaSAlIDQpICogMik7XG5cdCAgICAgICAgICAgICAgdmFyIGJpdHMyID0gcmV2ZXJzZU1hcFtiYXNlNjRTdHIuY2hhckNvZGVBdChpKV0gPj4+ICg2IC0gKGkgJSA0KSAqIDIpO1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzQ29tYmluZWQgPSBiaXRzMSB8IGJpdHMyO1xuXHQgICAgICAgICAgICAgIHdvcmRzW25CeXRlcyA+Pj4gMl0gfD0gYml0c0NvbWJpbmVkIDw8ICgyNCAtIChuQnl0ZXMgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICAgIG5CeXRlcysrO1xuXHQgICAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCBuQnl0ZXMpO1xuXHQgICAgfVxuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmVuYy5CYXNlNjQ7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgcHJvdG9jb2xtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSk7XG52YXIgdHJhbnNwb3J0XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBkZWZhdWx0c18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg4KSk7XG52YXIgY29ubmVjdGlvbmVycm9yc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyMCkpO1xudmFyIGF1dGhfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTcpKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIFhIUlN0YXRlc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyMSkpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbi8qIFRPRE86IGNhbiByZW1vdmUgb25jZSByZWFsdGltZSBzZW5kcyBwcm90b2NvbCBtZXNzYWdlIHJlc3BvbnNlcyBmb3IgY29tZXQgZXJyb3JzICovXG5mdW5jdGlvbiBzaG91bGRCZUVycm9yQWN0aW9uKGVycikge1xuICAgIHZhciBVTlJFU09MVkFCTEVfRVJST1JfQ09ERVMgPSBbODAwMTUsIDgwMDE3LCA4MDAzMF07XG4gICAgaWYgKGVyci5jb2RlKSB7XG4gICAgICAgIGlmIChhdXRoXzEuZGVmYXVsdC5pc1Rva2VuRXJyKGVycikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChVdGlscy5hcnJJbihVTlJFU09MVkFCTEVfRVJST1JfQ09ERVMsIGVyci5jb2RlKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZXJyLmNvZGUgPj0gNDAwMDAgJiYgZXJyLmNvZGUgPCA1MDAwMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8qIExpa2VseSBhIG5ldHdvcmsgb3IgdHJhbnNwb3J0IGVycm9yIG9mIHNvbWUga2luZC4gQ2VydGFpbmx5IG5vdCBmYXRhbCB0byB0aGUgY29ubmVjdGlvbiAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikge1xuICAgIC8qIGVyciB3aWxsIGJlIGVpdGhlciBhIGxlZ2FjeSAobm9uLXByb3RvY29sbWVzc2FnZSkgY29tZXQgZXJyb3IgcmVzcG9uc2VcbiAgICAgKiAod2hpY2ggd2lsbCBoYXZlIGFuIGVyci5jb2RlKSwgb3IgYSB4aHIvbmV0d29yayBlcnJvciAod2hpY2ggd29uJ3QpLiAqL1xuICAgIGlmIChzaG91bGRCZUVycm9yQWN0aW9uKGVycikpIHtcbiAgICAgICAgcmV0dXJuIFtwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoeyBhY3Rpb246IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuQWN0aW9uLkVSUk9SLCBlcnJvcjogZXJyIH0pXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHsgYWN0aW9uOiBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LkFjdGlvbi5ESVNDT05ORUNURUQsIGVycm9yOiBlcnIgfSldO1xuICAgIH1cbn1cbi8qXG4gKiBBIGJhc2UgY29tZXQgdHJhbnNwb3J0IGNsYXNzXG4gKi9cbnZhciBDb21ldFRyYW5zcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb21ldFRyYW5zcG9ydCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21ldFRyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMsIC8qIGJpbmFyeSBub3Qgc3VwcG9ydGVkIGZvciBjb21ldCBzbyBmb3JjZSBKU09OIHByb3RvY29sICovIHRydWUpIHx8IHRoaXM7XG4gICAgICAgIC8qIEZvciBjb21ldCwgd2UgY291bGQgZG8gdGhlIGF1dGggdXBkYXRlIGJ5IGFib3J0aW5nIHRoZSBjdXJyZW50IHJlY3YgYW5kXG4gICAgICAgICAqIHN0YXJ0aW5nIGEgbmV3IG9uZSB3aXRoIHRoZSBuZXcgdG9rZW4sIHRoYXQnZCBiZSBzdWZmaWNpZW50IGZvciByZWFsdGltZS5cbiAgICAgICAgICogUHJvYmxlbSBpcyBKU09OUCAtIHlvdSBjYW4ndCBjYW5jZWwgdHJ1bHkgYWJvcnQgYSByZWN2IG9uY2Ugc3RhcnRlZC4gU29cbiAgICAgICAgICogd2UgbmVlZCB0byBzZW5kIGFuIEFVVEggZm9yIGpzb25wLiBJbiB3aGljaCBjYXNlIGl0J3Mgc2ltcGxlciB0byBrZWVwIGFsbFxuICAgICAgICAgKiBjb21ldCB0cmFuc3BvcnRzIHRoZSBzYW1lIGFuZCBkbyBpdCBmb3IgYWxsIG9mIHRoZW0uIFNvIHdlIHNlbmQgdGhlIEFVVEhcbiAgICAgICAgICogaW5zdGVhZCwgYW5kIGRvbid0IG5lZWQgdG8gYWJvcnQgdGhlIHJlY3YgKi9cbiAgICAgICAgX3RoaXMub25BdXRoVXBkYXRlZCA9IGZ1bmN0aW9uICh0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgICAgIF90aGlzLmF1dGhQYXJhbXMgPSB7IGFjY2Vzc190b2tlbjogdG9rZW5EZXRhaWxzLnRva2VuIH07XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnN0cmVhbSA9ICdzdHJlYW0nIGluIHBhcmFtcyA/IHBhcmFtcy5zdHJlYW0gOiB0cnVlO1xuICAgICAgICBfdGhpcy5zZW5kUmVxdWVzdCA9IG51bGw7XG4gICAgICAgIF90aGlzLnJlY3ZSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgX3RoaXMucGVuZGluZ0NhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgX3RoaXMucGVuZGluZ0l0ZW1zID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5jb25uZWN0KCknLCAnc3RhcnRpbmcnKTtcbiAgICAgICAgdHJhbnNwb3J0XzEuZGVmYXVsdC5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgICAgIHZhciBvcHRpb25zID0gcGFyYW1zLm9wdGlvbnM7XG4gICAgICAgIHZhciBob3N0ID0gZGVmYXVsdHNfMS5kZWZhdWx0LmdldEhvc3Qob3B0aW9ucywgcGFyYW1zLmhvc3QpO1xuICAgICAgICB2YXIgcG9ydCA9IGRlZmF1bHRzXzEuZGVmYXVsdC5nZXRQb3J0KG9wdGlvbnMpO1xuICAgICAgICB2YXIgY29tZXRTY2hlbWUgPSBvcHRpb25zLnRscyA/ICdodHRwczovLycgOiAnaHR0cDovLyc7XG4gICAgICAgIHRoaXMuYmFzZVVyaSA9IGNvbWV0U2NoZW1lICsgaG9zdCArICc6JyArIHBvcnQgKyAnL2NvbWV0Lyc7XG4gICAgICAgIHZhciBjb25uZWN0VXJpID0gdGhpcy5iYXNlVXJpICsgJ2Nvbm5lY3QnO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LmNvbm5lY3QoKScsICd1cmk6ICcgKyBjb25uZWN0VXJpKTtcbiAgICAgICAgdGhpcy5hdXRoLmdldEF1dGhQYXJhbXMoZnVuY3Rpb24gKGVyciwgYXV0aFBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIF90aGlzLmRpc2Nvbm5lY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmF1dGhQYXJhbXMgPSBhdXRoUGFyYW1zO1xuICAgICAgICAgICAgdmFyIGNvbm5lY3RQYXJhbXMgPSBfdGhpcy5wYXJhbXMuZ2V0Q29ubmVjdFBhcmFtcyhhdXRoUGFyYW1zKTtcbiAgICAgICAgICAgIGlmICgnc3RyZWFtJyBpbiBjb25uZWN0UGFyYW1zKVxuICAgICAgICAgICAgICAgIF90aGlzLnN0cmVhbSA9IGNvbm5lY3RQYXJhbXMuc3RyZWFtO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5jb25uZWN0KCknLCAnY29ubmVjdFBhcmFtczonICsgVXRpbHMudG9RdWVyeVN0cmluZyhjb25uZWN0UGFyYW1zKSk7XG4gICAgICAgICAgICAvKiB0aGlzIHdpbGwgYmUgdGhlICdyZWN2UmVxdWVzdCcgc28gdGhpcyBjb25uZWN0aW9uIGNhbiBzdHJlYW0gbWVzc2FnZXMgKi9cbiAgICAgICAgICAgIHZhciBwcmVjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBjb25uZWN0UmVxdWVzdCA9IChfdGhpcy5yZWN2UmVxdWVzdCA9IF90aGlzLmNyZWF0ZVJlcXVlc3QoY29ubmVjdFVyaSwgbnVsbCwgY29ubmVjdFBhcmFtcywgbnVsbCwgX3RoaXMuc3RyZWFtID8gWEhSU3RhdGVzXzEuZGVmYXVsdC5SRVFfUkVDVl9TVFJFQU0gOiBYSFJTdGF0ZXNfMS5kZWZhdWx0LlJFUV9SRUNWKSk7XG4gICAgICAgICAgICBjb25uZWN0UmVxdWVzdC5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5yZWN2UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAvKiB0aGUgdHJhbnNwb3J0IHdhcyBkaXNwb3NlZCBiZWZvcmUgd2UgY29ubmVjdGVkICovXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwcmVjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgncHJlY29ubmVjdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5vbkRhdGEoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbm5lY3RSZXF1ZXN0Lm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnJlY3ZSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIHRoZSB0cmFuc3BvcnQgd2FzIGRpc3Bvc2VkIGJlZm9yZSB3ZSBjb25uZWN0ZWQgKi9cbiAgICAgICAgICAgICAgICAgICAgZXJyID0gZXJyIHx8IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdSZXF1ZXN0IGNhbmNlbGxlZCcsIDgwMDAzLCA0MDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5yZWN2UmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgLyogQ29ubmVjdCByZXF1ZXN0IG1heSBjb21wbGV0ZSB3aXRob3V0IGEgZW1pdHRpbmcgJ2RhdGEnIGV2ZW50IHNpbmNlIHRoYXQgaXMgbm90XG4gICAgICAgICAgICAgICAgICogZW1pdHRlZCBmb3IgZS5nLiBhIG5vbi1zdHJlYW1lZCBlcnJvciByZXNwb25zZS4gU3RpbGwgaW1wbGllcyBwcmVjb25uZWN0LiAqL1xuICAgICAgICAgICAgICAgIGlmICghcHJlY29ubmVjdGVkICYmICFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgncHJlY29ubmVjdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIEEgcHJvdG9jb2wgZXJyb3IgcmVjZWl2ZWQgZnJvbSByZWFsdGltZS4gVE9ETzogb25jZSByZWFsdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogY29uc2lzdGVuZGx5IHNlbmRzIGVycm9ycyB3cmFwcGVkIGluIHByb3RvY29sIG1lc3NhZ2VzLCBzaG91bGQgYmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGFibGUgdG8gcmVtb3ZlIHRoaXMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uRGF0YShwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBBIG5ldHdvcmsveGhyIGVycm9yLiBEb24ndCBib3RoZXIgd3JhcHBpbmcgaW4gYSBwcm90b2NvbCBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICoganVzdCBkaXNjb25uZWN0IHRoZSB0cmFuc3BvcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc2Nvbm5lY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWN2KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbm5lY3RSZXF1ZXN0LmV4ZWMoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUucmVxdWVzdENsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LnJlcXVlc3RDbG9zZSgpJyk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RDbG9zZU9yRGlzY29ubmVjdCh0cnVlKTtcbiAgICB9O1xuICAgIENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5yZXF1ZXN0RGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5yZXF1ZXN0RGlzY29ubmVjdCgpJyk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RDbG9zZU9yRGlzY29ubmVjdChmYWxzZSk7XG4gICAgfTtcbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuX3JlcXVlc3RDbG9zZU9yRGlzY29ubmVjdCA9IGZ1bmN0aW9uIChjbG9zaW5nKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjbG9zZU9yRGlzY29ubmVjdFVyaSA9IGNsb3NpbmcgPyB0aGlzLmNsb3NlVXJpIDogdGhpcy5kaXNjb25uZWN0VXJpO1xuICAgICAgICBpZiAoY2xvc2VPckRpc2Nvbm5lY3RVcmkpIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KGNsb3NlT3JEaXNjb25uZWN0VXJpLCBudWxsLCB0aGlzLmF1dGhQYXJhbXMsIG51bGwsIFhIUlN0YXRlc18xLmRlZmF1bHQuUkVRX1NFTkQpO1xuICAgICAgICAgICAgcmVxdWVzdC5vbignY29tcGxldGUnLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0NvbWV0VHJhbnNwb3J0LnJlcXVlc3QnICsgKGNsb3NpbmcgPyAnQ2xvc2UoKScgOiAnRGlzY29ubmVjdCgpJyksICdyZXF1ZXN0IHJldHVybmVkIGVyciA9ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlcXVlc3QuZXhlYygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5kaXNwb3NlKCknLCAnJyk7XG4gICAgICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVjdlJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LmRpc3Bvc2UoKScsICdhYm9ydGluZyByZWN2IHJlcXVlc3QnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY3ZSZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWN2UmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBJbiBhbG1vc3QgYWxsIGNhc2VzIHRoZSB0cmFuc3BvcnQgd2lsbCBiZSBmaW5pc2hlZCBiZWZvcmUgaXQnc1xuICAgICAgICAgICAgICogZGlzcG9zZWQuIEZpbmlzaCBoZXJlIGp1c3QgdG8gbWFrZSBzdXJlLiAqL1xuICAgICAgICAgICAgdGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGNvbm5lY3Rpb25lcnJvcnNfMS5kZWZhdWx0LmRpc2Nvbm5lY3RlZCgpKTtcbiAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Rpc3Bvc2VkJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uQ29ubmVjdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLyogaWYgdGhpcyB0cmFuc3BvcnQgaGFzIGJlZW4gZGlzcG9zZWQgd2hpbHN0IGF3YWl0aW5nIGNvbm5lY3Rpb24sIGRvIG5vdGhpbmcgKi9cbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIHRoZSBjb25uZWN0aW9uS2V5IGluIGEgY29tZXQgY29ubmVjdGVkIHJlc3BvbnNlIGlzIHJlYWxseVxuICAgICAgICAgKiA8aW5zdElkPi08Y29ubmVjdGlvbktleT4gKi9cbiAgICAgICAgdmFyIGNvbm5lY3Rpb25TdHIgPSAoX2EgPSBtZXNzYWdlLmNvbm5lY3Rpb25EZXRhaWxzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29ubmVjdGlvbktleTtcbiAgICAgICAgdHJhbnNwb3J0XzEuZGVmYXVsdC5wcm90b3R5cGUub25Db25uZWN0LmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgIHZhciBiYXNlQ29ubmVjdGlvblVyaSA9IHRoaXMuYmFzZVVyaSArIGNvbm5lY3Rpb25TdHI7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29tZXRUcmFuc3BvcnQub25Db25uZWN0KCknLCAnYmFzZVVyaSA9ICcgKyBiYXNlQ29ubmVjdGlvblVyaSk7XG4gICAgICAgIHRoaXMuc2VuZFVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgJy9zZW5kJztcbiAgICAgICAgdGhpcy5yZWN2VXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyAnL3JlY3YnO1xuICAgICAgICB0aGlzLmNsb3NlVXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyAnL2Nsb3NlJztcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0VXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyAnL2Rpc2Nvbm5lY3QnO1xuICAgIH07XG4gICAgQ29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy5zZW5kUmVxdWVzdCkge1xuICAgICAgICAgICAgLyogdGhlcmUgaXMgYSBwZW5kaW5nIHNlbmQsIHNvIHF1ZXVlIHRoaXMgbWVzc2FnZSAqL1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nSXRlbXMgPSB0aGlzLnBlbmRpbmdJdGVtcyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0l0ZW1zLnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyogc2VuZCB0aGlzLCBwbHVzIGFueSBwZW5kaW5nLCBub3cgKi9cbiAgICAgICAgdmFyIHBlbmRpbmdJdGVtcyA9IHRoaXMucGVuZGluZ0l0ZW1zIHx8IFtdO1xuICAgICAgICBwZW5kaW5nSXRlbXMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSXRlbXMgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbmRJdGVtcyhwZW5kaW5nSXRlbXMpO1xuICAgIH07XG4gICAgQ29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmRBbnlQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGVuZGluZ0l0ZW1zID0gdGhpcy5wZW5kaW5nSXRlbXM7XG4gICAgICAgIGlmICghcGVuZGluZ0l0ZW1zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nSXRlbXMgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbmRJdGVtcyhwZW5kaW5nSXRlbXMpO1xuICAgIH07XG4gICAgQ29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmRJdGVtcyA9IGZ1bmN0aW9uIChpdGVtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2VuZFJlcXVlc3QgPSAodGhpcy5zZW5kUmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdCh0aGlzLnNlbmRVcmksIG51bGwsIHRoaXMuYXV0aFBhcmFtcywgdGhpcy5lbmNvZGVSZXF1ZXN0KGl0ZW1zKSwgWEhSU3RhdGVzXzEuZGVmYXVsdC5SRVFfU0VORCkpO1xuICAgICAgICBzZW5kUmVxdWVzdC5vbignY29tcGxldGUnLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQ29tZXRUcmFuc3BvcnQuc2VuZEl0ZW1zKCknLCAnb24gY29tcGxldGU6IGVyciA9ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgICAgICAgICBfdGhpcy5zZW5kUmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICAvKiB0aGUgcmVzdWx0IG9mIHRoZSByZXF1ZXN0LCBldmVuIGlmIGEgbmFjaywgaXMgdXN1YWxseSBhIHByb3RvY29sIHJlc3BvbnNlXG4gICAgICAgICAgICAgKiBjb250YWluZWQgaW4gdGhlIGRhdGEuIEFuIGVyciBpcyBhbm9tb2xvdXMsIGFuZCBpbmRpY2F0ZXMgc29tZSBpc3N1ZSB3aXRoIHRoZVxuICAgICAgICAgICAgICogbmV0d29yayx0cmFuc3BvcnQsIG9yIGNvbm5lY3Rpb24gKi9cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogQSBwcm90b2NvbCBlcnJvciByZWNlaXZlZCBmcm9tIHJlYWx0aW1lLiBUT0RPOiBvbmNlIHJlYWx0aW1lXG4gICAgICAgICAgICAgICAgICAgICAqIGNvbnNpc3RlbmRseSBzZW5kcyBlcnJvcnMgd3JhcHBlZCBpbiBwcm90b2NvbCBtZXNzYWdlcywgc2hvdWxkIGJlXG4gICAgICAgICAgICAgICAgICAgICAqIGFibGUgdG8gcmVtb3ZlIHRoaXMgKi9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25EYXRhKHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIEEgbmV0d29yay94aHIgZXJyb3IuIERvbid0IGJvdGhlciB3cmFwcGluZyBpbiBhIHByb3RvY29sIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAqIGp1c3QgZGlzY29ubmVjdCB0aGUgdHJhbnNwb3J0ICovXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc2Nvbm5lY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkRhdGEoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMucGVuZGluZ0l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIElmIHRoZXJlJ3MgYSBuZXcgc2VuZCByZXF1ZXN0IGJ5IG5vdywgYW55IHBlbmRpbmcgaXRlbXMgd2lsbCBoYXZlXG4gICAgICAgICAgICAgICAgICAgICAqIGJlZW4gcGlja2VkIHVwIGJ5IHRoYXQ7IGFueSBuZXcgb25lcyBhZGRlZCBzaW5jZSB0aGVuIHdpbGwgYmVcbiAgICAgICAgICAgICAgICAgICAgICogcGlja2VkIHVwIGFmdGVyIHRoYXQgb25lIGNvbXBsZXRlcyAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnNlbmRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZW5kQW55UGVuZGluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZW5kUmVxdWVzdC5leGVjKCk7XG4gICAgfTtcbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUucmVjdiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyogZG8gbm90aGluZyBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgcmVxdWVzdCwgd2hpY2ggbWlnaHQgYmUgc3RyZWFtaW5nICovXG4gICAgICAgIGlmICh0aGlzLnJlY3ZSZXF1ZXN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKiBJZiB3ZSdyZSBubyBsb25nZXIgY29ubmVjdGVkLCBkbyBub3RoaW5nICovXG4gICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHJlY3ZSZXF1ZXN0ID0gKHRoaXMucmVjdlJlcXVlc3QgPSB0aGlzLmNyZWF0ZVJlcXVlc3QodGhpcy5yZWN2VXJpLCBudWxsLCB0aGlzLmF1dGhQYXJhbXMsIG51bGwsIHRoaXMuc3RyZWFtID8gWEhSU3RhdGVzXzEuZGVmYXVsdC5SRVFfUkVDVl9TVFJFQU0gOiBYSFJTdGF0ZXNfMS5kZWZhdWx0LlJFUV9SRUNWX1BPTEwpKTtcbiAgICAgICAgcmVjdlJlcXVlc3Qub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgX3RoaXMub25EYXRhKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVjdlJlcXVlc3Qub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgX3RoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgLyogQSByZXF1ZXN0IGNvbXBsZXRpbmcgbXVzdCBiZSBjb25zaWRlcmVkIGFjdGl2aXR5LCBhcyByZWFsdGltZSBzZW5kc1xuICAgICAgICAgICAgICogaGVhcnRiZWF0cyBldmVyeSAxNXMgc2luY2UgYSByZXF1ZXN0IGJlZ2FuLCBub3QgZXZlcnkgMTVzIGFic29sdXRlbHkgKi9cbiAgICAgICAgICAgIF90aGlzLm9uQWN0aXZpdHkoKTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogQSBwcm90b2NvbCBlcnJvciByZWNlaXZlZCBmcm9tIHJlYWx0aW1lLiBUT0RPOiBvbmNlIHJlYWx0aW1lXG4gICAgICAgICAgICAgICAgICAgICAqIGNvbnNpc3RlbnRseSBzZW5kcyBlcnJvcnMgd3JhcHBlZCBpbiBwcm90b2NvbCBtZXNzYWdlcywgc2hvdWxkIGJlXG4gICAgICAgICAgICAgICAgICAgICAqIGFibGUgdG8gcmVtb3ZlIHRoaXMgKi9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25EYXRhKHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIEEgbmV0d29yay94aHIgZXJyb3IuIERvbid0IGJvdGhlciB3cmFwcGluZyBpbiBhIHByb3RvY29sIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAqIGp1c3QgZGlzY29ubmVjdCB0aGUgdHJhbnNwb3J0ICovXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc2Nvbm5lY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVjdigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZWN2UmVxdWVzdC5leGVjKCk7XG4gICAgfTtcbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKHJlc3BvbnNlRGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5kZWNvZGVSZXNwb25zZShyZXNwb25zZURhdGEpO1xuICAgICAgICAgICAgaWYgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUHJvdG9jb2xNZXNzYWdlKHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuZnJvbURlc2VyaWFsaXplZChpdGVtc1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0NvbWV0VHJhbnNwb3J0Lm9uRGF0YSgpJywgJ1VuZXhwZWN0ZWQgZXhjZXB0aW9uIGhhbmRpbmcgY2hhbm5lbCBldmVudDogJyArIGUuc3RhY2spO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuZW5jb2RlUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0SXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlcXVlc3RJdGVtcyk7XG4gICAgfTtcbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuZGVjb2RlUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2VEYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2VEYXRhID09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2VEYXRhKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlRGF0YTtcbiAgICB9O1xuICAgIHJldHVybiBDb21ldFRyYW5zcG9ydDtcbn0odHJhbnNwb3J0XzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29tZXRUcmFuc3BvcnQ7XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG5cblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgYXV0aF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNykpO1xudmFyIEh0dHBNZXRob2RzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KSk7XG52YXIgZXJyb3JpbmZvXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuZnVuY3Rpb24gd2l0aEF1dGhEZXRhaWxzKHJlc3QsIGhlYWRlcnMsIHBhcmFtcywgZXJyQ2FsbGJhY2ssIG9wQ2FsbGJhY2spIHtcbiAgICBpZiAocmVzdC5odHRwLnN1cHBvcnRzQXV0aEhlYWRlcnMpIHtcbiAgICAgICAgcmVzdC5hdXRoLmdldEF1dGhIZWFkZXJzKGZ1bmN0aW9uIChlcnIsIGF1dGhIZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgIGVyckNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb3BDYWxsYmFjayhVdGlscy5taXhpbihhdXRoSGVhZGVycywgaGVhZGVycyksIHBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdC5hdXRoLmdldEF1dGhQYXJhbXMoZnVuY3Rpb24gKGVyciwgYXV0aFBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICBlcnJDYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9wQ2FsbGJhY2soaGVhZGVycywgVXRpbHMubWl4aW4oYXV0aFBhcmFtcywgcGFyYW1zKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVuZW52ZWxvcGUoY2FsbGJhY2ssIGZvcm1hdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyLCBib2R5LCBvdXRlckhlYWRlcnMsIHVucGFja2VkLCBvdXRlclN0YXR1c0NvZGUpIHtcbiAgICAgICAgaWYgKGVyciAmJiAhYm9keSkge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXVucGFja2VkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBVdGlscy5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChVdGlscy5pc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbyhlKSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKFV0aWxzLmluc3BlY3RFcnJvcihlKSwgbnVsbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygndW5lbnZlbG9wZSgpOiBSZXNwb25zZSBib2R5IGlzIG1pc3NpbmcnLCBudWxsKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gYm9keSwgd3JhcHBlZFN0YXR1c0NvZGUgPSBfYS5zdGF0dXNDb2RlLCByZXNwb25zZSA9IF9hLnJlc3BvbnNlLCB3cmFwcGVkSGVhZGVycyA9IF9hLmhlYWRlcnM7XG4gICAgICAgIGlmICh3cmFwcGVkU3RhdHVzQ29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvKiBFbnZlbG9wZSBhbHJlYWR5IHVud3JhcHBlZCBieSB0aGUgdHJhbnNwb3J0ICovXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIGJvZHksIG91dGVySGVhZGVycywgdHJ1ZSwgb3V0ZXJTdGF0dXNDb2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcHBlZFN0YXR1c0NvZGUgPCAyMDAgfHwgd3JhcHBlZFN0YXR1c0NvZGUgPj0gMzAwKSB7XG4gICAgICAgICAgICAvKiBoYW5kbGUgd3JhcHBlZCBlcnJvcnMgKi9cbiAgICAgICAgICAgIHZhciB3cmFwcGVkRXJyID0gKHJlc3BvbnNlICYmIHJlc3BvbnNlLmVycm9yKSB8fCBlcnI7XG4gICAgICAgICAgICBpZiAoIXdyYXBwZWRFcnIpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVkRXJyID0gbmV3IEVycm9yKCdFcnJvciBpbiB1bmVudmVsb3BpbmcgJyArIGJvZHkpO1xuICAgICAgICAgICAgICAgIHdyYXBwZWRFcnIuc3RhdHVzQ29kZSA9IHdyYXBwZWRTdGF0dXNDb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sod3JhcHBlZEVyciwgcmVzcG9uc2UsIHdyYXBwZWRIZWFkZXJzLCB0cnVlLCB3cmFwcGVkU3RhdHVzQ29kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZSwgd3JhcHBlZEhlYWRlcnMsIHRydWUsIHdyYXBwZWRTdGF0dXNDb2RlKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFyYW1TdHJpbmcocGFyYW1zKSB7XG4gICAgdmFyIHBhcmFtUGFpcnMgPSBbXTtcbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgIGZvciAodmFyIG5lZWRsZSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIHBhcmFtUGFpcnMucHVzaChuZWVkbGUgKyAnPScgKyBwYXJhbXNbbmVlZGxlXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtUGFpcnMuam9pbignJicpO1xufVxuZnVuY3Rpb24gdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHBhdGggKyAocGFyYW1zID8gJz8nIDogJycpICsgcGFyYW1TdHJpbmcocGFyYW1zKTtcbn1cbmZ1bmN0aW9uIGxvZ1Jlc3BvbnNlSGFuZGxlcihjYWxsYmFjaywgbWV0aG9kLCBwYXRoLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZXNvdXJjZS4nICsgbWV0aG9kICsgJygpJywgJ1JlY2VpdmVkIEVycm9yOyAnICsgdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSArICc7IEVycm9yOiAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZXNvdXJjZS4nICsgbWV0aG9kICsgJygpJywgJ1JlY2VpdmVkOyAnICtcbiAgICAgICAgICAgICAgICB1cmxGcm9tUGF0aEFuZFBhcmFtcyhwYXRoLCBwYXJhbXMpICtcbiAgICAgICAgICAgICAgICAnOyBIZWFkZXJzOiAnICtcbiAgICAgICAgICAgICAgICBwYXJhbVN0cmluZyhoZWFkZXJzKSArXG4gICAgICAgICAgICAgICAgJzsgU3RhdHVzQ29kZTogJyArXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZSArXG4gICAgICAgICAgICAgICAgJzsgQm9keTogJyArXG4gICAgICAgICAgICAgICAgKHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5pc0J1ZmZlcihib2R5KSA/IGJvZHkudG9TdHJpbmcoKSA6IGJvZHkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbnZhciBSZXNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNvdXJjZSgpIHtcbiAgICB9XG4gICAgUmVzb3VyY2UuZ2V0ID0gZnVuY3Rpb24gKHJlc3QsIHBhdGgsIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIFJlc291cmNlLmRvKEh0dHBNZXRob2RzXzEuZGVmYXVsdC5HZXQsIHJlc3QsIHBhdGgsIG51bGwsIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlc291cmNlLmRlbGV0ZSA9IGZ1bmN0aW9uIChyZXN0LCBwYXRoLCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjaykge1xuICAgICAgICBSZXNvdXJjZS5kbyhIdHRwTWV0aG9kc18xLmRlZmF1bHQuRGVsZXRlLCByZXN0LCBwYXRoLCBudWxsLCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZXNvdXJjZS5wb3N0ID0gZnVuY3Rpb24gKHJlc3QsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIFJlc291cmNlLmRvKEh0dHBNZXRob2RzXzEuZGVmYXVsdC5Qb3N0LCByZXN0LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZXNvdXJjZS5wYXRjaCA9IGZ1bmN0aW9uIChyZXN0LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjaykge1xuICAgICAgICBSZXNvdXJjZS5kbyhIdHRwTWV0aG9kc18xLmRlZmF1bHQuUGF0Y2gsIHJlc3QsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlc291cmNlLnB1dCA9IGZ1bmN0aW9uIChyZXN0LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjaykge1xuICAgICAgICBSZXNvdXJjZS5kbyhIdHRwTWV0aG9kc18xLmRlZmF1bHQuUHV0LCByZXN0LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZXNvdXJjZS5kbyA9IGZ1bmN0aW9uIChtZXRob2QsIHJlc3QsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChsb2dnZXJfMS5kZWZhdWx0LnNob3VsZExvZyhsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbG9nUmVzcG9uc2VIYW5kbGVyKGNhbGxiYWNrLCBtZXRob2QsIHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudmVsb3BlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHVuZW52ZWxvcGUoY2FsbGJhY2ssIGVudmVsb3BlKTtcbiAgICAgICAgICAgIChwYXJhbXMgPSBwYXJhbXMgfHwge30pWydlbnZlbG9wZSddID0gZW52ZWxvcGU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZG9SZXF1ZXN0KGhlYWRlcnMsIHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcl8xLmRlZmF1bHQuc2hvdWxkTG9nKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVzb3VyY2UuJyArIG1ldGhvZCArICcoKScsICdTZW5kaW5nOyAnICsgdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9nZ2VyXzEuZGVmYXVsdC5zaG91bGRMb2cobG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlY29kZWRCb2R5ID0gYm9keTtcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5kZXhPZignbXNncGFjaycpKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRCb2R5ID0gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5tc2dwYWNrLmRlY29kZShib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZGVjb2RlRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1Jlc291cmNlLicgKyBtZXRob2QgKyAnKCknLCAnU2VuZGluZyBNc2dQYWNrIERlY29kaW5nIEVycm9yOiAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGRlY29kZUVycikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVzb3VyY2UuJyArIG1ldGhvZCArICcoKScsICdTZW5kaW5nOyAnICsgdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSArICc7IEJvZHk6ICcgKyBkZWNvZGVkQm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN0Lmh0dHAuZG8obWV0aG9kLCByZXN0LCBwYXRoLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGZ1bmN0aW9uIChlcnIsIHJlcywgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGF1dGhfMS5kZWZhdWx0LmlzVG9rZW5FcnIoZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAvKiB0b2tlbiBoYXMgZXhwaXJlZCwgc28gZ2V0IGEgbmV3IG9uZSAqL1xuICAgICAgICAgICAgICAgICAgICByZXN0LmF1dGguYXV0aG9yaXplKG51bGwsIG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIHJldHJ5IC4uLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgd2l0aEF1dGhEZXRhaWxzKHJlc3QsIGhlYWRlcnMsIHBhcmFtcywgY2FsbGJhY2ssIGRvUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzLCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB3aXRoQXV0aERldGFpbHMocmVzdCwgaGVhZGVycywgcGFyYW1zLCBjYWxsYmFjaywgZG9SZXF1ZXN0KTtcbiAgICB9O1xuICAgIHJldHVybiBSZXNvdXJjZTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBSZXNvdXJjZTtcblxuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg5KSk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbmZ1bmN0aW9uIHRvQWN0aW9uVmFsdWUoYWN0aW9uU3RyaW5nKSB7XG4gICAgcmV0dXJuIFByZXNlbmNlTWVzc2FnZS5BY3Rpb25zLmluZGV4T2YoYWN0aW9uU3RyaW5nKTtcbn1cbnZhciBQcmVzZW5jZU1lc3NhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJlc2VuY2VNZXNzYWdlKCkge1xuICAgIH1cbiAgICAvKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBwcmVzZW5jZU1lc3NhZ2UgaXMgc3ludGhlc2l6ZWQsIGkuZS4gd2FzIG5vdCBhY3R1YWxseVxuICAgICAqIHNlbnQgYnkgdGhlIGNvbm5lY3Rpb24gKHVzdWFsbHkgbWVhbnMgYSBsZWF2ZSBldmVudCBzZW50IDE1cyBhZnRlciBhXG4gICAgICogZGlzY29ubmVjdGlvbikuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2Ugc3ludGhlc2l6ZWQgbWVzc2FnZXMgY2Fubm90IGJlXG4gICAgICogY29tcGFyZWQgZm9yIG5ld25lc3MgYnkgaWQgbGV4aWNvZ3JhcGhpY2FsbHkgLSBSVFAyYjFcbiAgICAgKi9cbiAgICBQcmVzZW5jZU1lc3NhZ2UucHJvdG90eXBlLmlzU3ludGhlc2l6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pZCB8fCAhdGhpcy5jb25uZWN0aW9uSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmlkLnN1YnN0cmluZyh0aGlzLmNvbm5lY3Rpb25JZC5sZW5ndGgsIDApICE9PSB0aGlzLmNvbm5lY3Rpb25JZDtcbiAgICB9O1xuICAgIC8qIFJUUDJiMiAqL1xuICAgIFByZXNlbmNlTWVzc2FnZS5wcm90b3R5cGUucGFyc2VJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJzZUlkKCk6IFByZXNlbmNlIG1lc3NhZ2UgZG9lcyBub3QgY29udGFpbiBhbiBpZCcpO1xuICAgICAgICB2YXIgcGFydHMgPSB0aGlzLmlkLnNwbGl0KCc6Jyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb25uZWN0aW9uSWQ6IHBhcnRzWzBdLFxuICAgICAgICAgICAgbXNnU2VyaWFsOiBwYXJzZUludChwYXJ0c1sxXSwgMTApLFxuICAgICAgICAgICAgaW5kZXg6IHBhcnNlSW50KHBhcnRzWzJdLCAxMCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPdmVybG9hZCB0b0pTT04oKSB0byBpbnRlcmNlcHQgSlNPTi5zdHJpbmdpZnkoKVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG4gICAgUHJlc2VuY2VNZXNzYWdlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIGVuY29kZSBkYXRhIHRvIGJhc2U2NCBpZiBwcmVzZW50IGFuZCB3ZSdyZSByZXR1cm5pbmcgcmVhbCBKU09OO1xuICAgICAgICAgKiBhbHRob3VnaCBtc2dwYWNrIGNhbGxzIHRvSlNPTigpLCB3ZSBrbm93IGl0IGlzIGEgc3RyaW5naWZ5KClcbiAgICAgICAgICogY2FsbCBpZiBpdCBoYXMgYSBub24tZW1wdHkgYXJndW1lbnRzIGxpc3QgKi9cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIHZhciBlbmNvZGluZyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgICAgIGlmIChkYXRhICYmIHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLyogc3RyaW5naWZ5IGNhbGwgKi9cbiAgICAgICAgICAgICAgICBlbmNvZGluZyA9IGVuY29kaW5nID8gZW5jb2RpbmcgKyAnL2Jhc2U2NCcgOiAnYmFzZTY0JztcbiAgICAgICAgICAgICAgICBkYXRhID0gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIENhbGxlZCBieSBtc2dwYWNrLiB0b0J1ZmZlciByZXR1cm5zIGEgZGF0YXR5cGUgdW5kZXJzdGFuZGFibGUgYnlcbiAgICAgICAgICAgICAgICAgKiB0aGF0IHBsYXRmb3JtJ3MgbXNncGFjayBpbXBsZW1lbnRhdGlvbiAoQnVmZmVyIGluIG5vZGUsIFVpbnQ4QXJyYXlcbiAgICAgICAgICAgICAgICAgKiBpbiBicm93c2VycykgKi9cbiAgICAgICAgICAgICAgICBkYXRhID0gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLnRvQnVmZmVyKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuICAgICAgICAgICAgLyogQ29udmVydCBwcmVzZW5jZSBhY3Rpb24gYmFjayB0byBhbiBpbnQgZm9yIHNlbmRpbmcgdG8gQWJseSAqL1xuICAgICAgICAgICAgYWN0aW9uOiB0b0FjdGlvblZhbHVlKHRoaXMuYWN0aW9uKSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICAgICAgICBleHRyYXM6IHRoaXMuZXh0cmFzLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgUHJlc2VuY2VNZXNzYWdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICdbUHJlc2VuY2VNZXNzYWdlJztcbiAgICAgICAgcmVzdWx0ICs9ICc7IGFjdGlvbj0nICsgdGhpcy5hY3Rpb247XG4gICAgICAgIGlmICh0aGlzLmlkKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGlkPScgKyB0aGlzLmlkO1xuICAgICAgICBpZiAodGhpcy50aW1lc3RhbXApXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgdGltZXN0YW1wPScgKyB0aGlzLnRpbWVzdGFtcDtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50SWQpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgY2xpZW50SWQ9JyArIHRoaXMuY2xpZW50SWQ7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25JZClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBjb25uZWN0aW9uSWQ9JyArIHRoaXMuY29ubmVjdGlvbklkO1xuICAgICAgICBpZiAodGhpcy5lbmNvZGluZylcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBlbmNvZGluZz0nICsgdGhpcy5lbmNvZGluZztcbiAgICAgICAgaWYgKHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRhdGEgPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGRhdGE9JyArIHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5pc0J1ZmZlcih0aGlzLmRhdGEpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnOyBkYXRhIChidWZmZXIpPScgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKHRoaXMuZGF0YSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGRhdGEgKGpzb24pPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4dHJhcykge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGV4dHJhcz0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5leHRyYXMpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnXSc7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1lc3NhZ2UuZnJvbVJlc3BvbnNlQm9keSA9IGZ1bmN0aW9uIChib2R5LCBvcHRpb25zLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2VzID0gW107XG4gICAgICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGJvZHkgPSBVdGlscy5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gKG1lc3NhZ2VzW2ldID0gUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMoYm9keVtpXSwgdHJ1ZSkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBQcmVzZW5jZU1lc3NhZ2UuZGVjb2RlKG1zZywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnUHJlc2VuY2VNZXNzYWdlLmZyb21SZXNwb25zZUJvZHkoKScsIGUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgIH07XG4gICAgUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzLCBzdHJpbmdpZnlBY3Rpb24pIHtcbiAgICAgICAgaWYgKHN0cmluZ2lmeUFjdGlvbikge1xuICAgICAgICAgICAgdmFsdWVzLmFjdGlvbiA9IFByZXNlbmNlTWVzc2FnZS5BY3Rpb25zW3ZhbHVlcy5hY3Rpb25dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBQcmVzZW5jZU1lc3NhZ2UoKSwgdmFsdWVzKTtcbiAgICB9O1xuICAgIFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzQXJyYXkgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKHZhbHVlc1tpXSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1lc3NhZ2UuZnJvbUVuY29kZWQgPSBmdW5jdGlvbiAoZW5jb2RlZCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbXNnID0gUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMoZW5jb2RlZCwgdHJ1ZSk7XG4gICAgICAgIC8qIGlmIGRlY29kaW5nIGZhaWxzIGF0IGFueSBwb2ludCwgY2F0Y2ggYW5kIHJldHVybiB0aGUgbWVzc2FnZSBkZWNvZGVkIHRvXG4gICAgICAgICAqIHRoZSBmdWxsZXN0IGV4dGVudCBwb3NzaWJsZSAqL1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgUHJlc2VuY2VNZXNzYWdlLmRlY29kZShtc2csIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdQcmVzZW5jZU1lc3NhZ2UuZnJvbUVuY29kZWQoKScsIGUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9O1xuICAgIFByZXNlbmNlTWVzc2FnZS5mcm9tRW5jb2RlZEFycmF5ID0gZnVuY3Rpb24gKGVuY29kZWRBcnJheSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZW5jb2RlZEFycmF5Lm1hcChmdW5jdGlvbiAoZW5jb2RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByZXNlbmNlTWVzc2FnZS5mcm9tRW5jb2RlZChlbmNvZGVkLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1lc3NhZ2UuZnJvbURhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFByZXNlbmNlTWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUHJlc2VuY2VNZXNzYWdlLkFjdGlvbnMgPSBbJ2Fic2VudCcsICdwcmVzZW50JywgJ2VudGVyJywgJ2xlYXZlJywgJ3VwZGF0ZSddO1xuICAgIFByZXNlbmNlTWVzc2FnZS5lbmNvZGUgPSBtZXNzYWdlXzEuZGVmYXVsdC5lbmNvZGU7XG4gICAgUHJlc2VuY2VNZXNzYWdlLmRlY29kZSA9IG1lc3NhZ2VfMS5kZWZhdWx0LmRlY29kZTtcbiAgICBQcmVzZW5jZU1lc3NhZ2UuZ2V0TWVzc2FnZXNTaXplID0gbWVzc2FnZV8xLmRlZmF1bHQuZ2V0TWVzc2FnZXNTaXplO1xuICAgIHJldHVybiBQcmVzZW5jZU1lc3NhZ2U7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUHJlc2VuY2VNZXNzYWdlO1xuXG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBldmVudGVtaXR0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNykpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBkZWZhdWx0c18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg4KSk7XG52YXIgWEhSU3RhdGVzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xuZnVuY3Rpb24gaXNBYmx5RXJyb3IocmVzcG9uc2VCb2R5LCBoZWFkZXJzKSB7XG4gICAgcmV0dXJuIFV0aWxzLmFyckluKFV0aWxzLmFsbFRvTG93ZXJDYXNlKFV0aWxzLmtleXNBcnJheShoZWFkZXJzKSksICd4LWFibHktZXJyb3Jjb2RlJyk7XG59XG5mdW5jdGlvbiBnZXRBYmx5RXJyb3IocmVzcG9uc2VCb2R5LCBoZWFkZXJzKSB7XG4gICAgaWYgKGlzQWJseUVycm9yKHJlc3BvbnNlQm9keSwgaGVhZGVycykpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlQm9keS5lcnJvciAmJiBlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMocmVzcG9uc2VCb2R5LmVycm9yKTtcbiAgICB9XG59XG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcbnZhciBpZENvdW50ZXIgPSAwO1xudmFyIHBlbmRpbmdSZXF1ZXN0cyA9IHt9O1xudmFyIGlzSUUgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuWERvbWFpblJlcXVlc3Q7XG5mdW5jdGlvbiBpZVZlcnNpb24oKSB7XG4gICAgdmFyIG1hdGNoID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b1N0cmluZygpLm1hdGNoKC9NU0lFXFxzKFtcXGQuXSspLyk7XG4gICAgcmV0dXJuIG1hdGNoICYmIE51bWJlcihtYXRjaFsxXSk7XG59XG5mdW5jdGlvbiBuZWVkSnNvbkVudmVsb3BlKCkge1xuICAgIC8qIElFIDEwIHhociBidWc6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2MzIwMzM5ICovXG4gICAgdmFyIHZlcnNpb247XG4gICAgcmV0dXJuIGlzSUUgJiYgKHZlcnNpb24gPSBpZVZlcnNpb24oKSkgJiYgdmVyc2lvbiA9PT0gMTA7XG59XG5mdW5jdGlvbiBnZXRIZWFkZXIoeGhyLCBoZWFkZXIpIHtcbiAgICByZXR1cm4geGhyLmdldFJlc3BvbnNlSGVhZGVyICYmIHhoci5nZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpO1xufVxuLyogU2FmYXJpIG15c3RlcmlvdXNseSByZXR1cm5zICdJZGVudGl0eScgZm9yIHRyYW5zZmVyLWVuY29kaW5nIHdoZW4gaW4gZmFjdFxuICogaXQgaXMgJ2NodW5rZWQnLiBTbyBpbnN0ZWFkLCBkZWNpZGUgdGhhdCBpdCBpcyBjaHVua2VkIHdoZW5cbiAqIHRyYW5zZmVyLWVuY29kaW5nIGlzIHByZXNlbnQgb3IgY29udGVudC1sZW5ndGggaXMgYWJzZW50LiAgKCdvcicgYmVjYXVzZVxuICogd2hlbiB1c2luZyBodHRwMiBzdHJlYW1pbmcsIHRoZXJlJ3Mgbm8gdHJhbnNmZXItZW5jb2RpbmcgaGVhZGVyLCBidXQgY2FuXG4gKiBzdGlsbCBkZWR1Y2Ugc3RyZWFtaW5nIGZyb20gbGFjayBvZiBjb250ZW50LWxlbmd0aCkgKi9cbmZ1bmN0aW9uIGlzRW5jb2RpbmdDaHVua2VkKHhocikge1xuICAgIHJldHVybiAoeGhyLmdldFJlc3BvbnNlSGVhZGVyICYmICh4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ3RyYW5zZmVyLWVuY29kaW5nJykgfHwgIXhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC1sZW5ndGgnKSkpO1xufVxuZnVuY3Rpb24gZ2V0SGVhZGVyc0FzT2JqZWN0KHhocikge1xuICAgIHZhciBoZWFkZXJQYWlycyA9IFV0aWxzLnRyaW0oeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWRlclBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGhlYWRlclBhaXJzW2ldLnNwbGl0KCc6JykubWFwKFV0aWxzLnRyaW0pO1xuICAgICAgICBoZWFkZXJzW3BhcnRzWzBdLnRvTG93ZXJDYXNlKCldID0gcGFydHNbMV07XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJzO1xufVxudmFyIFhIUlJlcXVlc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoWEhSUmVxdWVzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBYSFJSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgIHBhcmFtcy5ybmQgPSBVdGlscy5jaGVhcFJhbmRTdHIoKTtcbiAgICAgICAgaWYgKG5lZWRKc29uRW52ZWxvcGUoKSAmJiAhcGFyYW1zLmVudmVsb3BlKVxuICAgICAgICAgICAgcGFyYW1zLmVudmVsb3BlID0gJ2pzb24nO1xuICAgICAgICBfdGhpcy51cmkgPSB1cmkgKyBVdGlscy50b1F1ZXJ5U3RyaW5nKHBhcmFtcyk7XG4gICAgICAgIF90aGlzLmhlYWRlcnMgPSBoZWFkZXJzIHx8IHt9O1xuICAgICAgICBfdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgX3RoaXMubWV0aG9kID0gbWV0aG9kID8gbWV0aG9kLnRvVXBwZXJDYXNlKCkgOiBVdGlscy5pc0VtcHR5QXJnKGJvZHkpID8gJ0dFVCcgOiAnUE9TVCc7XG4gICAgICAgIF90aGlzLnJlcXVlc3RNb2RlID0gcmVxdWVzdE1vZGU7XG4gICAgICAgIF90aGlzLnRpbWVvdXRzID0gdGltZW91dHM7XG4gICAgICAgIF90aGlzLnRpbWVkT3V0ID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnJlcXVlc3RDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5pZCA9IFN0cmluZygrK2lkQ291bnRlcik7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0c1tfdGhpcy5pZF0gPSBfdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBYSFJSZXF1ZXN0LmNyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbiAodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbWV0aG9kKSB7XG4gICAgICAgIC8qIFhIUiByZXF1ZXN0cyBhcmUgdXNlZCBlaXRoZXIgd2l0aCB0aGUgY29udGV4dCBiZWluZyBhIHJlYWx0aW1lXG4gICAgICAgICAqIHRyYW5zcG9ydCwgb3Igd2l0aCB0aW1lb3V0cyBwYXNzZWQgaW4gKGZvciB3aGVuIHVzZWQgYnkgYSByZXN0IGNsaWVudCksXG4gICAgICAgICAqIG9yIGNvbXBsZXRlbHkgc3RhbmRhbG9uZS4gIFVzZSB0aGUgYXBwcm9wcmlhdGUgdGltZW91dHMgaW4gZWFjaCBjYXNlICovXG4gICAgICAgIHZhciBfdGltZW91dHMgPSB0aW1lb3V0cyB8fCBkZWZhdWx0c18xLmRlZmF1bHQuVElNRU9VVFM7XG4gICAgICAgIHJldHVybiBuZXcgWEhSUmVxdWVzdCh1cmksIGhlYWRlcnMsIFV0aWxzLmNvcHkocGFyYW1zKSwgYm9keSwgcmVxdWVzdE1vZGUsIF90aW1lb3V0cywgbWV0aG9kKTtcbiAgICB9O1xuICAgIFhIUlJlcXVlc3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlcXVlc3RDb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Q29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFlcnIgJiYgYm9keSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdjb21wbGV0ZScsIGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFhIUlJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIFhIUlJlcXVlc3QucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5oZWFkZXJzO1xuICAgICAgICB2YXIgdGltZW91dCA9IHRoaXMucmVxdWVzdE1vZGUgPT0gWEhSU3RhdGVzXzEuZGVmYXVsdC5SRVFfU0VORCA/IHRoaXMudGltZW91dHMuaHR0cFJlcXVlc3RUaW1lb3V0IDogdGhpcy50aW1lb3V0cy5yZWN2VGltZW91dCwgdGltZXIgPSAodGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMudGltZWRPdXQgPSB0cnVlO1xuICAgICAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICAgIH0sIHRpbWVvdXQpKSwgbWV0aG9kID0gdGhpcy5tZXRob2QsIHhociA9ICh0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpKSwgYWNjZXB0ID0gaGVhZGVyc1snYWNjZXB0J107XG4gICAgICAgIHZhciBib2R5ID0gdGhpcy5ib2R5O1xuICAgICAgICB2YXIgcmVzcG9uc2VUeXBlID0gJ3RleHQnO1xuICAgICAgICBpZiAoIWFjY2VwdCkge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBKU09OXG4gICAgICAgICAgICBoZWFkZXJzWydhY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY2NlcHQuaW5kZXhPZignYXBwbGljYXRpb24veC1tc2dwYWNrJykgPT09IDApIHtcbiAgICAgICAgICAgIC8vIE1zZ3BhY2sgcmVzcG9uc2VzIHdpbGwgYmUgdHlwZWQgYXMgQXJyYXlCdWZmZXJcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddIHx8IChoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTEgJiYgdHlwZW9mIGJvZHkgIT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbiBwcm9iYWJseSByZW1vdmUgdGhpcyBkaXJlY3RpdmUgaWYgaHR0cHM6Ly9naXRodWIuY29tL25vZGVzZWN1cml0eS9lc2xpbnQtcGx1Z2luLXNlY3VyaXR5L2lzc3Vlcy8yNiBpcyByZXNvbHZlZFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc2VjdXJpdHkvZGV0ZWN0LW5vbi1saXRlcmFsLWZzLWZpbGVuYW1lXG4gICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdGhpcy51cmksIHRydWUpO1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xuICAgICAgICBpZiAoJ2F1dGhvcml6YXRpb24nIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGggaW4gaGVhZGVycylcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGgsIGhlYWRlcnNbaF0pO1xuICAgICAgICB2YXIgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKGVycm9yRXZlbnQsIG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBtZXNzYWdlICsgJyAoZXZlbnQgdHlwZTogJyArIGVycm9yRXZlbnQudHlwZSArICcpJztcbiAgICAgICAgICAgIGlmICgoX2EgPSBfdGhpcyA9PT0gbnVsbCB8fCBfdGhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMueGhyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdHVzVGV4dClcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gJywgY3VycmVudCBzdGF0dXNUZXh0IGlzICcgKyBfdGhpcy54aHIuc3RhdHVzVGV4dDtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnUmVxdWVzdC5vbicgKyBlcnJvckV2ZW50LnR5cGUgKyAnKCknLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgX3RoaXMuY29tcGxldGUobmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oZXJyb3JNZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlKSk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yRXZlbnQpIHtcbiAgICAgICAgICAgIGVycm9ySGFuZGxlcihlcnJvckV2ZW50LCAnWEhSIGVycm9yIG9jY3VycmVkJywgbnVsbCwgNDAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbiAoZXJyb3JFdmVudCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnRpbWVkT3V0KSB7XG4gICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsICdSZXF1ZXN0IGFib3J0ZWQgZHVlIHRvIHJlcXVlc3QgdGltZW91dCBleHBpcmluZycsIG51bGwsIDQwOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIoZXJyb3JFdmVudCwgJ1JlcXVlc3QgY2FuY2VsbGVkJywgbnVsbCwgNDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uIChlcnJvckV2ZW50KSB7XG4gICAgICAgICAgICBlcnJvckhhbmRsZXIoZXJyb3JFdmVudCwgJ1JlcXVlc3QgdGltZWQgb3V0JywgbnVsbCwgNDA4KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN0cmVhbWluZztcbiAgICAgICAgdmFyIHN0YXR1c0NvZGU7XG4gICAgICAgIHZhciBzdWNjZXNzUmVzcG9uc2U7XG4gICAgICAgIHZhciBzdHJlYW1Qb3MgPSAwO1xuICAgICAgICB2YXIgdW5wYWNrZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIG9uUmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgc3VjY2Vzc1Jlc3BvbnNlID0gc3RhdHVzQ29kZSA8IDQwMDtcbiAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID09IDIwNCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKG51bGwsIG51bGwsIG51bGwsIG51bGwsIHN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbWluZyA9IF90aGlzLnJlcXVlc3RNb2RlID09IFhIUlN0YXRlc18xLmRlZmF1bHQuUkVRX1JFQ1ZfU1RSRUFNICYmIHN1Y2Nlc3NSZXNwb25zZSAmJiBpc0VuY29kaW5nQ2h1bmtlZCh4aHIpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkUmVzcG9uc2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IGdldEhlYWRlcih4aHIsICdjb250ZW50LXR5cGUnKTtcbiAgICAgICAgICAgICAgICAvKiBCZSBsaWJlcmFsIGluIHdoYXQgd2UgYWNjZXB0OyBidWdneSBhdXRoIHNlcnZlcnMgbWF5IHJlc3BvbmRcbiAgICAgICAgICAgICAgICAgKiB3aXRob3V0IHRoZSBjb3JyZWN0IGNvbnRlbnR0eXBlLCBidXQgYXNzdW1lIHRoZXkncmUgc3RpbGxcbiAgICAgICAgICAgICAgICAgKiByZXNwb25kaW5nIHdpdGgganNvbiAqL1xuICAgICAgICAgICAgICAgIHZhciBqc29uID0gY29udGVudFR5cGUgPyBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPj0gMCA6IHhoci5yZXNwb25zZVR5cGUgPT0gJ3RleHQnO1xuICAgICAgICAgICAgICAgIGlmIChqc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIElmIHdlIHJlcXVlc3RlZCBtc2dwYWNrIGJ1dCBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGgganNvbiwgdGhlbiBzaW5jZVxuICAgICAgICAgICAgICAgICAgICAgKiB3ZSBzZXQgdGhlIHJlc3BvbnNlVHlwZSBleHBlY3RpbmcgbXNncGFjaywgdGhlIHJlc3BvbnNlIHdpbGwgYmVcbiAgICAgICAgICAgICAgICAgICAgICogYW4gQXJyYXlCdWZmZXIgY29udGFpbmluZyBqc29uICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBqc29uUmVzcG9uc2VCb2R5ID0geGhyLnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMudXRmOERlY29kZSh4aHIucmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFN0cmluZyh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25SZXNwb25zZUJvZHkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXNwb25zZSA9IEpTT04ucGFyc2UoanNvblJlc3BvbnNlQm9keSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXNwb25zZSA9IGpzb25SZXNwb25zZUJvZHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdW5wYWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmVzcG9uc2UgPSB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRSZXNwb25zZS5yZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIHVud3JhcCBKU09OIGVudmVsb3BlICovXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgPSBwYXJzZWRSZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzUmVzcG9uc2UgPSBzdGF0dXNDb2RlIDwgNDAwO1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzID0gcGFyc2VkUmVzcG9uc2UuaGVhZGVycztcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmVzcG9uc2UgPSBwYXJzZWRSZXNwb25zZS5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMgPSBnZXRIZWFkZXJzQXNPYmplY3QoeGhyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdNYWxmb3JtZWQgcmVzcG9uc2UgYm9keSBmcm9tIHNlcnZlcjogJyArIGUubWVzc2FnZSwgbnVsbCwgNDAwKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogSWYgcmVzcG9uc2UgaXMgYW4gYXJyYXksIGl0J3MgYW4gYXJyYXkgb2YgcHJvdG9jb2wgbWVzc2FnZXMgLS0gZXZlbiBpZlxuICAgICAgICAgICAgICogaXMgY29udGFpbnMgYW4gZXJyb3IgYWN0aW9uIChoZW5jZSB0aGUgbm9uc3VjY2VzcyBzdGF0dXNjb2RlKSwgd2UgY2FuXG4gICAgICAgICAgICAgKiBjb25zaWRlciB0aGUgcmVxdWVzdCB0byBoYXZlIHN1Y2NlZWRlZCwganVzdCBwYXNzIGl0IG9uIHRvXG4gICAgICAgICAgICAgKiBvblByb3RvY29sTWVzc2FnZSB0byBkZWNpZGUgd2hhdCB0byBkbyAqL1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NSZXNwb25zZSB8fCBVdGlscy5pc0FycmF5KHBhcnNlZFJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKG51bGwsIHBhcnNlZFJlc3BvbnNlLCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVyciA9IGdldEFibHlFcnJvcihwYXJzZWRSZXNwb25zZSwgaGVhZGVycyk7XG4gICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgIGVyciA9IG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdFcnJvciByZXNwb25zZSByZWNlaXZlZCBmcm9tIHNlcnZlcjogJyArXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgK1xuICAgICAgICAgICAgICAgICAgICAnIGJvZHkgd2FzOiAnICtcbiAgICAgICAgICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KHBhcnNlZFJlc3BvbnNlKSwgbnVsbCwgc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jb21wbGV0ZShlcnIsIHBhcnNlZFJlc3BvbnNlLCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIG9uUHJvZ3Jlc3MoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VUZXh0ID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgIHZhciBib2R5RW5kID0gcmVzcG9uc2VUZXh0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB2YXIgaWR4LCBjaHVuaztcbiAgICAgICAgICAgIHdoaWxlIChzdHJlYW1Qb3MgPCBib2R5RW5kICYmIChpZHggPSByZXNwb25zZVRleHQuaW5kZXhPZignXFxuJywgc3RyZWFtUG9zKSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGNodW5rID0gcmVzcG9uc2VUZXh0LnNsaWNlKHN0cmVhbVBvcywgaWR4KTtcbiAgICAgICAgICAgICAgICBzdHJlYW1Qb3MgPSBpZHggKyAxO1xuICAgICAgICAgICAgICAgIG9uQ2h1bmsoY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvbkNodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNodW5rID0gSlNPTi5wYXJzZShjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdNYWxmb3JtZWQgcmVzcG9uc2UgYm9keSBmcm9tIHNlcnZlcjogJyArIGUubWVzc2FnZSwgbnVsbCwgNDAwKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uU3RyZWFtRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb25Qcm9ncmVzcygpO1xuICAgICAgICAgICAgX3RoaXMuc3RyZWFtQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZTtcbiAgICAgICAgICAgIGlmIChyZWFkeVN0YXRlIDwgMylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZSA9IHhoci5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgIC8qIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID09PSAxMjIzKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZSA9IDIwNDtcbiAgICAgICAgICAgICAgICAgICAgb25SZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVhZHlTdGF0ZSA9PSAzICYmIHN0cmVhbWluZykge1xuICAgICAgICAgICAgICAgICAgICBvblByb2dyZXNzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyZWFtaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgb25TdHJlYW1FbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb25FbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhoci5zZW5kKGJvZHkpO1xuICAgIH07XG4gICAgWEhSUmVxdWVzdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHhociA9IHRoaXMueGhyO1xuICAgICAgICBpZiAoeGhyKSB7XG4gICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0geGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPSBub29wO1xuICAgICAgICAgICAgdGhpcy54aHIgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHRpbWVyID0gdGhpcy50aW1lcjtcbiAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVxdWVzdENvbXBsZXRlKVxuICAgICAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBwZW5kaW5nUmVxdWVzdHNbdGhpcy5pZF07XG4gICAgfTtcbiAgICByZXR1cm4gWEhSUmVxdWVzdDtcbn0oZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gWEhSUmVxdWVzdDtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTMpKSlcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBtdWx0aWNhc3Rlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyMykpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgaG1hY19zaGEyNTZfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNDUpKTtcbnZhciBlbmNfYmFzZTY0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbnZhciBIdHRwTWV0aG9kc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxOCkpO1xudmFyIEh0dHBTdGF0dXNDb2Rlc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyNSkpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciByZXNvdXJjZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNCkpO1xudmFyIE1BWF9UT0tFTl9MRU5HVEggPSBNYXRoLnBvdygyLCAxNyk7XG5mdW5jdGlvbiBub29wKCkgeyB9XG5mdW5jdGlvbiByYW5kb20oKSB7XG4gICAgcmV0dXJuICgnMDAwMDAwJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlMTYpKS5zbGljZSgtMTYpO1xufVxuZnVuY3Rpb24gaXNSZWFsdGltZShjbGllbnQpIHtcbiAgICByZXR1cm4gISFjbGllbnQuY29ubmVjdGlvbjtcbn1cbi8qIEEgY2xpZW50IGF1dGggY2FsbGJhY2sgbWF5IGdpdmUgZXJyb3JzIGluIGFueSBudW1iZXIgb2YgZm9ybWF0czsgbm9ybWFsaXNlIHRvIGFuIEVycm9ySW5mbyBvciBQYXJ0aWFsRXJyb3JJbmZvICovXG5mdW5jdGlvbiBub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIpIHtcbiAgICBpZiAoIVV0aWxzLmlzRXJyb3JJbmZvT3JQYXJ0aWFsRXJyb3JJbmZvKGVycikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KFV0aWxzLmluc3BlY3RFcnJvcihlcnIpLCBlcnIuY29kZSB8fCA0MDE3MCwgZXJyLnN0YXR1c0NvZGUgfHwgNDAxKTtcbiAgICB9XG4gICAgLyogbmV0d29yayBlcnJvcnMgd2lsbCBub3QgaGF2ZSBhbiBpbmhlcmVudCBlcnJvciBjb2RlICovXG4gICAgaWYgKCFlcnIuY29kZSkge1xuICAgICAgICBpZiAoZXJyLnN0YXR1c0NvZGUgPT09IDQwMykge1xuICAgICAgICAgICAgZXJyLmNvZGUgPSA0MDMwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVyci5jb2RlID0gNDAxNzA7XG4gICAgICAgICAgICAvKiBub3JtYWxpc2Ugc3RhdHVzQ29kZSB0byA0MDEgcGVyIFJTQTRlICovXG4gICAgICAgICAgICBlcnIuc3RhdHVzQ29kZSA9IDQwMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyO1xufVxudmFyIGhtYWMgPSBmdW5jdGlvbiAodGV4dCwga2V5KSB7XG4gICAgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuY3JlYXRlSG1hYykge1xuICAgICAgICB2YXIgaW5zdCA9IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuY3JlYXRlSG1hYygnU0hBMjU2Jywga2V5KTtcbiAgICAgICAgaW5zdC51cGRhdGUodGV4dCk7XG4gICAgICAgIHJldHVybiBpbnN0LmRpZ2VzdCgnYmFzZTY0Jyk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgZW5jX2Jhc2U2NF8xLnN0cmluZ2lmeSkoKDAsIGhtYWNfc2hhMjU2XzEuZGVmYXVsdCkodGV4dCwga2V5KSk7XG59O1xuZnVuY3Rpb24gYzE0bihjYXBhYmlsaXR5KSB7XG4gICAgaWYgKCFjYXBhYmlsaXR5KVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgaWYgKHR5cGVvZiBjYXBhYmlsaXR5ID09ICdzdHJpbmcnKVxuICAgICAgICBjYXBhYmlsaXR5ID0gSlNPTi5wYXJzZShjYXBhYmlsaXR5KTtcbiAgICB2YXIgYzE0bkNhcGFiaWxpdHkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gVXRpbHMua2V5c0FycmF5KGNhcGFiaWxpdHksIHRydWUpO1xuICAgIGlmICgha2V5cylcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGtleXMuc29ydCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjMTRuQ2FwYWJpbGl0eVtrZXlzW2ldXSA9IGNhcGFiaWxpdHlba2V5c1tpXV0uc29ydCgpO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYzE0bkNhcGFiaWxpdHkpO1xufVxuZnVuY3Rpb24gbG9nQW5kVmFsaWRhdGVUb2tlbkF1dGhNZXRob2QoYXV0aE9wdGlvbnMpIHtcbiAgICBpZiAoYXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQXV0aCgpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoQ2FsbGJhY2snKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXV0aE9wdGlvbnMuYXV0aFVybCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGgoKScsICd1c2luZyB0b2tlbiBhdXRoIHdpdGggYXV0aFVybCcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdXRoT3B0aW9ucy5rZXkpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdBdXRoKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGNsaWVudC1zaWRlIHNpZ25pbmcnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQXV0aCgpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBzdXBwbGllZCB0b2tlbiBvbmx5Jyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgbXNnID0gJ2F1dGhPcHRpb25zIG11c3QgaW5jbHVkZSB2YWxpZCBhdXRoZW50aWNhdGlvbiBwYXJhbWV0ZXJzJztcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdBdXRoKCknLCBtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBiYXNpY0F1dGhGb3JjZWQob3B0aW9ucykge1xuICAgIHJldHVybiAndXNlVG9rZW5BdXRoJyBpbiBvcHRpb25zICYmICFvcHRpb25zLnVzZVRva2VuQXV0aDtcbn1cbi8qIFJTQTQgKi9cbmZ1bmN0aW9uIHVzZVRva2VuQXV0aChvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLnVzZVRva2VuQXV0aCB8fFxuICAgICAgICAoIWJhc2ljQXV0aEZvcmNlZChvcHRpb25zKSAmJiAob3B0aW9ucy5hdXRoQ2FsbGJhY2sgfHwgb3B0aW9ucy5hdXRoVXJsIHx8IG9wdGlvbnMudG9rZW4gfHwgb3B0aW9ucy50b2tlbkRldGFpbHMpKSk7XG59XG4vKiBSU0E0YSAqL1xuZnVuY3Rpb24gbm9XYXlUb1JlbmV3KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gIW9wdGlvbnMua2V5ICYmICFvcHRpb25zLmF1dGhDYWxsYmFjayAmJiAhb3B0aW9ucy5hdXRoVXJsO1xufVxudmFyIHRySWQgPSAwO1xuZnVuY3Rpb24gZ2V0VG9rZW5SZXF1ZXN0SWQoKSB7XG4gICAgcmV0dXJuIHRySWQrKztcbn1cbnZhciBBdXRoID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF1dGgoY2xpZW50LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIFRoaXMgaW5pdGlhbGl6YXRpb24gaXMgYWx3YXlzIG92ZXJ3cml0dGVuIGFuZCBvbmx5IHVzZWQgdG8gcHJldmVudCBhIFR5cGVTY3JpcHQgY29tcGlsZXIgZXJyb3JcbiAgICAgICAgdGhpcy5hdXRoT3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy50b2tlblBhcmFtcyA9IG9wdGlvbnMuZGVmYXVsdFRva2VuUGFyYW1zIHx8IHt9O1xuICAgICAgICAvKiBUaGUgaWQgb2YgdGhlIGN1cnJlbnQgdG9rZW4gcmVxdWVzdCBpZiBvbmUgaXMgaW4gcHJvZ3Jlc3MsIGVsc2UgbnVsbCAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IG51bGw7XG4gICAgICAgIHRoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdCA9IG51bGw7XG4gICAgICAgIGlmICh1c2VUb2tlbkF1dGgob3B0aW9ucykpIHtcbiAgICAgICAgICAgIC8qIFRva2VuIGF1dGggKi9cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmtleSAmJiAhaG1hYykge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnY2xpZW50LXNpZGUgdG9rZW4gcmVxdWVzdCBzaWduaW5nIG5vdCBzdXBwb3J0ZWQnO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQXV0aCgpJywgbXNnKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub1dheVRvUmVuZXcob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0F1dGgoKScsICdXYXJuaW5nOiBsaWJyYXJ5IGluaXRpYWxpemVkIHdpdGggYSB0b2tlbiBsaXRlcmFsIHdpdGhvdXQgYW55IHdheSB0byByZW5ldyB0aGUgdG9rZW4gd2hlbiBpdCBleHBpcmVzIChubyBhdXRoVXJsLCBhdXRoQ2FsbGJhY2ssIG9yIGtleSkuIFNlZSBodHRwczovL2hlbHAuYWJseS5pby9lcnJvci80MDE3MSBmb3IgaGVscCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2F2ZVRva2VuT3B0aW9ucyhvcHRpb25zLmRlZmF1bHRUb2tlblBhcmFtcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBsb2dBbmRWYWxpZGF0ZVRva2VuQXV0aE1ldGhvZCh0aGlzLmF1dGhPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIEJhc2ljIGF1dGggKi9cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ05vIGF1dGhlbnRpY2F0aW9uIG9wdGlvbnMgcHJvdmlkZWQ7IG5lZWQgb25lIG9mOiBrZXksIGF1dGhVcmwsIG9yIGF1dGhDYWxsYmFjayAob3IgZm9yIHRlc3Rpbmcgb25seSwgdG9rZW4gb3IgdG9rZW5EZXRhaWxzKSc7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdBdXRoKCknLCBtc2cpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgNDAxNjAsIDQwMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGgoKScsICdhbm9ueW1vdXMsIHVzaW5nIGJhc2ljIGF1dGgnKTtcbiAgICAgICAgICAgIHRoaXMuX3NhdmVCYXNpY09wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQXV0aC5wcm90b3R5cGUuYXV0aG9yaXplID0gZnVuY3Rpb24gKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hdXRoT3B0aW9ucztcbiAgICAgICAgLyogc2h1ZmZsZSBhbmQgbm9ybWFsaXNlIGFyZ3VtZW50cyBhcyBuZWNlc3NhcnkgKi9cbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlblBhcmFtcyA9PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSB0b2tlblBhcmFtcztcbiAgICAgICAgICAgIF9hdXRoT3B0aW9ucyA9IHRva2VuUGFyYW1zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXV0aE9wdGlvbnMgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYXV0aE9wdGlvbnM7XG4gICAgICAgICAgICBfYXV0aE9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2F1dGhPcHRpb25zID0gYXV0aE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xpZW50Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdhdXRob3JpemUnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIFJTQTEwYTogYXV0aG9yaXplKCkgY2FsbCBpbXBsaWVzIHRva2VuIGF1dGguIElmIGEga2V5IGlzIHBhc3NlZCBpdCwgd2VcbiAgICAgICAgICoganVzdCBjaGVjayBpZiBpdCBkb2Vzbid0IGNsYXNoIGFuZCBhc3N1bWUgd2UncmUgZ2VuZXJhdGluZyBhIHRva2VuIGZyb20gaXQgKi9cbiAgICAgICAgaWYgKF9hdXRoT3B0aW9ucyAmJiBfYXV0aE9wdGlvbnMua2V5ICYmIHRoaXMuYXV0aE9wdGlvbnMua2V5ICE9PSBfYXV0aE9wdGlvbnMua2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVW5hYmxlIHRvIHVwZGF0ZSBhdXRoIG9wdGlvbnMgd2l0aCBpbmNvbXBhdGlibGUga2V5JywgNDAxMDIsIDQwMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9hdXRoT3B0aW9ucyAmJiAnZm9yY2UnIGluIF9hdXRoT3B0aW9ucykge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdBdXRoLmF1dGhvcml6ZScsICdEZXByZWNhdGlvbiB3YXJuaW5nOiBzcGVjaWZ5aW5nIHtmb3JjZTogdHJ1ZX0gaW4gYXV0aE9wdGlvbnMgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSwgYXV0aG9yaXplKCkgbm93IGFsd2F5cyBnZXRzIGEgbmV3IHRva2VuLiBQbGVhc2UgcmVtb3ZlIHRoaXMsIGFzIGluIHZlcnNpb24gMS4wIGFuZCBsYXRlciwgaGF2aW5nIGEgbm9uLW51bGwgYXV0aE9wdGlvbnMgd2lsbCBvdmVyd3JpdGUgc3RvcmVkIGxpYnJhcnkgYXV0aE9wdGlvbnMsIHdoaWNoIG1heSBub3QgYmUgd2hhdCB5b3Ugd2FudCcpO1xuICAgICAgICAgICAgLyogRW11bGF0ZSB0aGUgb2xkIGJlaGF2aW91cjogaWYgJ2ZvcmNlJyB3YXMgdGhlIG9ubHkgbWVtYmVyIG9mIGF1dGhPcHRpb25zLFxuICAgICAgICAgICAgICogc2V0IGl0IHRvIG51bGwgc28gaXQgZG9lc24ndCBvdmVyd3JpdGUgc3RvcmVkLiBUT0RPOiByZW1vdmUgaW4gdmVyc2lvbiAxLjAgKi9cbiAgICAgICAgICAgIGlmIChVdGlscy5pc09ubHlQcm9wSW4oX2F1dGhPcHRpb25zLCAnZm9yY2UnKSkge1xuICAgICAgICAgICAgICAgIF9hdXRoT3B0aW9ucyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZm9yY2VOZXdUb2tlbih0b2tlblBhcmFtcywgX2F1dGhPcHRpb25zLCBmdW5jdGlvbiAoZXJyLCB0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY2xpZW50LmNvbm5lY3Rpb24gJiYgZXJyLnN0YXR1c0NvZGUgPT09IEh0dHBTdGF0dXNDb2Rlc18xLmRlZmF1bHQuRm9yYmlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFBlciBSU0E0ZCAmIFJTQTRkMSwgaWYgdGhlIGF1dGggc2VydmVyIGV4cGxpY2l0bHkgcmVwdWRpYXRlcyBvdXIgcmlnaHQgdG9cbiAgICAgICAgICAgICAgICAgICAgICogc3RheSBjb25uZWN0aWNlZCBieSByZXR1cm5pbmcgYSA0MDMsIHdlIGFjdGl2ZWx5IGRpc2Nvbm5lY3QgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICogZXZlbiB0aG91Z2ggd2UgbWF5IHdlbGwgc3RpbGwgaGF2ZSB0aW1lIGxlZnQgaW4gdGhlIG9sZCB0b2tlbi4gKi9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xpZW50LmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogUlRDOFxuICAgICAgICAgICAgICogLSBXaGVuIGF1dGhvcml6ZSBjYWxsZWQgYnkgYW4gZW5kIHVzZXIgYW5kIGhhdmUgYSByZWFsdGltZSBjb25uZWN0aW9uLFxuICAgICAgICAgICAgICogZG9uJ3QgY2FsbCBiYWNrIHRpbGwgbmV3IHRva2VuIGhhcyB0YWtlbiBlZmZlY3QuXG4gICAgICAgICAgICAgKiAtIFVzZSB0aGlzLmNsaWVudC5jb25uZWN0aW9uIGFzIGEgcHJveHkgZm9yICh0aGlzLmNsaWVudCBpbnN0YW5jZW9mIFJlYWx0aW1lKSxcbiAgICAgICAgICAgICAqIHdoaWNoIGRvZXNuJ3Qgd29yayBpbiBub2RlIGFzIFJlYWx0aW1lIGlzbid0IHBhcnQgb2YgdGhlIHZtIGNvbnRleHQgZm9yIFJlc3QgY2xpZW50cyAqL1xuICAgICAgICAgICAgaWYgKGlzUmVhbHRpbWUoX3RoaXMuY2xpZW50KSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNsaWVudC5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQodG9rZW5EZXRhaWxzLCBjYWxsYmFjayB8fCBub29wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhudWxsLCB0b2tlbkRldGFpbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEF1dGgucHJvdG90eXBlLmF1dGhvcmlzZSA9IGZ1bmN0aW9uICh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZGVwcmVjYXRlZCgnQXV0aC5hdXRob3Jpc2UnLCAnQXV0aC5hdXRob3JpemUnKTtcbiAgICAgICAgdGhpcy5hdXRob3JpemUodG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvKiBGb3IgaW50ZXJuYWwgdXNlLCBlZyBieSBjb25uZWN0aW9uTWFuYWdlciAtIHVzZWZ1bCB3aGVuIHdhbnQgdG8gY2FsbCBiYWNrXG4gICAgICogYXMgc29vbiBhcyB3ZSBoYXZlIHRoZSBuZXcgdG9rZW4sIHJhdGhlciB0aGFuIHdhaXRpbmcgZm9yIGl0IHRvIHRha2VcbiAgICAgKiBlZmZlY3Qgb24gdGhlIGNvbm5lY3Rpb24gYXMgI2F1dGhvcml6ZSBkb2VzICovXG4gICAgQXV0aC5wcm90b3R5cGUuX2ZvcmNlTmV3VG9rZW4gPSBmdW5jdGlvbiAodG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiBnZXQgcmlkIG9mIGN1cnJlbnQgdG9rZW4gZXZlbiBpZiBzdGlsbCB2YWxpZCAqL1xuICAgICAgICB0aGlzLnRva2VuRGV0YWlscyA9IG51bGw7XG4gICAgICAgIC8qIF9zYXZlIG5vcm1hbGlzZXMgdGhlIHRva2VuUGFyYW1zIGFuZCBhdXRoT3B0aW9ucyBhbmQgdXBkYXRlcyB0aGUgYXV0aFxuICAgICAgICAgKiBvYmplY3QuIEFsbCBzdWJzZXF1ZW50IG9wZXJhdGlvbnMgc2hvdWxkIHVzZSB0aGUgdmFsdWVzIG9uIGB0aGlzYCxcbiAgICAgICAgICogbm90IHRoZSBwYXNzZWQgaW4gb25lcy4gKi9cbiAgICAgICAgdGhpcy5fc2F2ZVRva2VuT3B0aW9ucyh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpO1xuICAgICAgICBsb2dBbmRWYWxpZGF0ZVRva2VuQXV0aE1ldGhvZCh0aGlzLmF1dGhPcHRpb25zKTtcbiAgICAgICAgdGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHModHJ1ZSwgZnVuY3Rpb24gKGVyciwgdG9rZW5EZXRhaWxzKSB7XG4gICAgICAgICAgICAvKiBSU0ExMGcgKi9cbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy50b2tlblBhcmFtcy50aW1lc3RhbXA7XG4gICAgICAgICAgICBkZWxldGUgX3RoaXMuYXV0aE9wdGlvbnMucXVlcnlUaW1lO1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCB0b2tlbkRldGFpbHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEF1dGgucHJvdG90eXBlLnJlcXVlc3RUb2tlbiA9IGZ1bmN0aW9uICh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qIHNodWZmbGUgYW5kIG5vcm1hbGlzZSBhcmd1bWVudHMgYXMgbmVjZXNzYXJ5ICovXG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW5QYXJhbXMgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdG9rZW5QYXJhbXM7XG4gICAgICAgICAgICBhdXRoT3B0aW9ucyA9IHRva2VuUGFyYW1zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXV0aE9wdGlvbnMgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYXV0aE9wdGlvbnM7XG4gICAgICAgICAgICBhdXRoT3B0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYWxsYmFjayAmJiB0aGlzLmNsaWVudC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdyZXF1ZXN0VG9rZW4nLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qIFJTQThlOiBpZiBhdXRoT3B0aW9ucyBwYXNzZWQgaW4sIHRoZXkncmUgdXNlZCBpbnN0ZWFkIG9mIHN0b3JlZCwgZG9uJ3QgbWVyZ2UgdGhlbSAqL1xuICAgICAgICBhdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zIHx8IHRoaXMuYXV0aE9wdGlvbnM7XG4gICAgICAgIHRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXMgfHwgVXRpbHMuY29weSh0aGlzLnRva2VuUGFyYW1zKTtcbiAgICAgICAgdmFyIF9jYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gICAgICAgIC8qIGZpcnN0IHNldCB1cCB3aGF0ZXZlciBjYWxsYmFjayB3aWxsIGJlIHVzZWQgdG8gZ2V0IHNpZ25lZFxuICAgICAgICAgKiB0b2tlbiByZXF1ZXN0cyAqL1xuICAgICAgICB2YXIgdG9rZW5SZXF1ZXN0Q2FsbGJhY2ssIGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgICAgICBpZiAoYXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhDYWxsYmFjaycpO1xuICAgICAgICAgICAgdG9rZW5SZXF1ZXN0Q2FsbGJhY2sgPSBhdXRoT3B0aW9ucy5hdXRoQ2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXV0aE9wdGlvbnMuYXV0aFVybCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoVXJsJyk7XG4gICAgICAgICAgICB0b2tlblJlcXVlc3RDYWxsYmFjayA9IGZ1bmN0aW9uIChwYXJhbXMsIGNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF1dGhIZWFkZXJzID0gVXRpbHMubWl4aW4oeyBhY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluJyB9LCBhdXRoT3B0aW9ucy5hdXRoSGVhZGVycyk7XG4gICAgICAgICAgICAgICAgdmFyIHVzZVBvc3QgPSBhdXRoT3B0aW9ucy5hdXRoTWV0aG9kICYmIGF1dGhPcHRpb25zLmF1dGhNZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gJ3Bvc3QnO1xuICAgICAgICAgICAgICAgIHZhciBwcm92aWRlZFFzUGFyYW1zO1xuICAgICAgICAgICAgICAgIC8qIENvbWJpbmUgYXV0aFBhcmFtcyB3aXRoIGFueSBxcyBwYXJhbXMgZ2l2ZW4gaW4gdGhlIGF1dGhVcmwgKi9cbiAgICAgICAgICAgICAgICB2YXIgcXVlcnlJZHggPSBhdXRoT3B0aW9ucy5hdXRoVXJsLmluZGV4T2YoJz8nKTtcbiAgICAgICAgICAgICAgICBpZiAocXVlcnlJZHggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlZFFzUGFyYW1zID0gVXRpbHMucGFyc2VRdWVyeVN0cmluZyhhdXRoT3B0aW9ucy5hdXRoVXJsLnNsaWNlKHF1ZXJ5SWR4KSk7XG4gICAgICAgICAgICAgICAgICAgIGF1dGhPcHRpb25zLmF1dGhVcmwgPSBhdXRoT3B0aW9ucy5hdXRoVXJsLnNsaWNlKDAsIHF1ZXJ5SWR4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VQb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBJbiBjYXNlIG9mIGNvbmZsaWN0LCBhdXRoUGFyYW1zIHRha2UgcHJlY2VkZW5jZSBvdmVyIHFzIHBhcmFtcyBpbiB0aGUgYXV0aFVybCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aE9wdGlvbnMuYXV0aFBhcmFtcyA9IFV0aWxzLm1peGluKHByb3ZpZGVkUXNQYXJhbXMsIGF1dGhPcHRpb25zLmF1dGhQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIFJTQThjMiAqL1xuICAgICAgICAgICAgICAgIHZhciBhdXRoUGFyYW1zID0gVXRpbHMubWl4aW4oe30sIGF1dGhPcHRpb25zLmF1dGhQYXJhbXMgfHwge30sIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgdmFyIGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKS50b2tlblJlcXVlc3RDYWxsYmFjaycsICdSZWNlaXZlZCBFcnJvcjogJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gaGVhZGVyc1snY29udGVudC10eXBlJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0F1dGgucmVxdWVzdFRva2VuKCkudG9rZW5SZXF1ZXN0Q2FsbGJhY2snLCAnUmVjZWl2ZWQ7IGNvbnRlbnQtdHlwZTogJyArIGNvbnRlbnRUeXBlICsgJzsgYm9keTogJyArIFV0aWxzLmluc3BlY3RCb2R5KGJvZHkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyIHx8IHVucGFja2VkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVyciwgYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuaXNCdWZmZXIoYm9keSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gYm9keS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYihuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnYXV0aFVybCByZXNwb25zZSBpcyBtaXNzaW5nIGEgY29udGVudC10eXBlIGhlYWRlcicsIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIganNvbiA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xLCB0ZXh0ID0gY29udGVudFR5cGUuaW5kZXhPZigndGV4dC9wbGFpbicpID4gLTEgfHwgY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vand0JykgPiAtMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqc29uICYmICF0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYihuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnYXV0aFVybCByZXNwb25kZWQgd2l0aCB1bmFjY2VwdGFibGUgY29udGVudC10eXBlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLCBzaG91bGQgYmUgZWl0aGVyIHRleHQvcGxhaW4sIGFwcGxpY2F0aW9uL2p3dCBvciBhcHBsaWNhdGlvbi9qc29uJywgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keS5sZW5ndGggPiBNQVhfVE9LRU5fTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ2F1dGhVcmwgcmVzcG9uc2UgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBsZW5ndGgnLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1VuZXhwZWN0ZWQgZXJyb3IgcHJvY2Vzc2luZyBhdXRoVVJMIHJlc3BvbnNlOyBlcnIgPSAnICsgZS5tZXNzYWdlLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIGJvZHksIGNvbnRlbnRUeXBlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKS50b2tlblJlcXVlc3RDYWxsYmFjaycsICdSZXF1ZXN0aW5nIHRva2VuIGZyb20gJyArXG4gICAgICAgICAgICAgICAgICAgIGF1dGhPcHRpb25zLmF1dGhVcmwgK1xuICAgICAgICAgICAgICAgICAgICAnOyBQYXJhbXM6ICcgK1xuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShhdXRoUGFyYW1zKSArXG4gICAgICAgICAgICAgICAgICAgICc7IG1ldGhvZDogJyArXG4gICAgICAgICAgICAgICAgICAgICh1c2VQb3N0ID8gJ1BPU1QnIDogJ0dFVCcpKTtcbiAgICAgICAgICAgICAgICBpZiAodXNlUG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAvKiBzZW5kIGJvZHkgZm9ybS1lbmNvZGVkICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzID0gYXV0aEhlYWRlcnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gVXRpbHMudG9RdWVyeVN0cmluZyhhdXRoUGFyYW1zKS5zbGljZSgxKTsgLyogc2xpY2UgaXMgdG8gcmVtb3ZlIHRoZSBpbml0aWFsICc/JyAqL1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbGllbnQuaHR0cC5kb1VyaShIdHRwTWV0aG9kc18xLmRlZmF1bHQuUG9zdCwgY2xpZW50LCBhdXRoT3B0aW9ucy5hdXRoVXJsLCBoZWFkZXJzLCBib2R5LCBwcm92aWRlZFFzUGFyYW1zLCBhdXRoVXJsUmVxdWVzdENhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNsaWVudC5odHRwLmRvVXJpKEh0dHBNZXRob2RzXzEuZGVmYXVsdC5HZXQsIGNsaWVudCwgYXV0aE9wdGlvbnMuYXV0aFVybCwgYXV0aEhlYWRlcnMgfHwge30sIG51bGwsIGF1dGhQYXJhbXMsIGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXV0aE9wdGlvbnMua2V5KSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGNsaWVudC1zaWRlIHNpZ25pbmcnKTtcbiAgICAgICAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrID0gZnVuY3Rpb24gKHBhcmFtcywgY2IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jcmVhdGVUb2tlblJlcXVlc3QocGFyYW1zLCBhdXRoT3B0aW9ucywgY2IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnTmVlZCBhIG5ldyB0b2tlbiwgYnV0IGF1dGhPcHRpb25zIGRvZXMgbm90IGluY2x1ZGUgYW55IHdheSB0byByZXF1ZXN0IG9uZSAobm8gYXV0aFVybCwgYXV0aENhbGxiYWNrLCBvciBrZXkpJztcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQXV0aCgpJywgJ2xpYnJhcnkgaW5pdGlhbGl6ZWQgd2l0aCBhIHRva2VuIGxpdGVyYWwgd2l0aG91dCBhbnkgd2F5IHRvIHJlbmV3IHRoZSB0b2tlbiB3aGVuIGl0IGV4cGlyZXMgKG5vIGF1dGhVcmwsIGF1dGhDYWxsYmFjaywgb3Iga2V5KS4gU2VlIGh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yLzQwMTcxIGZvciBoZWxwJyk7XG4gICAgICAgICAgICBfY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA0MDE3MSwgNDAzKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyogbm9ybWFsaXNlIHRva2VuIHBhcmFtcyAqL1xuICAgICAgICBpZiAoJ2NhcGFiaWxpdHknIGluIHRva2VuUGFyYW1zKVxuICAgICAgICAgICAgdG9rZW5QYXJhbXMuY2FwYWJpbGl0eSA9IGMxNG4odG9rZW5QYXJhbXMuY2FwYWJpbGl0eSk7XG4gICAgICAgIHZhciB0b2tlblJlcXVlc3QgPSBmdW5jdGlvbiAoc2lnbmVkVG9rZW5QYXJhbXMsIHRva2VuQ2IpIHtcbiAgICAgICAgICAgIHZhciBrZXlOYW1lID0gc2lnbmVkVG9rZW5QYXJhbXMua2V5TmFtZSwgcGF0aCA9ICcva2V5cy8nICsga2V5TmFtZSArICcvcmVxdWVzdFRva2VuJywgdG9rZW5VcmkgPSBmdW5jdGlvbiAoaG9zdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnQuYmFzZVVyaShob3N0KSArIHBhdGg7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gVXRpbHMuZGVmYXVsdFBvc3RIZWFkZXJzKF90aGlzLmNsaWVudC5vcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChhdXRoT3B0aW9ucy5yZXF1ZXN0SGVhZGVycylcbiAgICAgICAgICAgICAgICBVdGlscy5taXhpbihyZXF1ZXN0SGVhZGVycywgYXV0aE9wdGlvbnMucmVxdWVzdEhlYWRlcnMpO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdBdXRoLnJlcXVlc3RUb2tlbigpLnJlcXVlc3RUb2tlbicsICdTZW5kaW5nIFBPU1QgdG8gJyArIHBhdGggKyAnOyBUb2tlbiBwYXJhbXM6ICcgKyBKU09OLnN0cmluZ2lmeShzaWduZWRUb2tlblBhcmFtcykpO1xuICAgICAgICAgICAgX3RoaXMuY2xpZW50Lmh0dHAuZG8oSHR0cE1ldGhvZHNfMS5kZWZhdWx0LlBvc3QsIGNsaWVudCwgdG9rZW5VcmksIHJlcXVlc3RIZWFkZXJzLCBKU09OLnN0cmluZ2lmeShzaWduZWRUb2tlblBhcmFtcyksIG51bGwsIHRva2VuQ2IpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0RXhwaXJlZCA9IGZhbHNlLCB0aW1lb3V0TGVuZ3RoID0gdGhpcy5jbGllbnQub3B0aW9ucy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0LCB0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdUb2tlbiByZXF1ZXN0IGNhbGxiYWNrIHRpbWVkIG91dCBhZnRlciAnICsgdGltZW91dExlbmd0aCAvIDEwMDAgKyAnIHNlY29uZHMnO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgbXNnKTtcbiAgICAgICAgICAgIF9jYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgfSwgdGltZW91dExlbmd0aCk7XG4gICAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrKHRva2VuUGFyYW1zLCBmdW5jdGlvbiAoZXJyLCB0b2tlblJlcXVlc3RPckRldGFpbHMsIGNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICBpZiAodG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0RXhwaXJlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0KTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCAndG9rZW4gcmVxdWVzdCBzaWduaW5nIGNhbGwgcmV0dXJuZWQgZXJyb3I7IGVyciA9ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgX2NhbGxiYWNrKG5vcm1hbGlzZUF1dGhjYWxsYmFja0Vycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIHRoZSByZXNwb25zZSBmcm9tIHRoZSBjYWxsYmFjayBtaWdodCBiZSBhIHRva2VuIHN0cmluZywgYSBzaWduZWQgcmVxdWVzdCBvciBhIHRva2VuIGRldGFpbHMgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlblJlcXVlc3RPckRldGFpbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVG9rZW4gc3RyaW5nIGlzIGVtcHR5JywgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlblJlcXVlc3RPckRldGFpbHMubGVuZ3RoID4gTUFYX1RPS0VOX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgICAgICBfY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1Rva2VuIHN0cmluZyBleGNlZWRlZCBtYXggcGVybWl0dGVkIGxlbmd0aCAod2FzICcgKyB0b2tlblJlcXVlc3RPckRldGFpbHMubGVuZ3RoICsgJyBieXRlcyknLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuUmVxdWVzdE9yRGV0YWlscyA9PT0gJ3VuZGVmaW5lZCcgfHwgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogY29tbW9uIGZhaWx1cmUgbW9kZSB3aXRoIHBvb3JseS1pbXBsZW1lbnRlZCBhdXRoQ2FsbGJhY2tzICovXG4gICAgICAgICAgICAgICAgICAgIF9jYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVG9rZW4gc3RyaW5nIHdhcyBsaXRlcmFsIG51bGwvdW5kZWZpbmVkJywgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlblJlcXVlc3RPckRldGFpbHNbMF0gPT09ICd7JyAmJiAhKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2p3dCcpID4gLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChcIlRva2VuIHdhcyBkb3VibGUtZW5jb2RlZDsgbWFrZSBzdXJlIHlvdSdyZSBub3QgSlNPTi1lbmNvZGluZyBhbiBhbHJlYWR5IGVuY29kZWQgdG9rZW4gcmVxdWVzdCBvciBkZXRhaWxzXCIsIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYWxsYmFjayhudWxsLCB7IHRva2VuOiB0b2tlblJlcXVlc3RPckRldGFpbHMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnRXhwZWN0ZWQgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0byBjYWxsIGJhY2sgd2l0aCBhIHRva2VuIHN0cmluZyBvciB0b2tlbiByZXF1ZXN0L2RldGFpbHMgb2JqZWN0LCBidXQgZ290IGEgJyArXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0b2tlblJlcXVlc3RPckRldGFpbHM7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgbXNnKTtcbiAgICAgICAgICAgICAgICBfY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9iamVjdFNpemUgPSBKU09OLnN0cmluZ2lmeSh0b2tlblJlcXVlc3RPckRldGFpbHMpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChvYmplY3RTaXplID4gTUFYX1RPS0VOX0xFTkdUSCAmJiAhYXV0aE9wdGlvbnMuc3VwcHJlc3NNYXhMZW5ndGhDaGVjaykge1xuICAgICAgICAgICAgICAgIF9jYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVG9rZW4gcmVxdWVzdC9kZXRhaWxzIG9iamVjdCBleGNlZWRlZCBtYXggcGVybWl0dGVkIHN0cmluZ2lmaWVkIHNpemUgKHdhcyAnICsgb2JqZWN0U2l6ZSArICcgYnl0ZXMpJywgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnaXNzdWVkJyBpbiB0b2tlblJlcXVlc3RPckRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAvKiBhIHRva2VuRGV0YWlscyBvYmplY3QgKi9cbiAgICAgICAgICAgICAgICBfY2FsbGJhY2sobnVsbCwgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISgna2V5TmFtZScgaW4gdG9rZW5SZXF1ZXN0T3JEZXRhaWxzKSkge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnRXhwZWN0ZWQgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0byBjYWxsIGJhY2sgd2l0aCBhIHRva2VuIHN0cmluZywgdG9rZW4gcmVxdWVzdCBvYmplY3QsIG9yIHRva2VuIGRldGFpbHMgb2JqZWN0JztcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCBtc2cpO1xuICAgICAgICAgICAgICAgIF9jYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBpdCdzIGEgdG9rZW4gcmVxdWVzdCwgc28gbWFrZSB0aGUgcmVxdWVzdCAqL1xuICAgICAgICAgICAgdG9rZW5SZXF1ZXN0KHRva2VuUmVxdWVzdE9yRGV0YWlscywgZnVuY3Rpb24gKGVyciwgdG9rZW5SZXNwb25zZSwgaGVhZGVycywgdW5wYWNrZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsICd0b2tlbiByZXF1ZXN0IEFQSSBjYWxsIHJldHVybmVkIGVycm9yOyBlcnIgPSAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgICAgICBfY2FsbGJhY2sobm9ybWFsaXNlQXV0aGNhbGxiYWNrRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF1bnBhY2tlZClcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5SZXNwb25zZSA9IEpTT04ucGFyc2UodG9rZW5SZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdBdXRoLmdldFRva2VuKCknLCAndG9rZW4gcmVjZWl2ZWQnKTtcbiAgICAgICAgICAgICAgICBfY2FsbGJhY2sobnVsbCwgdG9rZW5SZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIHNpZ24gYSB0b2tlbiByZXF1ZXN0IGJhc2VkIG9uIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgICAqIE5PVEUgdGhpcyBjYW4gb25seSBiZSB1c2VkIHdoZW4gdGhlIGtleSB2YWx1ZSBpcyBhdmFpbGFibGUgbG9jYWxseS5cbiAgICAgKiBPdGhlcndpc2UsIHNpZ25lZCB0b2tlbiByZXF1ZXN0cyBtdXN0IGJlIG9idGFpbmVkIGZyb20gdGhlIGtleVxuICAgICAqIG93bmVyIChlaXRoZXIgdXNpbmcgdGhlIHRva2VuIHJlcXVlc3QgY2FsbGJhY2sgb3IgdXJsKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdXRoT3B0aW9uc1xuICAgICAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSByZXF1ZXN0IG9wdGlvbnM6XG4gICAgICogLSBrZXk6ICAgICAgICAgICB0aGUga2V5IHRvIHVzZS4gSWYgbm90IHNwZWNpZmllZCwgYSBrZXkgcGFzc2VkIGluIGNvbnN0cnVjdGluZ1xuICAgICAqICAgICAgICAgICAgICAgICAgdGhlIFJlc3QgaW50ZXJmYWNlIHdpbGwgYmUgdXNlZFxuICAgICAqXG4gICAgICogLSBxdWVyeVRpbWUgICAgICAob3B0aW9uYWwpIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoZSBhYmx5IHN5c3RlbSBzaG91bGQgYmVcbiAgICAgKiAgICAgICAgICAgICAgICAgIHF1ZXJpZWQgZm9yIHRoZSBjdXJyZW50IHRpbWUgd2hlbiBub25lIGlzIHNwZWNpZmllZCBleHBsaWNpdGx5XG4gICAgICpcbiAgICAgKiAtIHJlcXVlc3RIZWFkZXJzIChvcHRpb25hbCwgdW5zdXBwb3J0ZWQsIGZvciB0ZXN0aW5nIG9ubHkpIGV4dHJhIGhlYWRlcnMgdG8gYWRkIHRvIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2VuIHJlcXVlc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b2tlblBhcmFtc1xuICAgICAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVxdWVzdGVkIHRva2VuOlxuICAgICAqIC0gdHRsOiAgICAgICAob3B0aW9uYWwpIHRoZSByZXF1ZXN0ZWQgbGlmZSBvZiB0aGUgdG9rZW4gaW4gbXMuIElmIG5vbmUgaXMgc3BlY2lmaWVkXG4gICAgICogICAgICAgICAgICAgICAgICBhIGRlZmF1bHQgb2YgMSBob3VyIGlzIHByb3ZpZGVkLiBUaGUgbWF4aW11bSBsaWZldGltZSBpcyAyNGhvdXJzOyBhbnkgcmVxdWVzdFxuICAgICAqICAgICAgICAgICAgICAgICAgZXhjZWVkaW5nIHRoYXQgbGlmZXRpbWUgd2lsbCBiZSByZWplY3RlZCB3aXRoIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogLSBjYXBhYmlsaXR5OiAgICAob3B0aW9uYWwpIHRoZSBjYXBhYmlsaXR5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBhY2Nlc3MgdG9rZW4uXG4gICAgICogICAgICAgICAgICAgICAgICBJZiBub25lIGlzIHNwZWNpZmllZCwgYSB0b2tlbiB3aWxsIGJlIHJlcXVlc3RlZCB3aXRoIGFsbCBvZiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgIGNhcGFiaWxpdGllcyBvZiB0aGUgc3BlY2lmaWVkIGtleS5cbiAgICAgKlxuICAgICAqIC0gY2xpZW50SWQ6ICAgICAgKG9wdGlvbmFsKSBhIGNsaWVudCBJRCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgdG9rZW47IGlmIG5vdFxuICAgICAqICAgICAgICAgICAgICAgICAgc3BlY2lmaWVkLCBhIGNsaWVudElkIHBhc3NlZCBpbiBjb25zdHJ1Y3RpbmcgdGhlIFJlc3QgaW50ZXJmYWNlIHdpbGwgYmUgdXNlZFxuICAgICAqXG4gICAgICogLSB0aW1lc3RhbXA6ICAgICAob3B0aW9uYWwpIHRoZSB0aW1lIGluIG1zIHNpbmNlIHRoZSBlcG9jaC4gSWYgbm9uZSBpcyBzcGVjaWZpZWQsXG4gICAgICogICAgICAgICAgICAgICAgICB0aGUgc3lzdGVtIHdpbGwgYmUgcXVlcmllZCBmb3IgYSB0aW1lIHZhbHVlIHRvIHVzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAqL1xuICAgIEF1dGgucHJvdG90eXBlLmNyZWF0ZVRva2VuUmVxdWVzdCA9IGZ1bmN0aW9uICh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qIHNodWZmbGUgYW5kIG5vcm1hbGlzZSBhcmd1bWVudHMgYXMgbmVjZXNzYXJ5ICovXG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW5QYXJhbXMgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdG9rZW5QYXJhbXM7XG4gICAgICAgICAgICBhdXRoT3B0aW9ucyA9IHRva2VuUGFyYW1zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXV0aE9wdGlvbnMgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYXV0aE9wdGlvbnM7XG4gICAgICAgICAgICBhdXRoT3B0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYWxsYmFjayAmJiB0aGlzLmNsaWVudC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdjcmVhdGVUb2tlblJlcXVlc3QnLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qIFJTQTloOiBpZiBhdXRoT3B0aW9ucyBwYXNzZWQgaW4sIHRoZXkncmUgdXNlZCBpbnN0ZWFkIG9mIHN0b3JlZCwgZG9uJ3QgbWVyZ2UgdGhlbSAqL1xuICAgICAgICBhdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zIHx8IHRoaXMuYXV0aE9wdGlvbnM7XG4gICAgICAgIHRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXMgfHwgVXRpbHMuY29weSh0aGlzLnRva2VuUGFyYW1zKTtcbiAgICAgICAgdmFyIGtleSA9IGF1dGhPcHRpb25zLmtleTtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdObyBrZXkgc3BlY2lmaWVkJywgNDAxMDEsIDQwMykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlQYXJ0cyA9IGtleS5zcGxpdCgnOicpLCBrZXlOYW1lID0ga2V5UGFydHNbMF0sIGtleVNlY3JldCA9IGtleVBhcnRzWzFdO1xuICAgICAgICBpZiAoIWtleVNlY3JldCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0ludmFsaWQga2V5IHNwZWNpZmllZCcsIDQwMTAxLCA0MDMpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5QYXJhbXMuY2xpZW50SWQgPT09ICcnKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnY2xpZW50SWQgY2Fu4oCZdCBiZSBhbiBlbXB0eSBzdHJpbmcnLCA0MDAxMiwgNDAwKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdjYXBhYmlsaXR5JyBpbiB0b2tlblBhcmFtcykge1xuICAgICAgICAgICAgdG9rZW5QYXJhbXMuY2FwYWJpbGl0eSA9IGMxNG4odG9rZW5QYXJhbXMuY2FwYWJpbGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcXVlc3QgPSBVdGlscy5taXhpbih7IGtleU5hbWU6IGtleU5hbWUgfSwgdG9rZW5QYXJhbXMpLCBjbGllbnRJZCA9IHRva2VuUGFyYW1zLmNsaWVudElkIHx8ICcnLCB0dGwgPSB0b2tlblBhcmFtcy50dGwgfHwgJycsIGNhcGFiaWxpdHkgPSB0b2tlblBhcmFtcy5jYXBhYmlsaXR5IHx8ICcnO1xuICAgICAgICAoZnVuY3Rpb24gKGF1dGhvcmlzZUNiKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC50aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICBhdXRob3Jpc2VDYigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmdldFRpbWVzdGFtcChhdXRoT3B0aW9ucyAmJiBhdXRoT3B0aW9ucy5xdWVyeVRpbWUsIGZ1bmN0aW9uIChlcnIsIHRpbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVxdWVzdC50aW1lc3RhbXAgPSB0aW1lO1xuICAgICAgICAgICAgICAgIGF1dGhvcmlzZUNiKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLyogbm9uY2UgKi9cbiAgICAgICAgICAgIC8qIE5PVEU6IHRoZXJlIGlzIG5vIGV4cGVjdGF0aW9uIHRoYXQgdGhlIGNsaWVudFxuICAgICAgICAgICAgICogc3BlY2lmaWVzIHRoZSBub25jZTsgdGhpcyBpcyBkb25lIGJ5IHRoZSBsaWJyYXJ5XG4gICAgICAgICAgICAgKiBIb3dldmVyLCB0aGlzIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBjbGllbnRcbiAgICAgICAgICAgICAqIHNpbXBseSBmb3IgdGVzdGluZyBwdXJwb3Nlcy4gKi9cbiAgICAgICAgICAgIHZhciBub25jZSA9IHJlcXVlc3Qubm9uY2UgfHwgKHJlcXVlc3Qubm9uY2UgPSByYW5kb20oKSksIHRpbWVzdGFtcCA9IHJlcXVlc3QudGltZXN0YW1wO1xuICAgICAgICAgICAgdmFyIHNpZ25UZXh0ID0gcmVxdWVzdC5rZXlOYW1lICsgJ1xcbicgKyB0dGwgKyAnXFxuJyArIGNhcGFiaWxpdHkgKyAnXFxuJyArIGNsaWVudElkICsgJ1xcbicgKyB0aW1lc3RhbXAgKyAnXFxuJyArIG5vbmNlICsgJ1xcbic7XG4gICAgICAgICAgICAvKiBtYWMgKi9cbiAgICAgICAgICAgIC8qIE5PVEU6IHRoZXJlIGlzIG5vIGV4cGVjdGF0aW9uIHRoYXQgdGhlIGNsaWVudFxuICAgICAgICAgICAgICogc3BlY2lmaWVzIHRoZSBtYWM7IHRoaXMgaXMgZG9uZSBieSB0aGUgbGlicmFyeVxuICAgICAgICAgICAgICogSG93ZXZlciwgdGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgY2xpZW50XG4gICAgICAgICAgICAgKiBzaW1wbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuICovXG4gICAgICAgICAgICByZXF1ZXN0Lm1hYyA9IHJlcXVlc3QubWFjIHx8IGhtYWMoc2lnblRleHQsIGtleVNlY3JldCk7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGguZ2V0VG9rZW5SZXF1ZXN0KCknLCAnZ2VuZXJhdGVkIHNpZ25lZCByZXF1ZXN0Jyk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXF1ZXN0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGF1dGggcXVlcnkgcGFyYW1zIHRvIHVzZSBmb3IgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbixcbiAgICAgKiBiYXNlZCBvbiB0aGUgY3VycmVudCBhdXRoIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICBBdXRoLnByb3RvdHlwZS5nZXRBdXRoUGFyYW1zID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLm1ldGhvZCA9PSAnYmFzaWMnKVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeyBrZXk6IHRoaXMua2V5IH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmYWxzZSwgZnVuY3Rpb24gKGVyciwgdG9rZW5EZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdG9rZW5EZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0aC5nZXRBdXRoUGFyYW1zKCk6IF9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyByZXR1cm5lZCBubyBlcnJvciBvciB0b2tlbkRldGFpbHMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeyBhY2Nlc3NfdG9rZW46IHRva2VuRGV0YWlscy50b2tlbiB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhdXRob3JpemF0aW9uIGhlYWRlciB0byB1c2UgZm9yIGEgUkVTVCBvciBjb21ldCByZXF1ZXN0LFxuICAgICAqIGJhc2VkIG9uIHRoZSBjdXJyZW50IGF1dGggcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIEF1dGgucHJvdG90eXBlLmdldEF1dGhIZWFkZXJzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLm1ldGhvZCA9PSAnYmFzaWMnKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7IGF1dGhvcml6YXRpb246ICdCYXNpYyAnICsgdGhpcy5iYXNpY0tleSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKGZhbHNlLCBmdW5jdGlvbiAoZXJyLCB0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoLmdldEF1dGhQYXJhbXMoKTogX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzIHJldHVybmVkIG5vIGVycm9yIG9yIHRva2VuRGV0YWlscycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7IGF1dGhvcml6YXRpb246ICdCZWFyZXIgJyArIFV0aWxzLnRvQmFzZTY0KHRva2VuRGV0YWlscy50b2tlbikgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHRpbWUgYmFzZWQgb24gdGhlIGxvY2FsIGNsb2NrLFxuICAgICAqIG9yIGlmIHRoZSBvcHRpb24gcXVlcnlUaW1lIGlzIHRydWUsIHJldHVybiB0aGUgc2VydmVyIHRpbWUuXG4gICAgICogVGhlIHNlcnZlciB0aW1lIG9mZnNldCBmcm9tIHRoZSBsb2NhbCB0aW1lIGlzIHN0b3JlZCBzbyB0aGF0XG4gICAgICogb25seSBvbmUgcmVxdWVzdCB0byB0aGUgc2VydmVyIHRvIGdldCB0aGUgdGltZSBpcyBldmVyIG5lZWRlZFxuICAgICAqL1xuICAgIEF1dGgucHJvdG90eXBlLmdldFRpbWVzdGFtcCA9IGZ1bmN0aW9uIChxdWVyeVRpbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1RpbWVPZmZzZXRTZXQoKSAmJiAocXVlcnlUaW1lIHx8IHRoaXMuYXV0aE9wdGlvbnMucXVlcnlUaW1lKSkge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQudGltZShjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB0aGlzLmdldFRpbWVzdGFtcFVzaW5nT2Zmc2V0KCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdXRoLnByb3RvdHlwZS5nZXRUaW1lc3RhbXBVc2luZ09mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFV0aWxzLm5vdygpICsgKHRoaXMuY2xpZW50LnNlcnZlclRpbWVPZmZzZXQgfHwgMCk7XG4gICAgfTtcbiAgICBBdXRoLnByb3RvdHlwZS5pc1RpbWVPZmZzZXRTZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5zZXJ2ZXJUaW1lT2Zmc2V0ICE9PSBudWxsO1xuICAgIH07XG4gICAgQXV0aC5wcm90b3R5cGUuX3NhdmVCYXNpY09wdGlvbnMgPSBmdW5jdGlvbiAoYXV0aE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSAnYmFzaWMnO1xuICAgICAgICB0aGlzLmtleSA9IGF1dGhPcHRpb25zLmtleTtcbiAgICAgICAgdGhpcy5iYXNpY0tleSA9IFV0aWxzLnRvQmFzZTY0KGF1dGhPcHRpb25zLmtleSk7XG4gICAgICAgIHRoaXMuYXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgaWYgKCdjbGllbnRJZCcgaW4gYXV0aE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3VzZXJTZXRDbGllbnRJZChhdXRoT3B0aW9ucy5jbGllbnRJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1dGgucHJvdG90eXBlLl9zYXZlVG9rZW5PcHRpb25zID0gZnVuY3Rpb24gKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucykge1xuICAgICAgICB0aGlzLm1ldGhvZCA9ICd0b2tlbic7XG4gICAgICAgIGlmICh0b2tlblBhcmFtcykge1xuICAgICAgICAgICAgLyogV2UgdGVtcG9yYXJpbHkgcGVyc2lzdCB0b2tlblBhcmFtcy50aW1lc3RhbXAgaW4gY2FzZSBhIG5ldyB0b2tlbiBuZWVkc1xuICAgICAgICAgICAgICogdG8gYmUgcmVxdWVzdGVkLCB0aGVuIG51bGwgaXQgb3V0IGluIHRoZSBjYWxsYmFjayBvZlxuICAgICAgICAgICAgICogX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzIGZvciBSU0ExMGcgY29tcGxpYW5jZSAqL1xuICAgICAgICAgICAgdGhpcy50b2tlblBhcmFtcyA9IHRva2VuUGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdXRoT3B0aW9ucykge1xuICAgICAgICAgICAgLyogbm9ybWFsaXNlICovXG4gICAgICAgICAgICBpZiAoYXV0aE9wdGlvbnMudG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvKiBvcHRpb25zLnRva2VuIG1heSBjb250YWluIGEgdG9rZW4gc3RyaW5nIG9yLCBmb3IgY29udmVuaWVuY2UsIGEgVG9rZW5EZXRhaWxzICovXG4gICAgICAgICAgICAgICAgYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGF1dGhPcHRpb25zLnRva2VuID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IHRva2VuOiBhdXRoT3B0aW9ucy50b2tlbiB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IGF1dGhPcHRpb25zLnRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF1dGhPcHRpb25zLnRva2VuRGV0YWlscykge1xuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5EZXRhaWxzID0gYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdjbGllbnRJZCcgaW4gYXV0aE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91c2VyU2V0Q2xpZW50SWQoYXV0aE9wdGlvbnMuY2xpZW50SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiBAcGFyYW0gZm9yY2VTdXBlcnNlZGU6IGZvcmNlIGEgbmV3IHRva2VuIHJlcXVlc3QgZXZlbiBpZiB0aGVyZSdzIG9uZSBpblxuICAgICAqIHByb2dyZXNzLCBtYWtpbmcgYWxsIHBlbmRpbmcgY2FsbGJhY2tzIHdhaXQgZm9yIHRoZSBuZXcgb25lICovXG4gICAgQXV0aC5wcm90b3R5cGUuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzID0gZnVuY3Rpb24gKGZvcmNlU3VwZXJzZWRlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRva2VuRGV0YWlscztcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdG9rZW5DbGllbnRJZE1pc21hdGNoKHRva2VuLmNsaWVudElkKSkge1xuICAgICAgICAgICAgICAgIC8qIDQwMyB0byB0cmlnZ2VyIGEgcGVybWFuZW50bHkgZmFpbGVkIGNsaWVudCAtIFJTQTE1YyAqL1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdNaXNtYXRjaCBiZXR3ZWVuIGNsaWVudElkIGluIHRva2VuICgnICsgdG9rZW4uY2xpZW50SWQgKyAnKSBhbmQgY3VycmVudCBjbGllbnRJZCAoJyArIHRoaXMuY2xpZW50SWQgKyAnKScsIDQwMTAyLCA0MDMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBSU0E0YjEgLS0gaWYgd2UgaGF2ZSBhIHNlcnZlciB0aW1lIG9mZnNldCBzZXQgYWxyZWFkeSwgd2UgY2FuXG4gICAgICAgICAgICAgKiBhdXRvbWF0aWNhbGx5IHJlbW92ZSBleHBpcmVkIHRva2Vucy4gRWxzZSBqdXN0IHVzZSB0aGUgY2FjaGVkIHRva2VuLiBJZiBpdCBpc1xuICAgICAgICAgICAgICogZXhwaXJlZCBBYmx5IHdpbGwgdGVsbCB1cyBhbmQgd2UnbGwgZGlzY2FyZCBpdCB0aGVuLiAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVGltZU9mZnNldFNldCgpIHx8ICF0b2tlbi5leHBpcmVzIHx8IHRva2VuLmV4cGlyZXMgPj0gdGhpcy5nZXRUaW1lc3RhbXBVc2luZ09mZnNldCgpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdBdXRoLmdldFRva2VuKCknLCAndXNpbmcgY2FjaGVkIHRva2VuOyBleHBpcmVzID0gJyArIHRva2VuLmV4cGlyZXMpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBleHBpcmVkLCBzbyByZW1vdmUgYW5kIGZhbGx0aHJvdWdoIHRvIGdldHRpbmcgYSBuZXcgb25lICovXG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGguZ2V0VG9rZW4oKScsICdkZWxldGluZyBleHBpcmVkIHRva2VuJyk7XG4gICAgICAgICAgICB0aGlzLnRva2VuRGV0YWlscyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgKHRoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdCB8fCAodGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0ID0gbXVsdGljYXN0ZXJfMS5kZWZhdWx0LmNyZWF0ZSgpKSkucHVzaChjYWxsYmFjayk7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCAhPT0gbnVsbCAmJiAhZm9yY2VTdXBlcnNlZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBSZXF1ZXN0IGEgbmV3IHRva2VuICovXG4gICAgICAgIHZhciB0b2tlblJlcXVlc3RJZCA9ICh0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IGdldFRva2VuUmVxdWVzdElkKCkpO1xuICAgICAgICB0aGlzLnJlcXVlc3RUb2tlbih0aGlzLnRva2VuUGFyYW1zLCB0aGlzLmF1dGhPcHRpb25zLCBmdW5jdGlvbiAoZXJyLCB0b2tlblJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuY3VycmVudFRva2VuUmVxdWVzdElkID4gdG9rZW5SZXF1ZXN0SWQpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGguX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKCknLCAnRGlzY2FyZGluZyB0b2tlbiByZXF1ZXN0IHJlc3BvbnNlOyBvdmVydGFrZW4gYnkgbmV3ZXIgb25lJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuY3VycmVudFRva2VuUmVxdWVzdElkID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBjYWxsYmFja3MgPSBfdGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0IHx8IG5vb3A7XG4gICAgICAgICAgICBfdGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFja3MobnVsbCwgKF90aGlzLnRva2VuRGV0YWlscyA9IHRva2VuUmVzcG9uc2UpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiBVc2VyLXNldDogY2hlY2sgdHlwZXMsICcqJyBpcyBkaXNhbGxvd2VkLCB0aHJvdyBhbnkgZXJyb3JzICovXG4gICAgQXV0aC5wcm90b3R5cGUuX3VzZXJTZXRDbGllbnRJZCA9IGZ1bmN0aW9uIChjbGllbnRJZCkge1xuICAgICAgICBpZiAoISh0eXBlb2YgY2xpZW50SWQgPT09ICdzdHJpbmcnIHx8IGNsaWVudElkID09PSBudWxsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ2NsaWVudElkIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bGwnLCA0MDAxMiwgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGllbnRJZCA9PT0gJyonKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnQ2Fu4oCZdCB1c2UgXCIqXCIgYXMgYSBjbGllbnRJZCBhcyB0aGF0IHN0cmluZyBpcyByZXNlcnZlZC4gKFRvIGNoYW5nZSB0aGUgZGVmYXVsdCB0b2tlbiByZXF1ZXN0IGJlaGF2aW91ciB0byB1c2UgYSB3aWxkY2FyZCBjbGllbnRJZCwgaW5zdGFudGlhdGUgdGhlIGxpYnJhcnkgd2l0aCB7ZGVmYXVsdFRva2VuUGFyYW1zOiB7Y2xpZW50SWQ6IFwiKlwifX0pLCBvciBpZiBjYWxsaW5nIGF1dGhvcml6ZSgpLCBwYXNzIGl0IGluIGFzIGEgdG9rZW5QYXJhbTogYXV0aG9yaXplKHtjbGllbnRJZDogXCIqXCJ9LCBhdXRoT3B0aW9ucyknLCA0MDAxMiwgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSB0aGlzLl91bmNoZWNrZWRTZXRDbGllbnRJZChjbGllbnRJZCk7XG4gICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyogQWJseS1zZXQ6IG5vIHR5cGVjaGVja2luZywgJyonIGlzIGFsbG93ZWQgYnV0IG5vdCBzZXQgb24gdGhpcy5jbGllbnRJZCksIHJldHVybiBlcnJvcnMgdG8gdGhlIGNhbGxlciAqL1xuICAgIEF1dGgucHJvdG90eXBlLl91bmNoZWNrZWRTZXRDbGllbnRJZCA9IGZ1bmN0aW9uIChjbGllbnRJZCkge1xuICAgICAgICBpZiAodGhpcy5fdG9rZW5DbGllbnRJZE1pc21hdGNoKGNsaWVudElkKSkge1xuICAgICAgICAgICAgLyogU2hvdWxkIG5ldmVyIGhhcHBlbiBpbiBub3JtYWwgY2lyY3Vtc3RhbmNlcyBhcyByZWFsdGltZSBzaG91bGRcbiAgICAgICAgICAgICAqIHJlY29nbmlzZSBtaXNtYXRjaCBhbmQgcmV0dXJuIGFuIGVycm9yICovXG4gICAgICAgICAgICB2YXIgbXNnID0gJ1VuZXhwZWN0ZWQgY2xpZW50SWQgbWlzbWF0Y2g6IGNsaWVudCBoYXMgJyArIHRoaXMuY2xpZW50SWQgKyAnLCByZXF1ZXN0ZWQgJyArIGNsaWVudElkO1xuICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgNDAxMDIsIDQwMSk7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0F1dGguX3VuY2hlY2tlZFNldENsaWVudElkKCknLCBtc2cpO1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIFJTQTdhNDogaWYgb3B0aW9ucy5jbGllbnRJZCBpcyBwcm92aWRlZCBhbmQgaXMgbm90XG4gICAgICAgICAgICAgKiBudWxsLCBpdCBvdmVycmlkZXMgZGVmYXVsdFRva2VuUGFyYW1zLmNsaWVudElkICovXG4gICAgICAgICAgICB0aGlzLmNsaWVudElkID0gdGhpcy50b2tlblBhcmFtcy5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1dGgucHJvdG90eXBlLl90b2tlbkNsaWVudElkTWlzbWF0Y2ggPSBmdW5jdGlvbiAodG9rZW5DbGllbnRJZCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5jbGllbnRJZCAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRJZCAhPT0gJyonICYmXG4gICAgICAgICAgICB0b2tlbkNsaWVudElkICYmXG4gICAgICAgICAgICB0b2tlbkNsaWVudElkICE9PSAnKicgJiZcbiAgICAgICAgICAgIHRoaXMuY2xpZW50SWQgIT09IHRva2VuQ2xpZW50SWQpO1xuICAgIH07XG4gICAgQXV0aC5pc1Rva2VuRXJyID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvci5jb2RlICYmIGVycm9yLmNvZGUgPj0gNDAxNDAgJiYgZXJyb3IuY29kZSA8IDQwMTUwO1xuICAgIH07XG4gICAgQXV0aC5wcm90b3R5cGUucmV2b2tlVG9rZW5zID0gZnVuY3Rpb24gKHNwZWNpZmllcnMsIG9wdGlvbnNPckNhbGxiYWNrQXJnLCBjYWxsYmFja0FyZykge1xuICAgICAgICBpZiAodXNlVG9rZW5BdXRoKHRoaXMuY2xpZW50Lm9wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnQ2Fubm90IHJldm9rZSB0b2tlbnMgd2hlbiB1c2luZyB0b2tlbiBhdXRoJywgNDAxNjIsIDQwMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleU5hbWUgPSB0aGlzLmNsaWVudC5vcHRpb25zLmtleU5hbWU7XG4gICAgICAgIHZhciByZXNvbHZlZE9wdGlvbnM7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2tBcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrQXJnID0gb3B0aW9uc09yQ2FsbGJhY2tBcmc7XG4gICAgICAgICAgICByZXNvbHZlZE9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmVkT3B0aW9ucyA9IG9wdGlvbnNPckNhbGxiYWNrQXJnICE9PSBudWxsICYmIG9wdGlvbnNPckNhbGxiYWNrQXJnICE9PSB2b2lkIDAgPyBvcHRpb25zT3JDYWxsYmFja0FyZyA6IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFja0FyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3Jldm9rZVRva2VucycsIFtzcGVjaWZpZXJzLCByZXNvbHZlZE9wdGlvbnNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrQXJnID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFja0FyZztcbiAgICAgICAgdmFyIHJlcXVlc3RCb2R5RFRPID0gdHNsaWJfMS5fX2Fzc2lnbih7IHRhcmdldHM6IHNwZWNpZmllcnMubWFwKGZ1bmN0aW9uIChzcGVjaWZpZXIpIHsgcmV0dXJuIFwiXCIuY29uY2F0KHNwZWNpZmllci50eXBlLCBcIjpcIikuY29uY2F0KHNwZWNpZmllci52YWx1ZSk7IH0pIH0sIHJlc29sdmVkT3B0aW9ucyk7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgdGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgdmFyIHJlcXVlc3RCb2R5ID0gVXRpbHMuZW5jb2RlQm9keShyZXF1ZXN0Qm9keURUTywgZm9ybWF0KTtcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LnBvc3QodGhpcy5jbGllbnQsIFwiL2tleXMvXCIuY29uY2F0KGtleU5hbWUsIFwiL3Jldm9rZVRva2Vuc1wiKSwgcmVxdWVzdEJvZHksIGhlYWRlcnMsIHsgbmV3QmF0Y2hSZXNwb25zZTogJ3RydWUnIH0sIG51bGwsIGZ1bmN0aW9uIChlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyByZW1vdmUgdGhpcyB0eXBlIGFzc2VydGlvbiBhZnRlciBmaXhpbmcgaHR0cHM6Ly9naXRodWIuY29tL2FibHkvYWJseS1qcy9pc3N1ZXMvMTQwNVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJhdGNoUmVzdWx0ID0gKHVucGFja2VkID8gYm9keSA6IFV0aWxzLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KSk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBiYXRjaFJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEF1dGg7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXV0aDtcblxuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgSHR0cE1ldGhvZHM7XG4oZnVuY3Rpb24gKEh0dHBNZXRob2RzKSB7XG4gICAgSHR0cE1ldGhvZHNbXCJHZXRcIl0gPSBcImdldFwiO1xuICAgIEh0dHBNZXRob2RzW1wiRGVsZXRlXCJdID0gXCJkZWxldGVcIjtcbiAgICBIdHRwTWV0aG9kc1tcIlBvc3RcIl0gPSBcInBvc3RcIjtcbiAgICBIdHRwTWV0aG9kc1tcIlB1dFwiXSA9IFwicHV0XCI7XG4gICAgSHR0cE1ldGhvZHNbXCJQYXRjaFwiXSA9IFwicGF0Y2hcIjtcbn0pKEh0dHBNZXRob2RzIHx8IChIdHRwTWV0aG9kcyA9IHt9KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIdHRwTWV0aG9kcztcblxuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkh0dHBQYWdpbmF0ZWRSZXNwb25zZSA9IGV4cG9ydHMuUGFnaW5hdGVkUmVzdWx0ID0gdm9pZCAwO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciByZXNvdXJjZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNCkpO1xuZnVuY3Rpb24gZ2V0UmVsUGFyYW1zKGxpbmtVcmwpIHtcbiAgICB2YXIgdXJsTWF0Y2ggPSBsaW5rVXJsLm1hdGNoKC9eXFwuXFwvKFxcdyspXFw/KC4qKSQvKTtcbiAgICByZXR1cm4gdXJsTWF0Y2ggJiYgdXJsTWF0Y2hbMl0gJiYgVXRpbHMucGFyc2VRdWVyeVN0cmluZyh1cmxNYXRjaFsyXSk7XG59XG5mdW5jdGlvbiBwYXJzZVJlbExpbmtzKGxpbmtIZWFkZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpbmtIZWFkZXIgPT0gJ3N0cmluZycpXG4gICAgICAgIGxpbmtIZWFkZXIgPSBsaW5rSGVhZGVyLnNwbGl0KCcsJyk7XG4gICAgdmFyIHJlbFBhcmFtcyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlua0hlYWRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGlua01hdGNoID0gbGlua0hlYWRlcltpXS5tYXRjaCgvXlxccyo8KC4rKT47XFxzKnJlbD1cIihcXHcrKVwiJC8pO1xuICAgICAgICBpZiAobGlua01hdGNoKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gZ2V0UmVsUGFyYW1zKGxpbmtNYXRjaFsxXSk7XG4gICAgICAgICAgICBpZiAocGFyYW1zKVxuICAgICAgICAgICAgICAgIHJlbFBhcmFtc1tsaW5rTWF0Y2hbMl1dID0gcGFyYW1zO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWxQYXJhbXM7XG59XG5mdW5jdGlvbiByZXR1cm5FcnJPbmx5KGVyciwgYm9keSwgdXNlSFBSKSB7XG4gICAgLyogSWYgdXNpbmcgaHR0cFBhZ2luYXRlZFJlc3BvbnNlLCBlcnJvcnMgZnJvbSBBYmx5IGFyZSByZXR1cm5lZCBhcyBwYXJ0IG9mXG4gICAgICogdGhlIEhQUiwgb25seSBkbyBjYWxsYmFjayhlcnIpIGZvciBuZXR3b3JrIGVycm9ycyBldGMuIHdoaWNoIGRvbid0XG4gICAgICogcmV0dXJuIGEgYm9keSBhbmQvb3IgaGF2ZSBubyBhYmx5LW9yaWdpbmF0ZWQgZXJyb3IgY29kZSAobm9uLW51bWVyaWNcbiAgICAgKiBlcnJvciBjb2RlcyBvcmlnaW5hdGUgZnJvbSBub2RlKSAqL1xuICAgIHJldHVybiAhKHVzZUhQUiAmJiAoYm9keSB8fCB0eXBlb2YgZXJyLmNvZGUgPT09ICdudW1iZXInKSk7XG59XG52YXIgUGFnaW5hdGVkUmVzb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFnaW5hdGVkUmVzb3VyY2UocmVzdCwgcGF0aCwgaGVhZGVycywgZW52ZWxvcGUsIGJvZHlIYW5kbGVyLCB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5yZXN0ID0gcmVzdDtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgdGhpcy5lbnZlbG9wZSA9IGVudmVsb3BlICE9PSBudWxsICYmIGVudmVsb3BlICE9PSB2b2lkIDAgPyBlbnZlbG9wZSA6IG51bGw7XG4gICAgICAgIHRoaXMuYm9keUhhbmRsZXIgPSBib2R5SGFuZGxlcjtcbiAgICAgICAgdGhpcy51c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UgPSB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UgfHwgZmFsc2U7XG4gICAgfVxuICAgIFBhZ2luYXRlZFJlc291cmNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQuZ2V0KHRoaXMucmVzdCwgdGhpcy5wYXRoLCB0aGlzLmhlYWRlcnMsIHBhcmFtcywgdGhpcy5lbnZlbG9wZSwgZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVBhZ2UoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBhZ2luYXRlZFJlc291cmNlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQuZGVsZXRlKHRoaXMucmVzdCwgdGhpcy5wYXRoLCB0aGlzLmhlYWRlcnMsIHBhcmFtcywgdGhpcy5lbnZlbG9wZSwgZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVBhZ2UoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBhZ2luYXRlZFJlc291cmNlLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKHBhcmFtcywgYm9keSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LnBvc3QodGhpcy5yZXN0LCB0aGlzLnBhdGgsIGJvZHksIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZUJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVQYWdlKGVyciwgcmVzcG9uc2VCb2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBhZ2luYXRlZFJlc291cmNlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAocGFyYW1zLCBib2R5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQucHV0KHRoaXMucmVzdCwgdGhpcy5wYXRoLCBib2R5LCB0aGlzLmhlYWRlcnMsIHBhcmFtcywgdGhpcy5lbnZlbG9wZSwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2VCb2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlUGFnZShlcnIsIHJlc3BvbnNlQm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQYWdpbmF0ZWRSZXNvdXJjZS5wcm90b3R5cGUucGF0Y2ggPSBmdW5jdGlvbiAocGFyYW1zLCBib2R5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQucGF0Y2godGhpcy5yZXN0LCB0aGlzLnBhdGgsIGJvZHksIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZUJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVQYWdlKGVyciwgcmVzcG9uc2VCb2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBhZ2luYXRlZFJlc291cmNlLnByb3RvdHlwZS5oYW5kbGVQYWdlID0gZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChlcnIgJiYgcmV0dXJuRXJyT25seShlcnIsIGJvZHksIHRoaXMudXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlKSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdQYWdpbmF0ZWRSZXNvdXJjZS5oYW5kbGVQYWdlKCknLCAnVW5leHBlY3RlZCBlcnJvciBnZXR0aW5nIHJlc291cmNlOiBlcnIgPSAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGl0ZW1zLCBsaW5rSGVhZGVyLCByZWxQYXJhbXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpdGVtcyA9IHRoaXMuYm9keUhhbmRsZXIoYm9keSwgaGVhZGVycyB8fCB7fSwgdW5wYWNrZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvKiBJZiB3ZSBnb3QgYW4gZXJyb3IsIHRoZSBmYWlsdXJlIHRvIHBhcnNlIHRoZSBib2R5IGlzIGFsbW9zdCBjZXJ0YWlubHlcbiAgICAgICAgICAgICAqIGR1ZSB0byB0aGF0LCBzbyBjYWxsYmFjayB3aXRoIHRoYXQgaW4gcHJlZmVyZW5jZSBvdmVyIHRoZSBwYXJzZSBlcnJvciAqL1xuICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKGVyciB8fCBlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVycyAmJiAobGlua0hlYWRlciA9IGhlYWRlcnNbJ0xpbmsnXSB8fCBoZWFkZXJzWydsaW5rJ10pKSB7XG4gICAgICAgICAgICByZWxQYXJhbXMgPSBwYXJzZVJlbExpbmtzKGxpbmtIZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbmV3IEh0dHBQYWdpbmF0ZWRSZXNwb25zZSh0aGlzLCBpdGVtcywgaGVhZGVycyB8fCB7fSwgc3RhdHVzQ29kZSwgcmVsUGFyYW1zLCBlcnIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG5ldyBQYWdpbmF0ZWRSZXN1bHQodGhpcywgaXRlbXMsIHJlbFBhcmFtcykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUGFnaW5hdGVkUmVzb3VyY2U7XG59KCkpO1xudmFyIFBhZ2luYXRlZFJlc3VsdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYWdpbmF0ZWRSZXN1bHQocmVzb3VyY2UsIGl0ZW1zLCByZWxQYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXNvdXJjZSA9IHJlc291cmNlO1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHJlbFBhcmFtcykge1xuICAgICAgICAgICAgaWYgKCdmaXJzdCcgaW4gcmVsUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrICYmIHNlbGYucmVzb3VyY2UucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHNlbGYsICdmaXJzdCcsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmdldChyZWxQYXJhbXMuZmlyc3QsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdjdXJyZW50JyBpbiByZWxQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFjayAmJiBzZWxmLnJlc291cmNlLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeShzZWxmLCAnY3VycmVudCcsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmdldChyZWxQYXJhbXMuY3VycmVudCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrICYmIHNlbGYucmVzb3VyY2UucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkoc2VsZiwgJ25leHQnLCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgnbmV4dCcgaW4gcmVsUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZ2V0KHJlbFBhcmFtcy5uZXh0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5oYXNOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbmV4dCcgaW4gcmVsUGFyYW1zO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuaXNMYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gISgoX2EgPSBfdGhpcy5oYXNOZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChfdGhpcykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBXZSBhc3N1bWUgdGhhdCBvbmx5IHRoZSBpbml0aWFsIHJlcXVlc3QgY2FuIGJlIGEgUE9TVCwgYW5kIHRoYXQgYWNjZXNzaW5nXG4gICAgICogdGhlIHJlc3Qgb2YgYSBtdWx0aXBhZ2Ugc2V0IG9mIHJlc3VsdHMgY2FuIGFsd2F5cyBiZSBkb25lIHdpdGggR0VUICovXG4gICAgUGFnaW5hdGVkUmVzdWx0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5yZXNvdXJjZTtcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LmdldChyZXMucmVzdCwgcmVzLnBhdGgsIHJlcy5oZWFkZXJzLCBwYXJhbXMsIHJlcy5lbnZlbG9wZSwgZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIHJlcy5oYW5kbGVQYWdlKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFnaW5hdGVkUmVzdWx0O1xufSgpKTtcbmV4cG9ydHMuUGFnaW5hdGVkUmVzdWx0ID0gUGFnaW5hdGVkUmVzdWx0O1xudmFyIEh0dHBQYWdpbmF0ZWRSZXNwb25zZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhIdHRwUGFnaW5hdGVkUmVzcG9uc2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSHR0cFBhZ2luYXRlZFJlc3BvbnNlKHJlc291cmNlLCBpdGVtcywgaGVhZGVycywgc3RhdHVzQ29kZSwgcmVsUGFyYW1zLCBlcnIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcmVzb3VyY2UsIGl0ZW1zLCByZWxQYXJhbXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICBfdGhpcy5zdWNjZXNzID0gc3RhdHVzQ29kZSA8IDMwMCAmJiBzdGF0dXNDb2RlID49IDIwMDtcbiAgICAgICAgX3RoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIF90aGlzLmVycm9yQ29kZSA9IGVyciAmJiBlcnIuY29kZTtcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gZXJyICYmIGVyci5tZXNzYWdlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEh0dHBQYWdpbmF0ZWRSZXNwb25zZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICAgICAgICBzdGF0dXNDb2RlOiB0aGlzLnN0YXR1c0NvZGUsXG4gICAgICAgICAgICBzdWNjZXNzOiB0aGlzLnN1Y2Nlc3MsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBlcnJvckNvZGU6IHRoaXMuZXJyb3JDb2RlLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiB0aGlzLmVycm9yTWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBIdHRwUGFnaW5hdGVkUmVzcG9uc2U7XG59KFBhZ2luYXRlZFJlc3VsdCkpO1xuZXhwb3J0cy5IdHRwUGFnaW5hdGVkUmVzcG9uc2UgPSBIdHRwUGFnaW5hdGVkUmVzcG9uc2U7XG5leHBvcnRzLmRlZmF1bHQgPSBQYWdpbmF0ZWRSZXNvdXJjZTtcblxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzUmV0cmlhYmxlID0gdm9pZCAwO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgQ29ubmVjdGlvbkVycm9yQ29kZXMgPSB7XG4gICAgRElTQ09OTkVDVEVEOiA4MDAwMyxcbiAgICBTVVNQRU5ERUQ6IDgwMDAyLFxuICAgIEZBSUxFRDogODAwMDAsXG4gICAgQ0xPU0lORzogODAwMTcsXG4gICAgQ0xPU0VEOiA4MDAxNyxcbiAgICBVTktOT1dOX0NPTk5FQ1RJT05fRVJSOiA1MDAwMixcbiAgICBVTktOT1dOX0NIQU5ORUxfRVJSOiA1MDAwMSxcbn07XG52YXIgQ29ubmVjdGlvbkVycm9ycyA9IHtcbiAgICBkaXNjb25uZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgICAgICAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5ESVNDT05ORUNURUQsXG4gICAgICAgICAgICBtZXNzYWdlOiAnQ29ubmVjdGlvbiB0byBzZXJ2ZXIgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUnLFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHN1c3BlbmRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICAgICAgICAgIGNvZGU6IENvbm5lY3Rpb25FcnJvckNvZGVzLlNVU1BFTkRFRCxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdDb25uZWN0aW9uIHRvIHNlcnZlciB1bmF2YWlsYWJsZScsXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgZmFpbGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogNDAwLFxuICAgICAgICAgICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuRkFJTEVELFxuICAgICAgICAgICAgbWVzc2FnZTogJ0Nvbm5lY3Rpb24gZmFpbGVkIG9yIGRpc2Nvbm5lY3RlZCBieSBzZXJ2ZXInLFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGNsb3Npbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgICAgICAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5DTE9TSU5HLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0Nvbm5lY3Rpb24gY2xvc2luZycsXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgY2xvc2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogNDAwLFxuICAgICAgICAgICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuQ0xPU0VELFxuICAgICAgICAgICAgbWVzc2FnZTogJ0Nvbm5lY3Rpb24gY2xvc2VkJyxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICB1bmtub3duQ29ubmVjdGlvbkVycjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICAgICAgICAgIGNvZGU6IENvbm5lY3Rpb25FcnJvckNvZGVzLlVOS05PV05fQ09OTkVDVElPTl9FUlIsXG4gICAgICAgICAgICBtZXNzYWdlOiAnSW50ZXJuYWwgY29ubmVjdGlvbiBlcnJvcicsXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgdW5rbm93bkNoYW5uZWxFcnI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICBzdGF0dXNDb2RlOiA1MDAsXG4gICAgICAgICAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5VTktOT1dOX0NPTk5FQ1RJT05fRVJSLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0ludGVybmFsIGNoYW5uZWwgZXJyb3InLFxuICAgICAgICB9KTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGlzUmV0cmlhYmxlKGVycikge1xuICAgIGlmICghZXJyLnN0YXR1c0NvZGUgfHwgIWVyci5jb2RlIHx8IGVyci5zdGF0dXNDb2RlID49IDUwMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoQ29ubmVjdGlvbkVycm9yQ29kZXMpLmluY2x1ZGVzKGVyci5jb2RlKTtcbn1cbmV4cG9ydHMuaXNSZXRyaWFibGUgPSBpc1JldHJpYWJsZTtcbmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25FcnJvcnM7XG5cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFhIUlN0YXRlcztcbihmdW5jdGlvbiAoWEhSU3RhdGVzKSB7XG4gICAgWEhSU3RhdGVzW1hIUlN0YXRlc1tcIlJFUV9TRU5EXCJdID0gMF0gPSBcIlJFUV9TRU5EXCI7XG4gICAgWEhSU3RhdGVzW1hIUlN0YXRlc1tcIlJFUV9SRUNWXCJdID0gMV0gPSBcIlJFUV9SRUNWXCI7XG4gICAgWEhSU3RhdGVzW1hIUlN0YXRlc1tcIlJFUV9SRUNWX1BPTExcIl0gPSAyXSA9IFwiUkVRX1JFQ1ZfUE9MTFwiO1xuICAgIFhIUlN0YXRlc1tYSFJTdGF0ZXNbXCJSRVFfUkVDVl9TVFJFQU1cIl0gPSAzXSA9IFwiUkVRX1JFQ1ZfU1RSRUFNXCI7XG59KShYSFJTdGF0ZXMgfHwgKFhIUlN0YXRlcyA9IHt9KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBYSFJTdGF0ZXM7XG5cblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNiksIF9fd2VicGFja19yZXF1aXJlX18oNSksIF9fd2VicGFja19yZXF1aXJlX18oNTgpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0MCksIF9fd2VicGFja19yZXF1aXJlX18oMzIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyNyksIF9fd2VicGFja19yZXF1aXJlX18oMjgpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg2MCkpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0cmV0dXJuIENyeXB0b0pTO1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIE11bHRpY2FzdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFByaXZhdGUgY29uc3RydWN0b3I7IHVzZSBzdGF0aWMgTXVsdGljYXN0ZXIuY3JlYXRlIGluc3RlYWRcbiAgICBmdW5jdGlvbiBNdWx0aWNhc3RlcihtZW1iZXJzKSB7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IG1lbWJlcnMgfHwgW107XG4gICAgfVxuICAgIE11bHRpY2FzdGVyLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgX2IgPSB0aGlzLm1lbWJlcnM7IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgbWVtYmVyID0gX2JbX2FdO1xuICAgICAgICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbWJlci5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ011bHRpY2FzdGVyIG11bHRpcGxlIGNhbGxiYWNrIGhhbmRsZXInLCAnVW5leHBlY3RlZCBleGNlcHRpb246ICcgKyBlICsgJzsgc3RhY2sgPSAnICsgZS5zdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNdWx0aWNhc3Rlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMubWVtYmVycykucHVzaC5hcHBseShfYSwgYXJncyk7XG4gICAgfTtcbiAgICBNdWx0aWNhc3Rlci5jcmVhdGUgPSBmdW5jdGlvbiAobWVtYmVycykge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgTXVsdGljYXN0ZXIobWVtYmVycyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5jYWxsLmFwcGx5KGluc3RhbmNlLCBhcmdzKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGZuKSB7IHJldHVybiBpbnN0YW5jZS5wdXNoKGZuKTsgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTXVsdGljYXN0ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTXVsdGljYXN0ZXI7XG5cblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0Zjg7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEhNQUMgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgSE1BQyA9IENfYWxnby5ITUFDID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBITUFDLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaG1hY0hhc2hlciA9IENyeXB0b0pTLmFsZ28uSE1BQy5jcmVhdGUoQ3J5cHRvSlMuYWxnby5TSEEyNTYsIGtleSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGhhc2hlciwga2V5KSB7XG5cdCAgICAgICAgICAgIC8vIEluaXQgaGFzaGVyXG5cdCAgICAgICAgICAgIGhhc2hlciA9IHRoaXMuX2hhc2hlciA9IG5ldyBoYXNoZXIuaW5pdCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIGtleSA9IFV0ZjgucGFyc2Uoa2V5KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgaGFzaGVyQmxvY2tTaXplID0gaGFzaGVyLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGhhc2hlckJsb2NrU2l6ZUJ5dGVzID0gaGFzaGVyQmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBBbGxvdyBhcmJpdHJhcnkgbGVuZ3RoIGtleXNcblx0ICAgICAgICAgICAgaWYgKGtleS5zaWdCeXRlcyA+IGhhc2hlckJsb2NrU2l6ZUJ5dGVzKSB7XG5cdCAgICAgICAgICAgICAgICBrZXkgPSBoYXNoZXIuZmluYWxpemUoa2V5KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIGtleS5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENsb25lIGtleSBmb3IgaW5uZXIgYW5kIG91dGVyIHBhZHNcblx0ICAgICAgICAgICAgdmFyIG9LZXkgPSB0aGlzLl9vS2V5ID0ga2V5LmNsb25lKCk7XG5cdCAgICAgICAgICAgIHZhciBpS2V5ID0gdGhpcy5faUtleSA9IGtleS5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgb0tleVdvcmRzID0gb0tleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGlLZXlXb3JkcyA9IGlLZXkud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gWE9SIGtleXMgd2l0aCBwYWQgY29uc3RhbnRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFzaGVyQmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIG9LZXlXb3Jkc1tpXSBePSAweDVjNWM1YzVjO1xuXHQgICAgICAgICAgICAgICAgaUtleVdvcmRzW2ldIF49IDB4MzYzNjM2MzY7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb0tleS5zaWdCeXRlcyA9IGlLZXkuc2lnQnl0ZXMgPSBoYXNoZXJCbG9ja1NpemVCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBITUFDIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhhc2hlciA9IHRoaXMuX2hhc2hlcjtcblxuXHQgICAgICAgICAgICAvLyBSZXNldFxuXHQgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZSh0aGlzLl9pS2V5KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVXBkYXRlcyB0aGlzIEhNQUMgd2l0aCBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7SE1BQ30gVGhpcyBITUFDIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaGVyLnVwZGF0ZShtZXNzYWdlVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgSE1BQyBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSB0aGlzLl9oYXNoZXI7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBITUFDXG5cdCAgICAgICAgICAgIHZhciBpbm5lckhhc2ggPSBoYXNoZXIuZmluYWxpemUobWVzc2FnZVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAgICB2YXIgaG1hYyA9IGhhc2hlci5maW5hbGl6ZSh0aGlzLl9vS2V5LmNsb25lKCkuY29uY2F0KGlubmVySGFzaCkpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBobWFjO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9KCkpO1xuXG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1N1Y2Nlc3NDb2RlID0gdm9pZCAwO1xudmFyIEh0dHBTdGF0dXNDb2RlcztcbihmdW5jdGlvbiAoSHR0cFN0YXR1c0NvZGVzKSB7XG4gICAgSHR0cFN0YXR1c0NvZGVzW0h0dHBTdGF0dXNDb2Rlc1tcIlN1Y2Nlc3NcIl0gPSAyMDBdID0gXCJTdWNjZXNzXCI7XG4gICAgSHR0cFN0YXR1c0NvZGVzW0h0dHBTdGF0dXNDb2Rlc1tcIk5vQ29udGVudFwiXSA9IDIwNF0gPSBcIk5vQ29udGVudFwiO1xuICAgIEh0dHBTdGF0dXNDb2Rlc1tIdHRwU3RhdHVzQ29kZXNbXCJCYWRSZXF1ZXN0XCJdID0gNDAwXSA9IFwiQmFkUmVxdWVzdFwiO1xuICAgIEh0dHBTdGF0dXNDb2Rlc1tIdHRwU3RhdHVzQ29kZXNbXCJVbmF1dGhvcml6ZWRcIl0gPSA0MDFdID0gXCJVbmF1dGhvcml6ZWRcIjtcbiAgICBIdHRwU3RhdHVzQ29kZXNbSHR0cFN0YXR1c0NvZGVzW1wiRm9yYmlkZGVuXCJdID0gNDAzXSA9IFwiRm9yYmlkZGVuXCI7XG4gICAgSHR0cFN0YXR1c0NvZGVzW0h0dHBTdGF0dXNDb2Rlc1tcIlJlcXVlc3RUaW1lb3V0XCJdID0gNDA4XSA9IFwiUmVxdWVzdFRpbWVvdXRcIjtcbiAgICBIdHRwU3RhdHVzQ29kZXNbSHR0cFN0YXR1c0NvZGVzW1wiSW50ZXJuYWxTZXJ2ZXJFcnJvclwiXSA9IDUwMF0gPSBcIkludGVybmFsU2VydmVyRXJyb3JcIjtcbn0pKEh0dHBTdGF0dXNDb2RlcyB8fCAoSHR0cFN0YXR1c0NvZGVzID0ge30pKTtcbmZ1bmN0aW9uIGlzU3VjY2Vzc0NvZGUoc3RhdHVzQ29kZSkge1xuICAgIHJldHVybiBzdGF0dXNDb2RlID49IEh0dHBTdGF0dXNDb2Rlcy5TdWNjZXNzICYmIHN0YXR1c0NvZGUgPCBIdHRwU3RhdHVzQ29kZXMuQmFkUmVxdWVzdDtcbn1cbmV4cG9ydHMuaXNTdWNjZXNzQ29kZSA9IGlzU3VjY2Vzc0NvZGU7XG5leHBvcnRzLmRlZmF1bHQgPSBIdHRwU3RhdHVzQ29kZXM7XG5cblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHByb3RvY29sbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxMCkpO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgZXZlbnRlbWl0dGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIGNvbm5lY3Rpb25lcnJvcnNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjApKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciBhY3Rpb25zID0gcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5BY3Rpb247XG52YXIgY2xvc2VNZXNzYWdlID0gcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHsgYWN0aW9uOiBhY3Rpb25zLkNMT1NFIH0pO1xudmFyIGRpc2Nvbm5lY3RNZXNzYWdlID0gcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHsgYWN0aW9uOiBhY3Rpb25zLkRJU0NPTk5FQ1QgfSk7XG4vKlxuICogVHJhbnNwb3J0IGluc3RhbmNlcyBpbmhlcml0IGZyb20gRXZlbnRFbWl0dGVyIGFuZCBlbWl0IHRoZSBmb2xsb3dpbmcgZXZlbnRzOlxuICpcbiAqIGV2ZW50IG5hbWUgICAgICAgZGF0YVxuICogY2xvc2VkICAgICAgICAgICBlcnJvclxuICogZmFpbGVkICAgICAgICAgICBlcnJvclxuICogZGlzcG9zZWRcbiAqIGNvbm5lY3RlZCAgICAgICAgbnVsbCBlcnJvciwgY29ubmVjdGlvblNlcmlhbCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlsc1xuICogZXZlbnQgICAgICAgICAgICBjaGFubmVsIG1lc3NhZ2Ugb2JqZWN0XG4gKi9cbnZhciBUcmFuc3BvcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVHJhbnNwb3J0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zLCBmb3JjZUpzb25Qcm90b2NvbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBpZiAoZm9yY2VKc29uUHJvdG9jb2wpIHtcbiAgICAgICAgICAgIHBhcmFtcy5mb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBwYXJhbXMuaGVhcnRiZWF0cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBjb25uZWN0aW9uTWFuYWdlcjtcbiAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIucmVnaXN0ZXJQcm9wb3NlZFRyYW5zcG9ydChfdGhpcyk7XG4gICAgICAgIF90aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICBfdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIF90aGlzLnRpbWVvdXRzID0gcGFyYW1zLm9wdGlvbnMudGltZW91dHM7XG4gICAgICAgIF90aGlzLmZvcm1hdCA9IHBhcmFtcy5mb3JtYXQ7XG4gICAgICAgIF90aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmlzRmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICBfdGhpcy5pZGxlVGltZXIgPSBudWxsO1xuICAgICAgICBfdGhpcy5sYXN0QWN0aXZpdHkgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Q2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmlzaCgnY2xvc2VkJywgY29ubmVjdGlvbmVycm9yc18xLmRlZmF1bHQuY2xvc2VkKCkpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAvKiBVc2VkIGZvciBuZXR3b3JrL3RyYW5zcG9ydCBpc3N1ZXMgdGhhdCBuZWVkIHRvIHJlc3VsdCBpbiB0aGUgdHJhbnNwb3J0XG4gICAgICAgICAqIGJlaW5nIGRpc2Nvbm5lY3RlZCwgYnV0IHNob3VsZCBub3QgdHJhbnNpdGlvbiB0aGUgY29ubmVjdGlvbiB0byAnZmFpbGVkJyAqL1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluaXNoKCdkaXNjb25uZWN0ZWQnLCBlcnIgfHwgY29ubmVjdGlvbmVycm9yc18xLmRlZmF1bHQuZGlzY29ubmVjdGVkKCkpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAvKiBVc2VkIGZvciBjbGllbnQtc2lkZS1kZXRlY3RlZCBmYXRhbCBjb25uZWN0aW9uIGlzc3VlcyAqL1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluaXNoKCdmYWlsZWQnLCBlcnIgfHwgY29ubmVjdGlvbmVycm9yc18xLmRlZmF1bHQuZmFpbGVkKCkpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoZXZlbnQsIGVycikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF4SWRsZUludGVydmFsID0gbnVsbDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KChfYSA9IHRoaXMuaWRsZVRpbWVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmlkbGVUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdChldmVudCwgZXJyKTtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uUHJvdG9jb2xNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGxvZ2dlcl8xLmRlZmF1bHQuc2hvdWxkTG9nKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBvbiAnICtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3J0TmFtZSArXG4gICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5zdHJpbmdpZnkobWVzc2FnZSkgK1xuICAgICAgICAgICAgICAgICc7IGNvbm5lY3Rpb25JZCA9ICcgK1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLmFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLkhFQVJUQkVBVDpcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1RyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpJywgdGhpcy5zaG9ydE5hbWUgKyAnIGhlYXJ0YmVhdDsgY29ubmVjdGlvbklkID0gJyArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2hlYXJ0YmVhdCcsIG1lc3NhZ2UuaWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLkNPTk5FQ1RFRDpcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29ubmVjdChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3RlZCcsIG1lc3NhZ2UuZXJyb3IsIG1lc3NhZ2UuY29ubmVjdGlvbklkLCBtZXNzYWdlLmNvbm5lY3Rpb25EZXRhaWxzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5DTE9TRUQ6XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLkRJU0NPTk5FQ1RFRDpcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5BQ0s6XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdhY2snLCBtZXNzYWdlLm1zZ1NlcmlhbCwgbWVzc2FnZS5jb3VudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGFjdGlvbnMuTkFDSzpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ25hY2snLCBtZXNzYWdlLm1zZ1NlcmlhbCwgbWVzc2FnZS5jb3VudCwgbWVzc2FnZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGFjdGlvbnMuU1lOQzpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGFjdGlvbnMuQUNUSVZBVEU6XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlZC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5BVVRIOlxuICAgICAgICAgICAgICAgIHRoaXMuYXV0aC5hdXRob3JpemUoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1RyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpJywgJ0FibHkgcmVxdWVzdGVkIHJlLWF1dGhlbnRpY2F0aW9uLCBidXQgdW5hYmxlIHRvIG9idGFpbiBhIG5ldyB0b2tlbjogJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLkVSUk9SOlxuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKCknLCAncmVjZWl2ZWQgZXJyb3IgYWN0aW9uOyBjb25uZWN0aW9uSWQgPSAnICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWQgK1xuICAgICAgICAgICAgICAgICAgICAnOyBlcnIgPSAnICtcbiAgICAgICAgICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KG1lc3NhZ2UuZXJyb3IpICtcbiAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuY2hhbm5lbCA/ICcsIGNoYW5uZWw6ICcgKyBtZXNzYWdlLmNoYW5uZWwgOiAnJykpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmNoYW5uZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRmF0YWxFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIG90aGVyd2lzZSBpdCdzIGEgY2hhbm5lbC1zcGVjaWZpYyBlcnJvciwgc28gaGFuZGxlIGl0IGluIHRoZSBjaGFubmVsICovXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvKiBhbGwgb3RoZXIgYWN0aW9ucyBhcmUgY2hhbm5lbC1zcGVjaWZpYyAqL1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZShtZXNzYWdlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNvbm5lY3QgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFtZXNzYWdlLmNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydC5vbkNvbm5lY3QoKTogQ29ubmVjdCBtZXNzYWdlIHJlY2lldmVkIHdpdGhvdXQgY29ubmVjdGlvbkRldGFpbHMnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4UHJvbWlzZWRJZGxlID0gbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscy5tYXhJZGxlSW50ZXJ2YWw7XG4gICAgICAgIGlmIChtYXhQcm9taXNlZElkbGUpIHtcbiAgICAgICAgICAgIHRoaXMubWF4SWRsZUludGVydmFsID0gbWF4UHJvbWlzZWRJZGxlICsgdGhpcy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0O1xuICAgICAgICAgICAgdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogZWxzZSBSZWFsdGltZSBkZWNsaW5lcyB0byBndWFyYW50ZWUgYW55IG1heGltdW0gaWRsZSBpbnRlcnZhbCAtIENEMmggKi9cbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUub25EaXNjb25uZWN0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgLyogVXNlZCBmb3Igd2hlbiB0aGUgc2VydmVyIGhhcyBkaXNjb25uZWN0ZWQgdGhlIGNsaWVudCAodXN1YWxseSB3aXRoIGFcbiAgICAgICAgICogRElTQ09OTkVDVEVEIGFjdGlvbikgKi9cbiAgICAgICAgdmFyIGVyciA9IG1lc3NhZ2UgJiYgbWVzc2FnZS5lcnJvcjtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdUcmFuc3BvcnQub25EaXNjb25uZWN0KCknLCAnZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgdGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVycik7XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uRmF0YWxFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIC8qIE9uIHJlY2VpcHQgb2YgYSBmYXRhbCBjb25uZWN0aW9uIGVycm9yLCB3ZSBjYW4gYXNzdW1lIHRoYXQgdGhlIHNlcnZlclxuICAgICAgICAgKiB3aWxsIGNsb3NlIHRoZSBjb25uZWN0aW9uIGFuZCB0aGUgdHJhbnNwb3J0LCBhbmQgZG8gbm90IG5lZWQgdG8gcmVxdWVzdFxuICAgICAgICAgKiBhIGRpc2Nvbm5lY3Rpb24gLSBSVE4xNWkgKi9cbiAgICAgICAgdmFyIGVyciA9IG1lc3NhZ2UgJiYgbWVzc2FnZS5lcnJvcjtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdUcmFuc3BvcnQub25GYXRhbEVycm9yKCknLCAnZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgdGhpcy5maW5pc2goJ2ZhaWxlZCcsIGVycik7XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgZXJyID0gbWVzc2FnZSAmJiBtZXNzYWdlLmVycm9yO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5vbkNsb3NlKCknLCAnZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgdGhpcy5maW5pc2goJ2Nsb3NlZCcsIGVycik7XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLnJlcXVlc3RDbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdUcmFuc3BvcnQucmVxdWVzdENsb3NlKCknLCAnJyk7XG4gICAgICAgIHRoaXMuc2VuZChjbG9zZU1lc3NhZ2UpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5yZXF1ZXN0RGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdUcmFuc3BvcnQucmVxdWVzdERpc2Nvbm5lY3QoKScsICcnKTtcbiAgICAgICAgdGhpcy5zZW5kKGRpc2Nvbm5lY3RNZXNzYWdlKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgbXNnID0geyBhY3Rpb246IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuQWN0aW9uLkhFQVJUQkVBVCB9O1xuICAgICAgICBpZiAoaWQpXG4gICAgICAgICAgICBtc2cuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5zZW5kKHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyhtc2cpKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdUcmFuc3BvcnQuZGlzcG9zZSgpJywgJycpO1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9mZigpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkFjdGl2aXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMubWF4SWRsZUludGVydmFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0QWN0aXZpdHkgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmxhc3RBY3Rpdml0eSA9IFV0aWxzLm5vdygpO1xuICAgICAgICB0aGlzLnNldElkbGVUaW1lcih0aGlzLm1heElkbGVJbnRlcnZhbCArIDEwMCk7XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLnNldElkbGVUaW1lciA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5pZGxlVGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaWRsZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25JZGxlVGltZXJFeHBpcmUoKTtcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uSWRsZVRpbWVyRXhwaXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMubGFzdEFjdGl2aXR5IHx8ICF0aGlzLm1heElkbGVJbnRlcnZhbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQub25JZGxlVGltZXJFeHBpcmUoKTogbGFzdEFjdGl2aXR5L21heElkbGVJbnRlcnZhbCBub3Qgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xuICAgICAgICB2YXIgc2luY2VMYXN0ID0gVXRpbHMubm93KCkgLSB0aGlzLmxhc3RBY3Rpdml0eTtcbiAgICAgICAgdmFyIHRpbWVSZW1haW5pbmcgPSB0aGlzLm1heElkbGVJbnRlcnZhbCAtIHNpbmNlTGFzdDtcbiAgICAgICAgaWYgKHRpbWVSZW1haW5pbmcgPD0gMCkge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdObyBhY3Rpdml0eSBzZWVuIGZyb20gcmVhbHRpbWUgaW4gJyArIHNpbmNlTGFzdCArICdtczsgYXNzdW1pbmcgY29ubmVjdGlvbiBoYXMgZHJvcHBlZCc7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1RyYW5zcG9ydC5vbklkbGVUaW1lckV4cGlyZSgpJywgbXNnKTtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdChuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDgwMDAzLCA0MDgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SWRsZVRpbWVyKHRpbWVSZW1haW5pbmcgKyAxMDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmFuc3BvcnQudHJ5Q29ubmVjdCA9IGZ1bmN0aW9uICh0cmFuc3BvcnRDdG9yLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgdHJhbnNwb3J0UGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydEN0b3IoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHRyYW5zcG9ydFBhcmFtcyk7XG4gICAgICAgIHZhciB0cmFuc3BvcnRBdHRlbXB0VGltZXI7XG4gICAgICAgIHZhciBlcnJvckNiID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRyYW5zcG9ydEF0dGVtcHRUaW1lcik7XG4gICAgICAgICAgICBjYWxsYmFjayh7IGV2ZW50OiB0aGlzLmV2ZW50LCBlcnJvcjogZXJyIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVhbHRpbWVSZXF1ZXN0VGltZW91dCA9IGNvbm5lY3Rpb25NYW5hZ2VyLm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dDtcbiAgICAgICAgdHJhbnNwb3J0QXR0ZW1wdFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQub2ZmKFsncHJlY29ubmVjdCcsICdkaXNjb25uZWN0ZWQnLCAnZmFpbGVkJ10pO1xuICAgICAgICAgICAgdHJhbnNwb3J0LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGVycm9yQ2IuY2FsbCh7IGV2ZW50OiAnZGlzY29ubmVjdGVkJyB9LCBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVGltZW91dCB3YWl0aW5nIGZvciB0cmFuc3BvcnQgdG8gaW5kaWNhdGUgaXRzZWxmIHZpYWJsZScsIDUwMDAwLCA1MDApKTtcbiAgICAgICAgfSwgcmVhbHRpbWVSZXF1ZXN0VGltZW91dCk7XG4gICAgICAgIHRyYW5zcG9ydC5vbihbJ2ZhaWxlZCcsICdkaXNjb25uZWN0ZWQnXSwgZXJyb3JDYik7XG4gICAgICAgIHRyYW5zcG9ydC5vbigncHJlY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnVHJhbnNwb3J0LnRyeUNvbm5lY3QoKScsICd2aWFibGUgdHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRyYW5zcG9ydEF0dGVtcHRUaW1lcik7XG4gICAgICAgICAgICB0cmFuc3BvcnQub2ZmKFsnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCBlcnJvckNiKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRyYW5zcG9ydCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0cmFuc3BvcnQuY29ubmVjdCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zcG9ydDtcbn0oZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVHJhbnNwb3J0O1xuXG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKSwgX193ZWJwYWNrX3JlcXVpcmVfXygyNCkpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgTUQ1ID0gQ19hbGdvLk1ENTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGlzIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIGlzIG1lYW50IHRvIGNvbmZvcm0gd2l0aCBFVlBfQnl0ZXNUb0tleS5cblx0ICAgICAqIHd3dy5vcGVuc3NsLm9yZy9kb2NzL2NyeXB0by9FVlBfQnl0ZXNUb0tleS5odG1sXG5cdCAgICAgKi9cblx0ICAgIHZhciBFdnBLREYgPSBDX2FsZ28uRXZwS0RGID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoZSBrZXkgc2l6ZSBpbiB3b3JkcyB0byBnZW5lcmF0ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLiBEZWZhdWx0OiBNRDVcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXRlcmF0aW9ucyBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybS4gRGVmYXVsdDogMVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICBrZXlTaXplOiAxMjgvMzIsXG5cdCAgICAgICAgICAgIGhhc2hlcjogTUQ1LFxuXHQgICAgICAgICAgICBpdGVyYXRpb25zOiAxXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoZSBkZXJpdmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKCk7XG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiA4IH0pO1xuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIga2V5ID0ga2RmLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbXB1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCkge1xuXHQgICAgICAgICAgICB2YXIgYmxvY2s7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXQgaGFzaGVyXG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSBjZmcuaGFzaGVyLmNyZWF0ZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5ID0gV29yZEFycmF5LmNyZWF0ZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZEtleVdvcmRzID0gZGVyaXZlZEtleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGtleVNpemUgPSBjZmcua2V5U2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBjZmcuaXRlcmF0aW9ucztcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBrZXlcblx0ICAgICAgICAgICAgd2hpbGUgKGRlcml2ZWRLZXlXb3Jkcy5sZW5ndGggPCBrZXlTaXplKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoYmxvY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICBoYXNoZXIudXBkYXRlKGJsb2NrKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGJsb2NrID0gaGFzaGVyLnVwZGF0ZShwYXNzd29yZCkuZmluYWxpemUoc2FsdCk7XG5cdCAgICAgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gSXRlcmF0aW9uc1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBibG9jayA9IGhhc2hlci5maW5hbGl6ZShibG9jayk7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGRlcml2ZWRLZXkuY29uY2F0KGJsb2NrKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBkZXJpdmVkS2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGRlcml2ZWRLZXk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGNvbXB1dGF0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDggfSk7XG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuXHQgICAgICovXG5cdCAgICBDLkV2cEtERiA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgY2ZnKSB7XG5cdCAgICAgICAgcmV0dXJuIEV2cEtERi5jcmVhdGUoY2ZnKS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgIH07XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuRXZwS0RGO1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogQ2lwaGVyIGNvcmUgY29tcG9uZW50cy5cblx0ICovXG5cdENyeXB0b0pTLmxpYi5DaXBoZXIgfHwgKGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xuXHQgICAgdmFyIEJhc2U2NCA9IENfZW5jLkJhc2U2NDtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgRXZwS0RGID0gQ19hbGdvLkV2cEtERjtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGNpcGhlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGlzIGNpcGhlcidzIGtleSBzaXplLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdlNpemUgVGhpcyBjaXBoZXIncyBJViBzaXplLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfRU5DX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZW5jcnlwdGlvbiBtb2RlLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9ERUNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBkZWNyeXB0aW9uIG1vZGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDaXBoZXIgPSBDX2xpYi5DaXBoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGl2IFRoZSBJViB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZW5jcnlwdGlvbiBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRW5jcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRW5jcnlwdG9yOiBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0VOQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZGVjcnlwdGlvbiBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRGVjcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRGVjcnlwdG9yOiBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBjaXBoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geGZvcm1Nb2RlIEVpdGhlciB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHRyYW5zb3JtYXRpb24gbW9kZSBjb25zdGFudC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZShDcnlwdG9KUy5hbGdvLkFFUy5fRU5DX1hGT1JNX01PREUsIGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKHhmb3JtTW9kZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gU3RvcmUgdHJhbnNmb3JtIG1vZGUgYW5kIGtleVxuXHQgICAgICAgICAgICB0aGlzLl94Zm9ybU1vZGUgPSB4Zm9ybU1vZGU7XG5cdCAgICAgICAgICAgIHRoaXMuX2tleSA9IGtleTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBjaXBoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGNpcGhlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG5cdCAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuXHQgICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgZGF0YSB0byBiZSBlbmNyeXB0ZWQgb3IgZGVjcnlwdGVkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgcHJvY2Vzc2luZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2Vzcyh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBhdmFpbGFibGUgYmxvY2tzXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHByb2Nlc3MuXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVVwZGF0ZSBUaGUgZmluYWwgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkYXRhIGFmdGVyIGZpbmFsIHByb2Nlc3NpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSgnZGF0YScpO1xuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEZpbmFsIGRhdGEgdXBkYXRlXG5cdCAgICAgICAgICAgIGlmIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuXHQgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWREYXRhID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZERhdGE7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGtleVNpemU6IDEyOC8zMixcblxuXHQgICAgICAgIGl2U2l6ZTogMTI4LzMyLFxuXG5cdCAgICAgICAgX0VOQ19YRk9STV9NT0RFOiAxLFxuXG5cdCAgICAgICAgX0RFQ19YRk9STV9NT0RFOiAyLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBzaG9ydGN1dCBmdW5jdGlvbnMgdG8gYSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGVuY3J5cHQgYW5kIGRlY3J5cHQgc2hvcnRjdXQgZnVuY3Rpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgQUVTID0gQ3J5cHRvSlMubGliLkNpcGhlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uQUVTKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSGVscGVyOiAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBhc3N3b3JkQmFzZWRDaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBTZXJpYWxpemFibGVDaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNpcGhlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAobWVzc2FnZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZW5jcnlwdChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgICAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpLmRlY3J5cHQoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9KCkpXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIHN0cmVhbSBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMSAoMzIgYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIFN0cmVhbUNpcGhlciA9IENfbGliLlN0cmVhbUNpcGhlciA9IENpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgcGFydGlhbCBibG9ja3Ncblx0ICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2Nrcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiAxXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNb2RlIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfbW9kZSA9IEMubW9kZSA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2UgYmxvY2sgY2lwaGVyIG1vZGUgdGVtcGxhdGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCbG9ja0NpcGhlck1vZGUgPSBDX2xpYi5CbG9ja0NpcGhlck1vZGUgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGVuY3J5cHRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVFbmNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRW5jcnlwdG9yOiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZGVjcnlwdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZURlY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVEZWNyeXB0b3I6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLkRlY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2LndvcmRzKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICB0aGlzLl9jaXBoZXIgPSBjaXBoZXI7XG5cdCAgICAgICAgICAgIHRoaXMuX2l2ID0gaXY7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ2lwaGVyIEJsb2NrIENoYWluaW5nIG1vZGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDQkMgPSBDX21vZGUuQ0JDID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBYnN0cmFjdCBiYXNlIENCQyBtb2RlLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHZhciBDQkMgPSBCbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDQkMgZW5jcnlwdG9yLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIENCQy5FbmNyeXB0b3IgPSBDQkMuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBYT1IgYW5kIGVuY3J5cHRcblx0ICAgICAgICAgICAgICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcblx0ICAgICAgICAgICAgICAgIGNpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDQkMgZGVjcnlwdG9yLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIENCQy5EZWNyeXB0b3IgPSBDQkMuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcblx0ICAgICAgICAgICAgICAgIHZhciB0aGlzQmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIERlY3J5cHQgYW5kIFhPUlxuXHQgICAgICAgICAgICAgICAgY2lwaGVyLmRlY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVGhpcyBibG9jayBiZWNvbWVzIHRoZSBwcmV2aW91cyBibG9ja1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gdGhpc0Jsb2NrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBmdW5jdGlvbiB4b3JCbG9jayh3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBpdiA9IHRoaXMuX2l2O1xuXG5cdCAgICAgICAgICAgIC8vIENob29zZSBtaXhpbmcgYmxvY2tcblx0ICAgICAgICAgICAgaWYgKGl2KSB7XG5cdCAgICAgICAgICAgICAgICBibG9jayA9IGl2O1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGJsb2NrID0gdGhpcy5fcHJldkJsb2NrO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gWE9SIGJsb2Nrc1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tvZmZzZXQgKyBpXSBePSBibG9ja1tpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBDQkM7XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFBhZGRpbmcgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19wYWQgPSBDLnBhZCA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFBLQ1MgIzUvNyBwYWRkaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgUGtjczcgPSBDX3BhZC5Qa2NzNyA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBQYWRzIGRhdGEgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHBhZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tTaXplIFRoZSBtdWx0aXBsZSB0aGF0IHRoZSBkYXRhIHNob3VsZCBiZSBwYWRkZWQgdG8uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy5wYWQod29yZEFycmF5LCA0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYWQ6IGZ1bmN0aW9uIChkYXRhLCBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBwYWRkaW5nIGJ5dGVzXG5cdCAgICAgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gYmxvY2tTaXplQnl0ZXMgLSBkYXRhLnNpZ0J5dGVzICUgYmxvY2tTaXplQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIHBhZGRpbmcgd29yZFxuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ1dvcmQgPSAoblBhZGRpbmdCeXRlcyA8PCAyNCkgfCAoblBhZGRpbmdCeXRlcyA8PCAxNikgfCAoblBhZGRpbmdCeXRlcyA8PCA4KSB8IG5QYWRkaW5nQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdXb3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5QYWRkaW5nQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgcGFkZGluZ1dvcmRzLnB1c2gocGFkZGluZ1dvcmQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nID0gV29yZEFycmF5LmNyZWF0ZShwYWRkaW5nV29yZHMsIG5QYWRkaW5nQnl0ZXMpO1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGEuY29uY2F0KHBhZGRpbmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVbnBhZHMgZGF0YSB0aGF0IGhhZCBiZWVuIHBhZGRlZCB1c2luZyB0aGUgYWxnb3JpdGhtIGRlZmluZWQgaW4gUEtDUyAjNS83LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGRhdGEgVGhlIGRhdGEgdG8gdW5wYWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy51bnBhZCh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVucGFkOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgICAgICAvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcblx0ICAgICAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBkYXRhLndvcmRzWyhkYXRhLnNpZ0J5dGVzIC0gMSkgPj4+IDJdICYgMHhmZjtcblxuXHQgICAgICAgICAgICAvLyBSZW1vdmUgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5QYWRkaW5nQnl0ZXM7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGJsb2NrIGNpcGhlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIEJsb2NrQ2lwaGVyID0gQ19saWIuQmxvY2tDaXBoZXIgPSBDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdG8gdXNlLiBEZWZhdWx0OiBDQkNcblx0ICAgICAgICAgKiBAcHJvcGVydHkge1BhZGRpbmd9IHBhZGRpbmcgVGhlIHBhZGRpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBQa2NzN1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQ2lwaGVyLmNmZy5leHRlbmQoe1xuXHQgICAgICAgICAgICBtb2RlOiBDQkMsXG5cdCAgICAgICAgICAgIHBhZGRpbmc6IFBrY3M3XG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgbW9kZUNyZWF0b3I7XG5cblx0ICAgICAgICAgICAgLy8gUmVzZXQgY2lwaGVyXG5cdCAgICAgICAgICAgIENpcGhlci5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2ZnID0gdGhpcy5jZmc7XG5cdCAgICAgICAgICAgIHZhciBpdiA9IGNmZy5pdjtcblx0ICAgICAgICAgICAgdmFyIG1vZGUgPSBjZmcubW9kZTtcblxuXHQgICAgICAgICAgICAvLyBSZXNldCBibG9jayBtb2RlXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fRU5DX1hGT1JNX01PREUpIHtcblx0ICAgICAgICAgICAgICAgIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVFbmNyeXB0b3I7XG5cdCAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqLyB7XG5cdCAgICAgICAgICAgICAgICBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRGVjcnlwdG9yO1xuXHQgICAgICAgICAgICAgICAgLy8gS2VlcCBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gdGhlIGJ1ZmZlciBmb3IgdW5wYWRkaW5nXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9taW5CdWZmZXJTaXplID0gMTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlICYmIHRoaXMuX21vZGUuX19jcmVhdG9yID09IG1vZGVDcmVhdG9yKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9tb2RlLmluaXQodGhpcywgaXYgJiYgaXYud29yZHMpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbW9kZSA9IG1vZGVDcmVhdG9yLmNhbGwobW9kZSwgdGhpcywgaXYgJiYgaXYud29yZHMpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbW9kZS5fX2NyZWF0b3IgPSBtb2RlQ3JlYXRvcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX21vZGUucHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3M7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLmNmZy5wYWRkaW5nO1xuXG5cdCAgICAgICAgICAgIC8vIEZpbmFsaXplXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fRU5DX1hGT1JNX01PREUpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFBhZCBkYXRhXG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nLnBhZCh0aGlzLl9kYXRhLCB0aGlzLmJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblx0ICAgICAgICAgICAgfSBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcblx0ICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVW5wYWQgZGF0YVxuXHQgICAgICAgICAgICAgICAgcGFkZGluZy51bnBhZChmaW5hbFByb2Nlc3NlZEJsb2Nrcyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3M7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogMTI4LzMyXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIGNvbGxlY3Rpb24gb2YgY2lwaGVyIHBhcmFtZXRlcnMuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGNpcGhlcnRleHQgVGhlIHJhdyBjaXBoZXJ0ZXh0LlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGtleSBUaGUga2V5IHRvIHRoaXMgY2lwaGVydGV4dC5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBzYWx0IFRoZSBzYWx0IHVzZWQgd2l0aCBhIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtDaXBoZXJ9IGFsZ29yaXRobSBUaGUgY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHNjaGVtZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgYmxvY2sgc2l6ZSBvZiB0aGUgY2lwaGVyLlxuXHQgICAgICogQHByb3BlcnR5IHtGb3JtYXR9IGZvcm1hdHRlciBUaGUgZGVmYXVsdCBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cblx0ICAgICAqL1xuXHQgICAgdmFyIENpcGhlclBhcmFtcyA9IENfbGliLkNpcGhlclBhcmFtcyA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2lwaGVyUGFyYW1zIEFuIG9iamVjdCB3aXRoIGFueSBvZiB0aGUgcG9zc2libGUgY2lwaGVyIHBhcmFtZXRlcnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG5cdCAgICAgICAgICogICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAga2V5OiBrZXlXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBpdjogaXZXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBzYWx0OiBzYWx0V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAgYWxnb3JpdGhtOiBDcnlwdG9KUy5hbGdvLkFFUyxcblx0ICAgICAgICAgKiAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxuXHQgICAgICAgICAqICAgICAgICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLlBLQ1M3LFxuXHQgICAgICAgICAqICAgICAgICAgYmxvY2tTaXplOiA0LFxuXHQgICAgICAgICAqICAgICAgICAgZm9ybWF0dGVyOiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTFxuXHQgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG5cdCAgICAgICAgICAgIHRoaXMubWl4SW4oY2lwaGVyUGFyYW1zKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Rm9ybWF0fSBmb3JtYXR0ZXIgKE9wdGlvbmFsKSBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCBjaXBoZXIgcGFyYW1zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHRocm93cyBFcnJvciBJZiBuZWl0aGVyIHRoZSBmb3JtYXR0ZXIgbm9yIHRoZSBkZWZhdWx0IGZvcm1hdHRlciBpcyBzZXQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMgKyAnJztcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZygpO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGZvcm1hdHRlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gKGZvcm1hdHRlciB8fCB0aGlzLmZvcm1hdHRlcikuc3RyaW5naWZ5KHRoaXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEZvcm1hdCBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2Zvcm1hdCA9IEMuZm9ybWF0ID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogT3BlblNTTCBmb3JtYXR0aW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgT3BlblNTTEZvcm1hdHRlciA9IENfZm9ybWF0Lk9wZW5TU0wgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN9IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgb3BlblNTTFN0cmluZyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuXHQgICAgICAgICAgICB2YXIgd29yZEFycmF5O1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGNpcGhlclBhcmFtcy5jaXBoZXJ0ZXh0O1xuXHQgICAgICAgICAgICB2YXIgc2FsdCA9IGNpcGhlclBhcmFtcy5zYWx0O1xuXG5cdCAgICAgICAgICAgIC8vIEZvcm1hdFxuXHQgICAgICAgICAgICBpZiAoc2FsdCkge1xuXHQgICAgICAgICAgICAgICAgd29yZEFycmF5ID0gV29yZEFycmF5LmNyZWF0ZShbMHg1MzYxNmM3NCwgMHg2NTY0NWY1Zl0pLmNvbmNhdChzYWx0KS5jb25jYXQoY2lwaGVydGV4dCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB3b3JkQXJyYXkgPSBjaXBoZXJ0ZXh0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHdvcmRBcnJheS50b1N0cmluZyhCYXNlNjQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nIHRvIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlblNTTFN0ciBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wucGFyc2Uob3BlblNTTFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChvcGVuU1NMU3RyKSB7XG5cdCAgICAgICAgICAgIHZhciBzYWx0O1xuXG5cdCAgICAgICAgICAgIC8vIFBhcnNlIGJhc2U2NFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IEJhc2U2NC5wYXJzZShvcGVuU1NMU3RyKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dFdvcmRzID0gY2lwaGVydGV4dC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBUZXN0IGZvciBzYWx0XG5cdCAgICAgICAgICAgIGlmIChjaXBoZXJ0ZXh0V29yZHNbMF0gPT0gMHg1MzYxNmM3NCAmJiBjaXBoZXJ0ZXh0V29yZHNbMV0gPT0gMHg2NTY0NWY1Zikge1xuXHQgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBzYWx0XG5cdCAgICAgICAgICAgICAgICBzYWx0ID0gV29yZEFycmF5LmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoMiwgNCkpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgc2FsdCBmcm9tIGNpcGhlcnRleHRcblx0ICAgICAgICAgICAgICAgIGNpcGhlcnRleHRXb3Jkcy5zcGxpY2UoMCwgNCk7XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0LnNpZ0J5dGVzIC09IDE2O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LCBzYWx0OiBzYWx0IH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBjaXBoZXIgd3JhcHBlciB0aGF0IHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNlcmlhbGl6YWJsZUNpcGhlciA9IENfbGliLlNlcmlhbGl6YWJsZUNpcGhlciA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge0Zvcm1hdHRlcn0gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgY2lwaGVyIHBhcmFtIG9iamVjdHMgdG8gYW5kIGZyb20gYSBzdHJpbmcuIERlZmF1bHQ6IE9wZW5TU0xcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgZm9ybWF0OiBPcGVuU1NMRm9ybWF0dGVyXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZW5jcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXksIHsgaXY6IGl2IH0pO1xuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBtZXNzYWdlLCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICB2YXIgZW5jcnlwdG9yID0gY2lwaGVyLmNyZWF0ZUVuY3J5cHRvcihrZXksIGNmZyk7XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gZW5jcnlwdG9yLmZpbmFsaXplKG1lc3NhZ2UpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJDZmcgPSBlbmNyeXB0b3IuY2ZnO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgcmV0dXJuIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHtcblx0ICAgICAgICAgICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHQsXG5cdCAgICAgICAgICAgICAgICBrZXk6IGtleSxcblx0ICAgICAgICAgICAgICAgIGl2OiBjaXBoZXJDZmcuaXYsXG5cdCAgICAgICAgICAgICAgICBhbGdvcml0aG06IGNpcGhlcixcblx0ICAgICAgICAgICAgICAgIG1vZGU6IGNpcGhlckNmZy5tb2RlLFxuXHQgICAgICAgICAgICAgICAgcGFkZGluZzogY2lwaGVyQ2ZnLnBhZGRpbmcsXG5cdCAgICAgICAgICAgICAgICBibG9ja1NpemU6IGNpcGhlci5ibG9ja1NpemUsXG5cdCAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGNmZy5mb3JtYXRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcblx0ICAgICAgICAgICAgY2lwaGVydGV4dCA9IHRoaXMuX3BhcnNlKGNpcGhlcnRleHQsIGNmZy5mb3JtYXQpO1xuXG5cdCAgICAgICAgICAgIC8vIERlY3J5cHRcblx0ICAgICAgICAgICAgdmFyIHBsYWludGV4dCA9IGNpcGhlci5jcmVhdGVEZWNyeXB0b3Ioa2V5LCBjZmcpLmZpbmFsaXplKGNpcGhlcnRleHQuY2lwaGVydGV4dCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHRvIENpcGhlclBhcmFtcyxcblx0ICAgICAgICAgKiBlbHNlIGFzc3VtZWQgQ2lwaGVyUGFyYW1zIGFscmVhZHkgYW5kIHJldHVybnMgY2lwaGVydGV4dCB1bmNoYW5nZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtGb3JtYXR0ZXJ9IGZvcm1hdCBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UgdG8gcGFyc2Ugc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgdW5zZXJpYWxpemVkIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5fcGFyc2UoY2lwaGVydGV4dFN0cmluZ09yUGFyYW1zLCBmb3JtYXQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9wYXJzZTogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGZvcm1hdCkge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNpcGhlcnRleHQgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXQucGFyc2UoY2lwaGVydGV4dCwgdGhpcyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfa2RmID0gQy5rZGYgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBPcGVuU1NMIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICovXG5cdCAgICB2YXIgT3BlblNTTEtkZiA9IENfa2RmLk9wZW5TU0wgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVyaXZlcyBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byBkZXJpdmUgZnJvbS5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga2V5U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUga2V5IHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdlNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIElWIHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCAoT3B0aW9uYWwpIEEgNjQtYml0IHNhbHQgdG8gdXNlLiBJZiBvbWl0dGVkLCBhIHNhbHQgd2lsbCBiZSBnZW5lcmF0ZWQgcmFuZG9tbHkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3Qgd2l0aCB0aGUga2V5LCBJViwgYW5kIHNhbHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMik7XG5cdCAgICAgICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMiwgJ3NhbHRzYWx0Jyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBrZXlTaXplLCBpdlNpemUsIHNhbHQpIHtcblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUgcmFuZG9tIHNhbHRcblx0ICAgICAgICAgICAgaWYgKCFzYWx0KSB7XG5cdCAgICAgICAgICAgICAgICBzYWx0ID0gV29yZEFycmF5LnJhbmRvbSg2NC84KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIElWXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSBFdnBLREYuY3JlYXRlKHsga2V5U2l6ZToga2V5U2l6ZSArIGl2U2l6ZSB9KS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblxuXHQgICAgICAgICAgICAvLyBTZXBhcmF0ZSBrZXkgYW5kIElWXG5cdCAgICAgICAgICAgIHZhciBpdiA9IFdvcmRBcnJheS5jcmVhdGUoa2V5LndvcmRzLnNsaWNlKGtleVNpemUpLCBpdlNpemUgKiA0KTtcblx0ICAgICAgICAgICAga2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIHBhcmFtc1xuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGtleToga2V5LCBpdjogaXYsIHNhbHQ6IHNhbHQgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIHNlcmlhbGl6YWJsZSBjaXBoZXIgd3JhcHBlciB0aGF0IGRlcml2ZXMgdGhlIGtleSBmcm9tIGEgcGFzc3dvcmQsXG5cdCAgICAgKiBhbmQgcmV0dXJucyBjaXBoZXJ0ZXh0IGFzIGEgc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICovXG5cdCAgICB2YXIgUGFzc3dvcmRCYXNlZENpcGhlciA9IENfbGliLlBhc3N3b3JkQmFzZWRDaXBoZXIgPSBTZXJpYWxpemFibGVDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge0tERn0ga2RmIFRoZSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiB0byB1c2UgdG8gZ2VuZXJhdGUgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC4gRGVmYXVsdDogT3BlblNTTFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogU2VyaWFsaXphYmxlQ2lwaGVyLmNmZy5leHRlbmQoe1xuXHQgICAgICAgICAgICBrZGY6IE9wZW5TU0xLZGZcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEVuY3J5cHRzIGEgbWVzc2FnZSB1c2luZyBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcpO1xuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBtZXNzYWdlLCBwYXNzd29yZCwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBvdGhlciBwYXJhbXNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplKTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgSVYgdG8gY29uZmlnXG5cdCAgICAgICAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XG5cblx0ICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0LmNhbGwodGhpcywgY2lwaGVyLCBtZXNzYWdlLCBkZXJpdmVkUGFyYW1zLmtleSwgY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBNaXggaW4gZGVyaXZlZCBwYXJhbXNcblx0ICAgICAgICAgICAgY2lwaGVydGV4dC5taXhJbihkZXJpdmVkUGFyYW1zKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVjcnlwdHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHVzaW5nIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwbGFpbnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgY2lwaGVydGV4dCwgcGFzc3dvcmQsIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gQ2lwaGVyUGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcblxuXHQgICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBvdGhlciBwYXJhbXNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplLCBjaXBoZXJ0ZXh0LnNhbHQpO1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBJViB0byBjb25maWdcblx0ICAgICAgICAgICAgY2ZnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjtcblxuXHQgICAgICAgICAgICAvLyBEZWNyeXB0XG5cdCAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgY2lwaGVydGV4dCwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0fSgpKTtcblxuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVxdWVzdCA9IGV4cG9ydHMuY3JlYXRlUmVxdWVzdCA9IHZvaWQgMDtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGNvbWV0dHJhbnNwb3J0XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIGV2ZW50ZW1pdHRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG52YXIgZXJyb3JpbmZvXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIGRlZmF1bHRzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIFhIUlN0YXRlc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyMSkpO1xuLy8gV29ya2Fyb3VuZCBmb3Igc2FsZXNmb3JjZSBsaWdodG5pbmcgbG9ja2VyIGNvbXBhdGliaWxpdHlcbnZhciBnbG9iYWxPYmplY3QgPSBVdGlscy5nZXRHbG9iYWxPYmplY3QoKTtcbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuLyogQ2FuJ3QganVzdCB1c2Ugd2luZG93LkFibHksIGFzIHRoYXQgd29uJ3QgZXhpc3QgaWYgdXNpbmcgdGhlIGNvbW1vbmpzIHZlcnNpb24uICovXG52YXIgXyA9IChnbG9iYWxPYmplY3QuX2FibHlqc19qc29ucCA9IHt9KTtcbi8qIGV4cHJlc3Mgc3RyaXBzIG91dCBwYXJhbnRoZXNlcyBmcm9tIHRoZSBjYWxsYmFjayFcbiAqIEtsdWRnZSB0byBzdGlsbCBhbG93IGl0cyByZXNwb25zZXMgdG8gd29yaywgd2hpbGUgbm90IGtlZXBpbmcgdGhlXG4gKiBmdW5jdGlvbiBmb3JtIGZvciBub3JtYWwgdXNlIGFuZCBub3QgY2x1dHRlcmluZyB3aW5kb3cuQWJseVxuICogaHR0cHM6Ly9naXRodWIuY29tL2V4cHJlc3Nqcy9leHByZXNzL2Jsb2IvNWI0ZDRiNGFiMTMyNDc0MzUzNGZiY2Q0NzA5ZjRlNzViYjRiNGU5ZC9saWIvcmVzcG9uc2UuanMjTDMwNVxuICovXG5fLl8gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gX1snXycgKyBpZF0gfHwgbm9vcDtcbn07XG52YXIgaWRDb3VudGVyID0gMTtcbnZhciBzaG9ydE5hbWUgPSAnanNvbnAnO1xuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBtZXRob2QpIHtcbiAgICAvKiBKU09OUCByZXF1ZXN0cyBhcmUgdXNlZCBlaXRoZXIgd2l0aCB0aGUgY29udGV4dCBiZWluZyBhIHJlYWx0aW1lXG4gICAgICogdHJhbnNwb3J0LCBvciB3aXRoIHRpbWVvdXRzIHBhc3NlZCBpbiAoZm9yIHdoZW4gdXNlZCBieSBhIHJlc3QgY2xpZW50KSxcbiAgICAgKiBvciBjb21wbGV0ZWx5IHN0YW5kYWxvbmUuICBVc2UgdGhlIGFwcHJvcHJpYXRlIHRpbWVvdXRzIGluIGVhY2ggY2FzZSAqL1xuICAgIHRpbWVvdXRzID0gdGltZW91dHMgfHwgZGVmYXVsdHNfMS5kZWZhdWx0LlRJTUVPVVRTO1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh1bmRlZmluZWQsIHVyaSwgaGVhZGVycywgVXRpbHMuY29weShwYXJhbXMpLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCk7XG59XG5leHBvcnRzLmNyZWF0ZVJlcXVlc3QgPSBjcmVhdGVSZXF1ZXN0O1xudmFyIEpTT05QVHJhbnNwb3J0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEpTT05QVHJhbnNwb3J0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEpTT05QVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lO1xuICAgICAgICBwYXJhbXMuc3RyZWFtID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSlNPTlBUcmFuc3BvcnQuaXNBdmFpbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmpzb25wU3VwcG9ydGVkICYmIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuYWxsb3dDb21ldDtcbiAgICB9O1xuICAgIEpTT05QVHJhbnNwb3J0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdKU09OUFRyYW5zcG9ydDsgdXJpPScgKyB0aGlzLmJhc2VVcmkgKyAnOyBpc0Nvbm5lY3RlZD0nICsgdGhpcy5pc0Nvbm5lY3RlZDtcbiAgICB9O1xuICAgIEpTT05QVHJhbnNwb3J0LnByb3RvdHlwZS5jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCkge1xuICAgICAgICAvKiBKU09OUCByZXF1ZXN0cyBhcmUgdXNlZCBlaXRoZXIgd2l0aCB0aGUgY29udGV4dCBiZWluZyBhIHJlYWx0aW1lXG4gICAgICAgICAqIHRyYW5zcG9ydCwgb3Igd2l0aCB0aW1lb3V0cyBwYXNzZWQgaW4gKGZvciB3aGVuIHVzZWQgYnkgYSByZXN0IGNsaWVudCksXG4gICAgICAgICAqIG9yIGNvbXBsZXRlbHkgc3RhbmRhbG9uZS4gIFVzZSB0aGUgYXBwcm9wcmlhdGUgdGltZW91dHMgaW4gZWFjaCBjYXNlICovXG4gICAgICAgIHRpbWVvdXRzID0gKHRoaXMgPT09IG51bGwgfHwgdGhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhpcy50aW1lb3V0cykgfHwgdGltZW91dHMgfHwgZGVmYXVsdHNfMS5kZWZhdWx0LlRJTUVPVVRTO1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBtZXRob2QpO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05QVHJhbnNwb3J0O1xufShjb21ldHRyYW5zcG9ydF8xLmRlZmF1bHQpKTtcbnZhciBSZXF1ZXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJlcXVlc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVxdWVzdChpZCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbWV0aG9kKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgaWQgPSBpZENvdW50ZXIrKztcbiAgICAgICAgX3RoaXMuaWQgPSBpZDtcbiAgICAgICAgX3RoaXMudXJpID0gdXJpO1xuICAgICAgICBfdGhpcy5wYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgIF90aGlzLnBhcmFtcy5ybmQgPSBVdGlscy5jaGVhcFJhbmRTdHIoKTtcbiAgICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgICAgIC8qIEpTT05QIGRvZXNuJ3QgYWxsb3cgaGVhZGVycy4gQ2hlcnJ5LXBpY2sgYSBjb3VwbGUgdG8gdHVybiBpbnRvIHFzIHBhcmFtcyAqL1xuICAgICAgICAgICAgaWYgKGhlYWRlcnNbJ1gtQWJseS1WZXJzaW9uJ10pXG4gICAgICAgICAgICAgICAgX3RoaXMucGFyYW1zLnYgPSBoZWFkZXJzWydYLUFibHktVmVyc2lvbiddO1xuICAgICAgICAgICAgaWYgKGhlYWRlcnNbJ1gtQWJseS1MaWInXSlcbiAgICAgICAgICAgICAgICBfdGhpcy5wYXJhbXMubGliID0gaGVhZGVyc1snWC1BYmx5LUxpYiddO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICBfdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIF90aGlzLnJlcXVlc3RNb2RlID0gcmVxdWVzdE1vZGU7XG4gICAgICAgIF90aGlzLnRpbWVvdXRzID0gdGltZW91dHM7XG4gICAgICAgIF90aGlzLnJlcXVlc3RDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlcXVlc3QucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuaWQsIGJvZHkgPSB0aGlzLmJvZHksIG1ldGhvZCA9IHRoaXMubWV0aG9kLCB1cmkgPSB0aGlzLnVyaSwgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgICAgIHBhcmFtcy5jYWxsYmFjayA9ICdfYWJseWpzX2pzb25wLl8oJyArIGlkICsgJyknO1xuICAgICAgICBwYXJhbXMuZW52ZWxvcGUgPSAnanNvbnAnO1xuICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgcGFyYW1zLmJvZHkgPSBib2R5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgJiYgbWV0aG9kICE9PSAnZ2V0Jykge1xuICAgICAgICAgICAgcGFyYW1zLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NyaXB0ID0gKHRoaXMuc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpO1xuICAgICAgICB2YXIgc3JjID0gdXJpICsgVXRpbHMudG9RdWVyeVN0cmluZyhwYXJhbXMpO1xuICAgICAgICBzY3JpcHQuc3JjID0gc3JjO1xuICAgICAgICBpZiAoc2NyaXB0LnNyYy5zcGxpdCgnLycpLnNsaWNlKC0xKVswXSAhPT0gc3JjLnNwbGl0KCcvJykuc2xpY2UoLTEpWzBdKSB7XG4gICAgICAgICAgICAvKiBUaGUgc3JjIGhhcyBiZWVuIHRydW5jYXRlZC4gQ2FuJ3QgYWJvcnQsIGJ1dCBjYW4gYXQgbGVhc3QgZW1pdCBhblxuICAgICAgICAgICAgICogZXJyb3Igc28gdGhlIHVzZXIga25vd3Mgd2hhdCdzIGdvbmUgd3JvbmcuIChDYW4ndCBjb21wYXJlIHN0cmluZ3NcbiAgICAgICAgICAgICAqIGRpcmVjdGx5IGFzIHNyYyBtYXkgaGF2ZSBhIHBvcnQsIHNjcmlwdC5zcmMgd29uJ3QpICovXG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0pTT05QIFJlcXVlc3QuZXhlYygpJywgJ1dhcm5pbmc6IHRoZSBicm93c2VyIGFwcGVhcnMgdG8gaGF2ZSB0cnVuY2F0ZWQgdGhlIHNjcmlwdCBVUkkuIFRoaXMgd2lsbCBsaWtlbHkgcmVzdWx0IGluIHRoZSByZXF1ZXN0IGZhaWxpbmcgZHVlIHRvIGFuIHVucGFyc2VhYmxlIGJvZHkgcGFyYW0nKTtcbiAgICAgICAgfVxuICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICBzY3JpcHQuY2hhcnNldCA9ICdVVEYtOCc7XG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgX3RoaXMuY29tcGxldGUobmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ0pTT05QIHNjcmlwdCBlcnJvciAoZXZlbnQ6ICcgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QoZXJyKSArICcpJywgbnVsbCwgNDAwKSk7XG4gICAgICAgIH07XG4gICAgICAgIF9bJ18nICsgaWRdID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgICAgICAvKiBIYW5kbGUgYXMgZW52ZWxvcGVkIGpzb25wLCBhcyBhbGwganNvbnAgdHJhbnNwb3J0IHVzZXMgc2hvdWxkIGJlICovXG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gbWVzc2FnZS5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5zdGF0dXNDb2RlID09IDIwNCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wbGV0ZShudWxsLCBudWxsLCBudWxsLCBtZXNzYWdlLnN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcGxldGUobmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ0ludmFsaWQgc2VydmVyIHJlc3BvbnNlOiBubyBlbnZlbG9wZSBkZXRlY3RlZCcsIG51bGwsIDUwMCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlLnN0YXR1c0NvZGUgPCA0MDAgfHwgVXRpbHMuaXNBcnJheShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogSWYgcmVzcG9uc2UgaXMgYW4gYXJyYXksIGl0J3MgYW4gYXJyYXkgb2YgcHJvdG9jb2wgbWVzc2FnZXMgLS0gZXZlbiBpZlxuICAgICAgICAgICAgICAgICAgICAgKiBpdCBjb250YWlucyBhbiBlcnJvciBhY3Rpb24gKGhlbmNlIHRoZSBub25zdWNjZXNzIHN0YXR1c2NvZGUpLCB3ZSBjYW5cbiAgICAgICAgICAgICAgICAgICAgICogY29uc2lkZXIgdGhlIHJlcXVlc3QgdG8gaGF2ZSBzdWNjZWVkZWQsIGp1c3QgcGFzcyBpdCBvbiB0b1xuICAgICAgICAgICAgICAgICAgICAgKiBvblByb3RvY29sTWVzc2FnZSB0byBkZWNpZGUgd2hhdCB0byBkbyAqL1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wbGV0ZShudWxsLCByZXNwb25zZSwgbWVzc2FnZS5oZWFkZXJzLCBtZXNzYWdlLnN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IHJlc3BvbnNlLmVycm9yIHx8IG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdFcnJvciByZXNwb25zZSByZWNlaXZlZCBmcm9tIHNlcnZlcicsIG51bGwsIG1lc3NhZ2Uuc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogSGFuZGxlIGFzIG5vbi1lbnZlbG9wZWQgLS0gYXMgd2lsbCBiZSBlZyBmcm9tIGEgY3VzdG9tZXIncyBhdXRoVXJsIHNlcnZlciAqL1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKG51bGwsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGltZW91dCA9IHRoaXMucmVxdWVzdE1vZGUgPT0gWEhSU3RhdGVzXzEuZGVmYXVsdC5SRVFfU0VORCA/IHRoaXMudGltZW91dHMuaHR0cFJlcXVlc3RUaW1lb3V0IDogdGhpcy50aW1lb3V0cy5yZWN2VGltZW91dDtcbiAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQodGhpcy5hYm9ydC5iaW5kKHRoaXMpLCB0aW1lb3V0KTtcbiAgICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgICAgICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgfTtcbiAgICBSZXF1ZXN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uIChlcnIsIGJvZHksIGhlYWRlcnMsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgaGVhZGVycyA9IGhlYWRlcnMgfHwge307XG4gICAgICAgIGlmICghdGhpcy5yZXF1ZXN0Q29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdENvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGUgPSB0eXBlb2YgYm9keSA9PSAnc3RyaW5nJyA/ICd0ZXh0L3BsYWluJyA6ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IGNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdjb21wbGV0ZScsIGVyciwgYm9keSwgaGVhZGVycywgLyogdW5wYWNrZWQ6ICovIHRydWUsIHN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIFJlcXVlc3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aW1lciA9IHRoaXMudGltZXI7XG4gICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdDtcbiAgICAgICAgaWYgKHNjcmlwdC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgZGVsZXRlIF9bdGhpcy5pZF07XG4gICAgICAgIHRoaXMuZW1pdCgnZGlzcG9zZWQnKTtcbiAgICB9O1xuICAgIHJldHVybiBSZXF1ZXN0O1xufShldmVudGVtaXR0ZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuZnVuY3Rpb24gZGVmYXVsdF8xKGNvbm5lY3Rpb25NYW5hZ2VyKSB7XG4gICAgZ2xvYmFsT2JqZWN0LkpTT05QVHJhbnNwb3J0ID0gSlNPTlBUcmFuc3BvcnQ7XG4gICAgaWYgKEpTT05QVHJhbnNwb3J0LmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0c1tzaG9ydE5hbWVdID0gSlNPTlBUcmFuc3BvcnQ7XG4gICAgfVxuICAgIHJldHVybiBKU09OUFRyYW5zcG9ydDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmF1bHRfMTtcblxuXG4vKioqLyB9KSxcbi8qIDMwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIGRlZmF1bHRzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKTtcbnZhciBhdXRoXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSk7XG52YXIgcHVzaF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0NikpO1xudmFyIHBhZ2luYXRlZHJlc291cmNlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KSk7XG52YXIgY2hhbm5lbF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzMykpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgc3RhdHNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNDkpKTtcbnZhciBIdHRwTWV0aG9kc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxOCkpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciBtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDkpKTtcbnZhciBwcmVzZW5jZW1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTUpKTtcbnZhciByZXNvdXJjZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNCkpO1xudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG52YXIgUmVzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXN0KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ25vIG9wdGlvbnMgcHJvdmlkZWQnO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdSZXN0KCknLCBtc2cpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnNPYmogPSBkZWZhdWx0c18xLmRlZmF1bHQub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnNPYmoubG9nKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LnNldExvZyhvcHRpb25zT2JqLmxvZy5sZXZlbCwgb3B0aW9uc09iai5sb2cuaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZXN0KCknLCAnaW5pdGlhbGl6ZWQgd2l0aCBjbGllbnRPcHRpb25zICcgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3Qob3B0aW9ucykpO1xuICAgICAgICB2YXIgbm9ybWFsT3B0aW9ucyA9ICh0aGlzLm9wdGlvbnMgPSBkZWZhdWx0c18xLmRlZmF1bHQubm9ybWFsaXNlT3B0aW9ucyhvcHRpb25zT2JqKSk7XG4gICAgICAgIC8qIHByb2Nlc3Mgb3B0aW9ucyAqL1xuICAgICAgICBpZiAobm9ybWFsT3B0aW9ucy5rZXkpIHtcbiAgICAgICAgICAgIHZhciBrZXlNYXRjaCA9IG5vcm1hbE9wdGlvbnMua2V5Lm1hdGNoKC9eKFteOlxcc10rKTooW146Llxcc10rKSQvKTtcbiAgICAgICAgICAgIGlmICgha2V5TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ2ludmFsaWQga2V5IHBhcmFtZXRlcic7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdSZXN0KCknLCBtc2cpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgNDA0MDAsIDQwNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3JtYWxPcHRpb25zLmtleU5hbWUgPSBrZXlNYXRjaFsxXTtcbiAgICAgICAgICAgIG5vcm1hbE9wdGlvbnMua2V5U2VjcmV0ID0ga2V5TWF0Y2hbMl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdjbGllbnRJZCcgaW4gbm9ybWFsT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCEodHlwZW9mIG5vcm1hbE9wdGlvbnMuY2xpZW50SWQgPT09ICdzdHJpbmcnIHx8IG5vcm1hbE9wdGlvbnMuY2xpZW50SWQgPT09IG51bGwpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdjbGllbnRJZCBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBudWxsJywgNDAwMTIsIDQwMCk7XG4gICAgICAgICAgICBlbHNlIGlmIChub3JtYWxPcHRpb25zLmNsaWVudElkID09PSAnKicpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0NhbuKAmXQgdXNlIFwiKlwiIGFzIGEgY2xpZW50SWQgYXMgdGhhdCBzdHJpbmcgaXMgcmVzZXJ2ZWQuIChUbyBjaGFuZ2UgdGhlIGRlZmF1bHQgdG9rZW4gcmVxdWVzdCBiZWhhdmlvdXIgdG8gdXNlIGEgd2lsZGNhcmQgY2xpZW50SWQsIHVzZSB7ZGVmYXVsdFRva2VuUGFyYW1zOiB7Y2xpZW50SWQ6IFwiKlwifX0pJywgNDAwMTIsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdSZXN0KCknLCAnc3RhcnRlZDsgdmVyc2lvbiA9ICcgKyBkZWZhdWx0c18xLmRlZmF1bHQudmVyc2lvbik7XG4gICAgICAgIHRoaXMuYmFzZVVyaSA9IHRoaXMuYXV0aG9yaXR5ID0gZnVuY3Rpb24gKGhvc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0c18xLmRlZmF1bHQuZ2V0SHR0cFNjaGVtZShub3JtYWxPcHRpb25zKSArIGhvc3QgKyAnOicgKyBkZWZhdWx0c18xLmRlZmF1bHQuZ2V0UG9ydChub3JtYWxPcHRpb25zLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2N1cnJlbnRGYWxsYmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VydmVyVGltZU9mZnNldCA9IG51bGw7XG4gICAgICAgIHRoaXMuaHR0cCA9IG5ldyBwbGF0Zm9ybV8xLmRlZmF1bHQuSHR0cChub3JtYWxPcHRpb25zKTtcbiAgICAgICAgdGhpcy5hdXRoID0gbmV3IGF1dGhfMS5kZWZhdWx0KHRoaXMsIG5vcm1hbE9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gbmV3IENoYW5uZWxzKHRoaXMpO1xuICAgICAgICB0aGlzLnB1c2ggPSBuZXcgcHVzaF8xLmRlZmF1bHQodGhpcyk7XG4gICAgfVxuICAgIFJlc3QucHJvdG90eXBlLnN0YXRzID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgLyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXG4gICAgICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnc3RhdHMnLCBbcGFyYW1zXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzKHRoaXMub3B0aW9ucyksIGZvcm1hdCA9IHRoaXMub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGVudmVsb3BlID0gdGhpcy5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQ7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHRoaXMub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgbmV3IHBhZ2luYXRlZHJlc291cmNlXzEuZGVmYXVsdCh0aGlzLCAnL3N0YXRzJywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uIChib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgdmFyIHN0YXRzVmFsdWVzID0gdW5wYWNrZWQgPyBib2R5IDogSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdHNWYWx1ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgc3RhdHNWYWx1ZXNbaV0gPSBzdGF0c18xLmRlZmF1bHQuZnJvbVZhbHVlcyhzdGF0c1ZhbHVlc1tpXSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdHNWYWx1ZXM7XG4gICAgICAgIH0pLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlc3QucHJvdG90eXBlLnRpbWUgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICd0aW1lJywgW3BhcmFtc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgX2NhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0R2V0SGVhZGVycyh0aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCB0aGlzLm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIHZhciB0aW1lVXJpID0gZnVuY3Rpb24gKGhvc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5hdXRob3JpdHkoaG9zdCkgKyAnL3RpbWUnO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmh0dHAuZG8oSHR0cE1ldGhvZHNfMS5kZWZhdWx0LkdldCwgdGhpcywgdGltZVVyaSwgaGVhZGVycywgbnVsbCwgcGFyYW1zLCBmdW5jdGlvbiAoZXJyLCByZXMsIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2NhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF1bnBhY2tlZClcbiAgICAgICAgICAgICAgICByZXMgPSBKU09OLnBhcnNlKHJlcyk7XG4gICAgICAgICAgICB2YXIgdGltZSA9IHJlc1swXTtcbiAgICAgICAgICAgIGlmICghdGltZSkge1xuICAgICAgICAgICAgICAgIF9jYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnSW50ZXJuYWwgZXJyb3IgKHVuZXhwZWN0ZWQgcmVzdWx0IHR5cGUgZnJvbSBHRVQgL3RpbWUpJywgNTAwMDAsIDUwMCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGNhbGN1bGF0ZSB0aW1lIG9mZnNldCBvbmx5IG9uY2UgZm9yIHRoaXMgZGV2aWNlIGJ5IGFkZGluZyB0byB0aGUgcHJvdG90eXBlICovXG4gICAgICAgICAgICBfdGhpcy5zZXJ2ZXJUaW1lT2Zmc2V0ID0gdGltZSAtIFV0aWxzLm5vdygpO1xuICAgICAgICAgICAgX2NhbGxiYWNrKG51bGwsIHRpbWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlc3QucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXRoLCBwYXJhbXMsIGJvZHksIGN1c3RvbUhlYWRlcnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB1c2VCaW5hcnkgPSB0aGlzLm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wsIGVuY29kZXIgPSB1c2VCaW5hcnkgPyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm1zZ3BhY2suZW5jb2RlIDogSlNPTi5zdHJpbmdpZnksIGRlY29kZXIgPSB1c2VCaW5hcnkgPyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm1zZ3BhY2suZGVjb2RlIDogSlNPTi5wYXJzZSwgZm9ybWF0ID0gdXNlQmluYXJ5ID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgZW52ZWxvcGUgPSB0aGlzLmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICB2YXIgX21ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgaGVhZGVycyA9IF9tZXRob2QgPT0gJ2dldCcgPyBVdGlscy5kZWZhdWx0R2V0SGVhZGVycyh0aGlzLm9wdGlvbnMsIGZvcm1hdCkgOiBVdGlscy5kZWZhdWx0UG9zdEhlYWRlcnModGhpcy5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3JlcXVlc3QnLCBbbWV0aG9kLCBwYXRoLCBwYXJhbXMsIGJvZHksIGN1c3RvbUhlYWRlcnNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGJvZHkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gZW5jb2Rlcihib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHRoaXMub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VzdG9tSGVhZGVycykge1xuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgY3VzdG9tSGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhZ2luYXRlZFJlc291cmNlID0gbmV3IHBhZ2luYXRlZHJlc291cmNlXzEuZGVmYXVsdCh0aGlzLCBwYXRoLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24gKHJlc2JvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuZW5zdXJlQXJyYXkodW5wYWNrZWQgPyByZXNib2R5IDogZGVjb2RlcihyZXNib2R5KSk7XG4gICAgICAgIH0sIFxuICAgICAgICAvKiB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2U6ICovIHRydWUpO1xuICAgICAgICBpZiAoIVV0aWxzLmFyckluKHBsYXRmb3JtXzEuZGVmYXVsdC5IdHRwLm1ldGhvZHMsIF9tZXRob2QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVW5zdXBwb3J0ZWQgbWV0aG9kICcgKyBfbWV0aG9kLCA0MDUwMCwgNDA1KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVXRpbHMuYXJySW4ocGxhdGZvcm1fMS5kZWZhdWx0Lkh0dHAubWV0aG9kc1dpdGhCb2R5LCBfbWV0aG9kKSkge1xuICAgICAgICAgICAgcGFnaW5hdGVkUmVzb3VyY2VbX21ldGhvZF0ocGFyYW1zLCBib2R5LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYWdpbmF0ZWRSZXNvdXJjZVtfbWV0aG9kXShwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVzdC5wcm90b3R5cGUuYmF0Y2hQdWJsaXNoID0gZnVuY3Rpb24gKHNwZWNPclNwZWNzLCBjYWxsYmFja0FyZykge1xuICAgICAgICBpZiAoY2FsbGJhY2tBcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2JhdGNoUHVibGlzaCcsIFtzcGVjT3JTcGVjc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2tBcmcgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrQXJnO1xuICAgICAgICB2YXIgcmVxdWVzdEJvZHlEVE87XG4gICAgICAgIHZhciBzaW5nbGVTcGVjTW9kZTtcbiAgICAgICAgaWYgKFV0aWxzLmlzQXJyYXkoc3BlY09yU3BlY3MpKSB7XG4gICAgICAgICAgICByZXF1ZXN0Qm9keURUTyA9IHNwZWNPclNwZWNzO1xuICAgICAgICAgICAgc2luZ2xlU3BlY01vZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RCb2R5RFRPID0gW3NwZWNPclNwZWNzXTtcbiAgICAgICAgICAgIHNpbmdsZVNwZWNNb2RlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLm9wdGlvbnMsIGZvcm1hdCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHRoaXMub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgdmFyIHJlcXVlc3RCb2R5ID0gVXRpbHMuZW5jb2RlQm9keShyZXF1ZXN0Qm9keURUTywgZm9ybWF0KTtcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LnBvc3QodGhpcywgJy9tZXNzYWdlcycsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCB7IG5ld0JhdGNoUmVzcG9uc2U6ICd0cnVlJyB9LCBudWxsLCBmdW5jdGlvbiAoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgdHlwZSBhc3NlcnRpb24gYWZ0ZXIgZml4aW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5L2FibHktanMvaXNzdWVzLzE0MDVcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiYXRjaFJlc3VsdHMgPSAodW5wYWNrZWQgPyBib2R5IDogVXRpbHMuZGVjb2RlQm9keShib2R5LCBmb3JtYXQpKTtcbiAgICAgICAgICAgIC8vIEkgZG9uJ3QgbG92ZSB0aGUgYmVsb3cgdHlwZSBhc3NlcnRpb25zIGZvciBgY2FsbGJhY2tgIGJ1dCBub3Qgc3VyZSBob3cgdG8gYXZvaWQgdGhlbVxuICAgICAgICAgICAgaWYgKHNpbmdsZVNwZWNNb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYmF0Y2hSZXN1bHRzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGJhdGNoUmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVzdC5wcm90b3R5cGUuYmF0Y2hQcmVzZW5jZSA9IGZ1bmN0aW9uIChjaGFubmVscywgY2FsbGJhY2tBcmcpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrQXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdiYXRjaFByZXNlbmNlJywgW2NoYW5uZWxzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFja0FyZyA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tBcmc7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdFBvc3RIZWFkZXJzKHRoaXMub3B0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgdGhpcy5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICB2YXIgY2hhbm5lbHNQYXJhbSA9IGNoYW5uZWxzLmpvaW4oJywnKTtcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LmdldCh0aGlzLCAnL3ByZXNlbmNlJywgaGVhZGVycywgeyBuZXdCYXRjaFJlc3BvbnNlOiAndHJ1ZScsIGNoYW5uZWxzOiBjaGFubmVsc1BhcmFtIH0sIG51bGwsIGZ1bmN0aW9uIChlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyByZW1vdmUgdGhpcyB0eXBlIGFzc2VydGlvbiBhZnRlciBmaXhpbmcgaHR0cHM6Ly9naXRodWIuY29tL2FibHkvYWJseS1qcy9pc3N1ZXMvMTQwNVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJhdGNoUmVzdWx0ID0gKHVucGFja2VkID8gYm9keSA6IFV0aWxzLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KSk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBiYXRjaFJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVzdC5wcm90b3R5cGUuc2V0TG9nID0gZnVuY3Rpb24gKGxvZ09wdGlvbnMpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5zZXRMb2cobG9nT3B0aW9ucy5sZXZlbCwgbG9nT3B0aW9ucy5oYW5kbGVyKTtcbiAgICB9O1xuICAgIFJlc3QuUHJvbWlzZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0c18xLmRlZmF1bHQub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5wcm9taXNlcyA9IHRydWU7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlc3QuQ2FsbGJhY2tzID0gUmVzdDtcbiAgICBSZXN0LlBsYXRmb3JtID0gcGxhdGZvcm1fMS5kZWZhdWx0O1xuICAgIFJlc3QuTWVzc2FnZSA9IG1lc3NhZ2VfMS5kZWZhdWx0O1xuICAgIFJlc3QuUHJlc2VuY2VNZXNzYWdlID0gcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdDtcbiAgICByZXR1cm4gUmVzdDtcbn0oKSk7XG52YXIgQ2hhbm5lbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhbm5lbHMocmVzdCkge1xuICAgICAgICB0aGlzLnJlc3QgPSByZXN0O1xuICAgICAgICB0aGlzLmFsbCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIENoYW5uZWxzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcbiAgICAgICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICAgICAgICB0aGlzLmFsbFtuYW1lXSA9IGNoYW5uZWwgPSBuZXcgY2hhbm5lbF8xLmRlZmF1bHQodGhpcy5yZXN0LCBuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNoYW5uZWwuc2V0T3B0aW9ucyhjaGFubmVsT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgfTtcbiAgICAvKiBJbmNsdWRlZCB0byBzdXBwb3J0IGNlcnRhaW4gbmljaGUgdXNlLWNhc2VzOyBtb3N0IHVzZXJzIHNob3VsZCBpZ25vcmUgdGhpcy5cbiAgICAgKiBQbGVhc2UgZG8gbm90IHVzZSB0aGlzIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZyAqL1xuICAgIENoYW5uZWxzLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYWxsW1N0cmluZyhuYW1lKV07XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhbm5lbHM7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUmVzdDtcblxuXG4vKioqLyB9KSxcbi8qIDMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLlV0Zjg7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uIChNYXRoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gSW5pdGlhbGl6YXRpb24gYW5kIHJvdW5kIGNvbnN0YW50cyB0YWJsZXNcblx0ICAgIHZhciBIID0gW107XG5cdCAgICB2YXIgSyA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIGNvbnN0YW50c1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBpc1ByaW1lKG4pIHtcblx0ICAgICAgICAgICAgdmFyIHNxcnROID0gTWF0aC5zcXJ0KG4pO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBmYWN0b3IgPSAyOyBmYWN0b3IgPD0gc3FydE47IGZhY3RvcisrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIShuICUgZmFjdG9yKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEZyYWN0aW9uYWxCaXRzKG4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuICgobiAtIChuIHwgMCkpICogMHgxMDAwMDAwMDApIHwgMDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgbiA9IDI7XG5cdCAgICAgICAgdmFyIG5QcmltZSA9IDA7XG5cdCAgICAgICAgd2hpbGUgKG5QcmltZSA8IDY0KSB7XG5cdCAgICAgICAgICAgIGlmIChpc1ByaW1lKG4pKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoblByaW1lIDwgOCkge1xuXHQgICAgICAgICAgICAgICAgICAgIEhbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sIDEgLyAyKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBLW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLCAxIC8gMykpO1xuXG5cdCAgICAgICAgICAgICAgICBuUHJpbWUrKztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIG4rKztcblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3Rcblx0ICAgIHZhciBXID0gW107XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTI1NiBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTI1NiA9IENfYWxnby5TSEEyNTYgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KEguc2xpY2UoMCkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblx0ICAgICAgICAgICAgdmFyIGUgPSBIWzRdO1xuXHQgICAgICAgICAgICB2YXIgZiA9IEhbNV07XG5cdCAgICAgICAgICAgIHZhciBnID0gSFs2XTtcblx0ICAgICAgICAgICAgdmFyIGggPSBIWzddO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMHggPSBXW2kgLSAxNV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMCAgPSAoKGdhbW1hMHggPDwgMjUpIHwgKGdhbW1hMHggPj4+IDcpKSAgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChnYW1tYTB4IDw8IDE0KSB8IChnYW1tYTB4ID4+PiAxOCkpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZ2FtbWEweCA+Pj4gMyk7XG5cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExeCA9IFdbaSAtIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTEgID0gKChnYW1tYTF4IDw8IDE1KSB8IChnYW1tYTF4ID4+PiAxNykpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZ2FtbWExeCA8PCAxMykgfCAoZ2FtbWExeCA+Pj4gMTkpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdhbW1hMXggPj4+IDEwKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdmFyIGNoICA9IChlICYgZikgXiAofmUgJiBnKTtcblx0ICAgICAgICAgICAgICAgIHZhciBtYWogPSAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTAgPSAoKGEgPDwgMzApIHwgKGEgPj4+IDIpKSBeICgoYSA8PCAxOSkgfCAoYSA+Pj4gMTMpKSBeICgoYSA8PCAxMCkgfCAoYSA+Pj4gMjIpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTEgPSAoKGUgPDwgMjYpIHwgKGUgPj4+IDYpKSBeICgoZSA8PCAyMSkgfCAoZSA+Pj4gMTEpKSBeICgoZSA8PCA3KSAgfCAoZSA+Pj4gMjUpKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tpXSArIFdbaV07XG5cdCAgICAgICAgICAgICAgICB2YXIgdDIgPSBzaWdtYTAgKyBtYWo7XG5cblx0ICAgICAgICAgICAgICAgIGggPSBnO1xuXHQgICAgICAgICAgICAgICAgZyA9IGY7XG5cdCAgICAgICAgICAgICAgICBmID0gZTtcblx0ICAgICAgICAgICAgICAgIGUgPSAoZCArIHQxKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBkID0gYztcblx0ICAgICAgICAgICAgICAgIGMgPSBiO1xuXHQgICAgICAgICAgICAgICAgYiA9IGE7XG5cdCAgICAgICAgICAgICAgICBhID0gKHQxICsgdDIpIHwgMDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICAgICAgSFs0XSA9IChIWzRdICsgZSkgfCAwO1xuXHQgICAgICAgICAgICBIWzVdID0gKEhbNV0gKyBmKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNl0gPSAoSFs2XSArIGcpIHwgMDtcblx0ICAgICAgICAgICAgSFs3XSA9IChIWzddICsgaCkgfCAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTI1Nih3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTI1NiA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTI1Nik7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMjU2KG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTI1NiA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEEyNTYpO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEEyNTY7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgZXZlbnRlbWl0dGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIHByZXNlbmNlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KSk7XG52YXIgbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg5KSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBwYWdpbmF0ZWRyZXNvdXJjZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxOSkpO1xudmFyIHJlc291cmNlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxudmFyIE1TR19JRF9FTlRST1BZX0JZVEVTID0gOTtcbmZ1bmN0aW9uIGFsbEVtcHR5SWRzKG1lc3NhZ2VzKSB7XG4gICAgcmV0dXJuIFV0aWxzLmFyckV2ZXJ5KG1lc3NhZ2VzLCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gIW1lc3NhZ2UuaWQ7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpc2VDaGFubmVsT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIGNoYW5uZWxPcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoY2hhbm5lbE9wdGlvbnMuY2lwaGVyKSB7XG4gICAgICAgIGlmICghcGxhdGZvcm1fMS5kZWZhdWx0LkNyeXB0bylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiBub3QgZW5hYmxlZDsgdXNlIGFibHkuZW5jcnlwdGlvbi5qcyBpbnN0ZWFkJyk7XG4gICAgICAgIHZhciBjaXBoZXIgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQ3J5cHRvLmdldENpcGhlcihjaGFubmVsT3B0aW9ucy5jaXBoZXIpO1xuICAgICAgICBjaGFubmVsT3B0aW9ucy5jaXBoZXIgPSBjaXBoZXIuY2lwaGVyUGFyYW1zO1xuICAgICAgICBjaGFubmVsT3B0aW9ucy5jaGFubmVsQ2lwaGVyID0gY2lwaGVyLmNpcGhlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2NpcGhlcicgaW4gY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgLyogRG9uJ3QgZGVhY3RpdmF0ZSBhbiBleGlzdGluZyBjaXBoZXIgdW5sZXNzIG9wdGlvbnNcbiAgICAgICAgICogaGFzIGEgJ2NpcGhlcicga2V5IHRoYXQncyBmYWxzZXkgKi9cbiAgICAgICAgY2hhbm5lbE9wdGlvbnMuY2lwaGVyID0gdW5kZWZpbmVkO1xuICAgICAgICBjaGFubmVsT3B0aW9ucy5jaGFubmVsQ2lwaGVyID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWxPcHRpb25zO1xufVxudmFyIENoYW5uZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ2hhbm5lbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDaGFubmVsKHJlc3QsIG5hbWUsIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ2hhbm5lbCgpJywgJ3N0YXJ0ZWQ7IG5hbWUgPSAnICsgbmFtZSk7XG4gICAgICAgIF90aGlzLnJlc3QgPSByZXN0O1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMuYmFzZVBhdGggPSAnL2NoYW5uZWxzLycgKyBlbmNvZGVVUklDb21wb25lbnQobmFtZSk7XG4gICAgICAgIF90aGlzLnByZXNlbmNlID0gbmV3IHByZXNlbmNlXzEuZGVmYXVsdChfdGhpcyk7XG4gICAgICAgIF90aGlzLmNoYW5uZWxPcHRpb25zID0gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMoY2hhbm5lbE9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENoYW5uZWwucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmNoYW5uZWxPcHRpb25zID0gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfTtcbiAgICBDaGFubmVsLnByb3RvdHlwZS5oaXN0b3J5ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDaGFubmVsLmhpc3RvcnkoKScsICdjaGFubmVsID0gJyArIHRoaXMubmFtZSk7XG4gICAgICAgIC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xuICAgICAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnaGlzdG9yeScsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oaXN0b3J5KHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgQ2hhbm5lbC5wcm90b3R5cGUuX2hpc3RvcnkgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucmVzdCwgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgZW52ZWxvcGUgPSB0aGlzLnJlc3QuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0LCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdEdldEhlYWRlcnMocmVzdC5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICBpZiAocmVzdC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcbiAgICAgICAgbmV3IHBhZ2luYXRlZHJlc291cmNlXzEuZGVmYXVsdChyZXN0LCB0aGlzLmJhc2VQYXRoICsgJy9tZXNzYWdlcycsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbiAoYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlXzEuZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIG9wdGlvbnMsIHVucGFja2VkID8gdW5kZWZpbmVkIDogZm9ybWF0KTtcbiAgICAgICAgfSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgQ2hhbm5lbC5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCwgZmlyc3QgPSBhcmd1bWVudHNbMF0sIHNlY29uZCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ0NvdW50IC0gMV07XG4gICAgICAgIHZhciBtZXNzYWdlcztcbiAgICAgICAgdmFyIHBhcmFtcztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAncHVibGlzaCcsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gJ3N0cmluZycgfHwgZmlyc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8qIChuYW1lLCBkYXRhLCAuLi4pICovXG4gICAgICAgICAgICBtZXNzYWdlcyA9IFttZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHsgbmFtZTogZmlyc3QsIGRhdGE6IHNlY29uZCB9KV07XG4gICAgICAgICAgICBwYXJhbXMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVXRpbHMuaXNPYmplY3QoZmlyc3QpKSB7XG4gICAgICAgICAgICBtZXNzYWdlcyA9IFttZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKGZpcnN0KV07XG4gICAgICAgICAgICBwYXJhbXMgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVXRpbHMuaXNBcnJheShmaXJzdCkpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzID0gbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlc0FycmF5KGZpcnN0KTtcbiAgICAgICAgICAgIHBhcmFtcyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdUaGUgc2luZ2xlLWFyZ3VtZW50IGZvcm0gb2YgcHVibGlzaCgpIGV4cGVjdHMgYSBtZXNzYWdlIG9iamVjdCBvciBhbiBhcnJheSBvZiBtZXNzYWdlIG9iamVjdHMnLCA0MDAxMywgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyAhPT0gJ29iamVjdCcgfHwgIXBhcmFtcykge1xuICAgICAgICAgICAgLyogTm8gcGFyYW1zIHN1cHBsaWVkIChzbyBhZnRlci1tZXNzYWdlIGFyZ3VtZW50IGlzIGp1c3QgdGhlIGNhbGxiYWNrIG9yIHVuZGVmaW5lZCkgKi9cbiAgICAgICAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5yZXN0LCBvcHRpb25zID0gcmVzdC5vcHRpb25zLCBmb3JtYXQgPSBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nID0gcmVzdC5vcHRpb25zLmlkZW1wb3RlbnRSZXN0UHVibGlzaGluZywgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRQb3N0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCk7XG4gICAgICAgIGlmIChvcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBpZiAoaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nICYmIGFsbEVtcHR5SWRzKG1lc3NhZ2VzKSkge1xuICAgICAgICAgICAgdmFyIG1zZ0lkQmFzZV8xID0gVXRpbHMucmFuZG9tU3RyaW5nKE1TR19JRF9FTlRST1BZX0JZVEVTKTtcbiAgICAgICAgICAgIFV0aWxzLmFyckZvckVhY2gobWVzc2FnZXMsIGZ1bmN0aW9uIChtZXNzYWdlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWQgPSBtc2dJZEJhc2VfMSArICc6JyArIGluZGV4LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlXzEuZGVmYXVsdC5lbmNvZGVBcnJheShtZXNzYWdlcywgdGhpcy5jaGFubmVsT3B0aW9ucywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogUlNMMWkgKi9cbiAgICAgICAgICAgIHZhciBzaXplID0gbWVzc2FnZV8xLmRlZmF1bHQuZ2V0TWVzc2FnZXNTaXplKG1lc3NhZ2VzKSwgbWF4TWVzc2FnZVNpemUgPSBvcHRpb25zLm1heE1lc3NhZ2VTaXplO1xuICAgICAgICAgICAgaWYgKHNpemUgPiBtYXhNZXNzYWdlU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdNYXhpbXVtIHNpemUgb2YgbWVzc2FnZXMgdGhhdCBjYW4gYmUgcHVibGlzaGVkIGF0IG9uY2UgZXhjZWVkZWQgKCB3YXMgJyArXG4gICAgICAgICAgICAgICAgICAgIHNpemUgK1xuICAgICAgICAgICAgICAgICAgICAnIGJ5dGVzOyBsaW1pdCBpcyAnICtcbiAgICAgICAgICAgICAgICAgICAgbWF4TWVzc2FnZVNpemUgK1xuICAgICAgICAgICAgICAgICAgICAnIGJ5dGVzKScsIDQwMDA5LCA0MDApKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fcHVibGlzaChtZXNzYWdlXzEuZGVmYXVsdC5zZXJpYWxpemUobWVzc2FnZXMsIGZvcm1hdCksIGhlYWRlcnMsIHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoYW5uZWwucHJvdG90eXBlLl9wdWJsaXNoID0gZnVuY3Rpb24gKHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdC5wb3N0KHRoaXMucmVzdCwgdGhpcy5iYXNlUGF0aCArICcvbWVzc2FnZXMnLCByZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zLCBudWxsLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBDaGFubmVsLnByb3RvdHlwZS5zdGF0dXMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnc3RhdHVzJywgW10pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLnJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb247XG4gICAgICAgIHZhciBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdFBvc3RIZWFkZXJzKHRoaXMucmVzdC5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQuZ2V0KHRoaXMucmVzdCwgdGhpcy5iYXNlUGF0aCwgaGVhZGVycywge30sIGZvcm1hdCwgY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhbm5lbDtcbn0oZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhbm5lbDtcblxuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBldmVudGVtaXR0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNykpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgcGFnaW5hdGVkcmVzb3VyY2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTkpKTtcbnZhciBwcmVzZW5jZW1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTUpKTtcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbnZhciBQcmVzZW5jZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhQcmVzZW5jZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcmVzZW5jZShjaGFubmVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICBfdGhpcy5iYXNlUGF0aCA9IGNoYW5uZWwuYmFzZVBhdGggKyAnL3ByZXNlbmNlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQcmVzZW5jZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdQcmVzZW5jZS5nZXQoKScsICdjaGFubmVsID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lKTtcbiAgICAgICAgLyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXG4gICAgICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWwucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2dldCcsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdCA9IHRoaXMuY2hhbm5lbC5yZXN0LCBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBlbnZlbG9wZSA9IHRoaXMuY2hhbm5lbC5yZXN0Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzKHJlc3Qub3B0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuY2hhbm5lbC5jaGFubmVsT3B0aW9ucztcbiAgICAgICAgbmV3IHBhZ2luYXRlZHJlc291cmNlXzEuZGVmYXVsdChyZXN0LCB0aGlzLmJhc2VQYXRoLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24gKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIG9wdGlvbnMsIHVucGFja2VkID8gdW5kZWZpbmVkIDogZm9ybWF0KTtcbiAgICAgICAgfSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUHJlc2VuY2UucHJvdG90eXBlLmhpc3RvcnkgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1ByZXNlbmNlLmhpc3RvcnkoKScsICdjaGFubmVsID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpc3RvcnkocGFyYW1zLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBQcmVzZW5jZS5wcm90b3R5cGUuX2hpc3RvcnkgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICAvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbC5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnX2hpc3RvcnknLCBbcGFyYW1zXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdCA9IHRoaXMuY2hhbm5lbC5yZXN0LCBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBlbnZlbG9wZSA9IHRoaXMuY2hhbm5lbC5yZXN0Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzKHJlc3Qub3B0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuY2hhbm5lbC5jaGFubmVsT3B0aW9ucztcbiAgICAgICAgbmV3IHBhZ2luYXRlZHJlc291cmNlXzEuZGVmYXVsdChyZXN0LCB0aGlzLmJhc2VQYXRoICsgJy9oaXN0b3J5JywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uIChib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXNlbmNlbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShib2R5LCBvcHRpb25zLCB1bnBhY2tlZCA/IHVuZGVmaW5lZCA6IGZvcm1hdCk7XG4gICAgICAgIH0pLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIHJldHVybiBQcmVzZW5jZTtcbn0oZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUHJlc2VuY2U7XG5cblxuLyoqKi8gfSksXG4vKiAzNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhbnNwb3J0UGFyYW1zID0gdm9pZCAwO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHByb3RvY29sbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxMCkpO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgcHJvdG9jb2xfMSA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNTIpKTtcbnZhciBkZWZhdWx0c18xID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg4KSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIGV2ZW50ZW1pdHRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG52YXIgbWVzc2FnZXF1ZXVlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzcpKTtcbnZhciBjb25uZWN0aW9uZXJyb3JzXzEgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBhdXRoXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSk7XG52YXIgbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg5KSk7XG52YXIgbXVsdGljYXN0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjMpKTtcbnZhciB3ZWJzb2NrZXR0cmFuc3BvcnRfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNTMpKTtcbnZhciB0cmFuc3BvcnRfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjYpKTtcbnZhciBIdHRwU3RhdHVzQ29kZXNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjUpKTtcbnZhciBoYXZlV2ViU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHsgdmFyIF9hOyByZXR1cm4gdHlwZW9mIHBsYXRmb3JtXzEuZGVmYXVsdC5XZWJTdG9yYWdlICE9PSAndW5kZWZpbmVkJyAmJiAoKF9hID0gcGxhdGZvcm1fMS5kZWZhdWx0LldlYlN0b3JhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbFN1cHBvcnRlZCk7IH07XG52YXIgaGF2ZVNlc3Npb25TdG9yYWdlID0gZnVuY3Rpb24gKCkgeyB2YXIgX2E7IHJldHVybiB0eXBlb2YgcGxhdGZvcm1fMS5kZWZhdWx0LldlYlN0b3JhZ2UgIT09ICd1bmRlZmluZWQnICYmICgoX2EgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuV2ViU3RvcmFnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlc3Npb25TdXBwb3J0ZWQpOyB9O1xudmFyIGFjdGlvbnMgPSBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LkFjdGlvbjtcbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xudmFyIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lID0gJ2FibHktdHJhbnNwb3J0LXByZWZlcmVuY2UnO1xudmFyIHNlc3Npb25SZWNvdmVyeU5hbWUgPSAnYWJseS1jb25uZWN0aW9uLXJlY292ZXJ5JztcbmZ1bmN0aW9uIGdldFNlc3Npb25SZWNvdmVyRGF0YSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBoYXZlU2Vzc2lvblN0b3JhZ2UoKSAmJiAoKF9iID0gKF9hID0gcGxhdGZvcm1fMS5kZWZhdWx0LldlYlN0b3JhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTZXNzaW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgc2Vzc2lvblJlY292ZXJ5TmFtZSkpO1xufVxuZnVuY3Rpb24gc2V0U2Vzc2lvblJlY292ZXJEYXRhKHZhbHVlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgKChfYiA9IChfYSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5XZWJTdG9yYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0U2Vzc2lvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHNlc3Npb25SZWNvdmVyeU5hbWUsIHZhbHVlKSk7XG59XG5mdW5jdGlvbiBjbGVhclNlc3Npb25SZWNvdmVyRGF0YSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBoYXZlU2Vzc2lvblN0b3JhZ2UoKSAmJiAoKF9iID0gKF9hID0gcGxhdGZvcm1fMS5kZWZhdWx0LldlYlN0b3JhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVTZXNzaW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgc2Vzc2lvblJlY292ZXJ5TmFtZSkpO1xufVxuZnVuY3Rpb24gYmV0dGVyVHJhbnNwb3J0VGhhbihhLCBiKSB7XG4gICAgcmV0dXJuIChVdGlscy5hcnJJbmRleE9mKHBsYXRmb3JtXzEuZGVmYXVsdC5EZWZhdWx0cy50cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXIsIGEuc2hvcnROYW1lKSA+XG4gICAgICAgIFV0aWxzLmFyckluZGV4T2YocGxhdGZvcm1fMS5kZWZhdWx0LkRlZmF1bHRzLnRyYW5zcG9ydFByZWZlcmVuY2VPcmRlciwgYi5zaG9ydE5hbWUpKTtcbn1cbmZ1bmN0aW9uIGJ1bmRsZVdpdGgoZGVzdCwgc3JjLCBtYXhTaXplKSB7XG4gICAgdmFyIGFjdGlvbjtcbiAgICBpZiAoZGVzdC5jaGFubmVsICE9PSBzcmMuY2hhbm5lbCkge1xuICAgICAgICAvKiBSVEw2ZDMgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoKGFjdGlvbiA9IGRlc3QuYWN0aW9uKSAhPT0gYWN0aW9ucy5QUkVTRU5DRSAmJiBhY3Rpb24gIT09IGFjdGlvbnMuTUVTU0FHRSkge1xuICAgICAgICAvKiBSVEw2ZCAtIGNhbiBvbmx5IGJ1bmRsZSBtZXNzYWdlcyBvciBwcmVzZW5jZSAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhY3Rpb24gIT09IHNyYy5hY3Rpb24pIHtcbiAgICAgICAgLyogUlRMNmQ0ICovXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGtpbmQgPSBhY3Rpb24gPT09IGFjdGlvbnMuUFJFU0VOQ0UgPyAncHJlc2VuY2UnIDogJ21lc3NhZ2VzJywgcHJvcG9zZWQgPSBkZXN0W2tpbmRdLmNvbmNhdChzcmNba2luZF0pLCBzaXplID0gbWVzc2FnZV8xLmRlZmF1bHQuZ2V0TWVzc2FnZXNTaXplKHByb3Bvc2VkKTtcbiAgICBpZiAoc2l6ZSA+IG1heFNpemUpIHtcbiAgICAgICAgLyogUlRMNmQxICovXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFVdGlscy5hbGxTYW1lKHByb3Bvc2VkLCAnY2xpZW50SWQnKSkge1xuICAgICAgICAvKiBSVEw2ZDIgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIVV0aWxzLmFyckV2ZXJ5KHByb3Bvc2VkLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHJldHVybiAhbXNnLmlkO1xuICAgIH0pKSB7XG4gICAgICAgIC8qIFJUTDZkNyAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qIHdlJ3JlIGdvb2QgdG8gZ28hICovXG4gICAgZGVzdFtraW5kXSA9IHByb3Bvc2VkO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZGVjb2RlUmVjb3ZlcnlLZXkocmVjb3ZlcnlLZXkpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZWNvdmVyeUtleSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbnZhciBUcmFuc3BvcnRQYXJhbXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhbnNwb3J0UGFyYW1zKG9wdGlvbnMsIGhvc3QsIG1vZGUsIGNvbm5lY3Rpb25LZXkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uS2V5ID0gY29ubmVjdGlvbktleTtcbiAgICAgICAgdGhpcy5mb3JtYXQgPSBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbjtcbiAgICB9XG4gICAgVHJhbnNwb3J0UGFyYW1zLnByb3RvdHlwZS5nZXRDb25uZWN0UGFyYW1zID0gZnVuY3Rpb24gKGF1dGhQYXJhbXMpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGF1dGhQYXJhbXMgPyBVdGlscy5jb3B5KGF1dGhQYXJhbXMpIDoge307XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgICAgICAgY2FzZSAndXBncmFkZSc6XG4gICAgICAgICAgICAgICAgcGFyYW1zLnVwZ3JhZGUgPSB0aGlzLmNvbm5lY3Rpb25LZXk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZXN1bWUnOlxuICAgICAgICAgICAgICAgIHBhcmFtcy5yZXN1bWUgPSB0aGlzLmNvbm5lY3Rpb25LZXk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZWNvdmVyJzoge1xuICAgICAgICAgICAgICAgIHZhciByZWNvdmVyeUNvbnRleHQgPSBkZWNvZGVSZWNvdmVyeUtleShvcHRpb25zLnJlY292ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChyZWNvdmVyeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnJlY292ZXIgPSByZWNvdmVyeUNvbnRleHQuY29ubmVjdGlvbktleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNsaWVudElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5jbGllbnRJZCA9IG9wdGlvbnMuY2xpZW50SWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZWNob01lc3NhZ2VzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcGFyYW1zLmVjaG8gPSAnZmFsc2UnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZvcm1hdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5zdHJlYW0gPSB0aGlzLnN0cmVhbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oZWFydGJlYXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5oZWFydGJlYXRzID0gdGhpcy5oZWFydGJlYXRzO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy52ID0gZGVmYXVsdHNfMS5kZWZhdWx0LnByb3RvY29sVmVyc2lvbjtcbiAgICAgICAgcGFyYW1zLmFnZW50ID0gZW5jb2RlVVJJQ29tcG9uZW50KCgwLCBkZWZhdWx0c18xLmdldEFnZW50U3RyaW5nKSh0aGlzLm9wdGlvbnMpKTtcbiAgICAgICAgaWYgKG9wdGlvbnMudHJhbnNwb3J0UGFyYW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFV0aWxzLm1peGluKHBhcmFtcywgb3B0aW9ucy50cmFuc3BvcnRQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgICBUcmFuc3BvcnRQYXJhbXMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJ1ttb2RlPScgKyB0aGlzLm1vZGU7XG4gICAgICAgIGlmICh0aGlzLmhvc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnLGhvc3Q9JyArIHRoaXMuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uS2V5KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJyxjb25uZWN0aW9uS2V5PScgKyB0aGlzLmNvbm5lY3Rpb25LZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJyxmb3JtYXQ9JyArIHRoaXMuZm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnXSc7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhbnNwb3J0UGFyYW1zO1xufSgpKTtcbmV4cG9ydHMuVHJhbnNwb3J0UGFyYW1zID0gVHJhbnNwb3J0UGFyYW1zO1xudmFyIENvbm5lY3Rpb25NYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKENvbm5lY3Rpb25NYW5hZ2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbm5lY3Rpb25NYW5hZ2VyKHJlYWx0aW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRpc2Nvbm5lY3RlZFJldHJ5Q291bnQgPSAwO1xuICAgICAgICBDb25uZWN0aW9uTWFuYWdlci5pbml0VHJhbnNwb3J0cygpO1xuICAgICAgICBfdGhpcy5yZWFsdGltZSA9IHJlYWx0aW1lO1xuICAgICAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdmFyIHRpbWVvdXRzID0gb3B0aW9ucy50aW1lb3V0cztcbiAgICAgICAgLyogY29ubmVjdGluZ1RpbWVvdXQ6IGxlYXZlIHByZWZlcmVuY2VDb25uZWN0VGltZW91dCAofjZzKSB0byB0cnkgdGhlXG4gICAgICAgICAqIHByZWZlcmVuY2UgdHJhbnNwb3J0LCB0aGVuIHJlYWx0aW1lUmVxdWVzdFRpbWVvdXQgKH4xMHMpIHRvIGVzdGFibGlzaFxuICAgICAgICAgKiB0aGUgYmFzZSB0cmFuc3BvcnQgaW4gY2FzZSB0aGF0IGZhaWxzICovXG4gICAgICAgIHZhciBjb25uZWN0aW5nVGltZW91dCA9IHRpbWVvdXRzLnByZWZlcmVuY2VDb25uZWN0VGltZW91dCArIHRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQ7XG4gICAgICAgIF90aGlzLnN0YXRlcyA9IHtcbiAgICAgICAgICAgIGluaXRpYWxpemVkOiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdpbml0aWFsaXplZCcsXG4gICAgICAgICAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHF1ZXVlRXZlbnRzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNlbmRFdmVudHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZhaWxTdGF0ZTogJ2Rpc2Nvbm5lY3RlZCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29ubmVjdGluZzoge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnY29ubmVjdGluZycsXG4gICAgICAgICAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHF1ZXVlRXZlbnRzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNlbmRFdmVudHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJldHJ5RGVsYXk6IGNvbm5lY3RpbmdUaW1lb3V0LFxuICAgICAgICAgICAgICAgIGZhaWxTdGF0ZTogJ2Rpc2Nvbm5lY3RlZCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29ubmVjdGVkOiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdjb25uZWN0ZWQnLFxuICAgICAgICAgICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBxdWV1ZUV2ZW50czogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VuZEV2ZW50czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmYWlsU3RhdGU6ICdkaXNjb25uZWN0ZWQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN5bmNocm9uaXppbmc6IHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2Nvbm5lY3RlZCcsXG4gICAgICAgICAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHF1ZXVlRXZlbnRzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNlbmRFdmVudHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZvcmNlUXVldWVFdmVudHM6IHRydWUsXG4gICAgICAgICAgICAgICAgZmFpbFN0YXRlOiAnZGlzY29ubmVjdGVkJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNjb25uZWN0ZWQ6IHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2Rpc2Nvbm5lY3RlZCcsXG4gICAgICAgICAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHF1ZXVlRXZlbnRzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNlbmRFdmVudHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJldHJ5RGVsYXk6IHRpbWVvdXRzLmRpc2Nvbm5lY3RlZFJldHJ5VGltZW91dCxcbiAgICAgICAgICAgICAgICBmYWlsU3RhdGU6ICdkaXNjb25uZWN0ZWQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1c3BlbmRlZDoge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnc3VzcGVuZGVkJyxcbiAgICAgICAgICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcXVldWVFdmVudHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNlbmRFdmVudHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJldHJ5RGVsYXk6IHRpbWVvdXRzLnN1c3BlbmRlZFJldHJ5VGltZW91dCxcbiAgICAgICAgICAgICAgICBmYWlsU3RhdGU6ICdzdXNwZW5kZWQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3Npbmc6IHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2Nsb3NpbmcnLFxuICAgICAgICAgICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBxdWV1ZUV2ZW50czogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VuZEV2ZW50czogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmV0cnlEZWxheTogdGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCxcbiAgICAgICAgICAgICAgICBmYWlsU3RhdGU6ICdjbG9zZWQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlZDogeyBzdGF0ZTogJ2Nsb3NlZCcsIHRlcm1pbmFsOiB0cnVlLCBxdWV1ZUV2ZW50czogZmFsc2UsIHNlbmRFdmVudHM6IGZhbHNlLCBmYWlsU3RhdGU6ICdjbG9zZWQnIH0sXG4gICAgICAgICAgICBmYWlsZWQ6IHsgc3RhdGU6ICdmYWlsZWQnLCB0ZXJtaW5hbDogdHJ1ZSwgcXVldWVFdmVudHM6IGZhbHNlLCBzZW5kRXZlbnRzOiBmYWxzZSwgZmFpbFN0YXRlOiAnZmFpbGVkJyB9LFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IF90aGlzLnN0YXRlcy5pbml0aWFsaXplZDtcbiAgICAgICAgX3RoaXMuZXJyb3JSZWFzb24gPSBudWxsO1xuICAgICAgICBfdGhpcy5xdWV1ZWRNZXNzYWdlcyA9IG5ldyBtZXNzYWdlcXVldWVfMS5kZWZhdWx0KCk7XG4gICAgICAgIF90aGlzLm1zZ1NlcmlhbCA9IDA7XG4gICAgICAgIF90aGlzLmNvbm5lY3Rpb25EZXRhaWxzID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5jb25uZWN0aW9uSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLmNvbm5lY3Rpb25LZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCA9IHRpbWVvdXRzLmNvbm5lY3Rpb25TdGF0ZVR0bDtcbiAgICAgICAgX3RoaXMubWF4SWRsZUludGVydmFsID0gbnVsbDtcbiAgICAgICAgX3RoaXMudHJhbnNwb3J0cyA9IFV0aWxzLmludGVyc2VjdChvcHRpb25zLnRyYW5zcG9ydHMgfHwgZGVmYXVsdHNfMS5kZWZhdWx0LmRlZmF1bHRUcmFuc3BvcnRzLCBDb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzKTtcbiAgICAgICAgLyogYmFzZVRyYW5zcG9ydHMgc2VsZWN0cyB0aGUgbGVmdG1vc3QgdHJhbnNwb3J0IGluIHRoZSBEZWZhdWx0cy5iYXNlVHJhbnNwb3J0T3JkZXIgbGlzdFxuICAgICAgICAgKiB0aGF0J3MgYm90aCByZXF1ZXN0ZWQgYW5kIHN1cHBvcnRlZC4gTm9ybWFsbHkgdGhpcyB3aWxsIGJlIHhocl9wb2xsaW5nO1xuICAgICAgICAgKiBpZiB4aHIgaXNuJ3Qgc3VwcG9ydGVkIGl0IHdpbGwgYmUganNvbnAuIElmIHRoZSB1c2VyIGhhcyBmb3JjZWQgYVxuICAgICAgICAgKiB0cmFuc3BvcnQsIGl0J2xsIGp1c3QgYmUgdGhhdCBvbmUuICovXG4gICAgICAgIF90aGlzLmJhc2VUcmFuc3BvcnQgPSBVdGlscy5pbnRlcnNlY3QoZGVmYXVsdHNfMS5kZWZhdWx0LmJhc2VUcmFuc3BvcnRPcmRlciwgX3RoaXMudHJhbnNwb3J0cylbMF07XG4gICAgICAgIF90aGlzLnVwZ3JhZGVUcmFuc3BvcnRzID0gVXRpbHMuaW50ZXJzZWN0KF90aGlzLnRyYW5zcG9ydHMsIGRlZmF1bHRzXzEuZGVmYXVsdC51cGdyYWRlVHJhbnNwb3J0cyk7XG4gICAgICAgIF90aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgPSBudWxsO1xuICAgICAgICBfdGhpcy5odHRwSG9zdHMgPSBkZWZhdWx0c18xLmRlZmF1bHQuZ2V0SG9zdHMob3B0aW9ucyk7XG4gICAgICAgIF90aGlzLmFjdGl2ZVByb3RvY29sID0gbnVsbDtcbiAgICAgICAgX3RoaXMucHJvcG9zZWRUcmFuc3BvcnRzID0gW107XG4gICAgICAgIF90aGlzLnBlbmRpbmdUcmFuc3BvcnRzID0gW107XG4gICAgICAgIF90aGlzLmhvc3QgPSBudWxsO1xuICAgICAgICBfdGhpcy5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgPSBudWxsO1xuICAgICAgICBfdGhpcy5sYXN0QWN0aXZpdHkgPSBudWxsO1xuICAgICAgICBfdGhpcy5mb3JjZUZhbGxiYWNrSG9zdCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5jb25uZWN0Q291bnRlciA9IDA7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKScsICdzdGFydGVkJyk7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKScsICdyZXF1ZXN0ZWQgdHJhbnNwb3J0cyA9IFsnICsgKG9wdGlvbnMudHJhbnNwb3J0cyB8fCBkZWZhdWx0c18xLmRlZmF1bHQuZGVmYXVsdFRyYW5zcG9ydHMpICsgJ10nKTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpJywgJ2F2YWlsYWJsZSB0cmFuc3BvcnRzID0gWycgKyBfdGhpcy50cmFuc3BvcnRzICsgJ10nKTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpJywgJ2h0dHAgaG9zdHMgPSBbJyArIF90aGlzLmh0dHBIb3N0cyArICddJyk7XG4gICAgICAgIGlmICghX3RoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnbm8gcmVxdWVzdGVkIHRyYW5zcG9ydHMgYXZhaWxhYmxlJztcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAncmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKScsIG1zZyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWRkRXZlbnRMaXN0ZW5lciA9IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgaWYgKGFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIC8qIGludGVyY2VwdCBjbG9zZSBldmVudCBpbiBicm93c2VyIHRvIHBlcnNpc3QgY29ubmVjdGlvbiBpZCBpZiByZXF1ZXN0ZWQgKi9cbiAgICAgICAgICAgIGlmIChoYXZlU2Vzc2lvblN0b3JhZ2UoKSAmJiB0eXBlb2Ygb3B0aW9ucy5yZWNvdmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLyogVXN1YWxseSBjYW4ndCB1c2UgYmluZCBhcyBub3Qgc3VwcG9ydGVkIGluIElFOCwgYnV0IElFIGRvZXNuJ3Qgc3VwcG9ydCBzZXNzaW9uU3RvcmFnZSwgc28uLi4gKi9cbiAgICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBfdGhpcy5wZXJzaXN0Q29ubmVjdGlvbi5iaW5kKF90aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jbG9zZU9uVW5sb2FkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NQUpPUiwgJ1JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCAnYmVmb3JldW5sb2FkIGV2ZW50IGhhcyB0cmlnZ2VyZWQgdGhlIGNvbm5lY3Rpb24gdG8gY2xvc2UgYXMgY2xvc2VPblVubG9hZCBpcyB0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiAnY2xvc2luZycgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBMaXN0ZW4gZm9yIG9ubGluZSBhbmQgb2ZmbGluZSBldmVudHMgKi9cbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUgPT0gX3RoaXMuc3RhdGVzLmRpc2Nvbm5lY3RlZCB8fCBfdGhpcy5zdGF0ZSA9PSBfdGhpcy5zdGF0ZXMuc3VzcGVuZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIgY2F1Z2h0IGJyb3dzZXIg4oCYb25saW5l4oCZIGV2ZW50JywgJ3JlYXR0ZW1wdGluZyBjb25uZWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiAnY29ubmVjdGluZycgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnN0YXRlID09IF90aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJUTjIwYzogaWYgJ29ubGluZScgZXZlbnQgcmVjaWV2ZWQgd2hpbGUgQ09OTkVDVElORywgYWJhbmRvbiBjb25uZWN0aW9uIGF0dGVtcHQgYW5kIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBlbmRpbmdUcmFuc3BvcnRzLmZvckVhY2goZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGV0YWNoIHRyYW5zcG9ydCBsaXN0ZW5lcnMgdG8gYXZvaWQgY29ubmVjdGlvbiBzdGF0ZSBzaWRlIGVmZmVjdHMgZnJvbSBjYWxsaW5nIGRpc3Bvc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5vZmYoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXJ0Q29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUgPT0gX3RoaXMuc3RhdGVzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyIGNhdWdodCBicm93c2VyIOKAmG9mZmxpbmXigJkgZXZlbnQnLCAnZGlzY29ubmVjdGluZyBhY3RpdmUgdHJhbnNwb3J0Jyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBzdWZmaWNpZW50IHRvIGp1c3QgZ28gdG8gdGhlICdkaXNjb25uZWN0ZWQnIHN0YXRlLCB3YW50IHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcmNlIGFsbCB0cmFuc3BvcnRzIHRvIHJlYXR0ZW1wdCB0aGUgY29ubmVjdGlvbi4gV2lsbCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICAvLyByZXRyeS5cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLmluaXRUcmFuc3BvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAoMCwgd2Vic29ja2V0dHJhbnNwb3J0XzEuZGVmYXVsdCkoQ29ubmVjdGlvbk1hbmFnZXIpO1xuICAgICAgICBVdGlscy5hcnJGb3JFYWNoKHBsYXRmb3JtXzEuZGVmYXVsdC5UcmFuc3BvcnRzLCBmdW5jdGlvbiAoaW5pdEZuKSB7XG4gICAgICAgICAgICBpbml0Rm4oQ29ubmVjdGlvbk1hbmFnZXIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVUcmFuc3BvcnRQYXJhbXMgPSBmdW5jdGlvbiAoaG9zdCwgbW9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zcG9ydFBhcmFtcyh0aGlzLm9wdGlvbnMsIGhvc3QsIG1vZGUsIHRoaXMuY29ubmVjdGlvbktleSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VHJhbnNwb3J0UGFyYW1zID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkZWNpZGVNb2RlID0gZnVuY3Rpb24gKG1vZGVDYikge1xuICAgICAgICAgICAgaWYgKF90aGlzLmNvbm5lY3Rpb25LZXkpIHtcbiAgICAgICAgICAgICAgICBtb2RlQ2IoJ3Jlc3VtZScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMub3B0aW9ucy5yZWNvdmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIG1vZGVDYigncmVjb3ZlcicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZWNvdmVyRm4gPSBfdGhpcy5vcHRpb25zLnJlY292ZXIsIGxhc3RTZXNzaW9uRGF0YSA9IGdldFNlc3Npb25SZWNvdmVyRGF0YSgpO1xuICAgICAgICAgICAgaWYgKGxhc3RTZXNzaW9uRGF0YSAmJiB0eXBlb2YgcmVjb3ZlckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5nZXRUcmFuc3BvcnRQYXJhbXMoKScsICdDYWxsaW5nIGNsaWVudE9wdGlvbnMtcHJvdmlkZWQgcmVjb3ZlciBmdW5jdGlvbiB3aXRoIGxhc3Qgc2Vzc2lvbiBkYXRhJyk7XG4gICAgICAgICAgICAgICAgcmVjb3ZlckZuKGxhc3RTZXNzaW9uRGF0YSwgZnVuY3Rpb24gKHNob3VsZFJlY292ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFJlY292ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9wdGlvbnMucmVjb3ZlciA9IGxhc3RTZXNzaW9uRGF0YS5yZWNvdmVyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVDYigncmVjb3ZlcicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZUNiKCdjbGVhbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kZUNiKCdjbGVhbicpO1xuICAgICAgICB9O1xuICAgICAgICBkZWNpZGVNb2RlKGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNwb3J0UGFyYW1zID0gX3RoaXMuY3JlYXRlVHJhbnNwb3J0UGFyYW1zKG51bGwsIG1vZGUpO1xuICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdyZWNvdmVyJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZ2V0VHJhbnNwb3J0UGFyYW1zKCknLCAnVHJhbnNwb3J0IHJlY292ZXJ5IG1vZGUgPSByZWNvdmVyOyByZWNvdmVyeUtleSA9ICcgKyBfdGhpcy5vcHRpb25zLnJlY292ZXIpO1xuICAgICAgICAgICAgICAgIHZhciByZWNvdmVyeUNvbnRleHQgPSBkZWNvZGVSZWNvdmVyeUtleShfdGhpcy5vcHRpb25zLnJlY292ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChyZWNvdmVyeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubXNnU2VyaWFsID0gcmVjb3ZlcnlDb250ZXh0Lm1zZ1NlcmlhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmdldFRyYW5zcG9ydFBhcmFtcygpJywgJ1RyYW5zcG9ydCBwYXJhbXMgPSAnICsgdHJhbnNwb3J0UGFyYW1zLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sodHJhbnNwb3J0UGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IHRvIGNvbm5lY3QgdXNpbmcgYSBnaXZlbiB0cmFuc3BvcnRcbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0UGFyYW1zXG4gICAgICogQHBhcmFtIGNhbmRpZGF0ZSwgdGhlIHRyYW5zcG9ydCB0byB0cnlcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUudHJ5QVRyYW5zcG9ydCA9IGZ1bmN0aW9uICh0cmFuc3BvcnRQYXJhbXMsIGNhbmRpZGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KCknLCAndHJ5aW5nICcgKyBjYW5kaWRhdGUpO1xuICAgICAgICB0cmFuc3BvcnRfMS5kZWZhdWx0LnRyeUNvbm5lY3QoQ29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0c1tjYW5kaWRhdGVdLCB0aGlzLCB0aGlzLnJlYWx0aW1lLmF1dGgsIHRyYW5zcG9ydFBhcmFtcywgZnVuY3Rpb24gKHdyYXBwZWRFcnIsIHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gX3RoaXMuc3RhdGU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT0gX3RoaXMuc3RhdGVzLmNsb3NpbmcgfHwgc3RhdGUgPT0gX3RoaXMuc3RhdGVzLmNsb3NlZCB8fCBzdGF0ZSA9PSBfdGhpcy5zdGF0ZXMuZmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKScsICdjb25uZWN0aW9uICcgKyBzdGF0ZS5zdGF0ZSArICcgd2hpbGUgd2Ugd2VyZSBhdHRlbXB0aW5nIHRoZSB0cmFuc3BvcnQ7IGNsb3NpbmcgJyArIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod3JhcHBlZEVycikge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpJywgJ3RyYW5zcG9ydCAnICsgY2FuZGlkYXRlICsgJyAnICsgd3JhcHBlZEVyci5ldmVudCArICcsIGVycjogJyArIHdyYXBwZWRFcnIuZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgLyogQ29tZXQgdHJhbnNwb3J0IG9uY29ubmVjdCB0b2tlbiBlcnJvcnMgY2FuIGJlIGRlYWx0IHdpdGggaGVyZS5cbiAgICAgICAgICAgICAgICAgKiBXZWJzb2NrZXQgb25lcyBvbmx5IGhhcHBlbiBhZnRlciB0aGUgdHJhbnNwb3J0IGNsYWltcyB0byBiZSB2aWFibGUsXG4gICAgICAgICAgICAgICAgICogc28gYXJlIGRlYWx0IHdpdGggYXMgbm9uLW9uY29ubmVjdCB0b2tlbiBlcnJvcnMgKi9cbiAgICAgICAgICAgICAgICBpZiAoYXV0aF8xLmRlZmF1bHQuaXNUb2tlbkVycih3cmFwcGVkRXJyLmVycm9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAhKF90aGlzLmVycm9yUmVhc29uICYmIGF1dGhfMS5kZWZhdWx0LmlzVG9rZW5FcnIoX3RoaXMuZXJyb3JSZWFzb24pKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lcnJvclJlYXNvbiA9IHdyYXBwZWRFcnIuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIC8qIHJlLWdldCBhIHRva2VuIGFuZCB0cnkgYWdhaW4gKi9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVhbHRpbWUuYXV0aC5fZm9yY2VOZXdUb2tlbihudWxsLCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgY2FuZGlkYXRlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3cmFwcGVkRXJyLmV2ZW50ID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgICAgICAgICAvKiBFcnJvciB0aGF0J3MgZmF0YWwgdG8gdGhlIGNvbm5lY3Rpb24gKi9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogJ2ZhaWxlZCcsIGVycm9yOiB3cmFwcGVkRXJyLmVycm9yIH0pO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod3JhcHBlZEVyci5ldmVudCA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgY29ubmVjdGlvbmVycm9yc18xLmlzUmV0cmlhYmxlKSh3cmFwcGVkRXJyLmVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogRXJyb3IgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIHRoYXQgZG9lcyBub3QgY2FsbCBmb3IgdHJ5aW5nIGEgZmFsbGJhY2sgaG9zdCwgZWcgYSByYXRlIGxpbWl0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBfdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUsIGVycm9yOiB3cmFwcGVkRXJyLmVycm9yIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBFcnJvciB3aXRoIHRoYXQgdHJhbnNwb3J0IG9ubHk7IGNvbnRpbnVlIHRyeWluZyBvdGhlciBmYWxsYmFjayBob3N0cyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpJywgJ3ZpYWJsZSB0cmFuc3BvcnQgJyArIGNhbmRpZGF0ZSArICc7IHNldHRpbmcgcGVuZGluZycpO1xuICAgICAgICAgICAgX3RoaXMuc2V0VHJhbnNwb3J0UGVuZGluZyh0cmFuc3BvcnQsIHRyYW5zcG9ydFBhcmFtcyk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB0cmFuc3BvcnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGlzIGluZGljYXRlZCB0byBiZSB2aWFibGUsIGFuZCB0aGUgQ29ubmVjdGlvbk1hbmFnZXJcbiAgICAgKiBleHBlY3RzIHRvIGFjdGl2YXRlIHRoaXMgdHJhbnNwb3J0IGFzIHNvb24gYXMgaXQgaXMgY29ubmVjdGVkLlxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnRcbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0UGFyYW1zXG4gICAgICovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldFRyYW5zcG9ydFBlbmRpbmcgPSBmdW5jdGlvbiAodHJhbnNwb3J0LCB0cmFuc3BvcnRQYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG1vZGUgPSB0cmFuc3BvcnRQYXJhbXMubW9kZTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zZXRUcmFuc3BvcnRQZW5kaW5nKCknLCAndHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCArICc7IG1vZGUgPSAnICsgbW9kZSk7XG4gICAgICAgIFV0aWxzLmFyckRlbGV0ZVZhbHVlKHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xuICAgICAgICB0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLnB1c2godHJhbnNwb3J0KTtcbiAgICAgICAgdmFyIG9wdGltYWxUcmFuc3BvcnQgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuRGVmYXVsdHMudHJhbnNwb3J0UHJlZmVyZW5jZU9yZGVyW3BsYXRmb3JtXzEuZGVmYXVsdC5EZWZhdWx0cy50cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXIubGVuZ3RoIC0gMV07XG4gICAgICAgIHRyYW5zcG9ydC5vbmNlKCdjb25uZWN0ZWQnLCBmdW5jdGlvbiAoZXJyb3IsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMpIHtcbiAgICAgICAgICAgIGlmIChtb2RlID09ICd1cGdyYWRlJyAmJiBfdGhpcy5hY3RpdmVQcm90b2NvbCkge1xuICAgICAgICAgICAgICAgIC8qICBpZiB3cyBhbmQgeGhycyBhcmUgY29ubmVjdGluZyBpbiBwYXJhbGxlbCwgZGVsYXkgeGhycyBhY3RpdmF0aW9uIHRvIGxldCB3cyBnbyBhaGVhZCAqL1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc3BvcnQuc2hvcnROYW1lICE9PSBvcHRpbWFsVHJhbnNwb3J0ICYmXG4gICAgICAgICAgICAgICAgICAgIFV0aWxzLmFyckluKF90aGlzLmdldFVwZ3JhZGVQb3NzaWJpbGl0aWVzKCksIG9wdGltYWxUcmFuc3BvcnQpICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZVByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMpO1xuICAgICAgICAgICAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLnRpbWVvdXRzLnBhcmFsbGVsVXBncmFkZURlbGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbihlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmF0ZVRyYW5zcG9ydChlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAvKiBhbGxvdyBjb25uZWN0SW1wbCB0byBzdGFydCB0aGUgdXBncmFkZSBwcm9jZXNzIGlmIG5lZWRlZCwgYnV0IGFsbG93XG4gICAgICAgICAgICAgICAgICogb3RoZXIgZXZlbnQgaGFuZGxlcnMsIGluY2x1ZGluZyBhY3RpdmF0aW5nIHRoZSB0cmFuc3BvcnQsIHRvIHJ1biBmaXJzdCAqL1xuICAgICAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdyZWNvdmVyJyAmJiBfdGhpcy5vcHRpb25zLnJlY292ZXIpIHtcbiAgICAgICAgICAgICAgICAvKiBBZnRlciBhIHN1Y2Nlc3NmdWwgcmVjb3ZlcnksIHdlIHVucGVyc2lzdCwgYXMgYSByZWNvdmVyeSBrZXkgY2Fubm90XG4gICAgICAgICAgICAgICAgICogYmUgdXNlZCBtb3JlIHRoYW4gb25jZSAqL1xuICAgICAgICAgICAgICAgIF90aGlzLm9wdGlvbnMucmVjb3ZlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgX3RoaXMudW5wZXJzaXN0Q29ubmVjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0cmFuc3BvcnQub24oWydkaXNjb25uZWN0ZWQnLCAnY2xvc2VkJywgJ2ZhaWxlZCddLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHNlbGYuZGVhY3RpdmF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQsIHRoaXMuZXZlbnQsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdCgndHJhbnNwb3J0LnBlbmRpbmcnLCB0cmFuc3BvcnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYW4gdXBncmFkZSB0cmFuc3BvcnQgaXMgY29ubmVjdGVkLFxuICAgICAqIHRvIHNjaGVkdWxlIHRoZSBhY3RpdmF0aW9uIG9mIHRoYXQgdHJhbnNwb3J0LlxuICAgICAqIEBwYXJhbSBlcnJvclxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnRcbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbklkXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25EZXRhaWxzXG4gICAgICovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbiA9IGZ1bmN0aW9uIChlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjdXJyZW50VHJhbnNwb3J0ID0gdGhpcy5hY3RpdmVQcm90b2NvbCAmJiB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLCBhYmFuZG9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIFV0aWxzLmFyckRlbGV0ZVZhbHVlKF90aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkICYmIHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgIC8qIFRoaXMgaXMgbW9zdCBsaWtlbHkgdG8gaGFwcGVuIGZvciB0aGUgZGVsYXllZCBYSFJzLCB3aGVuIFhIUnMgYW5kIHdzIGFyZSBzY2hlZHVsZWQgaW4gcGFyYWxsZWwqL1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdDdXJyZW50IGNvbm5lY3Rpb24gc3RhdGUgKCcgK1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhdGUgK1xuICAgICAgICAgICAgICAgICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nID8gJywgYnV0IHdpdGggYW4gdXBncmFkZSBhbHJlYWR5IGluIHByb2dyZXNzJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgJykgaXMgbm90IHZhbGlkIHRvIHVwZ3JhZGUgaW47IGFiYW5kb25pbmcgdXBncmFkZSB0byAnICtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc2hvcnROYW1lKTtcbiAgICAgICAgICAgIGFiYW5kb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudFRyYW5zcG9ydCAmJiAhYmV0dGVyVHJhbnNwb3J0VGhhbih0cmFuc3BvcnQsIGN1cnJlbnRUcmFuc3BvcnQpKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1Byb3Bvc2VkIHRyYW5zcG9ydCAnICtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc2hvcnROYW1lICtcbiAgICAgICAgICAgICAgICAnIGlzIG5vIGJldHRlciB0aGFuIGN1cnJlbnQgYWN0aXZlIHRyYW5zcG9ydCAnICtcbiAgICAgICAgICAgICAgICBjdXJyZW50VHJhbnNwb3J0LnNob3J0TmFtZSArXG4gICAgICAgICAgICAgICAgJyAtIGFiYW5kb25pbmcgdXBncmFkZScpO1xuICAgICAgICAgICAgYWJhbmRvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnU2NoZWR1bGluZyB0cmFuc3BvcnQgdXBncmFkZTsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG4gICAgICAgIHZhciBvbGRQcm90b2NvbCA9IG51bGw7XG4gICAgICAgIGlmICghdHJhbnNwb3J0LmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAvKiBUaGlzIGlzIG9ubHkgcG9zc2libGUgaWYgdGhlIHhociBzdHJlYW1pbmcgdHJhbnNwb3J0IHdhcyBkaXNjb25uZWN0ZWQgZHVyaW5nIHRoZSBwYXJhbGxlbFVwZ3JhZGVEZWxheSAqL1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdQcm9wb3NlZCB0cmFuc3BvcnQgJyArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyAnaXMgbm8gbG9uZ2VyIGNvbm5lY3RlZDsgYWJhbmRvbmluZyB1cGdyYWRlJyk7XG4gICAgICAgICAgICBhYmFuZG9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdDdXJyZW50bHkgY29ubmVjdGVkLCBzbyB0ZW1wb3JhcmlseSBwYXVzaW5nIGV2ZW50cyB1bnRpbCB0aGUgdXBncmFkZSBpcyBjb21wbGV0ZScpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzLnN5bmNocm9uaXppbmc7XG4gICAgICAgICAgICBvbGRQcm90b2NvbCA9IHRoaXMuYWN0aXZlUHJvdG9jb2w7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZykge1xuICAgICAgICAgICAgLyogTm90ZTogdXBncmFkaW5nIGZyb20gdGhlIGNvbm5lY3Rpbmcgc3RhdGUgaXMgdmFsaWQgaWYgdGhlIG9sZCBhY3RpdmVcbiAgICAgICAgICAgICAqIHRyYW5zcG9ydCB3YXMgZGVhY3RpdmF0ZWQgYWZ0ZXIgdGhlIHVwZ3JhZGUgdHJhbnNwb3J0IGZpcnN0IGNvbm5lY3RlZDtcbiAgICAgICAgICAgICAqIHNlZSBsb2dpYyBpbiBkZWFjdGl2YXRlVHJhbnNwb3J0ICovXG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ0N1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZSAoJyArXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdGF0ZSArXG4gICAgICAgICAgICAgICAgKHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLnN5bmNocm9uaXppbmcgPyAnLCBidXQgd2l0aCBhbiB1cGdyYWRlIGFscmVhZHkgaW4gcHJvZ3Jlc3MnIDogJycpICtcbiAgICAgICAgICAgICAgICAnKSBpcyBub3QgdmFsaWQgdG8gdXBncmFkZSBpbjsgYWJhbmRvbmluZyB1cGdyYWRlIHRvICcgK1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zaG9ydE5hbWUpO1xuICAgICAgICAgICAgYWJhbmRvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnU3luY2luZyB0cmFuc3BvcnQ7IHRyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuICAgICAgICB2YXIgZmluaXNoVXBncmFkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnQWN0aXZhdGluZyB0cmFuc3BvcnQ7IHRyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgLy8gU2VuZCBBQ1RJVkFURSB0byB0ZWxsIHRoZSBzZXJ2ZXIgdG8gbWFrZSB0aGlzIHRyYW5zcG9ydCB0aGVcbiAgICAgICAgICAgIC8vIGFjdGl2ZSB0cmFuc3BvcnQsIHdoaWNoIHN1c3BlbmRzIGNoYW5uZWxzIHVudGlsIHdlIHJlLWF0dGFjaC5cbiAgICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25zLkFDVElWQVRFLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgX3RoaXMuYWN0aXZhdGVUcmFuc3BvcnQoZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscyk7XG4gICAgICAgICAgICAvKiBSZXN0b3JlIHByZS1zeW5jIHN0YXRlLiBJZiBzdGF0ZSBoYXMgY2hhbmdlZCBpbiB0aGUgbWVhbnRpbWUsXG4gICAgICAgICAgICAgKiBkb24ndCB0b3VjaCBpdCAtLSBzaW5jZSB0aGUgd2Vic29ja2V0IHRyYW5zcG9ydCB3YWl0cyBhIHRpY2sgYmVmb3JlXG4gICAgICAgICAgICAgKiBkaXNwb3NpbmcgaXRzZWxmLCBpdCdzIHBvc3NpYmxlIGZvciBpdCB0byBoYXZlIGhhcHBpbHkgc3luY2VkXG4gICAgICAgICAgICAgKiB3aXRob3V0IGVyciB3aGlsZSwgdW5rbm93biB0byBpdCwgdGhlIGNvbm5lY3Rpb24gaGFzIGNsb3NlZCBpbiB0aGVcbiAgICAgICAgICAgICAqIG1lYW50aW1lIGFuZCB0aGUgd3MgdHJhbnNwb3J0IGlzIHNjaGVkdWxlZCBmb3IgZGVhdGggKi9cbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZSA9PT0gX3RoaXMuc3RhdGVzLnN5bmNocm9uaXppbmcpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1ByZS11cGdyYWRlIHByb3RvY29sIGlkbGUsIHNlbmRpbmcgcXVldWVkIG1lc3NhZ2VzIG9uIHVwZ3JhZGVkIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBfdGhpcy5zdGF0ZXMuY29ubmVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdQcmUtdXBncmFkZSBwcm90b2NvbCBpZGxlLCBidXQgc3RhdGUgaXMgbm93ICcgKyBfdGhpcy5zdGF0ZS5zdGF0ZSArICcsIHNvIGxlYXZpbmcgdW5jaGFuZ2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuc2VuZEV2ZW50cykge1xuICAgICAgICAgICAgICAgIF90aGlzLnNlbmRRdWV1ZWRNZXNzYWdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBXYWl0IHVudGlsIHN5bmMgaXMgZG9uZSBhbmQgb2xkIHRyYW5zcG9ydCBpcyBpZGxlIGJlZm9yZSBhY3RpdmF0aW5nIG5ldyB0cmFuc3BvcnQuIFRoaXNcbiAgICAgICAgICogZ3VhcmFudGVlcyB0aGF0IG1lc3NhZ2VzIGFycml2ZSBhdCByZWFsdGltZSBpbiB0aGUgc2FtZSBvcmRlciB0aGV5IGFyZSBzZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBhIG1lc3NhZ2UgdGltZXMgb3V0IG9uIHRoZSBvbGQgdHJhbnNwb3J0LCBzaW5jZSBpdCdzIHN0aWxsIHRoZSBhY3RpdmUgdHJhbnNwb3J0IHRoZVxuICAgICAgICAgKiBtZXNzYWdlIHdpbGwgYmUgcmVxdWV1ZWQuIGRlYWN0aXZhdGVUcmFuc3BvcnQgd2lsbCBzZWUgdGhlIHBlbmRpbmcgdHJhbnNwb3J0IGFuZCBub3RpZnlcbiAgICAgICAgICogdGhlIGBjb25uZWN0aW5nYCBzdGF0ZSB3aXRob3V0IHN0YXJ0aW5nIGEgbmV3IGNvbm5lY3Rpb24sIHNvIHRoZSBuZXcgdHJhbnNwb3J0IGNhbiB0YWtlXG4gICAgICAgICAqIG92ZXIgb25jZSBkZWFjdGl2YXRlVHJhbnNwb3J0IGNsZWFycyB0aGUgb2xkIHByb3RvY29sJ3MgcXVldWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZXJlIGlzIG5vIG9sZCBwcm90b2NvbCwgdGhhdCBtZWFudCB0aGF0IHdlIHdlcmVuJ3QgaW4gdGhlIGNvbm5lY3RlZCBzdGF0ZSBhdCB0aGVcbiAgICAgICAgICogYmVnaW5uaW5nIG9mIHRoZSBzeW5jIC0gbGlrZWx5IHRoZSBiYXNlIHRyYW5zcG9ydCBkaWVkIGp1c3QgYmVmb3JlIHRoZSBzeW5jLiBTbyBjYW4ganVzdFxuICAgICAgICAgKiBmaW5pc2ggdGhlIHVwZ3JhZGUuIElmIHdlJ3JlIGFjdHVhbGx5IGluIGNsb3NpbmcvZmFpbGVkIHJhdGhlciB0aGFuIGNvbm5lY3RpbmcsIHRoYXQnc1xuICAgICAgICAgKiBmaW5lLCBhY3RpdmF0ZXRyYW5zcG9ydCB3aWxsIGRlYWwgd2l0aCB0aGF0LiAqL1xuICAgICAgICBpZiAob2xkUHJvdG9jb2wpIHtcbiAgICAgICAgICAgIC8qIE1vc3Qgb2YgdGhlIHRpbWUgdGhpcyB3aWxsIGJlIGFscmVhZHkgdHJ1ZTogdGhlIG5ldy10cmFuc3BvcnQgc3luYyB3aWxsIGhhdmUgZ2l2ZW5cbiAgICAgICAgICAgICAqIGVub3VnaCB0aW1lIGZvciBpbi1mbGlnaHQgbWVzc2FnZXMgb24gdGhlIG9sZCB0cmFuc3BvcnQgdG8gY29tcGxldGUuICovXG4gICAgICAgICAgICBvbGRQcm90b2NvbC5vbmNlSWRsZShmaW5pc2hVcGdyYWRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpbmlzaFVwZ3JhZGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSB0cmFuc3BvcnQgaXMgY29ubmVjdGVkLCBhbmQgdGhlIGNvbm5lY3Rpb25tYW5hZ2VyIGRlY2lkZXMgdGhhdFxuICAgICAqIGl0IHdpbGwgbm93IGJlIHRoZSBhY3RpdmUgdHJhbnNwb3J0LiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGl0IGFjdGl2YXRlZFxuICAgICAqIHRoZSB0cmFuc3BvcnQgKGlmIHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmcvY2xvc2VkIGl0IHdpbGwgY2hvb3NlIG5vdCB0bykuXG4gICAgICogQHBhcmFtIHRyYW5zcG9ydCB0aGUgdHJhbnNwb3J0IGluc3RhbmNlXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25JZCB0aGUgaWQgb2YgdGhlIG5ldyBhY3RpdmUgY29ubmVjdGlvblxuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uRGV0YWlscyB0aGUgZGV0YWlscyBvZiB0aGUgbmV3IGFjdGl2ZSBjb25uZWN0aW9uXG4gICAgICovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmFjdGl2YXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ3RyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdlcnJvciA9ICcgKyBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3Rpb25JZCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ2Nvbm5lY3Rpb25JZCA9ICAnICsgY29ubmVjdGlvbklkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdGlvbkRldGFpbHMpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdjb25uZWN0aW9uRGV0YWlscyA9ICAnICsgSlNPTi5zdHJpbmdpZnkoY29ubmVjdGlvbkRldGFpbHMpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKHRyYW5zcG9ydCk7XG4gICAgICAgIC8qIGlmIHRoZSBjb25uZWN0aW9ubWFuYWdlciBtb3ZlZCB0byB0aGUgY2xvc2luZy9jbG9zZWQgc3RhdGUgYmVmb3JlIHRoaXNcbiAgICAgICAgICogY29ubmVjdGlvbiBldmVudCwgdGhlbiB3ZSB3b24ndCBhY3RpdmF0ZSB0aGlzIHRyYW5zcG9ydCAqL1xuICAgICAgICB2YXIgZXhpc3RpbmdTdGF0ZSA9IHRoaXMuc3RhdGUsIGNvbm5lY3RlZFN0YXRlID0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnY3VycmVudCBzdGF0ZSA9ICcgKyBleGlzdGluZ1N0YXRlLnN0YXRlKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nU3RhdGUuc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY2xvc2luZy5zdGF0ZSB8fFxuICAgICAgICAgICAgZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5jbG9zZWQuc3RhdGUgfHxcbiAgICAgICAgICAgIGV4aXN0aW5nU3RhdGUuc3RhdGUgPT0gdGhpcy5zdGF0ZXMuZmFpbGVkLnN0YXRlKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnRGlzY29ubmVjdGluZyB0cmFuc3BvcnQgYW5kIGFiYW5kb25pbmcnKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyogcmVtb3ZlIHRoaXMgdHJhbnNwb3J0IGZyb20gcGVuZGluZyB0cmFuc3BvcnRzICovXG4gICAgICAgIFV0aWxzLmFyckRlbGV0ZVZhbHVlKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIHRyYW5zcG9ydCk7XG4gICAgICAgIC8qIGlmIHRoZSB0cmFuc3BvcnQgaXMgbm90IGNvbm5lY3RlZCB0aGVuIGRvbid0IGFjdGl2YXRlIGl0ICovXG4gICAgICAgIGlmICghdHJhbnNwb3J0LmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnRGVjbGluaW5nIHRvIGFjdGl2YXRlIHRyYW5zcG9ydCAnICsgdHJhbnNwb3J0ICsgJyBzaW5jZSBpdCBhcHBlYXJzIHRvIG5vIGxvbmdlciBiZSBjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKiB0aGUgZ2l2ZW4gdHJhbnNwb3J0IGlzIGNvbm5lY3RlZDsgdGhpcyB3aWxsIGltbWVkaWF0ZWx5XG4gICAgICAgICAqIHRha2Ugb3ZlciBhcyB0aGUgYWN0aXZlIHRyYW5zcG9ydCAqL1xuICAgICAgICB2YXIgZXhpc3RpbmdBY3RpdmVQcm90b2NvbCA9IHRoaXMuYWN0aXZlUHJvdG9jb2w7XG4gICAgICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wgPSBuZXcgcHJvdG9jb2xfMS5kZWZhdWx0KHRyYW5zcG9ydCk7XG4gICAgICAgIHRoaXMuaG9zdCA9IHRyYW5zcG9ydC5wYXJhbXMuaG9zdDtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb25LZXkgPSBjb25uZWN0aW9uRGV0YWlscy5jb25uZWN0aW9uS2V5O1xuICAgICAgICBpZiAoY29ubmVjdGlvbktleSAmJiB0aGlzLmNvbm5lY3Rpb25LZXkgIT0gY29ubmVjdGlvbktleSkge1xuICAgICAgICAgICAgdGhpcy5zZXRDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMsICEhZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIC8qIFJlYnJvYWRjYXN0IGFueSBuZXcgY29ubmVjdGlvbkRldGFpbHMgZnJvbSB0aGUgYWN0aXZlIHRyYW5zcG9ydCwgd2hpY2hcbiAgICAgICAgICogY2FuIGNvbWUgYXQgYW55IHRpbWUgKGVnIGZvbGxvd2luZyBhIHJlYXV0aCksIGFuZCBlbWl0IGFuIFJUTjI0IFVQREFURVxuICAgICAgICAgKiBldmVudC4gKExpc3RlbmVyIGFkZGVkIG9uIG5leHRUaWNrIGJlY2F1c2Ugd2UncmUgaW4gYSB0cmFuc3BvcnQub24oJ2Nvbm5lY3RlZCcpXG4gICAgICAgICAqIGNhbGxiYWNrIGF0IHRoZSBtb21lbnQ7IGlmIHdlIGFkZCBpdCBub3cgd2UnbGwgYmUgYWRkaW5nIGl0IHRvIHRoZSBlbmRcbiAgICAgICAgICogb2YgdGhlIGxpc3RlbmVycyBhcnJheSBhbmQgaXQnbGwgYmUgY2FsbGVkIGltbWVkaWF0ZWx5KSAqL1xuICAgICAgICB0aGlzLm9uQ29ubmVjdGlvbkRldGFpbHNVcGRhdGUoY29ubmVjdGlvbkRldGFpbHMsIHRyYW5zcG9ydCk7XG4gICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0Lm9uKCdjb25uZWN0ZWQnLCBmdW5jdGlvbiAoY29ubmVjdGVkRXJyLCBfY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscykge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uQ29ubmVjdGlvbkRldGFpbHNVcGRhdGUoY29ubmVjdGlvbkRldGFpbHMsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgndXBkYXRlJywgbmV3IGNvbm5lY3Rpb25zdGF0ZWNoYW5nZV8xLmRlZmF1bHQoY29ubmVjdGVkU3RhdGUsIGNvbm5lY3RlZFN0YXRlLCBudWxsLCBjb25uZWN0ZWRFcnIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLyogSWYgcHJldmlvdXNseSBub3QgY29ubmVjdGVkLCBub3RpZnkgdGhlIHN0YXRlIGNoYW5nZSAoaW5jbHVkaW5nIGFueVxuICAgICAgICAgKiBlcnJvcikuICovXG4gICAgICAgIGlmIChleGlzdGluZ1N0YXRlLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8qIGlmIHVwZ3JhZGluZyB3aXRob3V0IGVycm9yLCBsZWF2ZSBhbnkgZXhpc3RpbmcgZXJyb3JSZWFzb24gYWxvbmUgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yUmVhc29uID0gdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmVycm9yUmVhc29uID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgLyogT25seSBib3RoZXIgZW1pdHRpbmcgYW4gdXBncmFkZSBpZiB0aGVyZSdzIGFuIGVycm9yOyBvdGhlcndpc2UgaXQnc1xuICAgICAgICAgICAgICAgICAqIGp1c3QgYSB0cmFuc3BvcnQgdXBncmFkZSwgc28gYXV0aCBkZXRhaWxzIHdvbid0IGhhdmUgY2hhbmdlZCAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgbmV3IGNvbm5lY3Rpb25zdGF0ZWNoYW5nZV8xLmRlZmF1bHQoY29ubmVjdGVkU3RhdGUsIGNvbm5lY3RlZFN0YXRlLCBudWxsLCBlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiAnY29ubmVjdGVkJywgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IGVycm9yIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyogU2VuZCBhZnRlciB0aGUgY29ubmVjdGlvbiBzdGF0ZSB1cGRhdGUsIGFzIENoYW5uZWxzIGhvb2tzIGludG8gdGhpcyB0b1xuICAgICAgICAgKiByZXNlbmQgYXR0YWNoZXMgb24gYSBuZXcgdHJhbnNwb3J0IGlmIG5lY2Vzc2FyeSAqL1xuICAgICAgICB0aGlzLmVtaXQoJ3RyYW5zcG9ydC5hY3RpdmUnLCB0cmFuc3BvcnQpO1xuICAgICAgICAvKiBHcmFjZWZ1bGx5IHRlcm1pbmF0ZSBleGlzdGluZyBwcm90b2NvbCAqL1xuICAgICAgICBpZiAoZXhpc3RpbmdBY3RpdmVQcm90b2NvbCkge1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wubWVzc2FnZVF1ZXVlLmNvdW50KCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLyogV2UgY291bGQganVzdCByZXF1ZXVlIHBlbmRpbmcgbWVzc2FnZXMgb24gdGhlIG5ldyB0cmFuc3BvcnQsIGJ1dFxuICAgICAgICAgICAgICAgICAqIGFjdHVhbGx5IHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbjogdHJhbnNwb3J0cyBzaG91bGQgb25seSB0YWtlIG92ZXJcbiAgICAgICAgICAgICAgICAgKiBmcm9tIG90aGVyIGFjdGl2ZSB0cmFuc3BvcnRzIHdoZW4gdXBncmFkaW5nLCBhbmQgdXBncmFkaW5nIHdhaXRzIGZvclxuICAgICAgICAgICAgICAgICAqIHRoZSBvbGQgdHJhbnNwb3J0IHRvIGJlIGlkbGUuIFNvIGxvZyBhbiBlcnJvci4gKi9cbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnUHJldmlvdXMgYWN0aXZlIHByb3RvY29sIChmb3IgdHJhbnNwb3J0ICcgK1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0FjdGl2ZVByb3RvY29sLnRyYW5zcG9ydC5zaG9ydE5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAnLCBuZXcgb25lIGlzICcgK1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc2hvcnROYW1lICtcbiAgICAgICAgICAgICAgICAgICAgJykgZmluaXNoaW5nIHdpdGggJyArXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wubWVzc2FnZVF1ZXVlLmNvdW50KCkgK1xuICAgICAgICAgICAgICAgICAgICAnIG1lc3NhZ2VzIHN0aWxsIHBlbmRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleGlzdGluZ0FjdGl2ZVByb3RvY29sLnRyYW5zcG9ydCA9PT0gdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdBc3N1bXB0aW9uIHZpb2xhdGVkOiBhY3RpdmF0aW5nIGEgdHJhbnNwb3J0IHRoYXQgd2FzIGFsc28gdGhlIHRyYW5zcG9ydCBmb3IgdGhlIHByZXZpb3VzIGFjdGl2ZSBwcm90b2NvbDsgdHJhbnNwb3J0ID0gJyArXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zaG9ydE5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAnOyBzdGFjayA9ICcgK1xuICAgICAgICAgICAgICAgICAgICBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCBtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdBY3RpdmVQcm90b2NvbC5maW5pc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBUZXJtaW5hdGUgYW55IG90aGVyIHBlbmRpbmcgdHJhbnNwb3J0KHMpLCBhbmRcbiAgICAgICAgICogYWJvcnQgYW55IG5vdC15ZXQtcGVuZGluZyB0cmFuc3BvcnQgYXR0ZW1wdHMgKi9cbiAgICAgICAgVXRpbHMuc2FmZUFyckZvckVhY2godGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgZnVuY3Rpb24gKHBlbmRpbmdUcmFuc3BvcnQpIHtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nVHJhbnNwb3J0ID09PSB0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ0Fzc3VtcHRpb24gdmlvbGF0ZWQ6IGFjdGl2YXRpbmcgYSB0cmFuc3BvcnQgdGhhdCBpcyBzdGlsbCBtYXJrZWQgYXMgYSBwZW5kaW5nIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zaG9ydE5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAnOyBzdGFjayA9ICcgK1xuICAgICAgICAgICAgICAgICAgICBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCBtc2cpO1xuICAgICAgICAgICAgICAgIFV0aWxzLmFyckRlbGV0ZVZhbHVlKF90aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ1RyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBVdGlscy5zYWZlQXJyRm9yRWFjaCh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cywgZnVuY3Rpb24gKHByb3Bvc2VkVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBpZiAocHJvcG9zZWRUcmFuc3BvcnQgPT09IHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdBc3N1bXB0aW9uIHZpb2xhdGVkOiBhY3RpdmF0aW5nIGEgdHJhbnNwb3J0IHRoYXQgaXMgc3RpbGwgbWFya2VkIGFzIGEgcHJvcG9zZWQgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNob3J0TmFtZSArXG4gICAgICAgICAgICAgICAgICAgICc7IHN0YWNrID0gJyArXG4gICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcigpLnN0YWNrKTtcbiAgICAgICAgICAgICAgICBVdGlscy5hcnJEZWxldGVWYWx1ZShfdGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9wb3NlZFRyYW5zcG9ydC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGlzIG5vIGxvbmdlciB0aGUgYWN0aXZlIHRyYW5zcG9ydC4gVGhpcyBjYW4gb2NjdXJcbiAgICAgKiBpbiBhbnkgdHJhbnNwb3J0IGNvbm5lY3Rpb24gc3RhdGUuXG4gICAgICogQHBhcmFtIHRyYW5zcG9ydFxuICAgICAqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kZWFjdGl2YXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydCwgc3RhdGUsIGVycm9yKSB7XG4gICAgICAgIHZhciBjdXJyZW50UHJvdG9jb2wgPSB0aGlzLmFjdGl2ZVByb3RvY29sLCB3YXNBY3RpdmUgPSBjdXJyZW50UHJvdG9jb2wgJiYgY3VycmVudFByb3RvY29sLmdldFRyYW5zcG9ydCgpID09PSB0cmFuc3BvcnQsIHdhc1BlbmRpbmcgPSBVdGlscy5hcnJEZWxldGVWYWx1ZSh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCB0cmFuc3BvcnQpLCB3YXNQcm9wb3NlZCA9IFV0aWxzLmFyckRlbGV0ZVZhbHVlKHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLCB0cmFuc3BvcnQpLCBub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uID0gdGhpcy5ub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uKCk7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ3RyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICdzdGF0ZSA9ICcgK1xuICAgICAgICAgICAgc3RhdGUgK1xuICAgICAgICAgICAgKHdhc0FjdGl2ZSA/ICc7IHdhcyBhY3RpdmUnIDogd2FzUGVuZGluZyA/ICc7IHdhcyBwZW5kaW5nJyA6IHdhc1Byb3Bvc2VkID8gJzsgd2FzIHByb3Bvc2VkJyA6ICcnKSArXG4gICAgICAgICAgICAobm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbiA/ICcnIDogJzsgYW5vdGhlciB0cmFuc3BvcnQgaXMgc2NoZWR1bGVkIGZvciBhY3RpdmF0aW9uJykpO1xuICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ3JlYXNvbiA9ICAnICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIGlmICh3YXNBY3RpdmUpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ0dldHRpbmcsIGNsZWFyaW5nLCBhbmQgcmVxdWV1aW5nICcgK1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wubWVzc2FnZVF1ZXVlLmNvdW50KCkgK1xuICAgICAgICAgICAgICAgICcgcGVuZGluZyBtZXNzYWdlcycpO1xuICAgICAgICAgICAgdGhpcy5xdWV1ZVBlbmRpbmdNZXNzYWdlcyhjdXJyZW50UHJvdG9jb2wuZ2V0UGVuZGluZ01lc3NhZ2VzKCkpO1xuICAgICAgICAgICAgLyogQ2xlYXIgYW55IG1lc3NhZ2VzIHdlIHJlcXVldWUgdG8gYWxsb3cgdGhlIHByb3RvY29sIHRvIGJlY29tZSBpZGxlLlxuICAgICAgICAgICAgICogSW4gY2FzZSBvZiBhbiB1cGdyYWRlLCB0aGlzIHdpbGwgdHJpZ2dlciBhbiBpbW1lZGlhdGUgYWN0aXZhdGlvbiBvZlxuICAgICAgICAgICAgICogdGhlIHVwZ3JhZGUgdHJhbnNwb3J0LCBzbyBkZWxheSBhIHRpY2sgc28gdGhpcyB0cmFuc3BvcnQgY2FuIGZpbmlzaFxuICAgICAgICAgICAgICogZGVhY3RpdmF0aW5nICovXG4gICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvdG9jb2wuY2xlYXJQZW5kaW5nTWVzc2FnZXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVQcm90b2NvbCA9IHRoaXMuaG9zdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCd0cmFuc3BvcnQuaW5hY3RpdmUnLCB0cmFuc3BvcnQpO1xuICAgICAgICAvKiB0aGlzIHRyYW5zcG9ydCBzdGF0ZSBjaGFuZ2UgaXMgYSBzdGF0ZSBjaGFuZ2UgZm9yIHRoZSBjb25uZWN0aW9ubWFuYWdlciBpZlxuICAgICAgICAgKiAtIHRoZSB0cmFuc3BvcnQgd2FzIHRoZSBhY3RpdmUgdHJhbnNwb3J0IGFuZCB0aGVyZSBhcmUgbm8gdHJhbnNwb3J0c1xuICAgICAgICAgKiAgIHdoaWNoIGFyZSBjb25uZWN0ZWQgYW5kIHNjaGVkdWxlZCBmb3IgYWN0aXZhdGlvbiwganVzdCB3YWl0aW5nIGZvciB0aGVcbiAgICAgICAgICogICBhY3RpdmUgdHJhbnNwb3J0IHRvIGZpbmlzaCB3aGF0IGl0cyBkb2luZzsgb3JcbiAgICAgICAgICogLSB0aGUgdHJhbnNwb3J0IHdhcyB0aGUgYWN0aXZlIHRyYW5zcG9ydCBhbmQgdGhlIGVycm9yIHdhcyBmYXRhbCAoc29cbiAgICAgICAgICogICB1bmhlYWxhYmxlIGJ5IGFub3RoZXIgdHJhbnNwb3J0KTsgb3JcbiAgICAgICAgICogLSB0aGVyZSBpcyBubyBhY3RpdmUgdHJhbnNwb3J0LCBhbmQgdGhpcyBpcyB0aGUgbGFzdCByZW1haW5pbmdcbiAgICAgICAgICogICBwZW5kaW5nIHRyYW5zcG9ydCAoc28gd2Ugd2VyZSBpbiB0aGUgY29ubmVjdGluZyBzdGF0ZSlcbiAgICAgICAgICovXG4gICAgICAgIGlmICgod2FzQWN0aXZlICYmIG5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24pIHx8XG4gICAgICAgICAgICAod2FzQWN0aXZlICYmIHN0YXRlID09PSAnZmFpbGVkJykgfHxcbiAgICAgICAgICAgIHN0YXRlID09PSAnY2xvc2VkJyB8fFxuICAgICAgICAgICAgKGN1cnJlbnRQcm90b2NvbCA9PT0gbnVsbCAmJiB3YXNQZW5kaW5nICYmIHRoaXMucGVuZGluZ1RyYW5zcG9ydHMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgLyogSWYgd2UncmUgZGlzY29ubmVjdGVkIHdpdGggYSA1eHggd2UgbmVlZCB0byB0cnkgZmFsbGJhY2sgaG9zdHNcbiAgICAgICAgICAgICAqIChSVE4xNGQpLCBidXQgKGEpIGR1ZSB0byBob3cgdGhlIHVwZ3JhZGUgc2VxdWVuY2Ugd29ya3MsIHRoZVxuICAgICAgICAgICAgICogaG9zdC90cmFuc3BvcnQgc2VsZWN0aW9uIHNlcXVlbmNlIG9ubHkgY2FyZXMgYWJvdXQgZ2V0dGluZyB0b1xuICAgICAgICAgICAgICogYHByZWNvbm5lY3RgIChlZyBlc3RhYmxpc2hpbmcgYSB3ZWJzb2NrZXQpIGdldHRpbmcgYSBgZGlzY29ubmVjdGVkYFxuICAgICAgICAgICAgICogcHJvdG9jb2wgbWVzc2FnZSBhZnRlcndhcmRzIGlzIHRvbyBsYXRlOyBhbmQgKGIpIGhvc3QgcmV0cnkgb25seVxuICAgICAgICAgICAgICogYXBwbGllcyB0byBjb25uZWN0QmFzZSB1bmxlc3MgdGhlIHN0b3JlZCBwcmVmZXJlbmNlIHRyYW5zcG9ydCBkb2Vzbid0XG4gICAgICAgICAgICAgKiB3b3JrLiBXZSBzb2x2ZSB0aGlzIGJ5IHVucGVyc2lzdGluZyB0aGUgdHJhbnNwb3J0IHByZWZlcmVuY2UgYW5kXG4gICAgICAgICAgICAgKiBzZXR0aW5nIGFuIGluc3RhbmNlIHZhcmlhYmxlIHRvIGZvcmNlIGZhbGxiYWNrIGhvc3RzIHRvIGJlIHVzZWQgKGlmXG4gICAgICAgICAgICAgKiBhbnkpIGhlcmUuIEJpdCBvZiBhIGtsdWRnZSwgYnV0IG5vIHJlYWwgYmV0dGVyIGFsdGVybmF0aXZlcyB3aXRob3V0XG4gICAgICAgICAgICAgKiByZXdyaXRpbmcgdGhlIGVudGlyZSB0aGluZyAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyAmJiBlcnJvciAmJiBlcnJvci5zdGF0dXNDb2RlID4gNTAwICYmIHRoaXMuaHR0cEhvc3RzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcmNlRmFsbGJhY2tIb3N0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvKiBhbmQgdHJ5IHRvIGNvbm5lY3QgYWdhaW4gdG8gdHJ5IGEgZmFsbGJhY2sgaG9zdCB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSB1c3VhbCAxNXMgZGlzY29ubmVjdGVkUmV0cnlUaW1lb3V0ICovXG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBzdGF0ZSwgZXJyb3I6IGVycm9yLCByZXRyeUltbWVkaWF0ZWx5OiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFRPRE8gcmVtb3ZlIGJlbG93IGxpbmUgb25jZSByZWFsdGltZSBzZW5kcyB0b2tlbiBlcnJvcnMgYXMgRElTQ09OTkVDVEVEcyAqL1xuICAgICAgICAgICAgdmFyIG5ld0Nvbm5lY3Rpb25TdGF0ZSA9IHN0YXRlID09PSAnZmFpbGVkJyAmJiBhdXRoXzEuZGVmYXVsdC5pc1Rva2VuRXJyKGVycm9yKSA/ICdkaXNjb25uZWN0ZWQnIDogc3RhdGU7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IG5ld0Nvbm5lY3Rpb25TdGF0ZSwgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3YXNBY3RpdmUgJiYgc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnICYmIHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLnN5bmNocm9uaXppbmcpIHtcbiAgICAgICAgICAgIC8qIElmIHdlIHdlcmUgYWN0aXZlIGJ1dCB0aGVyZSBpcyBhbm90aGVyIHRyYW5zcG9ydCBzY2hlZHVsZWQgZm9yXG4gICAgICAgICAgICAgKiBhY3RpdmF0aW9uLCBnbyBpbnRvIHRvIHRoZSBjb25uZWN0aW5nIHN0YXRlIHVudGlsIHRoYXQgdHJhbnNwb3J0XG4gICAgICAgICAgICAgKiBhY3RpdmF0ZXMgYW5kIHNldHMgdXMgYmFjayB0byBjb25uZWN0ZWQuIChtYW51YWxseSBzdGFydGluZyB0aGVcbiAgICAgICAgICAgICAqIHRyYW5zaXRpb24gdGltZXJzIGluIGNhc2UgdGhhdCBuZXZlciBoYXBwZW5zKS4gKElmIHdlIHdlcmUgaW4gdGhlXG4gICAgICAgICAgICAgKiBzeW5jaHJvbml6aW5nIHN0YXRlLCB0aGVuIHRoYXQncyBmaW5lLCB0aGUgb2xkIHRyYW5zcG9ydCBqdXN0IGdvdCBpdHNcbiAgICAgICAgICAgICAqIGRpc2Nvbm5lY3RlZCBiZWZvcmUgdGhlIG5ldyBvbmUgZ290IHRoZSBzeW5jIC0tIGlnbm9yZSBpdCBhbmQga2VlcFxuICAgICAgICAgICAgICogd2FpdGluZyBmb3IgdGhlIHN5bmMuIElmIGl0IGZhaWxzIHdlIGhhdmUgYSBzZXBhcmF0ZSBzeW5jIHRpbWVyIHRoYXRcbiAgICAgICAgICAgICAqIHdpbGwgZXhwaXJlKS4gKi9cbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ3dhc0FjdGl2ZSBidXQgYW5vdGhlciB0cmFuc3BvcnQgaXMgY29ubmVjdGVkIGFuZCBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb24sIHNvIGdvaW5nIGludG8gdGhlIGNvbm5lY3Rpbmcgc3RhdGUgdW50aWwgaXQgYWN0aXZhdGVzJyk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0U3VzcGVuZFRpbWVyKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0VHJhbnNpdGlvblRpbWVyKHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiAnY29ubmVjdGluZycsIGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyogSGVscGVyIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBubyB0cmFuc3BvcnRzIHdoaWNoIGFyZSBwZW5kaW5nLFxuICAgICAqIGhhdmUgYmVlbiBjb25uZWN0ZWQsIGFuZCBhcmUganVzdCB3YWl0aW5nIGZvciBvbmNlTm9QZW5kaW5nIHRvIGZpcmUgYmVmb3JlXG4gICAgICogYmVpbmcgYWN0aXZhdGVkICovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoVXRpbHMuaXNFbXB0eSh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzKSB8fFxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5ldmVyeShmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0cmFuc3BvcnQuaXNDb25uZWN0ZWQ7XG4gICAgICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uIChjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBoYXNDb25uZWN0aW9uRXJyb3IpIHtcbiAgICAgICAgLyogaWYgY29ubmVjdGlvbktleSBjaGFuZ2VzIGJ1dCBjb25uZWN0aW9uSWQgc3RheXMgdGhlIHNhbWUsIHRoZW4ganVzdCBhXG4gICAgICAgICAqIHRyYW5zcG9ydCBjaGFuZ2Ugb24gdGhlIHNhbWUgY29ubmVjdGlvbi4gSWYgY29ubmVjdGlvbklkIGNoYW5nZXMsIHdlJ3JlXG4gICAgICAgICAqIG9uIGEgbmV3IGNvbm5lY3Rpb24sIHdpdGggaW1wbGljYXRpb25zIGZvciBtc2dTZXJpYWwgYW5kIGNoYW5uZWwgc3RhdGUgKi9cbiAgICAgICAgLyogSWYgbm8gcHJldmlvdXMgY29ubmVjdGlvbklkLCBkb24ndCByZXNldCB0aGUgbXNnU2VyaWFsIGFzIGl0IG1heSBoYXZlXG4gICAgICAgICAqIGJlZW4gc2V0IGJ5IHJlY292ZXIgZGF0YSAodW5sZXNzIHRoZSByZWNvdmVyIGZhaWxlZCkgKi9cbiAgICAgICAgdmFyIHByZXZDb25uSWQgPSB0aGlzLmNvbm5lY3Rpb25JZCwgY29ubklkQ2hhbmdlZCA9IHByZXZDb25uSWQgJiYgcHJldkNvbm5JZCAhPT0gY29ubmVjdGlvbklkLCByZWNvdmVyRmFpbHVyZSA9ICFwcmV2Q29ubklkICYmIGhhc0Nvbm5lY3Rpb25FcnJvcjtcbiAgICAgICAgaWYgKGNvbm5JZENoYW5nZWQgfHwgcmVjb3ZlckZhaWx1cmUpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2V0Q29ubmVjdGlvbigpJywgJ1Jlc2V0dGluZyBtc2dTZXJpYWwnKTtcbiAgICAgICAgICAgIHRoaXMubXNnU2VyaWFsID0gMDtcbiAgICAgICAgICAgIC8vIFJUTjE5YTI6IEluIHRoZSBldmVudCBvZiBhIG5ldyBjb25uZWN0aW9uSWQsIHByZXZpb3VzIG1zZ1NlcmlhbHMgYXJlXG4gICAgICAgICAgICAvLyBtZWFuaW5nbGVzcy5cbiAgICAgICAgICAgIHRoaXMucXVldWVkTWVzc2FnZXMucmVzZXRTZW5kQXR0ZW1wdGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbklkICE9PSBjb25uZWN0aW9uSWQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2V0Q29ubmVjdGlvbigpJywgJ05ldyBjb25uZWN0aW9uSWQ7IHJlYXR0YWNoaW5nIGFueSBhdHRhY2hlZCBjaGFubmVscycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5pZCA9IHRoaXMuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuICAgICAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24ua2V5ID0gdGhpcy5jb25uZWN0aW9uS2V5ID0gY29ubmVjdGlvbkRldGFpbHMuY29ubmVjdGlvbktleTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbGVhckNvbm5lY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5pZCA9IHRoaXMuY29ubmVjdGlvbklkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24ua2V5ID0gdGhpcy5jb25uZWN0aW9uS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm1zZ1NlcmlhbCA9IDA7XG4gICAgICAgIHRoaXMudW5wZXJzaXN0Q29ubmVjdGlvbigpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZVJlY292ZXJ5S2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBSVE4xNmcyLlxuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGlvbktleSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25LZXk6IHRoaXMuY29ubmVjdGlvbktleSxcbiAgICAgICAgICAgIG1zZ1NlcmlhbDogdGhpcy5tc2dTZXJpYWwsXG4gICAgICAgICAgICBjaGFubmVsU2VyaWFsczogdGhpcy5yZWFsdGltZS5jaGFubmVscy5jaGFubmVsU2VyaWFscygpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jaGVja0Nvbm5lY3Rpb25TdGF0ZUZyZXNobmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxhc3RBY3Rpdml0eSB8fCAhdGhpcy5jb25uZWN0aW9uSWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2luY2VMYXN0ID0gVXRpbHMubm93KCkgLSB0aGlzLmxhc3RBY3Rpdml0eTtcbiAgICAgICAgaWYgKHNpbmNlTGFzdCA+IHRoaXMuY29ubmVjdGlvblN0YXRlVHRsICsgdGhpcy5tYXhJZGxlSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY2hlY2tDb25uZWN0aW9uU3RhdGVGcmVzaG5lc3MoKScsICdMYXN0IGtub3duIGFjdGl2aXR5IGZyb20gcmVhbHRpbWUgd2FzICcgKyBzaW5jZUxhc3QgKyAnbXMgYWdvOyBkaXNjYXJkaW5nIGNvbm5lY3Rpb24gc3RhdGUnKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9ICdzdXNwZW5kZWQnO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbm1hbmFnZXIgd2FudHMgdG8gcGVyc2lzdCB0cmFuc3BvcnRcbiAgICAgKiBzdGF0ZSBmb3IgbGF0ZXIgcmVjb3ZlcnkuIE9ubHkgYXBwbGljYWJsZSBpbiB0aGUgYnJvd3NlciBjb250ZXh0LlxuICAgICAqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5wZXJzaXN0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGhhdmVTZXNzaW9uU3RvcmFnZSgpKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3ZlcnlLZXkgPSB0aGlzLmNyZWF0ZVJlY292ZXJ5S2V5KCk7XG4gICAgICAgICAgICBpZiAocmVjb3ZlcnlLZXkpIHtcbiAgICAgICAgICAgICAgICBzZXRTZXNzaW9uUmVjb3ZlckRhdGEoe1xuICAgICAgICAgICAgICAgICAgICByZWNvdmVyeUtleTogcmVjb3ZlcnlLZXksXG4gICAgICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3RlZEF0OiBVdGlscy5ub3coKSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGdsb2JhbC5sb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMucmVhbHRpbWUuYXV0aC5jbGllbnRJZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbm5lY3Rpb25tYW5hZ2VyIHdhbnRzIHRvIHBlcnNpc3QgdHJhbnNwb3J0XG4gICAgICogc3RhdGUgZm9yIGxhdGVyIHJlY292ZXJ5LiBPbmx5IGFwcGxpY2FibGUgaW4gdGhlIGJyb3dzZXIgY29udGV4dC5cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUudW5wZXJzaXN0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJTZXNzaW9uUmVjb3ZlckRhdGEoKTtcbiAgICB9O1xuICAgIC8qKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBzdGF0ZSBtYW5hZ2VtZW50XG4gICAgICoqKioqKioqKioqKioqKioqKioqKi9cbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yUmVhc29uIHx8IHRoaXMuZ2V0U3RhdGVFcnJvcigpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFN0YXRlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBjb25uZWN0aW9uZXJyb3JzXzEuZGVmYXVsdClbdGhpcy5zdGF0ZS5zdGF0ZV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5hY3RpdmVTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucXVldWVFdmVudHMgfHwgdGhpcy5zdGF0ZS5zZW5kRXZlbnRzO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmVuYWN0U3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiAoc3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgdmFyIGxvZ0xldmVsID0gc3RhdGVDaGFuZ2UuY3VycmVudCA9PT0gJ2ZhaWxlZCcgPyBsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiA6IGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01BSk9SO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dMZXZlbCwgJ0Nvbm5lY3Rpb24gc3RhdGUnLCBzdGF0ZUNoYW5nZS5jdXJyZW50ICsgKHN0YXRlQ2hhbmdlLnJlYXNvbiA/ICc7IHJlYXNvbjogJyArIHN0YXRlQ2hhbmdlLnJlYXNvbiA6ICcnKSk7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZW5hY3RTdGF0ZUNoYW5nZScsICdzZXR0aW5nIG5ldyBzdGF0ZTogJyArXG4gICAgICAgICAgICBzdGF0ZUNoYW5nZS5jdXJyZW50ICtcbiAgICAgICAgICAgICc7IHJlYXNvbiA9ICcgK1xuICAgICAgICAgICAgKHN0YXRlQ2hhbmdlLnJlYXNvbiAmJiBzdGF0ZUNoYW5nZS5yZWFzb24ubWVzc2FnZSkpO1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSAodGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzW3N0YXRlQ2hhbmdlLmN1cnJlbnRdKTtcbiAgICAgICAgaWYgKHN0YXRlQ2hhbmdlLnJlYXNvbikge1xuICAgICAgICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHN0YXRlQ2hhbmdlLnJlYXNvbjtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IHN0YXRlQ2hhbmdlLnJlYXNvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3U3RhdGUudGVybWluYWwgfHwgbmV3U3RhdGUuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgICAgICAvKiBzdXNwZW5kZWQgaXMgbm9udGVybWluYWwsIGJ1dCBvbmNlIGluIHRoZSBzdXNwZW5kZWQgc3RhdGUsIHJlYWx0aW1lXG4gICAgICAgICAgICAgKiB3aWxsIGhhdmUgZGlzY2FyZGVkIG91ciBjb25uZWN0aW9uIHN0YXRlLCBzbyBmdXRoZXIgY29ubmVjdGlvblxuICAgICAgICAgICAgICogYXR0ZW1wdHMgc2hvdWxkIHN0YXJ0IGZyb20gc2NyYXRjaCAqL1xuICAgICAgICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3Rpb25zdGF0ZScsIHN0YXRlQ2hhbmdlKTtcbiAgICB9O1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogQ29ubmVjdGlvbk1hbmFnZXIgY29ubmVjdGlvbiBsaWZlY3ljbGVcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc3RhcnRUcmFuc2l0aW9uVGltZXIgPSBmdW5jdGlvbiAodHJhbnNpdGlvblN0YXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRUcmFuc2l0aW9uVGltZXIoKScsICd0cmFuc2l0aW9uU3RhdGU6ICcgKyB0cmFuc2l0aW9uU3RhdGUuc3RhdGUpO1xuICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uVGltZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRUcmFuc2l0aW9uVGltZXIoKScsICdjbGVhcmluZyBhbHJlYWR5LXJ1bm5pbmcgdGltZXInKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRyYW5zaXRpb25UaW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFuc2l0aW9uVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy50cmFuc2l0aW9uVGltZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50cmFuc2l0aW9uVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIgJyArIHRyYW5zaXRpb25TdGF0ZS5zdGF0ZSArICcgdGltZXIgZXhwaXJlZCcsICdyZXF1ZXN0aW5nIG5ldyBzdGF0ZTogJyArIHRyYW5zaXRpb25TdGF0ZS5mYWlsU3RhdGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IHRyYW5zaXRpb25TdGF0ZS5mYWlsU3RhdGUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRyYW5zaXRpb25TdGF0ZS5yZXRyeURlbGF5KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jYW5jZWxUcmFuc2l0aW9uVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY2FuY2VsVHJhbnNpdGlvblRpbWVyKCknLCAnJyk7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25UaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudHJhbnNpdGlvblRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnN0YXJ0U3VzcGVuZFRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zdXNwZW5kVGltZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc3VzcGVuZFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3VzcGVuZFRpbWVyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3VzcGVuZFRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyIHN1c3BlbmQgdGltZXIgZXhwaXJlZCcsICdyZXF1ZXN0aW5nIG5ldyBzdGF0ZTogc3VzcGVuZGVkJyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlID0gJ3N1c3BlbmRlZCc7XG4gICAgICAgICAgICAgICAgX3RoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogJ3N1c3BlbmRlZCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuY29ubmVjdGlvblN0YXRlVHRsKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jaGVja1N1c3BlbmRUaW1lciA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUgIT09ICdkaXNjb25uZWN0ZWQnICYmIHN0YXRlICE9PSAnc3VzcGVuZGVkJyAmJiBzdGF0ZSAhPT0gJ2Nvbm5lY3RpbmcnKVxuICAgICAgICAgICAgdGhpcy5jYW5jZWxTdXNwZW5kVGltZXIoKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jYW5jZWxTdXNwZW5kVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlID0gJ2Rpc2Nvbm5lY3RlZCc7XG4gICAgICAgIGlmICh0aGlzLnN1c3BlbmRUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc3VzcGVuZFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuc3VzcGVuZFRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnN0YXJ0UmV0cnlUaW1lciA9IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJldHJ5VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIgcmV0cnkgdGltZXIgZXhwaXJlZCcsICdyZXRyeWluZycpO1xuICAgICAgICAgICAgX3RoaXMucmV0cnlUaW1lciA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogJ2Nvbm5lY3RpbmcnIH0pO1xuICAgICAgICB9LCBpbnRlcnZhbCk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2FuY2VsUmV0cnlUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmV0cnlUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUubm90aWZ5U3RhdGUgPSBmdW5jdGlvbiAoaW5kaWNhdGVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBzdGF0ZSA9IGluZGljYXRlZC5zdGF0ZTtcbiAgICAgICAgLyogV2UgcmV0cnkgaW1tZWRpYXRlbHkgaWY6XG4gICAgICAgICAqIC0gc29tZXRoaW5nIGRpc2Nvbm5lY3RzIHVzIHdoaWxlIHdlJ3JlIGNvbm5lY3RlZCwgb3JcbiAgICAgICAgICogLSBhIHZpYWJsZSAoYnV0IG5vdCB5ZXQgYWN0aXZlKSB0cmFuc3BvcnQgZmFpbHMgZHVlIHRvIGEgdG9rZW4gZXJyb3IgKHNvXG4gICAgICAgICAqICAgdGhpcy5lcnJvclJlYXNvbiB3aWxsIGJlIHNldCwgYW5kIHN0YXJ0Q29ubmVjdCB3aWxsIGRvIGEgZm9yY2VkXG4gICAgICAgICAqICAgYXV0aG9yaXplKS4gSWYgdGhpcy5lcnJvclJlYXNvbiBpcyBhbHJlYWR5IHNldCAodG8gYSB0b2tlbiBlcnJvciksXG4gICAgICAgICAqICAgdGhlbiB0aGVyZSBoYXMgYmVlbiBhdCBsZWFzdCBvbmUgcHJldmlvdXMgYXR0ZW1wdCB0byBjb25uZWN0IHRoYXQgYWxzb1xuICAgICAgICAgKiAgIGZhaWxlZCBmb3IgYSB0b2tlbiBlcnJvciwgc28gYnkgUlROMTRiIHdlIGdvIHRvIERJU0NPTk5FQ1RFRCBhbmQgd2FpdFxuICAgICAgICAgKiAgIGJlZm9yZSB0cnlpbmcgYWdhaW4gKi9cbiAgICAgICAgdmFyIHJldHJ5SW1tZWRpYXRlbHkgPSBzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgJiZcbiAgICAgICAgICAgICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nIHx8XG4gICAgICAgICAgICAgICAgaW5kaWNhdGVkLnJldHJ5SW1tZWRpYXRlbHkgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZyAmJlxuICAgICAgICAgICAgICAgICAgICBpbmRpY2F0ZWQuZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgYXV0aF8xLmRlZmF1bHQuaXNUb2tlbkVycihpbmRpY2F0ZWQuZXJyb3IpICYmXG4gICAgICAgICAgICAgICAgICAgICEodGhpcy5lcnJvclJlYXNvbiAmJiBhdXRoXzEuZGVmYXVsdC5pc1Rva2VuRXJyKHRoaXMuZXJyb3JSZWFzb24pKSkpO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm5vdGlmeVN0YXRlKCknLCAnbmV3IHN0YXRlOiAnICsgc3RhdGUgKyAocmV0cnlJbW1lZGlhdGVseSA/ICc7IHdpbGwgcmV0cnkgY29ubmVjdGlvbiBpbW1lZGlhdGVseScgOiAnJykpO1xuICAgICAgICAvKiBkbyBub3RoaW5nIGlmIHdlJ3JlIGFscmVhZHkgaW4gdGhlIGluZGljYXRlZCBzdGF0ZSAqL1xuICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5zdGF0ZS5zdGF0ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLyoga2lsbCB0aW1lcnMgKHBvc3NpYmx5IGV4Y2VwdGluZyBzdXNwZW5kIHRpbWVyIGRlcGVuZGluZyBvbiB0aGUgbm90aWZpZWRcbiAgICAgICAgICogc3RhdGUpLCBhcyB0aGVzZSBhcmUgc3VwZXJzZWRlZCBieSB0aGlzIG5vdGlmaWNhdGlvbiAqL1xuICAgICAgICB0aGlzLmNhbmNlbFRyYW5zaXRpb25UaW1lcigpO1xuICAgICAgICB0aGlzLmNhbmNlbFJldHJ5VGltZXIoKTtcbiAgICAgICAgdGhpcy5jaGVja1N1c3BlbmRUaW1lcihpbmRpY2F0ZWQuc3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdzdXNwZW5kZWQnIHx8IHN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0ZWRSZXRyeUNvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvKiBkbyBub3RoaW5nIGlmIHdlJ3JlIHVuYWJsZSB0byBtb3ZlIGZyb20gdGhlIGN1cnJlbnQgc3RhdGUgKi9cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudGVybWluYWwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8qIHByb2Nlc3MgbmV3IHN0YXRlICovXG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IHRoaXMuc3RhdGVzW2luZGljYXRlZC5zdGF0ZV07XG4gICAgICAgIHZhciByZXRyeURlbGF5ID0gbmV3U3RhdGUucmV0cnlEZWxheTtcbiAgICAgICAgaWYgKG5ld1N0YXRlLnN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0ZWRSZXRyeUNvdW50Kys7XG4gICAgICAgICAgICByZXRyeURlbGF5ID0gVXRpbHMuZ2V0UmV0cnlUaW1lKG5ld1N0YXRlLnJldHJ5RGVsYXksIHRoaXMuZGlzY29ubmVjdGVkUmV0cnlDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYW5nZSA9IG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfMS5kZWZhdWx0KHRoaXMuc3RhdGUuc3RhdGUsIG5ld1N0YXRlLnN0YXRlLCByZXRyeURlbGF5LCBpbmRpY2F0ZWQuZXJyb3IgfHwgKChfYiA9IChfYSA9IGNvbm5lY3Rpb25lcnJvcnNfMS5kZWZhdWx0KVtuZXdTdGF0ZS5zdGF0ZV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSkpO1xuICAgICAgICBpZiAocmV0cnlJbW1lZGlhdGVseSkge1xuICAgICAgICAgICAgdmFyIGF1dG9SZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlID09PSBfdGhpcy5zdGF0ZXMuZGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCA9IFV0aWxzLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogJ2Nvbm5lY3RpbmcnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgc2luY2VMYXN0ID0gdGhpcy5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgJiYgVXRpbHMubm93KCkgLSB0aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCArIDE7XG4gICAgICAgICAgICBpZiAoc2luY2VMYXN0ICYmIHNpbmNlTGFzdCA8IDEwMDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm5vdGlmeVN0YXRlKCknLCAnTGFzdCByZWNvbm5lY3QgYXR0ZW1wdCB3YXMgb25seSAnICtcbiAgICAgICAgICAgICAgICAgICAgc2luY2VMYXN0ICtcbiAgICAgICAgICAgICAgICAgICAgJ21zIGFnbywgd2FpdGluZyBhbm90aGVyICcgK1xuICAgICAgICAgICAgICAgICAgICAoMTAwMCAtIHNpbmNlTGFzdCkgK1xuICAgICAgICAgICAgICAgICAgICAnbXMgYmVmb3JlIHRyeWluZyBhZ2FpbicpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoYXV0b1JlY29ubmVjdCwgMTAwMCAtIHNpbmNlTGFzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGF1dG9SZWNvbm5lY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyB8fCBzdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRSZXRyeVRpbWVyKHJldHJ5RGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIC8qIElmIGdvaW5nIGludG8gZGlzY29ubmVjdC9zdXNwZW5kZWQgKGFuZCBub3QgcmV0cnlpbmcgaW1tZWRpYXRlbHkpLCBvciBhXG4gICAgICAgICAqIHRlcm1pbmFsIHN0YXRlLCBlbnN1cmUgdGhlcmUgYXJlIG5vIG9ycGhhbmVkIHRyYW5zcG9ydHMgaGFuZ2luZyBhcm91bmQuICovXG4gICAgICAgIGlmICgoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnICYmICFyZXRyeUltbWVkaWF0ZWx5KSB8fCBzdGF0ZSA9PT0gJ3N1c3BlbmRlZCcgfHwgbmV3U3RhdGUudGVybWluYWwpIHtcbiAgICAgICAgICAgIC8qIFdhaXQgdGlsbCB0aGUgbmV4dCB0aWNrIHNvIHRoZSBjb25uZWN0aW9uIHN0YXRlIGNoYW5nZSBpcyBlbmFjdGVkLFxuICAgICAgICAgICAgICogc28gYWJvcnRpbmcgdHJhbnNwb3J0cyBkb2Vzbid0IHRyaWdnZXIgcmVkdW5kYW50IHN0YXRlIGNoYW5nZXMgKi9cbiAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgPT0gJ2Nvbm5lY3RlZCcgJiYgIXRoaXMuYWN0aXZlUHJvdG9jb2wpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKScsICdCcm9rZW4gaW52YXJpYW50OiBhdHRlbXB0ZWQgdG8gZ28gaW50byBjb25uZWN0ZWQgc3RhdGUsIGJ1dCB0aGVyZSBpcyBubyBhY3RpdmUgcHJvdG9jb2wnKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpbXBsZW1lbnQgdGhlIGNoYW5nZSBhbmQgbm90aWZ5ICovXG4gICAgICAgIHRoaXMuZW5hY3RTdGF0ZUNoYW5nZShjaGFuZ2UpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRRdWV1ZWRNZXNzYWdlcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLnN0YXRlLnF1ZXVlRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLnByb3BvZ2F0ZUNvbm5lY3Rpb25JbnRlcnJ1cHRpb24oc3RhdGUsIGNoYW5nZS5yZWFzb24pO1xuICAgICAgICAgICAgdGhpcy5mYWlsUXVldWVkTWVzc2FnZXMoY2hhbmdlLnJlYXNvbik7IC8vIFJUTjdjXG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZXF1ZXN0U3RhdGUgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgc3RhdGUgPSByZXF1ZXN0LnN0YXRlO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnJlcXVlc3RTdGF0ZSgpJywgJ3JlcXVlc3RlZCBzdGF0ZTogJyArIHN0YXRlICsgJzsgY3VycmVudCBzdGF0ZTogJyArIHRoaXMuc3RhdGUuc3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUgPT0gdGhpcy5zdGF0ZS5zdGF0ZSlcbiAgICAgICAgICAgIHJldHVybjsgLyogc2lsZW50bHkgZG8gbm90aGluZyAqL1xuICAgICAgICAvKiBraWxsIHJ1bm5pbmcgdGltZXJzLCBhcyB0aGlzIHJlcXVlc3Qgc3VwZXJzZWRlcyB0aGVtICovXG4gICAgICAgIHRoaXMuY2FuY2VsVHJhbnNpdGlvblRpbWVyKCk7XG4gICAgICAgIHRoaXMuY2FuY2VsUmV0cnlUaW1lcigpO1xuICAgICAgICAvKiBmb3Igc3VzcGVuZCB0aW1lciBjaGVjayByYXRoZXIgdGhhbiBjYW5jZWwgLS0gZWcgcmVxdWVzdGluZyBhIGNvbm5lY3RpbmdcbiAgICAgICAgICogc3RhdGUgc2hvdWxkIG5vdCByZXNldCB0aGUgc3VzcGVuZCB0aW1lciAqL1xuICAgICAgICB0aGlzLmNoZWNrU3VzcGVuZFRpbWVyKHN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlID09ICdjb25uZWN0aW5nJyAmJiB0aGlzLnN0YXRlLnN0YXRlID09ICdjb25uZWN0ZWQnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoc3RhdGUgPT0gJ2Nsb3NpbmcnICYmIHRoaXMuc3RhdGUuc3RhdGUgPT0gJ2Nsb3NlZCcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IHRoaXMuc3RhdGVzW3N0YXRlXSwgY2hhbmdlID0gbmV3IGNvbm5lY3Rpb25zdGF0ZWNoYW5nZV8xLmRlZmF1bHQodGhpcy5zdGF0ZS5zdGF0ZSwgbmV3U3RhdGUuc3RhdGUsIG51bGwsIHJlcXVlc3QuZXJyb3IgfHwgKChfYiA9IChfYSA9IGNvbm5lY3Rpb25lcnJvcnNfMS5kZWZhdWx0KVtuZXdTdGF0ZS5zdGF0ZV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSkpO1xuICAgICAgICB0aGlzLmVuYWN0U3RhdGVDaGFuZ2UoY2hhbmdlKTtcbiAgICAgICAgaWYgKHN0YXRlID09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhcnRDb25uZWN0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgPT0gJ2Nsb3NpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlSW1wbCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc3RhcnRDb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZykge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zdGFydENvbm5lY3QoKScsICdNdXN0IGJlIGluIGNvbm5lY3Rpbmcgc3RhdGUgdG8gY29ubmVjdCwgYnV0IHdhcyAnICsgdGhpcy5zdGF0ZS5zdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF1dGggPSB0aGlzLnJlYWx0aW1lLmF1dGg7XG4gICAgICAgIC8qIFRoZSBwb2ludCBvZiB0aGUgY29ubmVjdENvdW50ZXIgbWVjaGFuaXNtIGlzIHRvIGVuc3VyZSB0aGF0IHRoZVxuICAgICAgICAgKiBjb25uZWN0aW9uIHByb2NlZHVyZSBjYW4gYmUgY2FuY2VsbGVkLiBXZSB3YW50IGRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzXG4gICAgICAgICAqIHRvIGJlIGFibGUgdG8gc3RvcCBhbnkgaW4tcHJvZ3Jlc3MgY29ubmVjdGlvbiwgZXZlbiBiZWZvcmUgaXQgZ2V0cyB0b1xuICAgICAgICAgKiB0aGUgc3RhZ2Ugb2YgaGF2aW5nIGEgcGVuZGluZyAob3IgZXZlbiBhIHByb3Bvc2VkKSB0cmFuc3BvcnQgdGhhdCBpdCBjYW5cbiAgICAgICAgICogZGlzcG9zZSgpIG9mLiBTbyB3ZSBjaGVjayB0aGF0IGl0J3Mgc3RpbGwgY3VycmVudCBhZnRlciBhbnkgYXN5bmMgc3RhZ2UsXG4gICAgICAgICAqIHVwIHVudGlsIHRoZSBzdGFnZSB0aGF0IGlzIHN5bmNocm9ub3VzIHdpdGggaW5zdGFudGlhdGluZyBhIHRyYW5zcG9ydCAqL1xuICAgICAgICB2YXIgY29ubmVjdENvdW50ID0gKyt0aGlzLmNvbm5lY3RDb3VudGVyO1xuICAgICAgICB2YXIgY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKCk7XG4gICAgICAgICAgICBfdGhpcy5nZXRUcmFuc3BvcnRQYXJhbXMoZnVuY3Rpb24gKHRyYW5zcG9ydFBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc3BvcnRQYXJhbXMubW9kZSA9PT0gJ3JlY292ZXInICYmIHRyYW5zcG9ydFBhcmFtcy5vcHRpb25zLnJlY292ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY292ZXJ5Q29udGV4dCA9IGRlY29kZVJlY292ZXJ5S2V5KHRyYW5zcG9ydFBhcmFtcy5vcHRpb25zLnJlY292ZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3ZlcnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWFsdGltZS5jaGFubmVscy5yZWNvdmVyQ2hhbm5lbHMocmVjb3ZlcnlDb250ZXh0LmNoYW5uZWxTZXJpYWxzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdENvdW50ICE9PSBfdGhpcy5jb25uZWN0Q291bnRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0Q29ubmVjdCgpJywgJ3N0YXJ0aW5nIGNvbm5lY3Rpb24nKTtcbiAgICAgICAgdGhpcy5zdGFydFN1c3BlbmRUaW1lcigpO1xuICAgICAgICB0aGlzLnN0YXJ0VHJhbnNpdGlvblRpbWVyKHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpO1xuICAgICAgICBpZiAoYXV0aC5tZXRob2QgPT09ICdiYXNpYycpIHtcbiAgICAgICAgICAgIGNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhdXRoQ2IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3RDb3VudCAhPT0gX3RoaXMuY29ubmVjdENvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVycm9yUmVhc29uICYmIGF1dGhfMS5kZWZhdWx0LmlzVG9rZW5FcnIodGhpcy5lcnJvclJlYXNvbikpIHtcbiAgICAgICAgICAgICAgICAvKiBGb3JjZSBhIHJlZmV0Y2ggb2YgYSBuZXcgdG9rZW4gKi9cbiAgICAgICAgICAgICAgICBhdXRoLl9mb3JjZU5ld1Rva2VuKG51bGwsIG51bGwsIGF1dGhDYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdXRoLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmYWxzZSwgYXV0aENiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlcmUgYXJlIHRocmVlIHN0YWdlcyBpbiBjb25uZWN0aW5nOlxuICAgICAqIC0gcHJlZmVyZW5jZTogaWYgdGhlcmUgaXMgYSBjYWNoZWQgdHJhbnNwb3J0IHByZWZlcmVuY2UsIHdlIHRyeSB0byBjb25uZWN0XG4gICAgICogICBvbiB0aGF0LiBJZiB0aGF0IGZhaWxzIG9yIHRpbWVzIG91dCB3ZSBhYm9ydCB0aGUgYXR0ZW1wdCwgcmVtb3ZlIHRoZVxuICAgICAqICAgcHJlZmVyZW5jZSBhbmQgZmFsbCBiYWNrIHRvIGJhc2UuIElmIGl0IHN1Y2NlZWRzLCB3ZSB0cnkgdXBncmFkaW5nIGl0IGlmXG4gICAgICogICBuZWVkZWQgKHdpbGwgb25seSBiZSBpbiB0aGUgY2FzZSB3aGVyZSB0aGUgcHJlZmVyZW5jZSBpcyB4aHJzIGFuZCB0aGVcbiAgICAgKiAgIGJyb3dzZXIgc3VwcG9ydHMgd3MpLlxuICAgICAqIC0gYmFzZTogd2UgdHJ5IHRvIGNvbm5lY3Qgd2l0aCB0aGUgYmVzdCB0cmFuc3BvcnQgdGhhdCB3ZSB0aGluayB3aWxsXG4gICAgICogICBuZXZlciBmYWlsIGZvciB0aGlzIGJyb3dzZXIgKHVzdWFsbHkgdGhpcyBpcyB4aHJfcG9sbGluZzsgZm9yIHZlcnkgb2xkXG4gICAgICogICBicm93c2VycyB3aWxsIGJlIGpzb25wLCBmb3Igbm9kZSB3aWxsIGJlIGNvbWV0KS4gSWYgaXQgZG9lc24ndCB3b3JrLCB3ZVxuICAgICAqICAgdHJ5IGZhbGxiYWNrIGhvc3RzLlxuICAgICAqIC0gdXBncmFkZTogZ2l2ZW4gYSBjb25uZWN0ZWQgdHJhbnNwb3J0LCB3ZSBzZWUgaWYgdGhlcmUgYXJlIGFueSBiZXR0ZXJcbiAgICAgKiAgIG9uZXMsIGFuZCBpZiBzbywgdHJ5IHRvIHVwZ3JhZGUgdG8gdGhlbS5cbiAgICAgKlxuICAgICAqIGNvbm5lY3RJbXBsIHdvcmtzIG91dCB3aGF0IHN0YWdlIHlvdSdyZSBhdCAod2hpY2ggaXMgcHVyZWx5IGEgZnVuY3Rpb24gb2ZcbiAgICAgKiB0aGUgY3VycmVudCBjb25uZWN0aW9uIHN0YXRlIGFuZCB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgc3RvcmVkIHByZWZlcmVuY2VzKSxcbiAgICAgKiBhbmQgZGlzcGF0Y2hlcyBhY2NvcmRpbmdseS4gQWZ0ZXIgYSB0cmFuc3BvcnQgaGFzIGJlZW4gc2V0IHBlbmRpbmcsXG4gICAgICogdHJ5QVRyYW5zcG9ydCBjYWxscyBjb25uZWN0SW1wbCB0byBzZWUgaWYgdGhlcmUncyBhbm90aGVyIHN0YWdlIHRvIGJlIGRvbmUuXG4gICAgICogKi9cbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdEltcGwgPSBmdW5jdGlvbiAodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZS5zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLnN0YXRlICYmIHN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpIHtcbiAgICAgICAgICAgIC8qIE9ubHkga2VlcCB0cnlpbmcgYXMgbG9uZyBhcyBpbiB0aGUgJ2Nvbm5lY3RpbmcnIHN0YXRlIChvciAnY29ubmVjdGVkJ1xuICAgICAgICAgICAgICogZm9yIHVwZ3JhZGluZykuIEFueSBvcGVyYXRpb24gY2FuIHB1dCB1cyBpbnRvICdkaXNjb25uZWN0ZWQnIHRvIGNhbmNlbFxuICAgICAgICAgICAgICogY29ubmVjdGlvbiBhdHRlbXB0cyBhbmQgd2FpdCBiZWZvcmUgcmV0cnlpbmcsIG9yICdmYWlsZWQnIHRvIGZhaWwuICovXG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RJbXBsKCknLCAnTXVzdCBiZSBpbiBjb25uZWN0aW5nIHN0YXRlIHRvIGNvbm5lY3QgKG9yIGNvbm5lY3RlZCB0byB1cGdyYWRlKSwgYnV0IHdhcyAnICsgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RJbXBsKCknLCAnVHJhbnNwb3J0cyAnICsgdGhpcy5wZW5kaW5nVHJhbnNwb3J0c1swXS50b1N0cmluZygpICsgJyBjdXJyZW50bHkgcGVuZGluZzsgdGFraW5nIG5vIGFjdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlID09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZC5zdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy51cGdyYWRlSWZOZWVkZWQodHJhbnNwb3J0UGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnRyYW5zcG9ydHMubGVuZ3RoID4gMSAmJiB0aGlzLmdldFRyYW5zcG9ydFByZWZlcmVuY2UoKSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0UHJlZmVyZW5jZSh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RCYXNlKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3RQcmVmZXJlbmNlID0gZnVuY3Rpb24gKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcmVmZXJlbmNlID0gdGhpcy5nZXRUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG4gICAgICAgIHZhciBwcmVmZXJlbmNlVGltZW91dEV4cGlyZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFVdGlscy5hcnJJbih0aGlzLnRyYW5zcG9ydHMsIHByZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICB0aGlzLnVucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UoKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdEltcGwodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdFByZWZlcmVuY2UoKScsICdUcnlpbmcgdG8gY29ubmVjdCB3aXRoIHN0b3JlZCB0cmFuc3BvcnQgcHJlZmVyZW5jZSAnICsgcHJlZmVyZW5jZSk7XG4gICAgICAgIHZhciBwcmVmZXJlbmNlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJlZmVyZW5jZVRpbWVvdXRFeHBpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghKF90aGlzLnN0YXRlLnN0YXRlID09PSBfdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdFByZWZlcmVuY2UoKScsICdTaG9ydGNpcmN1aXQgY29ubmVjdGlvbiBhdHRlbXB0IHdpdGggJyArIHByZWZlcmVuY2UgKyAnIGZhaWxlZDsgY2xlYXJpbmcgcHJlZmVyZW5jZSBhbmQgdHJ5aW5nIGZyb20gc2NyYXRjaCcpO1xuICAgICAgICAgICAgICAgIC8qIEFib3J0IGFsbCBjb25uZWN0aW9uIGF0dGVtcHRzLiAoVGhpcyBhbHNvIGRpc2Nvbm5lY3RzIHRoZSBhY3RpdmVcbiAgICAgICAgICAgICAgICAgKiBwcm90b2NvbCwgYnV0IG5vbmUgZXhpc3RzIGlmIHdlJ3JlIG5vdCBpbiB0aGUgY29ubmVjdGVkIHN0YXRlKSAqL1xuICAgICAgICAgICAgICAgIF90aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG4gICAgICAgICAgICAgICAgLyogQmUgcXVpdGUgYWdyZXNzaXZlIGFib3V0IGNsZWFyaW5nIHRoZSBzdG9yZWQgcHJlZmVyZW5jZSBpZiBldmVyIGl0IGRvZXNuJ3Qgd29yayAqL1xuICAgICAgICAgICAgICAgIF90aGlzLnVucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KTtcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLnRpbWVvdXRzLnByZWZlcmVuY2VDb25uZWN0VGltZW91dCk7XG4gICAgICAgIC8qIEZvciBjb25uZWN0UHJlZmVyZW5jZSwganVzdCB1c2UgdGhlIG1haW4gaG9zdC4gSWYgaG9zdCBmYWxsYmFjayBpcyBuZWVkZWQsIGRvIGl0IGluIGNvbm5lY3RCYXNlLlxuICAgICAgICAgKiBUaGUgd3N0cmFuc3BvcnQgaXQgd2lsbCBzdWJzdGl0dXRlIHRoZSBodHRwaG9zdCBmb3IgYW4gYXBwcm9wcmlhdGUgd3Nob3N0ICovXG4gICAgICAgIHRyYW5zcG9ydFBhcmFtcy5ob3N0ID0gdGhpcy5odHRwSG9zdHNbMF07XG4gICAgICAgIHRoaXMudHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIHByZWZlcmVuY2UsIGZ1bmN0aW9uIChmYXRhbCwgdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQocHJlZmVyZW5jZVRpbWVvdXQpO1xuICAgICAgICAgICAgaWYgKHByZWZlcmVuY2VUaW1lb3V0RXhwaXJlZCAmJiB0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAvKiBWaWFibGUsIGJ1dCB0b28gbGF0ZSAtIGNvbm5lY3RJbXBsKCkgd2lsbCBhbHJlYWR5IGJlIHRyeWluZ1xuICAgICAgICAgICAgICAgICAqIGNvbm5lY3RCYXNlLCBhbmQgd2Ugd2VyZW4ndCBpbiB1cGdyYWRlIG1vZGUuIEp1c3QgcmVtb3ZlIHRoZVxuICAgICAgICAgICAgICAgICAqIG9uY29ubmVjdGVkIGxpc3RlbmVyIGFuZCBnZXQgcmlkIG9mIGl0ICovXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0Lm9mZigpO1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgVXRpbHMuYXJyRGVsZXRlVmFsdWUoX3RoaXMucGVuZGluZ1RyYW5zcG9ydHMsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdHJhbnNwb3J0ICYmICFmYXRhbCkge1xuICAgICAgICAgICAgICAgIC8qIFByZWZlcmVuY2UgZmFpbGVkIGluIGEgdHJhbnNwb3J0LXNwZWNpZmljIHdheS4gVHJ5IG1vcmUgKi9cbiAgICAgICAgICAgICAgICBfdGhpcy51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29ubmVjdEltcGwodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogSWYgc3VjZWVkZWQsIG9yIGZhaWxlZCBmYXRhbGx5LCBub3RoaW5nIHRvIGRvICovXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJ5IHRvIGVzdGFibGlzaCBhIHRyYW5zcG9ydCBvbiB0aGUgYmFzZSB0cmFuc3BvcnQgKHRoZSBiZXN0IHRyYW5zcG9ydFxuICAgICAqIHN1Y2ggdGhhdCBpZiBpdCBkb2Vzbid0IHdvcmssIG5vdGhpbmcgd2lsbCB3b3JrKSBhcyBkZXRlcm1pbmVkIHRocm91Z2hcbiAgICAgKiBzdGF0aWMgZmVhdHVyZSBkZXRlY3Rpb24sIGNoZWNraW5nIGZvciBuZXR3b3JrIGNvbm5lY3Rpdml0eSBhbmQgdHJ5aW5nXG4gICAgICogZmFsbGJhY2sgaG9zdHMgaWYgYXBwbGljYWJsZS5cbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0UGFyYW1zXG4gICAgICovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3RCYXNlID0gZnVuY3Rpb24gKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBnaXZlVXAgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBfdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBfdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUsIGVycm9yOiBlcnIgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjYW5kaWRhdGVIb3N0cyA9IHRoaXMuaHR0cEhvc3RzLnNsaWNlKCk7XG4gICAgICAgIHZhciBob3N0QXR0ZW1wdENiID0gZnVuY3Rpb24gKGZhdGFsLCB0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIGlmIChjb25uZWN0Q291bnQgIT09IF90aGlzLmNvbm5lY3RDb3VudGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0cmFuc3BvcnQgJiYgIWZhdGFsKSB7XG4gICAgICAgICAgICAgICAgdHJ5RmFsbGJhY2tIb3N0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RCYXNlKCknLCAnVHJ5aW5nIHRvIGNvbm5lY3Qgd2l0aCBiYXNlIHRyYW5zcG9ydCAnICsgdGhpcy5iYXNlVHJhbnNwb3J0KTtcbiAgICAgICAgLyogZmlyc3QgdHJ5IHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gd2l0aCB0aGUgcHJpb3JpdHkgaG9zdCB3aXRoIGh0dHAgdHJhbnNwb3J0ICovXG4gICAgICAgIHZhciBob3N0ID0gY2FuZGlkYXRlSG9zdHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKCFob3N0KSB7XG4gICAgICAgICAgICBnaXZlVXAobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1VuYWJsZSB0byBjb25uZWN0IChubyBhdmFpbGFibGUgaG9zdCknLCA4MDAwMywgNDA0KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNwb3J0UGFyYW1zLmhvc3QgPSBob3N0O1xuICAgICAgICAvKiB0aGlzIGlzIHdoYXQgd2UnbGwgYmUgZG9pbmcgaWYgdGhlIGF0dGVtcHQgZm9yIHRoZSBtYWluIGhvc3QgZmFpbHMgKi9cbiAgICAgICAgdmFyIHRyeUZhbGxiYWNrSG9zdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvKiBpZiB0aGVyZSBhcmVuJ3QgYW55IGZhbGxiYWNrIGhvc3RzLCBmYWlsICovXG4gICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGdpdmVVcChuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVW5hYmxlIHRvIGNvbm5lY3QgKGFuZCBubyBtb3JlIGZhbGxiYWNrIGhvc3RzIHRvIHRyeSknLCA4MDAwMywgNDA0KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYmVmb3JlIHRyeWluZyBhbnkgZmFsbGJhY2sgKG9yIGFueSByZW1haW5pbmcgZmFsbGJhY2spIHdlIGRlY2lkZSBpZlxuICAgICAgICAgICAgICogdGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggdGhlIGFibHkgaG9zdCwgb3IgdGhlcmUgaXMgYSBnZW5lcmFsIGNvbm5lY3Rpdml0eVxuICAgICAgICAgICAgICogcHJvYmxlbSAqL1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5yZWFsdGltZS5odHRwLmNoZWNrQ29ubmVjdGl2aXR5KSB7XG4gICAgICAgICAgICAgICAgZ2l2ZVVwKG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdJbnRlcm5hbCBlcnJvcjogSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSBub3Qgc2V0JywgbnVsbCwgNTAwKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucmVhbHRpbWUuaHR0cC5jaGVja0Nvbm5lY3Rpdml0eShmdW5jdGlvbiAoZXJyLCBjb25uZWN0aXZpdHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdENvdW50ICE9PSBfdGhpcy5jb25uZWN0Q291bnRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIHdlIGtub3cgZXJyIHdvbid0IGhhcHBlbiBidXQgaGFuZGxlIGl0IGhlcmUgYW55d2F5ICovXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBnaXZlVXAoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvbm5lY3Rpdml0eSkge1xuICAgICAgICAgICAgICAgICAgICAvKiB0aGUgaW50ZXJuZXQgaXNuJ3QgcmVhY2hhYmxlLCBzbyBkb24ndCB0cnkgdGhlIGZhbGxiYWNrIGhvc3RzICovXG4gICAgICAgICAgICAgICAgICAgIGdpdmVVcChuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVW5hYmxlIHRvIGNvbm5lY3QgKG5ldHdvcmsgdW5yZWFjaGFibGUpJywgODAwMDMsIDQwNCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIHRoZSBuZXR3b3JrIGlzIHRoZXJlLCBzbyB0aGVyZSdzIGEgcHJvYmxlbSB3aXRoIHRoZSBtYWluIGhvc3QsIG9yXG4gICAgICAgICAgICAgICAgICogaXRzIGRucy4gVHJ5IHRoZSBmYWxsYmFjayBob3N0cy4gV2UgY291bGQgdHJ5IHRoZW0gc2ltdWx0YW5lb3VzbHkgYnV0XG4gICAgICAgICAgICAgICAgICogdGhhdCB3b3VsZCBwb3RlbnRpYWxseSBjYXVzZSBhIGh1Z2Ugc3Bpa2UgaW4gbG9hZCBvbiB0aGUgbG9hZCBiYWxhbmNlciAqL1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydFBhcmFtcy5ob3N0ID0gVXRpbHMuYXJyUG9wUmFuZG9tRWxlbWVudChjYW5kaWRhdGVIb3N0cyk7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIF90aGlzLmJhc2VUcmFuc3BvcnQsIGhvc3RBdHRlbXB0Q2IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmZvcmNlRmFsbGJhY2tIb3N0ICYmIGNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5mb3JjZUZhbGxiYWNrSG9zdCA9IGZhbHNlO1xuICAgICAgICAgICAgdHJ5RmFsbGJhY2tIb3N0cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIHRoaXMuYmFzZVRyYW5zcG9ydCwgaG9zdEF0dGVtcHRDYik7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VXBncmFkZVBvc3NpYmlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIHJldHVybnMgdGhlIHN1YnNldCBvZiB1cGdyYWRlVHJhbnNwb3J0cyB0byB0aGUgcmlnaHQgb2YgdGhlIGN1cnJlbnRcbiAgICAgICAgICogdHJhbnNwb3J0IGluIHVwZ3JhZGVUcmFuc3BvcnRzIChpZiBpdCdzIGluIHRoZXJlIC0gaWYgbm90LCBjdXJyZW50U2VyaWFsXG4gICAgICAgICAqIHdpbGwgYmUgLTEsIHNvIHJldHVybiB1cGdyYWRlVHJhbnNwb3J0cy5zbGljZSgwKSA9PSB1cGdyYWRlVHJhbnNwb3J0cyAqL1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuc2hvcnROYW1lO1xuICAgICAgICB2YXIgY3VycmVudFNlcmlhbCA9IFV0aWxzLmFyckluZGV4T2YodGhpcy51cGdyYWRlVHJhbnNwb3J0cywgY3VycmVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZ3JhZGVUcmFuc3BvcnRzLnNsaWNlKGN1cnJlbnRTZXJpYWwgKyAxKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS51cGdyYWRlSWZOZWVkZWQgPSBmdW5jdGlvbiAodHJhbnNwb3J0UGFyYW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB1cGdyYWRlUG9zc2liaWxpdGllcyA9IHRoaXMuZ2V0VXBncmFkZVBvc3NpYmlsaXRpZXMoKTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci51cGdyYWRlSWZOZWVkZWQoKScsICd1cGdyYWRlIHBvc3NpYmlsaXRpZXM6ICcgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QodXBncmFkZVBvc3NpYmlsaXRpZXMpKTtcbiAgICAgICAgaWYgKCF1cGdyYWRlUG9zc2liaWxpdGllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBVdGlscy5hcnJGb3JFYWNoKHVwZ3JhZGVQb3NzaWJpbGl0aWVzLCBmdW5jdGlvbiAodXBncmFkZVRyYW5zcG9ydCkge1xuICAgICAgICAgICAgLyogTm90ZTogdGhlIHRyYW5zcG9ydCBtYXkgbXV0YXRlIHRoZSBwYXJhbXMsIHNvIGdpdmUgZWFjaCB0cmFuc3BvcnQgYSBmcmVzaCBvbmUgKi9cbiAgICAgICAgICAgIHZhciB1cGdyYWRlVHJhbnNwb3J0UGFyYW1zID0gX3RoaXMuY3JlYXRlVHJhbnNwb3J0UGFyYW1zKHRyYW5zcG9ydFBhcmFtcy5ob3N0LCAndXBncmFkZScpO1xuICAgICAgICAgICAgX3RoaXMudHJ5QVRyYW5zcG9ydCh1cGdyYWRlVHJhbnNwb3J0UGFyYW1zLCB1cGdyYWRlVHJhbnNwb3J0LCBub29wKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2xvc2VJbXBsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpJywgJ2Nsb3NpbmcgY29ubmVjdGlvbicpO1xuICAgICAgICB0aGlzLmNhbmNlbFN1c3BlbmRUaW1lcigpO1xuICAgICAgICB0aGlzLnN0YXJ0VHJhbnNpdGlvblRpbWVyKHRoaXMuc3RhdGVzLmNsb3NpbmcpO1xuICAgICAgICBVdGlscy5zYWZlQXJyRm9yRWFjaCh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpJywgJ0Nsb3NpbmcgcGVuZGluZyB0cmFuc3BvcnQ6ICcgKyB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgaWYgKHRyYW5zcG9ydClcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFV0aWxzLnNhZmVBcnJGb3JFYWNoKHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLCBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpJywgJ0Rpc3Bvc2luZyBvZiBwcm9wb3NlZCB0cmFuc3BvcnQ6ICcgKyB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgaWYgKHRyYW5zcG9ydClcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlUHJvdG9jb2wpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKCknLCAnQ2xvc2luZyBhY3RpdmUgdHJhbnNwb3J0OiAnICsgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogSWYgdGhlcmUgd2FzIGFuIGFjdGl2ZSB0cmFuc3BvcnQsIHRoaXMgd2lsbCBwcm9iYWJseSBiZVxuICAgICAgICAgKiBwcmVlbXB0ZWQgYnkgdGhlIG5vdGlmeVN0YXRlIGNhbGwgaW4gZGVhY3RpdmF0ZVRyYW5zcG9ydCAqL1xuICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6ICdjbG9zZWQnIH0pO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uQXV0aFVwZGF0ZWQgPSBmdW5jdGlvbiAodG9rZW5EZXRhaWxzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZS5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzoge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIub25BdXRoVXBkYXRlZCgpJywgJ1NlbmRpbmcgQVVUSCBtZXNzYWdlIG9uIGFjdGl2ZSB0cmFuc3BvcnQnKTtcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGVyZSBhcmUgYW55IHByb3Bvc2VkL3BlbmRpbmcgdHJhbnNwb3J0cyAoZWcgYW4gdXBncmFkZSB0aGF0XG4gICAgICAgICAgICAgICAgICogaXNuJ3QgeWV0IHNjaGVkdWxlZCBmb3IgYWN0aXZhdGlvbikgdGhhdCBoYXNuJ3QgeWV0IHN0YXJ0ZWQgc3luY2luZyxcbiAgICAgICAgICAgICAgICAgKiBqdXN0IHRvIGdldCByaWQgb2YgdGhlbSAmIHJlc3RhcnQgdGhlIHVwZ3JhZGUgd2l0aCB0aGUgbmV3IHRva2VuLCB0b1xuICAgICAgICAgICAgICAgICAqIGF2b2lkIGEgcmFjZSBjb25kaXRpb24uIChJZiBpdCBoYXMgc3RhcnRlZCBzeW5jaW5nLCB0aGUgQVVUSCB3aWxsIGJlXG4gICAgICAgICAgICAgICAgICogcXVldWVkIHVudGlsIHRoZSB1cGdyYWRlIGlzIGNvbXBsZXRlLCBzbyBldmVyeXRoaW5nJ3MgZmluZSkgKi9cbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMubGVuZ3RoIHx8IHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLmxlbmd0aCkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuc3luY2hyb25pemluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKC8qIGV4Y2VwdEFjdGl2ZTogKi8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc3BvcnRQYXJhbXNfMSA9IHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkucGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGdyYWRlSWZOZWVkZWQodHJhbnNwb3J0UGFyYW1zXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogRG8gYW55IHRyYW5zcG9ydC1zcGVjaWZpYyBuZXctdG9rZW4gYWN0aW9uICovXG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZVRyYW5zcG9ydCA9IChfYSA9IHRoaXMuYWN0aXZlUHJvdG9jb2wpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRUcmFuc3BvcnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlVHJhbnNwb3J0ICYmIGFjdGl2ZVRyYW5zcG9ydC5vbkF1dGhVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRyYW5zcG9ydC5vbkF1dGhVcGRhdGVkKHRva2VuRGV0YWlscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhdXRoTXNnID0gcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25zLkFVVEgsXG4gICAgICAgICAgICAgICAgICAgIGF1dGg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0b2tlbkRldGFpbHMudG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kKGF1dGhNc2cpO1xuICAgICAgICAgICAgICAgIC8qIFRoZSBhbnN3ZXIgd2lsbCBjb21lIGJhY2sgYXMgZWl0aGVyIGEgY29ubmVjdGlvbmRldGFpbHMgZXZlbnRcbiAgICAgICAgICAgICAgICAgKiAocmVhbHRpbWUgc2VuZHMgYSBDT05ORUNURUQgdG8gYWNrbm93bGVkZ2UgdGhlIHJlYXV0aCkgb3IgYVxuICAgICAgICAgICAgICAgICAqIHN0YXRlY2hhbmdlIHRvIGZhaWxlZCAqL1xuICAgICAgICAgICAgICAgIHZhciBzdWNjZXNzTGlzdGVuZXJfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2ZmKGZhaWx1cmVMaXN0ZW5lcl8xKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdG9rZW5EZXRhaWxzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlTGlzdGVuZXJfMSA9IGZ1bmN0aW9uIChzdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVDaGFuZ2UuY3VycmVudCA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZihzdWNjZXNzTGlzdGVuZXJfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmYoZmFpbHVyZUxpc3RlbmVyXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soc3RhdGVDaGFuZ2UucmVhc29uIHx8IF90aGlzLmdldFN0YXRlRXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMub25jZSgnY29ubmVjdGlvbmRldGFpbHMnLCBzdWNjZXNzTGlzdGVuZXJfMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbignY29ubmVjdGlvbnN0YXRlJywgZmFpbHVyZUxpc3RlbmVyXzEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnY29ubmVjdGluZyc6XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKCknLCAnQWJvcnRpbmcgY3VycmVudCBjb25uZWN0aW9uIGF0dGVtcHRzIGluIG9yZGVyIHRvIHN0YXJ0IGFnYWluIHdpdGggdGhlIG5ldyBhdXRoIGRldGFpbHMnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG4gICAgICAgICAgICAvKiBmYWxsdGhyb3VnaCB0byBhZGQgc3RhdGVjaGFuZ2UgbGlzdGVuZXIgKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoKScsICdDb25uZWN0aW9uIHN0YXRlIGlzICcgKyB0aGlzLnN0YXRlLnN0YXRlICsgJzsgd2FpdGluZyB1bnRpbCBlaXRoZXIgY29ubmVjdGVkIG9yIGZhaWxlZCcpO1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcl8xID0gZnVuY3Rpb24gKHN0YXRlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGVDaGFuZ2UuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmYobGlzdGVuZXJfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdG9rZW5EZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3VzcGVuZGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmYobGlzdGVuZXJfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soc3RhdGVDaGFuZ2UucmVhc29uIHx8IF90aGlzLmdldFN0YXRlRXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlnbm9yZSB0aWxsIHdlIGdldCBlaXRoZXIgY29ubmVjdGVkIG9yIGZhaWxlZCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKCdjb25uZWN0aW9uc3RhdGUnLCBsaXN0ZW5lcl8xKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGNhbiBoYXBwZW4gaWYgaW4gdGhlIGNvbm5lY3Rpbmcgc3RhdGUgYnV0IG5vIHRyYW5zcG9ydCB3YXMgcGVuZGluZ1xuICAgICAgICAgICAgICAgICAgICAgKiB5ZXQsIHNvIGRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzIGRpZCBub3QgdHJpZ2dlciBhIGRpc2Nvbm5lY3RlZCBzdGF0ZSAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogJ2Nvbm5lY3RpbmcnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzID0gZnVuY3Rpb24gKGV4Y2VwdEFjdGl2ZSkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCknLCAnRGlzY29ubmVjdGluZyBhbGwgdHJhbnNwb3J0cycgKyAoZXhjZXB0QWN0aXZlID8gJyBleGNlcHQgdGhlIGFjdGl2ZSB0cmFuc3BvcnQnIDogJycpKTtcbiAgICAgICAgLyogVGhpcyB3aWxsIHByZXZlbnQgYW55IGNvbm5lY3Rpb24gcHJvY2VkdXJlIGluIGFuIGFzeW5jIHBhcnQgb2Ygb25lIG9mIGl0cyBlYXJseSBzdGFnZXMgZnJvbSBjb250aW51aW5nICovXG4gICAgICAgIHRoaXMuY29ubmVjdENvdW50ZXIrKztcbiAgICAgICAgVXRpbHMuc2FmZUFyckZvckVhY2godGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpJywgJ0Rpc2Nvbm5lY3RpbmcgcGVuZGluZyB0cmFuc3BvcnQ6ICcgKyB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgaWYgKHRyYW5zcG9ydClcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wZW5kaW5nVHJhbnNwb3J0cyA9IFtdO1xuICAgICAgICBVdGlscy5zYWZlQXJyRm9yRWFjaCh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cywgZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpJywgJ0Rpc3Bvc2luZyBvZiBwcm9wb3NlZCB0cmFuc3BvcnQ6ICcgKyB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgaWYgKHRyYW5zcG9ydClcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlUHJvdG9jb2wgJiYgIWV4Y2VwdEFjdGl2ZSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpJywgJ0Rpc2Nvbm5lY3RpbmcgYWN0aXZlIHRyYW5zcG9ydDogJyArIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogTm8gbmVlZCB0byBub3RpZnkgc3RhdGUgZGlzY29ubmVjdGVkOyBkaXNjb25uZWN0aW5nIHRoZSBhY3RpdmUgdHJhbnNwb3J0XG4gICAgICAgICAqIHdpbGwgaGF2ZSB0aGF0IGVmZmVjdCAqL1xuICAgIH07XG4gICAgLyoqKioqKioqKioqKioqKioqKlxuICAgICAqIGV2ZW50IHF1ZXVlaW5nXG4gICAgICoqKioqKioqKioqKioqKioqKi9cbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtc2csIHF1ZXVlRXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2VuZCgpJywgJ3NlbmRpbmcgZXZlbnQnKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZEltcGwobmV3IHByb3RvY29sXzEuUGVuZGluZ01lc3NhZ2UobXNnLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaG91bGRRdWV1ZSA9IChxdWV1ZUV2ZW50ICYmIHN0YXRlLnF1ZXVlRXZlbnRzKSB8fCBzdGF0ZS5mb3JjZVF1ZXVlRXZlbnRzO1xuICAgICAgICBpZiAoIXNob3VsZFF1ZXVlKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gJ3JlamVjdGluZyBldmVudCwgcXVldWVFdmVudCB3YXMgJyArIHF1ZXVlRXZlbnQgKyAnLCBzdGF0ZSB3YXMgJyArIHN0YXRlLnN0YXRlO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZW5kKCknLCBlcnIpO1xuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5lcnJvclJlYXNvbiB8fCBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChlcnIsIDkwMDAwLCA0MDApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9nZ2VyXzEuZGVmYXVsdC5zaG91bGRMb2cobG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoKScsICdxdWV1ZWluZyBtc2c7ICcgKyBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LnN0cmluZ2lmeShtc2cpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnF1ZXVlKG1zZywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNlbmRJbXBsID0gZnVuY3Rpb24gKHBlbmRpbmdNZXNzYWdlKSB7XG4gICAgICAgIHZhciBtc2cgPSBwZW5kaW5nTWVzc2FnZS5tZXNzYWdlO1xuICAgICAgICAvKiBJZiBoYXZlIGFscmVhZHkgYXR0ZW1wdGVkIHRvIHNlbmQgdGhpcywgcmVzZW5kIHdpdGggdGhlIHNhbWUgbXNnU2VyaWFsLFxuICAgICAgICAgKiBzbyBBYmx5IGNhbiBkZWR1cCBpZiB0aGUgcHJldmlvdXMgc2VuZCBzdWNjZWVkZWQgKi9cbiAgICAgICAgaWYgKHBlbmRpbmdNZXNzYWdlLmFja1JlcXVpcmVkICYmICFwZW5kaW5nTWVzc2FnZS5zZW5kQXR0ZW1wdGVkKSB7XG4gICAgICAgICAgICBtc2cubXNnU2VyaWFsID0gdGhpcy5tc2dTZXJpYWwrKztcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVQcm90b2NvbC5zZW5kKHBlbmRpbmdNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5zZW5kSW1wbCgpJywgJ1VuZXhwZWN0ZWQgZXhjZXB0aW9uIGluIHRyYW5zcG9ydC5zZW5kKCk6ICcgKyBlLnN0YWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnF1ZXVlID0gZnVuY3Rpb24gKG1zZywgY2FsbGJhY2spIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5xdWV1ZSgpJywgJ3F1ZXVlaW5nIGV2ZW50Jyk7XG4gICAgICAgIHZhciBsYXN0UXVldWVkID0gdGhpcy5xdWV1ZWRNZXNzYWdlcy5sYXN0KCk7XG4gICAgICAgIHZhciBtYXhTaXplID0gdGhpcy5vcHRpb25zLm1heE1lc3NhZ2VTaXplO1xuICAgICAgICAvKiBJZiBoYXZlIGFscmVhZHkgYXR0ZW1wdGVkIHRvIHNlbmQgYSBtZXNzYWdlLCBkb24ndCBtZXJnZSBtb3JlIG1lc3NhZ2VzXG4gICAgICAgICAqIGludG8gaXQsIGFzIGlmIHRoZSBwcmV2aW91cyBzZW5kIGFjdHVhbGx5IHN1Y2NlZWRlZCBhbmQgcmVhbHRpbWUgaWdub3Jlc1xuICAgICAgICAgKiB0aGUgZHVwLCB0aGV5J2xsIGJlIGxvc3QgKi9cbiAgICAgICAgaWYgKGxhc3RRdWV1ZWQgJiYgIWxhc3RRdWV1ZWQuc2VuZEF0dGVtcHRlZCAmJiBidW5kbGVXaXRoKGxhc3RRdWV1ZWQubWVzc2FnZSwgbXNnLCBtYXhTaXplKSkge1xuICAgICAgICAgICAgaWYgKCFsYXN0UXVldWVkLm1lcmdlZCkge1xuICAgICAgICAgICAgICAgIGxhc3RRdWV1ZWQuY2FsbGJhY2sgPSBtdWx0aWNhc3Rlcl8xLmRlZmF1bHQuY3JlYXRlKFtsYXN0UXVldWVkLmNhbGxiYWNrXSk7XG4gICAgICAgICAgICAgICAgbGFzdFF1ZXVlZC5tZXJnZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdFF1ZXVlZC5jYWxsYmFjay5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucXVldWVkTWVzc2FnZXMucHVzaChuZXcgcHJvdG9jb2xfMS5QZW5kaW5nTWVzc2FnZShtc2csIGNhbGxiYWNrKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZW5kUXVldWVkTWVzc2FnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2VuZFF1ZXVlZE1lc3NhZ2VzKCknLCAnc2VuZGluZyAnICsgdGhpcy5xdWV1ZWRNZXNzYWdlcy5jb3VudCgpICsgJyBxdWV1ZWQgbWVzc2FnZXMnKTtcbiAgICAgICAgdmFyIHBlbmRpbmdNZXNzYWdlO1xuICAgICAgICB3aGlsZSAoKHBlbmRpbmdNZXNzYWdlID0gdGhpcy5xdWV1ZWRNZXNzYWdlcy5zaGlmdCgpKSlcbiAgICAgICAgICAgIHRoaXMuc2VuZEltcGwocGVuZGluZ01lc3NhZ2UpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnF1ZXVlUGVuZGluZ01lc3NhZ2VzID0gZnVuY3Rpb24gKHBlbmRpbmdNZXNzYWdlcykge1xuICAgICAgICBpZiAocGVuZGluZ01lc3NhZ2VzICYmIHBlbmRpbmdNZXNzYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIucXVldWVQZW5kaW5nTWVzc2FnZXMoKScsICdxdWV1ZWluZyAnICsgcGVuZGluZ01lc3NhZ2VzLmxlbmd0aCArICcgcGVuZGluZyBtZXNzYWdlcycpO1xuICAgICAgICAgICAgdGhpcy5xdWV1ZWRNZXNzYWdlcy5wcmVwZW5kKHBlbmRpbmdNZXNzYWdlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5mYWlsUXVldWVkTWVzc2FnZXMgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBudW1RdWV1ZWQgPSB0aGlzLnF1ZXVlZE1lc3NhZ2VzLmNvdW50KCk7XG4gICAgICAgIGlmIChudW1RdWV1ZWQgPiAwKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmZhaWxRdWV1ZWRNZXNzYWdlcygpJywgJ2ZhaWxpbmcgJyArIG51bVF1ZXVlZCArICcgcXVldWVkIG1lc3NhZ2VzLCBlcnIgPSAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuICAgICAgICAgICAgdGhpcy5xdWV1ZWRNZXNzYWdlcy5jb21wbGV0ZUFsbE1lc3NhZ2VzKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vbkNoYW5uZWxNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHRyYW5zcG9ydCkge1xuICAgICAgICB2YXIgb25BY3RpdmVUcmFuc3BvcnQgPSB0aGlzLmFjdGl2ZVByb3RvY29sICYmIHRyYW5zcG9ydCA9PT0gdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSwgb25VcGdyYWRlVHJhbnNwb3J0ID0gVXRpbHMuYXJySW4odGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KSAmJiB0aGlzLnN0YXRlID09IHRoaXMuc3RhdGVzLnN5bmNocm9uaXppbmc7XG4gICAgICAgIC8qIEFzIHRoZSBsaWIgbm93IGhhcyBhIHBlcmlvZCB3aGVyZSB0aGUgdXBncmFkZSB0cmFuc3BvcnQgaXMgc3luY2VkIGJ1dFxuICAgICAgICAgKiBiZWZvcmUgaXQncyBiZWNvbWUgYWN0aXZlICh3aGlsZSB3YWl0aW5nIGZvciB0aGUgb2xkIG9uZSB0byBiZWNvbWVcbiAgICAgICAgICogaWRsZSksIG1lc3NhZ2UgY2FuIHZhbGlkbHkgYXJyaXZlIG9uIGl0IGV2ZW4gdGhvdWdoIGl0IGlzbid0IGFjdGl2ZSAqL1xuICAgICAgICBpZiAob25BY3RpdmVUcmFuc3BvcnQgfHwgb25VcGdyYWRlVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNZXNzYWdlIGNhbWUgaW4gb24gYSBkZWZ1bmN0IHRyYW5zcG9ydC4gQWxsb3cgb25seSBhY2tzLCBuYWNrcywgJiBlcnJvcnMgZm9yIG91dHN0YW5kaW5nXG4gICAgICAgICAgICAvLyBtZXNzYWdlcywgIG5vIG5ldyBtZXNzYWdlcyAoYXMgc3luYyBoYXMgYmVlbiBzZW50IG9uIG5ldyB0cmFuc3BvcnQgc28gbmV3IG1lc3NhZ2VzIHdpbGxcbiAgICAgICAgICAgIC8vIGJlIHJlc2VudCB0aGVyZSwgb3IgY29ubmVjdGlvbiBoYXMgYmVlbiBjbG9zZWQgc28gZG9uJ3Qgd2FudCBuZXcgbWVzc2FnZXMpXG4gICAgICAgICAgICBpZiAoVXRpbHMuYXJySW5kZXhPZihbYWN0aW9ucy5BQ0ssIGFjdGlvbnMuTkFDSywgYWN0aW9ucy5FUlJPUl0sIG1lc3NhZ2UuYWN0aW9uKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5jaGFubmVscy5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKCknLCAncmVjZWl2ZWQgbWVzc2FnZSAnICsgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkgKyAnb24gZGVmdW5jdCB0cmFuc3BvcnQ7IGRpc2NhcmRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAodHJhbnNwb3J0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiBpZiB0cmFuc3BvcnQgaXMgc3BlY2lmaWVkLCB0cnkgdGhhdCAqL1xuICAgICAgICBpZiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnBpbmcoKScsICd0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIHZhciBvblRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0Lm9mZignaGVhcnRiZWF0Jywgb25IZWFydGJlYXRfMSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1RpbWVvdXQgd2FpdGluZyBmb3IgaGVhcnRiZWF0IHJlc3BvbnNlJywgNTAwMDAsIDUwMCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBwaW5nU3RhcnRfMSA9IFV0aWxzLm5vdygpLCBpZF8xID0gVXRpbHMuY2hlYXBSYW5kU3RyKCk7XG4gICAgICAgICAgICB2YXIgb25IZWFydGJlYXRfMSA9IGZ1bmN0aW9uIChyZXNwb25zZUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlSWQgPT09IGlkXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0Lm9mZignaGVhcnRiZWF0Jywgb25IZWFydGJlYXRfMSk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcl8xKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlVGltZSA9IFV0aWxzLm5vdygpIC0gcGluZ1N0YXJ0XzE7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlVGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB0aW1lcl8xID0gc2V0VGltZW91dChvblRpbWVvdXQsIHRoaXMub3B0aW9ucy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5vbignaGVhcnRiZWF0Jywgb25IZWFydGJlYXRfMSk7XG4gICAgICAgICAgICB0cmFuc3BvcnQucGluZyhpZF8xKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBpZiB3ZSdyZSBub3QgY29ubmVjdGVkLCBkb24ndCBhdHRlbXB0ICovXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnN0YXRlICE9PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1VuYWJsZSB0byBwaW5nIHNlcnZpY2U7IG5vdCBjb25uZWN0ZWQnLCA0MDAwMCwgNDAwKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyogbm8gdHJhbnNwb3J0IHdhcyBzcGVjaWZpZWQsIHNvIHVzZSB0aGUgY3VycmVudCAoY29ubmVjdGVkKSBvbmVcbiAgICAgICAgICogYnV0IGVuc3VyZSB0aGF0IHdlIHJldHJ5IGlmIHRoZSB0cmFuc3BvcnQgaXMgc3VwZXJzZWRlZCBiZWZvcmUgd2UgY29tcGxldGUgKi9cbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgb25QaW5nQ29tcGxldGUgPSBmdW5jdGlvbiAoZXJyLCByZXNwb25zZVRpbWUpIHtcbiAgICAgICAgICAgIF90aGlzLm9mZigndHJhbnNwb3J0LmFjdGl2ZScsIG9uVHJhbnNwb3J0QWN0aXZlKTtcbiAgICAgICAgICAgIGlmICghY29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvblRyYW5zcG9ydEFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghY29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgLyogZW5zdXJlIHRoYXQgbm8gY2FsbGJhY2sgaGFwcGVucyBmb3IgdGhlIGN1cnJlbnRseSBvdXRzdGFuZGluZyBvcGVyYXRpb24gKi9cbiAgICAgICAgICAgICAgICBjb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8qIHJlcGVhdCBidXQgcGlja2luZyB1cCB0aGUgbmV3IHRyYW5zcG9ydCAqL1xuICAgICAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5waW5nKG51bGwsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbigndHJhbnNwb3J0LmFjdGl2ZScsIG9uVHJhbnNwb3J0QWN0aXZlKTtcbiAgICAgICAgdGhpcy5waW5nKHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCksIG9uUGluZ0NvbXBsZXRlKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLmZhaWwoZXJyb3IpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyUHJvcG9zZWRUcmFuc3BvcnQgPSBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gICAgICAgIHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLnB1c2godHJhbnNwb3J0KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRUcmFuc3BvcnRQcmVmZXJlbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlIHx8IChoYXZlV2ViU3RvcmFnZSgpICYmICgoX2IgPSAoX2EgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuV2ViU3RvcmFnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lKSkpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoVXRpbHMuYXJySW4oZGVmYXVsdHNfMS5kZWZhdWx0LnVwZ3JhZGVUcmFuc3BvcnRzLCB0cmFuc3BvcnQuc2hvcnROYW1lKSkge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gdHJhbnNwb3J0LnNob3J0TmFtZTtcbiAgICAgICAgICAgIGlmIChoYXZlV2ViU3RvcmFnZSgpKSB7XG4gICAgICAgICAgICAgICAgKF9iID0gKF9hID0gcGxhdGZvcm1fMS5kZWZhdWx0LldlYlN0b3JhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSwgdHJhbnNwb3J0LnNob3J0TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgPSBudWxsO1xuICAgICAgICBpZiAoaGF2ZVdlYlN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgKF9iID0gKF9hID0gcGxhdGZvcm1fMS5kZWZhdWx0LldlYlN0b3JhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qIFRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBkdXJpbmcgY29ubmVjdGlvbiBhdHRlbXB0cywgc28gaW1wbGVtZW50cyBSU0E0YzEsIFJTQTRjMixcbiAgICAgKiBhbmQgUlNBNGQuIEl0IGlzIGdlbmVyYWxseSBub3QgaW52b2tlZCBmb3Igc2VydmVyc2lkZS10cmlnZ2VyZWQgcmVhdXRocyBvciBtYW51YWxcbiAgICAgKiByZWF1dGhzLCBzbyBSU0E0YzMgZG9lcyBub3QgYXBwbHksIGV4Y2VwdCAocGVyIHBlciBSU0E0ZDEpIGluIHRoZSBjYXNlIHRoYXQgdGhlIGF1dGhcbiAgICAgKiBzZXJ2ZXIgcmV0dXJucyA0MDMuICovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDQwMTcxKSB7XG4gICAgICAgICAgICAvKiBObyB3YXkgdG8gcmVhdXRoICovXG4gICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6ICdmYWlsZWQnLCBlcnJvcjogZXJyIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVyci5jb2RlID09PSA0MDEwMikge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiAnZmFpbGVkJywgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcnIuc3RhdHVzQ29kZSA9PT0gSHR0cFN0YXR1c0NvZGVzXzEuZGVmYXVsdC5Gb3JiaWRkZW4pIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnQ2xpZW50IGNvbmZpZ3VyZWQgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgcmV0dXJuZWQgNDAzOyBmYWlsaW5nIHRoZSBjb25uZWN0aW9uJztcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0T25FcnJvckZyb21BdXRob3JpemUoKScsIG1zZyk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6ICdmYWlsZWQnLCBlcnJvcjogbmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA4MDAxOSwgNDAzLCBlcnIpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdDbGllbnQgY29uZmlndXJlZCBhdXRoZW50aWNhdGlvbiBwcm92aWRlciByZXF1ZXN0IGZhaWxlZCc7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplJywgbXNnKTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogdGhpcy5zdGF0ZS5mYWlsU3RhdGUsIGVycm9yOiBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDgwMDE5LCA0MDEsIGVycikgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlID0gZnVuY3Rpb24gKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpIHtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uRGV0YWlscykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkRldGFpbHMgPSBjb25uZWN0aW9uRGV0YWlscztcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25EZXRhaWxzLm1heE1lc3NhZ2VTaXplKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWF4TWVzc2FnZVNpemUgPSBjb25uZWN0aW9uRGV0YWlscy5tYXhNZXNzYWdlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xpZW50SWQgPSBjb25uZWN0aW9uRGV0YWlscy5jbGllbnRJZDtcbiAgICAgICAgaWYgKGNsaWVudElkKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gdGhpcy5yZWFsdGltZS5hdXRoLl91bmNoZWNrZWRTZXRDbGllbnRJZChjbGllbnRJZCk7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKCknLCBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLyogRXJyb3JzIHNldHRpbmcgdGhlIGNsaWVudElkIGFyZSBmYXRhbCB0byB0aGUgY29ubmVjdGlvbiAqL1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5mYWlsKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjb25uZWN0aW9uU3RhdGVUdGwgPSBjb25uZWN0aW9uRGV0YWlscy5jb25uZWN0aW9uU3RhdGVUdGw7XG4gICAgICAgIGlmIChjb25uZWN0aW9uU3RhdGVUdGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblN0YXRlVHRsID0gY29ubmVjdGlvblN0YXRlVHRsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF4SWRsZUludGVydmFsID0gY29ubmVjdGlvbkRldGFpbHMubWF4SWRsZUludGVydmFsO1xuICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3Rpb25kZXRhaWxzJywgY29ubmVjdGlvbkRldGFpbHMpO1xuICAgIH07XG4gICAgLyoqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIHRyYW5zcG9ydCBtYW5hZ2VtZW50XG4gICAgICoqKioqKioqKioqKioqKioqKioqKi9cbiAgICBDb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzID0ge307XG4gICAgcmV0dXJuIENvbm5lY3Rpb25NYW5hZ2VyO1xufShldmVudGVtaXR0ZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uTWFuYWdlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTMpKSlcblxuLyoqKi8gfSksXG4vKiAzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIGV2ZW50ZW1pdHRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBNZXNzYWdlUXVldWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTWVzc2FnZVF1ZXVlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VRdWV1ZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNZXNzYWdlUXVldWUucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5sZW5ndGg7XG4gICAgfTtcbiAgICBNZXNzYWdlUXVldWUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgfTtcbiAgICBNZXNzYWdlUXVldWUucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5zaGlmdCgpO1xuICAgIH07XG4gICAgTWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlc1t0aGlzLm1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgIH07XG4gICAgTWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jb3B5QWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5zbGljZSgpO1xuICAgIH07XG4gICAgTWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAobWVzc2FnZXMpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5wdXNoLmFwcGx5KHRoaXMubWVzc2FnZXMsIG1lc3NhZ2VzKTtcbiAgICB9O1xuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIChtZXNzYWdlcykge1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLnVuc2hpZnQuYXBwbHkodGhpcy5tZXNzYWdlcywgbWVzc2FnZXMpO1xuICAgIH07XG4gICAgTWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jb21wbGV0ZU1lc3NhZ2VzID0gZnVuY3Rpb24gKHNlcmlhbCwgY291bnQsIGVycikge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ01lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKCknLCAnc2VyaWFsID0gJyArIHNlcmlhbCArICc7IGNvdW50ID0gJyArIGNvdW50KTtcbiAgICAgICAgZXJyID0gZXJyIHx8IG51bGw7XG4gICAgICAgIHZhciBtZXNzYWdlcyA9IHRoaXMubWVzc2FnZXM7XG4gICAgICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoKTogY29tcGxldGVNZXNzYWdlcyBjYWxsZWQgb24gYW55IGVtcHR5IE1lc3NhZ2VRdWV1ZScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXJzdCA9IG1lc3NhZ2VzWzBdO1xuICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIHZhciBzdGFydFNlcmlhbCA9IGZpcnN0Lm1lc3NhZ2UubXNnU2VyaWFsO1xuICAgICAgICAgICAgdmFyIGVuZFNlcmlhbCA9IHNlcmlhbCArIGNvdW50OyAvKiB0aGUgc2VyaWFsIG9mIHRoZSBmaXJzdCBtZXNzYWdlIHRoYXQgaXMgKm5vdCogdGhlIHN1YmplY3Qgb2YgdGhpcyBjYWxsICovXG4gICAgICAgICAgICBpZiAoZW5kU2VyaWFsID4gc3RhcnRTZXJpYWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcGxldGVNZXNzYWdlcyA9IG1lc3NhZ2VzLnNwbGljZSgwLCBlbmRTZXJpYWwgLSBzdGFydFNlcmlhbCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjb21wbGV0ZU1lc3NhZ2VzXzEgPSBjb21wbGV0ZU1lc3NhZ2VzOyBfaSA8IGNvbXBsZXRlTWVzc2FnZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBjb21wbGV0ZU1lc3NhZ2VzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaWRsZScpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXNzYWdlUXVldWUucHJvdG90eXBlLmNvbXBsZXRlQWxsTWVzc2FnZXMgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGVNZXNzYWdlcygwLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCBOdW1iZXIuTUFYX1ZBTFVFLCBlcnIpO1xuICAgIH07XG4gICAgTWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5yZXNldFNlbmRBdHRlbXB0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLm1lc3NhZ2VzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIG1zZyA9IF9hW19pXTtcbiAgICAgICAgICAgIG1zZy5zZW5kQXR0ZW1wdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnTWVzc2FnZVF1ZXVlLmNsZWFyKCknLCAnY2xlYXJpbmcgJyArIHRoaXMubWVzc2FnZXMubGVuZ3RoICsgJyBtZXNzYWdlcycpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gICAgICAgIHRoaXMuZW1pdCgnaWRsZScpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VRdWV1ZTtcbn0oZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTWVzc2FnZVF1ZXVlO1xuXG5cbi8qKiovIH0pLFxuLyogMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGlvblN0YXRlQ2hhbmdlKHByZXZpb3VzLCBjdXJyZW50LCByZXRyeUluLCByZWFzb24pIHtcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICBpZiAocmV0cnlJbilcbiAgICAgICAgICAgIHRoaXMucmV0cnlJbiA9IHJldHJ5SW47XG4gICAgICAgIGlmIChyZWFzb24pXG4gICAgICAgICAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB9XG4gICAgcmV0dXJuIENvbm5lY3Rpb25TdGF0ZUNoYW5nZTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uU3RhdGVDaGFuZ2U7XG5cblxuLyoqKi8gfSksXG4vKiAzOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHByb3RvY29sbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxMCkpO1xudmFyIGV2ZW50ZW1pdHRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBjaGFubmVsXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciByZWFsdGltZXByZXNlbmNlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KSk7XG52YXIgbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg5KSk7XG52YXIgY2hhbm5lbHN0YXRlY2hhbmdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBwcmVzZW5jZW1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTUpKTtcbnZhciBjb25uZWN0aW9uZXJyb3JzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKSk7XG52YXIgYWN0aW9ucyA9IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuQWN0aW9uO1xudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG5mdW5jdGlvbiB2YWxpZGF0ZUNoYW5uZWxPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiAncGFyYW1zJyBpbiBvcHRpb25zICYmICFVdGlscy5pc09iamVjdChvcHRpb25zLnBhcmFtcykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdvcHRpb25zLnBhcmFtcyBtdXN0IGJlIGFuIG9iamVjdCcsIDQwMDAwLCA0MDApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyAmJiAnbW9kZXMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFVdGlscy5pc0FycmF5KG9wdGlvbnMubW9kZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ29wdGlvbnMubW9kZXMgbXVzdCBiZSBhbiBhcnJheScsIDQwMDAwLCA0MDApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5tb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRNb2RlID0gb3B0aW9ucy5tb2Rlc1tpXTtcbiAgICAgICAgICAgIGlmICghY3VycmVudE1vZGUgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgY3VycmVudE1vZGUgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAgICAgIVV0aWxzLmFyckluKHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuY2hhbm5lbE1vZGVzLCBTdHJpbmcucHJvdG90eXBlLnRvVXBwZXJDYXNlLmNhbGwoY3VycmVudE1vZGUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnSW52YWxpZCBjaGFubmVsIG1vZGU6ICcgKyBjdXJyZW50TW9kZSwgNDAwMDAsIDQwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgUmVhbHRpbWVDaGFubmVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJlYWx0aW1lQ2hhbm5lbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWFsdGltZUNoYW5uZWwocmVhbHRpbWUsIG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcmVhbHRpbWUsIG5hbWUsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJldHJ5Q291bnQgPSAwO1xuICAgICAgICBfdGhpcy5oaXN0b3J5ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLmhpc3RvcnkoKScsICdjaGFubmVsID0gJyArIHRoaXMubmFtZSk7XG4gICAgICAgICAgICAvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cbiAgICAgICAgICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnaGlzdG9yeScsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLnVudGlsQXR0YWNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdhdHRhY2hlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ29wdGlvbiB1bnRpbEF0dGFjaCByZXF1aXJlcyB0aGUgY2hhbm5lbCB0byBiZSBhdHRhY2hlZCcsIDQwMDAwLCA0MDApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ3VudGlsQXR0YWNoIHdhcyBzcGVjaWZpZWQgYW5kIGNoYW5uZWwgaXMgYXR0YWNoZWQsIGJ1dCBhdHRhY2hTZXJpYWwgaXMgbm90IGRlZmluZWQnLCA0MDAwMCwgNDAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy51bnRpbEF0dGFjaDtcbiAgICAgICAgICAgICAgICBwYXJhbXMuZnJvbV9zZXJpYWwgPSB0aGlzLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhbm5lbF8xLmRlZmF1bHQucHJvdG90eXBlLl9oaXN0b3J5LmNhbGwodGhpcywgcGFyYW1zLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLndoZW5TdGF0ZSA9IChmdW5jdGlvbiAoc3RhdGUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRlbWl0dGVyXzEuZGVmYXVsdC5wcm90b3R5cGUud2hlblN0YXRlLmNhbGwoX3RoaXMsIHN0YXRlLCBfdGhpcy5zdGF0ZSwgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwoKScsICdzdGFydGVkOyBuYW1lID0gJyArIG5hbWUpO1xuICAgICAgICBfdGhpcy5yZWFsdGltZSA9IHJlYWx0aW1lO1xuICAgICAgICBfdGhpcy5wcmVzZW5jZSA9IG5ldyByZWFsdGltZXByZXNlbmNlXzEuZGVmYXVsdChfdGhpcyk7XG4gICAgICAgIF90aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gcmVhbHRpbWUuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlcjtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSAnaW5pdGlhbGl6ZWQnO1xuICAgICAgICBfdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgX3RoaXMuc3luY0NoYW5uZWxTZXJpYWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBhdHRhY2hTZXJpYWw6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoYW5uZWxTZXJpYWw6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgX3RoaXMuZXJyb3JSZWFzb24gPSBudWxsO1xuICAgICAgICBfdGhpcy5fcmVxdWVzdGVkRmxhZ3MgPSBudWxsO1xuICAgICAgICBfdGhpcy5fbW9kZSA9IG51bGw7XG4gICAgICAgIF90aGlzLl9hdHRhY2hSZXN1bWUgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX2RlY29kaW5nQ29udGV4dCA9IHtcbiAgICAgICAgICAgIGNoYW5uZWxPcHRpb25zOiBfdGhpcy5jaGFubmVsT3B0aW9ucyxcbiAgICAgICAgICAgIHBsdWdpbnM6IHJlYWx0aW1lLm9wdGlvbnMucGx1Z2lucyB8fCB7fSxcbiAgICAgICAgICAgIGJhc2VFbmNvZGVkUHJldmlvdXNQYXlsb2FkOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLl9sYXN0UGF5bG9hZCA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2VJZDogbnVsbCxcbiAgICAgICAgICAgIHByb3RvY29sTWVzc2FnZUNoYW5uZWxTZXJpYWw6IG51bGwsXG4gICAgICAgICAgICBkZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICAvKiBPbmx5IGRpZmZlcmVuY2VzIGJldHdlZW4gdGhpcyBhbmQgdGhlIHB1YmxpYyBldmVudCBlbWl0dGVyIGlzIHRoYXQgdGhpcyBlbWl0cyBhblxuICAgICAgICAgKiB1cGRhdGUgZXZlbnQgZm9yIGFsbCBBVFRBQ0hFRHMsIHdoZXRoZXIgcmVzdW1lZCBvciBub3QgKi9cbiAgICAgICAgX3RoaXMuX2FsbENoYW5uZWxDaGFuZ2VzID0gbmV3IGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmludmFsaWRTdGF0ZUVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0NoYW5uZWwgb3BlcmF0aW9uIGZhaWxlZCBhcyBjaGFubmVsIHN0YXRlIGlzICcgKyB0aGlzLnN0YXRlLCA5MDAwMSwgNDAwLCB0aGlzLmVycm9yUmVhc29uIHx8IHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvY2Vzc0xpc3RlbmVyQXJncyA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovXG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFyZ3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnc2V0T3B0aW9ucycsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9jYWxsYmFjayA9IGNhbGxiYWNrIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5zZXRPcHRpb25zKCknLCAnU2V0IG9wdGlvbnMgZmFpbGVkOiAnICsgZXJyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIHZhciBlcnIgPSB2YWxpZGF0ZUNoYW5uZWxPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBfY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjaGFubmVsXzEuZGVmYXVsdC5wcm90b3R5cGUuc2V0T3B0aW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5fZGVjb2RpbmdDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy5fZGVjb2RpbmdDb250ZXh0LmNoYW5uZWxPcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZFJlYXR0YWNoVG9TZXRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAvKiBUaGlzIGRvZXMgbm90IGp1c3QgZG8gX2F0dGFjaCh0cnVlLCBudWxsLCBjYWxsYmFjaykgYmVjYXVzZSB0aGF0IHdvdWxkIHB1dCB1c1xuICAgICAgICAgICAgICogaW50byB0aGUgJ2F0dGFjaGluZycgc3RhdGUgdW50aWwgd2UgcmVjZWl2ZSB0aGUgbmV3IGF0dGFjaGVkLCB3aGljaCBpc1xuICAgICAgICAgICAgICogY29uY2VwdHVhbGx5IGluY29ycmVjdDogd2UgYXJlIHN0aWxsIGF0dGFjaGVkLCB3ZSBqdXN0IGhhdmUgYSBwZW5kaW5nIHJlcXVlc3QgdG9cbiAgICAgICAgICAgICAqIGNoYW5nZSBzb21lIGNoYW5uZWwgcGFyYW1zLiBQZXIgUlRMMTcgZ29pbmcgaW50byB0aGUgYXR0YWNoaW5nIHN0YXRlIHdvdWxkIG1lYW5cbiAgICAgICAgICAgICAqIHJlamVjdGluZyBtZXNzYWdlcyB1bnRpbCB3ZSBoYXZlIGNvbmZpcm1hdGlvbiB0aGF0IHRoZSBvcHRpb25zIGhhdmUgY2hhbmdlZCxcbiAgICAgICAgICAgICAqIHdoaWNoIHdvdWxkIHVubmVjZXNzYXJpbHkgbG9zZSBtZXNzYWdlIGNvbnRpbnVpdHkuICovXG4gICAgICAgICAgICB0aGlzLmF0dGFjaEltcGwoKTtcbiAgICAgICAgICAgIC8vIElnbm9yZSAnYXR0YWNoaW5nJyAtLSBjb3VsZCBiZSBqdXN0IGR1ZSB0byB0byBhIHJlc3VtZSAmIHJlYXR0YWNoLCBzaG91bGQgbm90XG4gICAgICAgICAgICAvLyBjYWxsIGJhY2sgc2V0T3B0aW9ucyB1bnRpbCB3ZSdyZSBkZWZpbml0ZWx5IGF0dGFjaGVkIHdpdGggdGhlIG5ldyBvcHRpb25zIChvclxuICAgICAgICAgICAgLy8gZWxzZSBpbiBhIHRlcm1pbmFsIHN0YXRlKVxuICAgICAgICAgICAgdGhpcy5fYWxsQ2hhbm5lbENoYW5nZXMub25jZShbJ2F0dGFjaGVkJywgJ3VwZGF0ZScsICdkZXRhY2hlZCcsICdmYWlsZWQnXSwgZnVuY3Rpb24gKHN0YXRlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F0dGFjaGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jYWxsYmFjayA9PT0gbnVsbCB8fCBfY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jYWxsYmFjayA9PT0gbnVsbCB8fCBfY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jYWxsYmFjayhzdGF0ZUNoYW5nZS5yZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2NhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuX3Nob3VsZFJlYXR0YWNoVG9TZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXRlID09PSAnYXR0YWNoZWQnIHx8IHRoaXMuc3RhdGUgPT09ICdhdHRhY2hpbmcnKSAmJiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpIHx8IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kZXMpKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVzc2FnZXMgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgYXJnQ291bnQgPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1thcmdDb3VudCAtIDFdO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAncHVibGlzaCcsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgICAgICArK2FyZ0NvdW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdDb3VudCA9PSAyKSB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3QobWVzc2FnZXMpKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzID0gW21lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMobWVzc2FnZXMpXTtcbiAgICAgICAgICAgIGVsc2UgaWYgKFV0aWxzLmlzQXJyYXkobWVzc2FnZXMpKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzID0gbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlc0FycmF5KG1lc3NhZ2VzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVGhlIHNpbmdsZS1hcmd1bWVudCBmb3JtIG9mIHB1Ymxpc2goKSBleHBlY3RzIGEgbWVzc2FnZSBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgbWVzc2FnZSBvYmplY3RzJywgNDAwMTMsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlcyA9IFttZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHsgbmFtZTogYXJnc1swXSwgZGF0YTogYXJnc1sxXSB9KV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heE1lc3NhZ2VTaXplID0gdGhpcy5yZWFsdGltZS5vcHRpb25zLm1heE1lc3NhZ2VTaXplO1xuICAgICAgICBtZXNzYWdlXzEuZGVmYXVsdC5lbmNvZGVBcnJheShtZXNzYWdlcywgdGhpcy5jaGFubmVsT3B0aW9ucywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogUlNMMWkgKi9cbiAgICAgICAgICAgIHZhciBzaXplID0gbWVzc2FnZV8xLmRlZmF1bHQuZ2V0TWVzc2FnZXNTaXplKG1lc3NhZ2VzKTtcbiAgICAgICAgICAgIGlmIChzaXplID4gbWF4TWVzc2FnZVNpemUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnTWF4aW11bSBzaXplIG9mIG1lc3NhZ2VzIHRoYXQgY2FuIGJlIHB1Ymxpc2hlZCBhdCBvbmNlIGV4Y2VlZGVkICggd2FzICcgK1xuICAgICAgICAgICAgICAgICAgICBzaXplICtcbiAgICAgICAgICAgICAgICAgICAgJyBieXRlczsgbGltaXQgaXMgJyArXG4gICAgICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VTaXplICtcbiAgICAgICAgICAgICAgICAgICAgJyBieXRlcyknLCA0MDAwOSwgNDAwKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX19wdWJsaXNoKG1lc3NhZ2VzLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gRG91YmxlIHVuZGVyc2NvcmUgdXNlZCB0byBwcmV2ZW50IHR5cGUgY29uZmxpY3Qgd2l0aCB1bmRlcmx5aW5nIENoYW5uZWwuX3B1Ymxpc2ggbWV0aG9kXG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5fX3B1Ymxpc2ggPSBmdW5jdGlvbiAobWVzc2FnZXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLnB1Ymxpc2goKScsICdtZXNzYWdlIGNvdW50ID0gJyArIG1lc3NhZ2VzLmxlbmd0aCk7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICBjYXNlICdzdXNwZW5kZWQnOlxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyh0aGlzLmludmFsaWRTdGF0ZUVycm9yKCkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5wdWJsaXNoKCknLCAnc2VuZGluZyBtZXNzYWdlOyBjaGFubmVsIHN0YXRlIGlzICcgKyBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IG5ldyBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbXNnLmFjdGlvbiA9IGFjdGlvbnMuTUVTU0FHRTtcbiAgICAgICAgICAgICAgICBtc2cuY2hhbm5lbCA9IHRoaXMubmFtZTtcbiAgICAgICAgICAgICAgICBtc2cubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKG1zZywgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLm9uRXZlbnQgPSBmdW5jdGlvbiAobWVzc2FnZXMpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwub25FdmVudCgpJywgJ3JlY2VpdmVkIG1lc3NhZ2UnKTtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbWVzc2FnZXNbaV07XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zLmVtaXQobWVzc2FnZS5uYW1lLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoZmxhZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfZmxhZ3M7XG4gICAgICAgIGlmICh0eXBlb2YgZmxhZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZmxhZ3M7XG4gICAgICAgICAgICBfZmxhZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2ZsYWdzID0gZmxhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2F0dGFjaCcsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01BSk9SLCAnUmVhbHRpbWVDaGFubmVsLmF0dGFjaCgpJywgJ0NoYW5uZWwgYXR0YWNoIGZhaWxlZDogJyArIGVyci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChfZmxhZ3MpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZGVwcmVjYXRlZCgnY2hhbm5lbC5hdHRhY2goKSB3aXRoIGZsYWdzJywgJ2NoYW5uZWwuc2V0T3B0aW9ucygpIHdpdGggY2hhbm5lbE9wdGlvbnMucGFyYW1zJyk7XG4gICAgICAgICAgICAvKiBJZiBmbGFncyByZXF1ZXN0ZWQsIGFsd2F5cyBkbyBhIHJlLWF0dGFjaC4gVE9ETyBvbmx5IGRvIHRoaXMgaWZcbiAgICAgICAgICAgICAqIGN1cnJlbnQgbW9kZSBkaWZmZXJzIGZyb20gcmVxdWVzdGVkIG1vZGUgKi9cbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RlZEZsYWdzID0gX2ZsYWdzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2F0dGFjaChmYWxzZSwgbnVsbCwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5fYXR0YWNoID0gZnVuY3Rpb24gKGZvcmNlUmVhdHRhY2gsIGF0dGFjaFJlYXNvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5fYXR0YWNoKCknLCAnQ2hhbm5lbCBhdHRhY2ggZmFpbGVkOiAnICsgZXJyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ2F0dGFjaGluZycgfHwgZm9yY2VSZWF0dGFjaCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoJ2F0dGFjaGluZycsIGF0dGFjaFJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbmNlKGZ1bmN0aW9uIChzdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmV2ZW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYXR0YWNoZWQnOlxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2sobnVsbCwgc3RhdGVDaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkZXRhY2hlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnc3VzcGVuZGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soc3RhdGVDaGFuZ2UucmVhc29uIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVW5hYmxlIHRvIGF0dGFjaDsgcmVhc29uIHVua25vd247IHN0YXRlID0gJyArIHRoaXMuZXZlbnQsIDkwMDAwLCA1MDApKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGV0YWNoaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdBdHRhY2ggcmVxdWVzdCBzdXBlcnNlZGVkIGJ5IGEgc3Vic2VxdWVudCBkZXRhY2ggcmVxdWVzdCcsIDkwMDAwLCA0MDkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5hdHRhY2hJbXBsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5hdHRhY2hJbXBsKCknLCAnc2VuZGluZyBBVFRBQ0ggbWVzc2FnZScpO1xuICAgICAgICB2YXIgYXR0YWNoTXNnID0gcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9ucy5BVFRBQ0gsXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuY2hhbm5lbE9wdGlvbnMucGFyYW1zLFxuICAgICAgICAgICAgLy8gUlRMNGMxOiBJbmNsdWRlcyB0aGUgY2hhbm5lbCBzZXJpYWwgdG8gcmVzdW1lIGZyb20gYSBwcmV2aW91cyBtZXNzYWdlXG4gICAgICAgICAgICAvLyBvciBhdHRhY2htZW50LlxuICAgICAgICAgICAgY2hhbm5lbFNlcmlhbDogdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWwsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdGVkRmxhZ3MpIHtcbiAgICAgICAgICAgIGF0dGFjaE1zZy5lbmNvZGVNb2Rlc1RvRmxhZ3ModGhpcy5fcmVxdWVzdGVkRmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY2hhbm5lbE9wdGlvbnMubW9kZXMpIHtcbiAgICAgICAgICAgIGF0dGFjaE1zZy5lbmNvZGVNb2Rlc1RvRmxhZ3MoVXRpbHMuYWxsVG9VcHBlckNhc2UodGhpcy5jaGFubmVsT3B0aW9ucy5tb2RlcykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hdHRhY2hSZXN1bWUpIHtcbiAgICAgICAgICAgIGF0dGFjaE1zZy5zZXRGbGFnKCdBVFRBQ0hfUkVTVU1FJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGF0dGFjaE1zZy5jaGFubmVsU2VyaWFsID0gdGhpcy5fbGFzdFBheWxvYWQucHJvdG9jb2xNZXNzYWdlQ2hhbm5lbFNlcmlhbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKGF0dGFjaE1zZywgbm9vcCk7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnZGV0YWNoJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyO1xuICAgICAgICBpZiAoIWNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnc3VzcGVuZGVkJzpcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKCdkZXRhY2hlZCcpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkZXRhY2hlZCc6XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1VuYWJsZSB0byBkZXRhY2g7IGNoYW5uZWwgc3RhdGUgPSBmYWlsZWQnLCA5MDAwMSwgNDAwKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKCdkZXRhY2hpbmcnKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSAnZGV0YWNoaW5nJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoZnVuY3Rpb24gKHN0YXRlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5ldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGV0YWNoZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhdHRhY2hlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdXNwZW5kZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhzdGF0ZUNoYW5nZS5yZWFzb24gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVW5hYmxlIHRvIGRldGFjaDsgcmVhc29uIHVua25vd247IHN0YXRlID0gJyArIHRoaXMuZXZlbnQsIDkwMDAwLCA1MDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F0dGFjaGluZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0RldGFjaCByZXF1ZXN0IHN1cGVyc2VkZWQgYnkgYSBzdWJzZXF1ZW50IGF0dGFjaCByZXF1ZXN0JywgOTAwMDAsIDQwOSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuZGV0YWNoSW1wbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5kZXRhY2goKScsICdzZW5kaW5nIERFVEFDSCBtZXNzYWdlJyk7XG4gICAgICAgIHZhciBtc2cgPSBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoeyBhY3Rpb246IGFjdGlvbnMuREVUQUNILCBjaGFubmVsOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UobXNnLCBjYWxsYmFjayB8fCBub29wKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdOyAvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqL1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAgLyogW2V2ZW50XSwgbGlzdGVuZXIsIFtjYWxsYmFja10gKi87IF9pIDwgYXJndW1lbnRzLmxlbmd0aCAvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqLzsgX2krKyAvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqLykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldOyAvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqL1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IFJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzKGFyZ3MpLCBldmVudCA9IF9hWzBdLCBsaXN0ZW5lciA9IF9hWzFdLCBjYWxsYmFjayA9IF9hWzJdO1xuICAgICAgICBpZiAoIWNhbGxiYWNrICYmIHRoaXMucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnc3Vic2NyaWJlJywgW2V2ZW50LCBsaXN0ZW5lcl0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyh0aGlzLmludmFsaWRTdGF0ZUVycm9yKCkpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaWx0ZXJlZFxuICAgICAgICBpZiAoZXZlbnQgJiYgdHlwZW9mIGV2ZW50ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZUZpbHRlcihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5fc3Vic2NyaWJlRmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlciwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGZpbHRlcmVkTGlzdGVuZXIgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBtLm5hbWUsXG4gICAgICAgICAgICAgICAgcmVmVGltZXNlcmlhbDogKF9iID0gKF9hID0gbS5leHRyYXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50aW1lc2VyaWFsLFxuICAgICAgICAgICAgICAgIHJlZlR5cGU6IChfZCA9IChfYyA9IG0uZXh0cmFzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVmKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudHlwZSxcbiAgICAgICAgICAgICAgICBpc1JlZjogISEoKF9mID0gKF9lID0gbS5leHRyYXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5yZWYpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi50aW1lc2VyaWFsKSxcbiAgICAgICAgICAgICAgICBjbGllbnRJZDogbS5jbGllbnRJZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbnkgdmFsdWVzIGFyZSBkZWZpbmVkIGluIHRoZSBmaWx0ZXIgYW5kIGlmIHRoZXkgbWF0Y2ggdGhlIHZhbHVlIGluIHRoZSBtZXNzYWdlIG9iamVjdFxuICAgICAgICAgICAgaWYgKE9iamVjdC5lbnRyaWVzKGZpbHRlcikuZmluZChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2FbMF0sIHZhbHVlID0gX2FbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyBtYXBwaW5nW2tleV0gIT09IHZhbHVlIDogZmFsc2U7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVyKG0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9hZGRGaWx0ZXJlZFN1YnNjcmlwdGlvbihmaWx0ZXIsIGxpc3RlbmVyLCBmaWx0ZXJlZExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLm9uKGZpbHRlcmVkTGlzdGVuZXIpO1xuICAgIH07XG4gICAgLy8gQWRkcyBhIG5ldyBmaWx0ZXJlZCBzdWJzY3JpcHRpb25cbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLl9hZGRGaWx0ZXJlZFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChmaWx0ZXIsIHJlYWxMaXN0ZW5lciwgZmlsdGVyZWRMaXN0ZW5lcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRTdWJzY3JpcHRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5oYXMocmVhbExpc3RlbmVyKSkge1xuICAgICAgICAgICAgdmFyIHJlYWxMaXN0ZW5lck1hcCA9IHRoaXMuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmdldChyZWFsTGlzdGVuZXIpO1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBmaWx0ZXJlZCBsaXN0ZW5lciB0byB0aGUgbWFwLCBvciBhcHBlbmQgdG8gdGhlIGFycmF5IGlmIHRoaXMgZmlsdGVyIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFxuICAgICAgICAgICAgcmVhbExpc3RlbmVyTWFwLnNldChmaWx0ZXIsICgoX2EgPSByZWFsTGlzdGVuZXJNYXAgPT09IG51bGwgfHwgcmVhbExpc3RlbmVyTWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWFsTGlzdGVuZXJNYXAuZ2V0KGZpbHRlcikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25jYXQoZmlsdGVyZWRMaXN0ZW5lcikpIHx8IFtmaWx0ZXJlZExpc3RlbmVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5zZXQocmVhbExpc3RlbmVyLCBuZXcgTWFwKFtbZmlsdGVyLCBbZmlsdGVyZWRMaXN0ZW5lcl1dXSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLl9nZXRBbmREZWxldGVGaWx0ZXJlZFN1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoZmlsdGVyLCByZWFsTGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gTm8gZmlsdGVyZWQgc3Vic2NyaXB0aW9ucyBtYXAgbWVhbnMgdGhlcmUgaGFzIGJlZW4gbm8gZmlsdGVyZWQgc3Vic2NyaXB0aW9ucyB5ZXQsIHNvIHJldHVybiBub3RoaW5nXG4gICAgICAgIGlmICghdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGEgZmlsdGVyIGlzIHBhc3NlZCBpbiB3aXRoIG5vIHNwZWNpZmljIGxpc3RlbmVyXG4gICAgICAgIGlmICghcmVhbExpc3RlbmVyICYmIGZpbHRlcikge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGVhY2ggbGlzdGVuZXIgd2hpY2ggaXMgYXR0YWNoZWQgdG8gdGhlIHNwZWNpZmllZCBmaWx0ZXIgb2JqZWN0XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5lbnRyaWVzKCkpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF9hWzBdLCBmaWx0ZXJNYXBzID0gX2FbMV07XG4gICAgICAgICAgICAgICAgLy8gR2V0ICh0aGVuIGRlbGV0ZSkgdGhlIG1hcHMgbWF0Y2hpbmcgdGhpcyBmaWx0ZXJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJNYXBzID0gZmlsdGVyTWFwcy5nZXQoZmlsdGVyKTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJNYXBzLmRlbGV0ZShmaWx0ZXIpO1xuICAgICAgICAgICAgICAgIC8vIENsZWFyIHRoZSBwYXJlbnQgaWYgbm90aGluZyBpcyBsZWZ0XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlck1hcHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAoX2IgPSBfdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyTWFwcztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiAoY3VyID8gKF9hID0gcHJldikuY29uY2F0LmFwcGx5KF9hLCBjdXIpIDogcHJldik7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gc3Vic2NyaXB0aW9ucyBmb3IgdGhpcyBsaXN0ZW5lclxuICAgICAgICBpZiAoIXJlYWxMaXN0ZW5lciB8fCAhdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuaGFzKHJlYWxMaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVhbExpc3RlbmVyTWFwID0gdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuZ2V0KHJlYWxMaXN0ZW5lcik7XG4gICAgICAgIC8vIElmIG5vIGZpbHRlciBpcyBzcGVjaWZpZWQgcmV0dXJuIGFsbCBsaXN0ZW5lcnMgdXNpbmcgdGhhdCBmdW5jdGlvblxuICAgICAgICBpZiAoIWZpbHRlcikge1xuICAgICAgICAgICAgLy8gYXJyYXkuZmxhdCBpcyBub3QgYXZhaWxhYmxlIHVubGVzcyB3ZSBzdXBwb3J0IGVzMjAxOSBvciBoaWdoZXJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnNfMSA9IEFycmF5LmZyb20ocmVhbExpc3RlbmVyTWFwLnZhbHVlcygpKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikgeyByZXR1cm4gcHJldi5jb25jYXQuYXBwbHkocHJldiwgY3VyKTsgfSwgW10pO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tIHRoZSBtYXBcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmRlbGV0ZShyZWFsTGlzdGVuZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyc18xO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSByZWFsTGlzdGVuZXJNYXAuZ2V0KGZpbHRlcik7XG4gICAgICAgIHJlYWxMaXN0ZW5lck1hcC5kZWxldGUoZmlsdGVyKTtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVycyB8fCBbXTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTsgLyogW2V2ZW50XSwgbGlzdGVuZXIgKi9cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwIC8qIFtldmVudF0sIGxpc3RlbmVyICovOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGggLyogW2V2ZW50XSwgbGlzdGVuZXIgKi87IF9pKysgLyogW2V2ZW50XSwgbGlzdGVuZXIgKi8pIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTsgLyogW2V2ZW50XSwgbGlzdGVuZXIgKi9cbiAgICAgICAgfVxuICAgICAgICB2YXIgX2IgPSBSZWFsdGltZUNoYW5uZWwucHJvY2Vzc0xpc3RlbmVyQXJncyhhcmdzKSwgZXZlbnQgPSBfYlswXSwgbGlzdGVuZXIgPSBfYlsxXTtcbiAgICAgICAgLy8gSWYgd2UgZWl0aGVyIGhhdmUgYSBmaWx0ZXJlZCBsaXN0ZW5lciwgYSBmaWx0ZXIgb3IgYm90aCB3ZSBuZWVkIHRvIGRvIGFkZGl0aW9uYWwgcHJvY2Vzc2luZyB0byBmaW5kIHRoZSBvcmlnaW5hbCBmdW5jdGlvbihzKVxuICAgICAgICBpZiAoKHR5cGVvZiBldmVudCA9PT0gJ29iamVjdCcgJiYgIWxpc3RlbmVyKSB8fCAoKF9hID0gdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYXMobGlzdGVuZXIpKSkge1xuICAgICAgICAgICAgdGhpcy5fZ2V0QW5kRGVsZXRlRmlsdGVyZWRTdWJzY3JpcHRpb25zKGV2ZW50LCBsaXN0ZW5lcikuZm9yRWFjaChmdW5jdGlvbiAobCkgeyByZXR1cm4gX3RoaXMuc3Vic2NyaXB0aW9ucy5vZmYobCk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyogY2hlY2sgcHJlY29uZGl0aW9ucyAqL1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2luaXRpYWxpemVkJzpcbiAgICAgICAgICAgIGNhc2UgJ2RldGFjaGluZyc6XG4gICAgICAgICAgICBjYXNlICdkZXRhY2hlZCc6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ1VuYWJsZSB0byBzeW5jIHRvIGNoYW5uZWw7IG5vdCBhdHRhY2hlZCcsIDQwMDAwKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIC8qIHNlbmQgc3luYyByZXF1ZXN0ICovXG4gICAgICAgIHZhciBzeW5jTWVzc2FnZSA9IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyh7IGFjdGlvbjogYWN0aW9ucy5TWU5DLCBjaGFubmVsOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgIGlmICh0aGlzLnN5bmNDaGFubmVsU2VyaWFsKSB7XG4gICAgICAgICAgICBzeW5jTWVzc2FnZS5jaGFubmVsU2VyaWFsID0gdGhpcy5zeW5jQ2hhbm5lbFNlcmlhbDtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5zZW5kKHN5bmNNZXNzYWdlKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbiAobXNnLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnNlbmQobXNnLCB0aGlzLnJlYWx0aW1lLm9wdGlvbnMucXVldWVNZXNzYWdlcywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zZW5kUHJlc2VuY2UgPSBmdW5jdGlvbiAocHJlc2VuY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBtc2cgPSBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25zLlBSRVNFTkNFLFxuICAgICAgICAgICAgY2hhbm5lbDogdGhpcy5uYW1lLFxuICAgICAgICAgICAgcHJlc2VuY2U6IFV0aWxzLmlzQXJyYXkocHJlc2VuY2UpXG4gICAgICAgICAgICAgICAgPyBwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXNBcnJheShwcmVzZW5jZSlcbiAgICAgICAgICAgICAgICA6IFtwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMocHJlc2VuY2UpXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UobXNnLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLm9uTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmFjdGlvbiA9PT0gYWN0aW9ucy5BVFRBQ0hFRCB8fFxuICAgICAgICAgICAgbWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMuTUVTU0FHRSB8fFxuICAgICAgICAgICAgbWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMuUFJFU0VOQ0UpIHtcbiAgICAgICAgICAgIC8vIFJUTDE1YlxuICAgICAgICAgICAgdGhpcy5zZXRDaGFubmVsU2VyaWFsKG1lc3NhZ2UuY2hhbm5lbFNlcmlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN5bmNDaGFubmVsU2VyaWFsLCBpc1N5bmMgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLmFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLkFUVEFDSEVEOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbCA9IG1lc3NhZ2UuY2hhbm5lbFNlcmlhbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb2RlID0gbWVzc2FnZS5nZXRNb2RlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBtZXNzYWdlLnBhcmFtcyB8fCB7fTtcbiAgICAgICAgICAgICAgICB2YXIgbW9kZXNGcm9tRmxhZ3MgPSBtZXNzYWdlLmRlY29kZU1vZGVzRnJvbUZsYWdzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlcyA9IChtb2Rlc0Zyb21GbGFncyAmJiBVdGlscy5hbGxUb0xvd2VyQ2FzZShtb2Rlc0Zyb21GbGFncykpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdW1lZCA9IG1lc3NhZ2UuaGFzRmxhZygnUkVTVU1FRCcpO1xuICAgICAgICAgICAgICAgIHZhciBoYXNQcmVzZW5jZSA9IG1lc3NhZ2UuaGFzRmxhZygnSEFTX1BSRVNFTkNFJyk7XG4gICAgICAgICAgICAgICAgdmFyIGhhc0JhY2tsb2cgPSBtZXNzYWdlLmhhc0ZsYWcoJ0hBU19CQUNLTE9HJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBPbiBhIGxvc3Mgb2YgY29udGludWl0eSwgdGhlIHByZXNlbmNlIHNldCBuZWVkcyB0byBiZSByZS1zeW5jZWQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJlc2VuY2Uub25BdHRhY2hlZChoYXNQcmVzZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZSA9IG5ldyBjaGFubmVsc3RhdGVjaGFuZ2VfMS5kZWZhdWx0KHRoaXMuc3RhdGUsIHRoaXMuc3RhdGUsIHJlc3VtZWQsIGhhc0JhY2tsb2csIG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbGxDaGFubmVsQ2hhbmdlcy5lbWl0KCd1cGRhdGUnLCBjaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VtZWQgfHwgdGhpcy5jaGFubmVsT3B0aW9ucy51cGRhdGVPbkF0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ2RldGFjaGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogUlRMNWk6IHJlLXNlbmQgREVUQUNIIGFuZCByZW1haW4gaW4gdGhlICdkZXRhY2hpbmcnIHN0YXRlICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nU3RhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoJ2F0dGFjaGVkJywgbWVzc2FnZS5lcnJvciwgcmVzdW1lZCwgaGFzUHJlc2VuY2UsIGhhc0JhY2tsb2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5ERVRBQ0hFRDoge1xuICAgICAgICAgICAgICAgIHZhciBkZXRhY2hFcnIgPSBtZXNzYWdlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgID8gZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKG1lc3NhZ2UuZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0NoYW5uZWwgZGV0YWNoZWQnLCA5MDAwMSwgNDA0KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2RldGFjaGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSgnZGV0YWNoZWQnLCBkZXRhY2hFcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAnYXR0YWNoaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvKiBPbmx5IHJldHJ5IGltbWVkaWF0ZWx5IGlmIHdlIHdlcmUgcHJldmlvdXNseSBhdHRhY2hlZC4gSWYgd2Ugd2VyZVxuICAgICAgICAgICAgICAgICAgICAgKiBhdHRhY2hpbmcsIGdvIGludG8gc3VzcGVuZGVkLCBmYWlsIG1lc3NhZ2VzLCBhbmQgd2FpdCBhIGZldyBzZWNvbmRzXG4gICAgICAgICAgICAgICAgICAgICAqIGJlZm9yZSByZXRyeWluZyAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKCdzdXNwZW5kZWQnLCBkZXRhY2hFcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoJ2F0dGFjaGluZycsIGRldGFjaEVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLlNZTkM6XG4gICAgICAgICAgICAgICAgLyogc3luY3MgY2FuIGhhdmUgY2hhbm5lbFNlcmlhbHMsIGJ1dCBtaWdodCBub3QgaWYgdGhlIHN5bmMgaXMgb25lIHBhZ2UgbG9uZyAqL1xuICAgICAgICAgICAgICAgIGlzU3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3luY0NoYW5uZWxTZXJpYWwgPSB0aGlzLnN5bmNDaGFubmVsU2VyaWFsID0gbWVzc2FnZS5jaGFubmVsU2VyaWFsO1xuICAgICAgICAgICAgICAgIC8qIHN5bmNzIGNhbiBoYXBwZW4gb24gY2hhbm5lbHMgd2l0aCBubyBwcmVzZW5jZSBkYXRhIGFzIHBhcnQgb2YgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAqIHJlc3VtaW5nLCBpbiB3aGljaCBjYXNlIHByb3RvY29sIG1lc3NhZ2UgaGFzIG5vIHByZXNlbmNlIHByb3BlcnR5ICovXG4gICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlLnByZXNlbmNlKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLlBSRVNFTkNFOiB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXNlbmNlID0gbWVzc2FnZS5wcmVzZW5jZTtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBtZXNzYWdlLmlkLCBjb25uZWN0aW9uSWQgPSBtZXNzYWdlLmNvbm5lY3Rpb25JZCwgdGltZXN0YW1wID0gbWVzc2FnZS50aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xuICAgICAgICAgICAgICAgIHZhciBwcmVzZW5jZU1zZyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXNlbmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZU1zZyA9IHByZXNlbmNlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5kZWNvZGUocHJlc2VuY2VNc2csIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmVzZW5jZU1zZy5jb25uZWN0aW9uSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2VNc2cuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmVzZW5jZU1zZy50aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2VNc2cudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmVzZW5jZU1zZy5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZU1zZy5pZCA9IGlkICsgJzonICsgaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCBlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucHJlc2VuY2Uuc2V0UHJlc2VuY2UocHJlc2VuY2UsIGlzU3luYywgc3luY0NoYW5uZWxTZXJpYWwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLk1FU1NBR0U6IHtcbiAgICAgICAgICAgICAgICAvL1JUTDE3XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdhdHRhY2hlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUFKT1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCAnTWVzc2FnZSBcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXCIgc2tpcHBlZCBhcyB0aGlzIGNoYW5uZWwgXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXCIgc3RhdGUgaXMgbm90IFwiYXR0YWNoZWRcIiAoc3RhdGUgaXMgXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1wiKS4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZXMgPSBtZXNzYWdlLm1lc3NhZ2VzLCBmaXJzdE1lc3NhZ2UgPSBtZXNzYWdlc1swXSwgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXSwgaWQgPSBtZXNzYWdlLmlkLCBjb25uZWN0aW9uSWQgPSBtZXNzYWdlLmNvbm5lY3Rpb25JZCwgdGltZXN0YW1wID0gbWVzc2FnZS50aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0TWVzc2FnZS5leHRyYXMgJiZcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RNZXNzYWdlLmV4dHJhcy5kZWx0YSAmJlxuICAgICAgICAgICAgICAgICAgICBmaXJzdE1lc3NhZ2UuZXh0cmFzLmRlbHRhLmZyb20gIT09IHRoaXMuX2xhc3RQYXlsb2FkLm1lc3NhZ2VJZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ0RlbHRhIG1lc3NhZ2UgZGVjb2RlIGZhaWx1cmUgLSBwcmV2aW91cyBtZXNzYWdlIG5vdCBhdmFpbGFibGUgZm9yIG1lc3NhZ2UgXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1wiIG9uIHRoaXMgY2hhbm5lbCBcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcIi4nO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbk1lc3NhZ2UoKScsIG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0RGVjb2RlRmFpbHVyZVJlY292ZXJ5KG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgNDAwMTgsIDQwMCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gbWVzc2FnZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlXzEuZGVmYXVsdC5kZWNvZGUobXNnLCB0aGlzLl9kZWNvZGluZ0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBkZWNyeXB0IGZhaWxlZCAuLiB0aGUgbW9zdCBsaWtlbHkgY2F1c2UgaXMgdGhhdCB3ZSBoYXZlIHRoZSB3cm9uZyBrZXkgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uTWVzc2FnZSgpJywgZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MDAxODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZGVjb2RlIGZhaWx1cmUgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnREZWNvZGVGYWlsdXJlUmVjb3ZlcnkoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQwMDE5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIE5vIHZjZGlmZiBwbHVnaW4gcGFzc2VkIGluIC0gbm8gcG9pbnQgcmVjb3ZlcmluZywgZ2l2ZSB1cCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDAwMjE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBkZWx0YXMsIHNpbWlsYXJseSBubyBwb2ludCByZWNvdmVyaW5nICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoJ2ZhaWxlZCcsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtc2cuY29ubmVjdGlvbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnLmNvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb25JZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtc2cudGltZXN0YW1wKVxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtc2cuaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cuaWQgPSBpZCArICc6JyArIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RQYXlsb2FkLm1lc3NhZ2VJZCA9IGxhc3RNZXNzYWdlLmlkO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RQYXlsb2FkLnByb3RvY29sTWVzc2FnZUNoYW5uZWxTZXJpYWwgPSBtZXNzYWdlLmNoYW5uZWxTZXJpYWw7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkV2ZW50KG1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5FUlJPUjoge1xuICAgICAgICAgICAgICAgIC8qIHRoZXJlIHdhcyBhIGNoYW5uZWwtc3BlY2lmaWMgZXJyb3IgKi9cbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gbWVzc2FnZS5lcnJvcjtcbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09IDgwMDE2KSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGF0dGFjaC9kZXRhY2ggb3BlcmF0aW9uIGF0dGVtcHRlZCBvbiBzdXBlcnNlZGVkIHRyYW5zcG9ydCBoYW5kbGUgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSgnZmFpbGVkJywgZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCAnRmF0YWwgcHJvdG9jb2wgZXJyb3I6IHVucmVjb2duaXNlZCBhY3Rpb24gKCcgKyBtZXNzYWdlLmFjdGlvbiArICcpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5hYm9ydChjb25uZWN0aW9uZXJyb3JzXzEuZGVmYXVsdC51bmtub3duQ2hhbm5lbEVycigpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5fc3RhcnREZWNvZGVGYWlsdXJlUmVjb3ZlcnkgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUFKT1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCAnU3RhcnRpbmcgZGVjb2RlIGZhaWx1cmUgcmVjb3ZlcnkgcHJvY2Vzcy4nKTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoKHRydWUsIHJlYXNvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5vbkF0dGFjaGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbkF0dGFjaGVkJywgJ2FjdGl2YXRpbmcgY2hhbm5lbDsgbmFtZSA9ICcgKyB0aGlzLm5hbWUpO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5ub3RpZnlTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgcmVhc29uLCByZXN1bWVkLCBoYXNQcmVzZW5jZSwgaGFzQmFja2xvZykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5ub3RpZnlTdGF0ZScsICduYW1lID0gJyArIHRoaXMubmFtZSArICcsIGN1cnJlbnQgc3RhdGUgPSAnICsgdGhpcy5zdGF0ZSArICcsIG5vdGlmeWluZyBzdGF0ZSAnICsgc3RhdGUpO1xuICAgICAgICB0aGlzLmNsZWFyU3RhdGVUaW1lcigpO1xuICAgICAgICAvLyBSVFA1YTFcbiAgICAgICAgaWYgKFV0aWxzLmFyckluKFsnZGV0YWNoZWQnLCAnc3VzcGVuZGVkJywgJ2ZhaWxlZCddLCBzdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5jaGFubmVsU2VyaWFsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgPT09IHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXNlbmNlLmFjdE9uQ2hhbm5lbFN0YXRlKHN0YXRlLCBoYXNQcmVzZW5jZSwgcmVhc29uKTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnc3VzcGVuZGVkJyAmJiB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRSZXRyeVRpbWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbFJldHJ5VGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVhc29uKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yUmVhc29uID0gcmVhc29uO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFuZ2UgPSBuZXcgY2hhbm5lbHN0YXRlY2hhbmdlXzEuZGVmYXVsdCh0aGlzLnN0YXRlLCBzdGF0ZSwgcmVzdW1lZCwgaGFzQmFja2xvZywgcmVhc29uKTtcbiAgICAgICAgdmFyIGxvZ0xldmVsID0gc3RhdGUgPT09ICdmYWlsZWQnID8gbG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IgOiBsb2dnZXJfMS5kZWZhdWx0LkxPR19NQUpPUjtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nTGV2ZWwsICdDaGFubmVsIHN0YXRlIGZvciBjaGFubmVsIFwiJyArIHRoaXMubmFtZSArICdcIicsIHN0YXRlICsgKHJlYXNvbiA/ICc7IHJlYXNvbjogJyArIHJlYXNvbiA6ICcnKSk7XG4gICAgICAgIGlmIChzdGF0ZSAhPT0gJ2F0dGFjaGluZycgJiYgc3RhdGUgIT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qIE5vdGU6IHdlIGRvbid0IHNldCBpblByb2dyZXNzIGZvciBwZW5kaW5nIHN0YXRlcyB1bnRpbCB0aGUgcmVxdWVzdCBpcyBhY3R1YWxseSBpbiBwcm9ncmVzcyAqL1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcbiAgICAgICAgICAgIHRoaXMub25BdHRhY2hlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2F0dGFjaGVkJykge1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoUmVzdW1lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ2RldGFjaGluZycgfHwgc3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9hdHRhY2hSZXN1bWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLmVtaXQoc3RhdGUsIGNoYW5nZSk7XG4gICAgICAgIHRoaXMuZW1pdChzdGF0ZSwgY2hhbmdlKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUucmVxdWVzdFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCByZWFzb24pIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwucmVxdWVzdFN0YXRlJywgJ25hbWUgPSAnICsgdGhpcy5uYW1lICsgJywgc3RhdGUgPSAnICsgc3RhdGUpO1xuICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHN0YXRlLCByZWFzb24pO1xuICAgICAgICAvKiBzZW5kIHRoZSBldmVudCBhbmQgYXdhaXQgcmVzcG9uc2UgKi9cbiAgICAgICAgdGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5jaGVja1BlbmRpbmdTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyogaWYgY2FuJ3Qgc2VuZCBldmVudHMsIGRvIG5vdGhpbmcgKi9cbiAgICAgICAgdmFyIGNtU3RhdGUgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlO1xuICAgICAgICAvKiBBbGxvdyBhdHRhY2ggbWVzc2FnZXMgdG8gcXVldWUgdXAgd2hlbiBzeW5jaHJvbml6aW5nLCBzaW5jZSB0aGlzIHdpbGwgYmVcbiAgICAgICAgICogdGhlIHN0YXRlIHdlJ2xsIGJlIGluIHdoZW4gdXBncmFkZSB0cmFuc3BvcnQuYWN0aXZlIHRyaWdnZXJzIGEgY2hlY2twZW5kaW5nc3RhdGUgKi9cbiAgICAgICAgaWYgKCEoY21TdGF0ZS5zZW5kRXZlbnRzIHx8IGNtU3RhdGUuZm9yY2VRdWV1ZUV2ZW50cykpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLmNoZWNrUGVuZGluZ1N0YXRlJywgJ3NlbmRFdmVudHMgaXMgZmFsc2U7IHN0YXRlIGlzICcgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5jaGVja1BlbmRpbmdTdGF0ZScsICduYW1lID0gJyArIHRoaXMubmFtZSArICcsIHN0YXRlID0gJyArIHRoaXMuc3RhdGUpO1xuICAgICAgICAvKiBPbmx5IHN0YXJ0IHRoZSBzdGF0ZSB0aW1lciBydW5uaW5nIHdoZW4gYWN0dWFsbHkgc2VuZGluZyB0aGUgZXZlbnQgKi9cbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdhdHRhY2hpbmcnOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hJbXBsKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkZXRhY2hpbmcnOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRhY2hJbXBsKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhdHRhY2hlZCc6XG4gICAgICAgICAgICAgICAgLyogcmVzdW1lIGFueSBzeW5jIG9wZXJhdGlvbiB0aGF0IHdhcyBpbiBwcm9ncmVzcyAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc3luYygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS50aW1lb3V0UGVuZGluZ1N0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2F0dGFjaGluZyc6IHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0NoYW5uZWwgYXR0YWNoIHRpbWVkIG91dCcsIDkwMDA3LCA0MDgpO1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoJ3N1c3BlbmRlZCcsIGVycik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdkZXRhY2hpbmcnOiB7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdDaGFubmVsIGRldGFjaCB0aW1lZCBvdXQnLCA5MDAwNywgNDA4KTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKCdhdHRhY2hlZCcsIGVycik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nU3RhdGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcnLCAndGltZXIgZXhwaXJlZCcpO1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIF90aGlzLnRpbWVvdXRQZW5kaW5nU3RhdGUoKTtcbiAgICAgICAgICAgIH0sIHRoaXMucmVhbHRpbWUub3B0aW9ucy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5jbGVhclN0YXRlVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZVRpbWVyID0gdGhpcy5zdGF0ZVRpbWVyO1xuICAgICAgICBpZiAoc3RhdGVUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zdGFydFJldHJ5VGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnJldHJ5VGltZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmV0cnlDb3VudCsrO1xuICAgICAgICB2YXIgcmV0cnlEZWxheSA9IFV0aWxzLmdldFJldHJ5VGltZSh0aGlzLnJlYWx0aW1lLm9wdGlvbnMudGltZW91dHMuY2hhbm5lbFJldHJ5VGltZW91dCwgdGhpcy5yZXRyeUNvdW50KTtcbiAgICAgICAgdGhpcy5yZXRyeVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvKiBJZiBjb25uZWN0aW9uIGlzIG5vdCBjb25uZWN0ZWQsIGp1c3QgbGVhdmUgaW4gc3VzcGVuZGVkLCBhIHJlYXR0YWNoXG4gICAgICAgICAgICAgKiB3aWxsIGJlIHRyaWdnZXJlZCBvbmNlIGl0IGNvbm5lY3RzIGFnYWluICovXG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUgPT09ICdzdXNwZW5kZWQnICYmIF90aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXRyeVRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbCByZXRyeSB0aW1lciBleHBpcmVkJywgJ2F0dGVtcHRpbmcgYSBuZXcgYXR0YWNoJyk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVxdWVzdFN0YXRlKCdhdHRhY2hpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgcmV0cnlEZWxheSk7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmNhbmNlbFJldHJ5VGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJldHJ5VGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZXIpO1xuICAgICAgICAgICAgdGhpcy5yZXRyeVRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyogQHJldHVybnMgbnVsbCAoaWYgY2FuIHNhZmVseSBiZSByZWxlYXNlZCkgfCBFcnJvckluZm8gKGlmIGNhbm5vdCkgKi9cbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmdldFJlbGVhc2VFcnIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKHMgPT09ICdpbml0aWFsaXplZCcgfHwgcyA9PT0gJ2RldGFjaGVkJyB8fCBzID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdDYW4gb25seSByZWxlYXNlIGEgY2hhbm5lbCBpbiBhIHN0YXRlIHdoZXJlIHRoZXJlIGlzIG5vIHBvc3NpYmlsaXR5IG9mIGZ1cnRoZXIgdXBkYXRlcyBmcm9tIHRoZSBzZXJ2ZXIgYmVpbmcgcmVjZWl2ZWQgKGluaXRpYWxpemVkLCBkZXRhY2hlZCwgb3IgZmFpbGVkKTsgd2FzICcgK1xuICAgICAgICAgICAgcywgOTAwMDEsIDQwMCk7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnNldENoYW5uZWxTZXJpYWwgPSBmdW5jdGlvbiAoY2hhbm5lbFNlcmlhbCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5zZXRDaGFubmVsU2VyaWFsKCknLCAnVXBkYXRpbmcgY2hhbm5lbCBzZXJpYWw7IHNlcmlhbCA9ICcgKyBjaGFubmVsU2VyaWFsICsgJzsgcHJldmlvdXMgPSAnICsgdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWwpO1xuICAgICAgICAvLyBSVFAxN2g6IE9ubHkgdXBkYXRlIHRoZSBjaGFubmVsIHNlcmlhbCBpZiBpdHMgcHJlc2VudCAoaXQgd29uJ3QgYWx3YXlzXG4gICAgICAgIC8vIGJlIHNldCkuXG4gICAgICAgIGlmIChjaGFubmVsU2VyaWFsKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCA9IGNoYW5uZWxTZXJpYWw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZWFsdGltZUNoYW5uZWw7XG59KGNoYW5uZWxfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBSZWFsdGltZUNoYW5uZWw7XG5cblxuLyoqKi8gfSksXG4vKiAzOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENoYW5uZWxTdGF0ZUNoYW5nZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDaGFubmVsU3RhdGVDaGFuZ2UocHJldmlvdXMsIGN1cnJlbnQsIHJlc3VtZWQsIGhhc0JhY2tsb2csIHJlYXNvbikge1xuICAgICAgICB0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgIGlmIChjdXJyZW50ID09PSAnYXR0YWNoZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VtZWQgPSByZXN1bWVkO1xuICAgICAgICAgICAgdGhpcy5oYXNCYWNrbG9nID0gaGFzQmFja2xvZztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVhc29uKVxuICAgICAgICAgICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgfVxuICAgIHJldHVybiBDaGFubmVsU3RhdGVDaGFuZ2U7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhbm5lbFN0YXRlQ2hhbmdlO1xuXG5cbi8qKiovIH0pLFxuLyogNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDYpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0XG5cdCAgICB2YXIgVyA9IFtdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS0xIGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgU0hBMSA9IENfYWxnby5TSEExID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LFxuXHQgICAgICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3Nixcblx0ICAgICAgICAgICAgICAgIDB4YzNkMmUxZjBcblx0ICAgICAgICAgICAgXSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWJsZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXHQgICAgICAgICAgICB2YXIgZSA9IEhbNF07XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IDE2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgV1tpXSA9IE1bb2Zmc2V0ICsgaV0gfCAwO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl07XG5cdCAgICAgICAgICAgICAgICAgICAgV1tpXSA9IChuIDw8IDEpIHwgKG4gPj4+IDMxKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdmFyIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGUgKyBXW2ldO1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAyMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKChiICYgYykgfCAofmIgJiBkKSkgKyAweDVhODI3OTk5O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgNDApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9IChiIF4gYyBeIGQpICsgMHg2ZWQ5ZWJhMTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IDYwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpKSAtIDB4NzBlNDQzMjQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgLyogaWYgKGkgPCA4MCkgKi8ge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKGIgXiBjIF4gZCkgLSAweDM1OWQzZTJhO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBlID0gZDtcblx0ICAgICAgICAgICAgICAgIGQgPSBjO1xuXHQgICAgICAgICAgICAgICAgYyA9IChiIDw8IDMwKSB8IChiID4+PiAyKTtcblx0ICAgICAgICAgICAgICAgIGIgPSBhO1xuXHQgICAgICAgICAgICAgICAgYSA9IHQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNF0gPSAoSFs0XSArIGUpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSBuQml0c1RvdGFsO1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMSgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMSh3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTEgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEExKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEExKG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTEgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMSk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMTtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBpbnNwZWN0KGJ1ZmZlcikge1xuICAgIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgIHZhciB2aWV3O1xuICAgIHZhciB0eXBlO1xuICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICB0eXBlID0gJ0FycmF5QnVmZmVyJztcbiAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChidWZmZXIgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgICAgICB0eXBlID0gJ0RhdGFWaWV3JztcbiAgICAgICAgdmlldyA9IGJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKCF2aWV3KVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYnVmZmVyKTtcbiAgICB2YXIgYnl0ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPiAyMCkge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCgnLi4uJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnl0ZV8gPSB2aWV3LmdldFVpbnQ4KGkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKGJ5dGVfLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIGJ5dGVfID0gJzAnICsgYnl0ZV87XG4gICAgICAgIGJ5dGVzLnB1c2goYnl0ZV8pO1xuICAgIH1cbiAgICByZXR1cm4gJzwnICsgdHlwZSArICcgJyArIGJ5dGVzLmpvaW4oJyAnKSArICc+Jztcbn1cbi8vIEVuY29kZSBzdHJpbmcgYXMgdXRmOCBpbnRvIGRhdGF2aWV3IGF0IG9mZnNldFxuZnVuY3Rpb24gdXRmOFdyaXRlKHZpZXcsIG9mZnNldCwgc3RyaW5nKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgLy8gT25lIGJ5dGUgb2YgVVRGLThcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssICgoY29kZVBvaW50ID4+PiAwKSAmIDB4N2YpIHwgMHgwMCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUd28gYnl0ZXMgb2YgVVRGLThcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAoKGNvZGVQb2ludCA+Pj4gNikgJiAweDFmKSB8IDB4YzApO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgKChjb2RlUG9pbnQgPj4+IDApICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRocmVlIGJ5dGVzIG9mIFVURi04LlxuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgKChjb2RlUG9pbnQgPj4+IDEyKSAmIDB4MGYpIHwgMHhlMCk7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAoKGNvZGVQb2ludCA+Pj4gNikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgKChjb2RlUG9pbnQgPj4+IDApICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvdXIgYnl0ZXMgb2YgVVRGLThcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAoKGNvZGVQb2ludCA+Pj4gMTgpICYgMHgwNykgfCAweGYwKTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssICgoY29kZVBvaW50ID4+PiAxMikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgKChjb2RlUG9pbnQgPj4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssICgoY29kZVBvaW50ID4+PiAwKSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBjb2RlcG9pbnQgJyArIGNvZGVQb2ludCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXRmOFJlYWQodmlldywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICB2YXIgc3RyaW5nID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IG9mZnNldCwgZW5kID0gb2Zmc2V0ICsgbGVuZ3RoOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgdmFyIGJ5dGVfID0gdmlldy5nZXRVaW50OChpKTtcbiAgICAgICAgLy8gT25lIGJ5dGUgY2hhcmFjdGVyXG4gICAgICAgIGlmICgoYnl0ZV8gJiAweDgwKSA9PT0gMHgwMCkge1xuICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZV8pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHdvIGJ5dGUgY2hhcmFjdGVyXG4gICAgICAgIGlmICgoYnl0ZV8gJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChieXRlXyAmIDB4MGYpIDw8IDYpIHwgKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRocmVlIGJ5dGUgY2hhcmFjdGVyXG4gICAgICAgIGlmICgoYnl0ZV8gJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChieXRlXyAmIDB4MGYpIDw8IDEyKSB8ICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgNikgfCAoKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpIDw8IDApKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvdXIgYnl0ZSBjaGFyYWN0ZXJcbiAgICAgICAgaWYgKChieXRlXyAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGJ5dGVfICYgMHgwNykgPDwgMTgpIHxcbiAgICAgICAgICAgICAgICAoKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpIDw8IDEyKSB8XG4gICAgICAgICAgICAgICAgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCA2KSB8XG4gICAgICAgICAgICAgICAgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCAwKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSAnICsgYnl0ZV8udG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZztcbn1cbmZ1bmN0aW9uIHV0ZjhCeXRlQ291bnQoc3RyaW5nKSB7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgICAgICAgY291bnQgKz0gMjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICBjb3VudCArPSAzO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICBjb3VudCArPSA0O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgY29kZXBvaW50ICcgKyBjb2RlUG9pbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG59XG5mdW5jdGlvbiBlbmNvZGUodmFsdWUsIHNwYXJzZSkge1xuICAgIHZhciBzaXplID0gc2l6ZW9mKHZhbHVlLCBzcGFyc2UpO1xuICAgIGlmIChzaXplID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoc2l6ZSk7XG4gICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBfZW5jb2RlKHZhbHVlLCB2aWV3LCAwLCBzcGFyc2UpO1xuICAgIHJldHVybiBidWZmZXI7XG59XG52YXIgU0hfTF8zMiA9ICgxIDw8IDE2KSAqICgxIDw8IDE2KSwgU0hfUl8zMiA9IDEgLyBTSF9MXzMyO1xuZnVuY3Rpb24gZ2V0SW50NjQodmlldywgb2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgcmV0dXJuIHZpZXcuZ2V0SW50MzIob2Zmc2V0KSAqIFNIX0xfMzIgKyB2aWV3LmdldFVpbnQzMihvZmZzZXQgKyA0KTtcbn1cbmZ1bmN0aW9uIGdldFVpbnQ2NCh2aWV3LCBvZmZzZXQpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICByZXR1cm4gdmlldy5nZXRVaW50MzIob2Zmc2V0KSAqIFNIX0xfMzIgKyB2aWV3LmdldFVpbnQzMihvZmZzZXQgKyA0KTtcbn1cbmZ1bmN0aW9uIHNldEludDY0KHZpZXcsIG9mZnNldCwgdmFsKSB7XG4gICAgaWYgKHZhbCA8IDB4ODAwMDAwMDAwMDAwMDAwMCkge1xuICAgICAgICB2aWV3LnNldEludDMyKG9mZnNldCwgTWF0aC5mbG9vcih2YWwgKiBTSF9SXzMyKSk7XG4gICAgICAgIHZpZXcuc2V0SW50MzIob2Zmc2V0ICsgNCwgdmFsICYgLTEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCAweDdmZmZmZmZmKTtcbiAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgNCwgMHg3ZmZmZmZmZik7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0VWludDY0KHZpZXcsIG9mZnNldCwgdmFsKSB7XG4gICAgaWYgKHZhbCA8IDB4MTAwMDAwMDAwMDAwMDAwMDApIHtcbiAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCBNYXRoLmZsb29yKHZhbCAqIFNIX1JfMzIpKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMihvZmZzZXQgKyA0LCB2YWwgJiAtMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIDB4ZmZmZmZmZmYpO1xuICAgICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQgKyA0LCAweGZmZmZmZmZmKTtcbiAgICB9XG59XG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9mcnN5dWtpLzU0MzI1NTkgLSB2NSBzcGVjXG4vL1xuLy8gSSd2ZSB1c2VkIG9uZSBleHRlbnNpb24gcG9pbnQgZnJvbSBgZml4ZXh0IDFgIHRvIHN0b3JlIGB1bmRlZmluZWRgLiBPbiB0aGUgd2lyZSB0aGlzXG4vLyBzaG91bGQgdHJhbnNsYXRlIHRvIGV4YWN0bHkgMHhkNDAwMDBcbi8vXG4vLyArLS0tLS0tLS0rLS0tLS0tLS0rLS0tLS0tLS0rXG4vLyB8ICAweGQ0ICB8ICAweDAwICB8ICAweDAwICB8XG4vLyArLS0tLS0tLS0rLS0tLS0tLS0rLS0tLS0tLS0rXG4vLyAgICBeIGZpeGV4dCB8ICAgICAgICBeIHZhbHVlIHBhcnQgdW51c2VkIChmaXhlZCB0byBiZSAwKVxuLy8gICAgICAgICAgICAgXiBpbmRpY2F0ZXMgdW5kZWZpbmVkIHZhbHVlXG4vL1xudmFyIERlY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVjb2Rlcih2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5tYXAgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3RoaXMucGFyc2UoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gX3RoaXMucGFyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iaW4gPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoKTtcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHZhbHVlKS5zZXQobmV3IFVpbnQ4QXJyYXkoX3RoaXMudmlldy5idWZmZXIsIF90aGlzLm9mZnNldCwgbGVuZ3RoKSwgMCk7XG4gICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJ1ZiA9IHRoaXMuYmluO1xuICAgICAgICB0aGlzLnN0ciA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHV0ZjhSZWFkKF90aGlzLnZpZXcsIF90aGlzLm9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSBsZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYXJyYXkgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IF90aGlzLnBhcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXh0ID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogX3RoaXMudmlldy5nZXRJbnQ4KF90aGlzLm9mZnNldCksXG4gICAgICAgICAgICAgICAgZGF0YTogX3RoaXMuYnVmKGxlbmd0aCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBhcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBfdGhpcy52aWV3LmdldFVpbnQ4KF90aGlzLm9mZnNldCk7XG4gICAgICAgICAgICB2YXIgdmFsdWUsIGxlbmd0aDtcbiAgICAgICAgICAgIC8vIFBvc2l0aXZlIEZpeEludCAtIDB4eHh4eHh4XG4gICAgICAgICAgICBpZiAoKHR5cGUgJiAweDgwKSA9PT0gMHgwMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRml4TWFwIC0gMTAwMHh4eHhcbiAgICAgICAgICAgIGlmICgodHlwZSAmIDB4ZjApID09PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdHlwZSAmIDB4MGY7XG4gICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm1hcChsZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRml4QXJyYXkgLSAxMDAxeHh4eFxuICAgICAgICAgICAgaWYgKCh0eXBlICYgMHhmMCkgPT09IDB4OTApIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB0eXBlICYgMHgwZjtcbiAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpeFN0ciAtIDEwMXh4eHh4XG4gICAgICAgICAgICBpZiAoKHR5cGUgJiAweGUwKSA9PT0gMHhhMCkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHR5cGUgJiAweDFmO1xuICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zdHIobGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5lZ2F0aXZlIEZpeEludCAtIDExMXh4eHh4XG4gICAgICAgICAgICBpZiAoKHR5cGUgJiAweGUwKSA9PT0gMHhlMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMudmlldy5nZXRJbnQ4KF90aGlzLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gbmlsXG4gICAgICAgICAgICAgICAgY2FzZSAweGMwOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgLy8gMHhjMSBuZXZlciB1c2VkIC0gdXNlIGZvciB1bmRlZmluZWQgKE5PTi1TVEFOREFSRClcbiAgICAgICAgICAgICAgICBjYXNlIDB4YzE6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIC8vIGZhbHNlXG4gICAgICAgICAgICAgICAgY2FzZSAweGMyOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIHRydWVcbiAgICAgICAgICAgICAgICBjYXNlIDB4YzM6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBiaW4gOFxuICAgICAgICAgICAgICAgIGNhc2UgMHhjNDpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX3RoaXMudmlldy5nZXRVaW50OChfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5iaW4obGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBiaW4gMTZcbiAgICAgICAgICAgICAgICBjYXNlIDB4YzU6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IF90aGlzLnZpZXcuZ2V0VWludDE2KF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmJpbihsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIGJpbiAzMlxuICAgICAgICAgICAgICAgIGNhc2UgMHhjNjpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX3RoaXMudmlldy5nZXRVaW50MzIoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYmluKGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gZXh0IDhcbiAgICAgICAgICAgICAgICBjYXNlIDB4Yzc6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IF90aGlzLnZpZXcuZ2V0VWludDgoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gZXh0IDE2XG4gICAgICAgICAgICAgICAgY2FzZSAweGM4OlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBfdGhpcy52aWV3LmdldFVpbnQxNihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5leHQobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBleHQgMzJcbiAgICAgICAgICAgICAgICBjYXNlIDB4Yzk6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IF90aGlzLnZpZXcuZ2V0VWludDMyKF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV4dChsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIGZsb2F0IDMyXG4gICAgICAgICAgICAgICAgY2FzZSAweGNhOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnZpZXcuZ2V0RmxvYXQzMihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyBmbG9hdCA2NFxuICAgICAgICAgICAgICAgIGNhc2UgMHhjYjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy52aWV3LmdldEZsb2F0NjQoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSA5O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gdWludDhcbiAgICAgICAgICAgICAgICBjYXNlIDB4Y2M6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMudmlldy5nZXRVaW50OChfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyB1aW50IDE2XG4gICAgICAgICAgICAgICAgY2FzZSAweGNkOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnZpZXcuZ2V0VWludDE2KF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIHVpbnQgMzJcbiAgICAgICAgICAgICAgICBjYXNlIDB4Y2U6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMudmlldy5nZXRVaW50MzIoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gdWludCA2NFxuICAgICAgICAgICAgICAgIGNhc2UgMHhjZjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRVaW50NjQoX3RoaXMudmlldywgX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSA5O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gaW50IDhcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZDA6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMudmlldy5nZXRJbnQ4KF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIGludCAxNlxuICAgICAgICAgICAgICAgIGNhc2UgMHhkMTpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy52aWV3LmdldEludDE2KF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIGludCAzMlxuICAgICAgICAgICAgICAgIGNhc2UgMHhkMjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy52aWV3LmdldEludDMyKF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIGludCA2NFxuICAgICAgICAgICAgICAgIGNhc2UgMHhkMzpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRJbnQ2NChfdGhpcy52aWV3LCBfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyBmaXhleHQgMVxuICAgICAgICAgICAgICAgIGNhc2UgMHhkNDpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5leHQobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBmaXhleHQgMlxuICAgICAgICAgICAgICAgIGNhc2UgMHhkNTpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gMjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5leHQobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBmaXhleHQgNFxuICAgICAgICAgICAgICAgIGNhc2UgMHhkNjpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gNDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5leHQobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBmaXhleHQgOFxuICAgICAgICAgICAgICAgIGNhc2UgMHhkNzpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gODtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5leHQobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBmaXhleHQgMTZcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZDg6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IDE2O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV4dChsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIHN0cjhcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZDk6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IF90aGlzLnZpZXcuZ2V0VWludDgoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc3RyKGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gc3RyIDE2XG4gICAgICAgICAgICAgICAgY2FzZSAweGRhOlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBfdGhpcy52aWV3LmdldFVpbnQxNihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zdHIobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBzdHIgMzJcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZGI6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IF90aGlzLnZpZXcuZ2V0VWludDMyKF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnN0cihsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIGFycmF5IDE2XG4gICAgICAgICAgICAgICAgY2FzZSAweGRjOlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBfdGhpcy52aWV3LmdldFVpbnQxNihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5hcnJheShsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIGFycmF5IDMyXG4gICAgICAgICAgICAgICAgY2FzZSAweGRkOlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBfdGhpcy52aWV3LmdldFVpbnQzMihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5hcnJheShsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIG1hcCAxNlxuICAgICAgICAgICAgICAgIGNhc2UgMHhkZTpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX3RoaXMudmlldy5nZXRVaW50MTYoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubWFwKGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gbWFwIDMyXG4gICAgICAgICAgICAgICAgY2FzZSAweGRmOlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBfdGhpcy52aWV3LmdldFVpbnQzMihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5tYXAobGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlIDB4JyArIHR5cGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICB9XG4gICAgcmV0dXJuIERlY29kZXI7XG59KCkpO1xuZnVuY3Rpb24gZGVjb2RlKGJ1ZmZlcikge1xuICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgdmFyIGRlY29kZXIgPSBuZXcgRGVjb2Rlcih2aWV3KTtcbiAgICB2YXIgdmFsdWUgPSBkZWNvZGVyLnBhcnNlKCk7XG4gICAgaWYgKGRlY29kZXIub2Zmc2V0ICE9PSBidWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGJ1ZmZlci5ieXRlTGVuZ3RoIC0gZGVjb2Rlci5vZmZzZXQgKyAnIHRyYWlsaW5nIGJ5dGVzJyk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZW5jb2RlYWJsZUtleXModmFsdWUsIHNwYXJzZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB2YWwgPSB2YWx1ZVtlXSwgdHlwZSA9IHR5cGVvZiB2YWw7XG4gICAgICAgIHJldHVybiAoIXNwYXJzZSB8fCAodmFsICE9PSB1bmRlZmluZWQgJiYgdmFsICE9PSBudWxsKSkgJiYgKCdmdW5jdGlvbicgIT09IHR5cGUgfHwgISF2YWwudG9KU09OKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIF9lbmNvZGUodmFsdWUsIHZpZXcsIG9mZnNldCwgc3BhcnNlKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgLy8gU3RyaW5ncyBCeXRlc1xuICAgIC8vIFRoZXJlIGFyZSBmb3VyIHN0cmluZyB0eXBlczogZml4c3RyL3N0cjgvc3RyMTYvc3RyMzJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgbGVuZ3RoXzEgPSB1dGY4Qnl0ZUNvdW50KHZhbHVlKTtcbiAgICAgICAgLy8gZml4c3RyXG4gICAgICAgIGlmIChsZW5ndGhfMSA8IDB4MjApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCBsZW5ndGhfMSB8IDB4YTApO1xuICAgICAgICAgICAgdXRmOFdyaXRlKHZpZXcsIG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAxICsgbGVuZ3RoXzE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RyOFxuICAgICAgICBpZiAobGVuZ3RoXzEgPCAweDEwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDkpO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQgKyAxLCBsZW5ndGhfMSk7XG4gICAgICAgICAgICB1dGY4V3JpdGUodmlldywgb2Zmc2V0ICsgMiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIDIgKyBsZW5ndGhfMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdHIxNlxuICAgICAgICBpZiAobGVuZ3RoXzEgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkYSk7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAxLCBsZW5ndGhfMSk7XG4gICAgICAgICAgICB1dGY4V3JpdGUodmlldywgb2Zmc2V0ICsgMywgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIDMgKyBsZW5ndGhfMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdHIzMlxuICAgICAgICBpZiAobGVuZ3RoXzEgPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZGIpO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgMSwgbGVuZ3RoXzEpO1xuICAgICAgICAgICAgdXRmOFdyaXRlKHZpZXcsIG9mZnNldCArIDUsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiA1ICsgbGVuZ3RoXzE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgICAgIC8vIGV4dHJhY3QgdGhlIGFycmF5YnVmZmVyIGFuZCBmYWxsdGhyb3VnaFxuICAgICAgICB2YWx1ZSA9IHZhbHVlLmJ1ZmZlcjtcbiAgICB9XG4gICAgLy8gVGhlcmUgYXJlIHRocmVlIGJpbiB0eXBlczogYmluOC9iaW4xNi9iaW4zMlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHZhciBsZW5ndGhfMiA9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgICAgIC8vIGJpbjhcbiAgICAgICAgaWYgKGxlbmd0aF8yIDwgMHgxMDApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGM0KTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMSwgbGVuZ3RoXzIpO1xuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkodmlldy5idWZmZXIpLnNldChuZXcgVWludDhBcnJheSh2YWx1ZSksIG9mZnNldCArIDIpO1xuICAgICAgICAgICAgcmV0dXJuIDIgKyBsZW5ndGhfMjtcbiAgICAgICAgfVxuICAgICAgICAvLyBiaW4xNlxuICAgICAgICBpZiAobGVuZ3RoXzIgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjNSk7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAxLCBsZW5ndGhfMik7XG4gICAgICAgICAgICBuZXcgVWludDhBcnJheSh2aWV3LmJ1ZmZlcikuc2V0KG5ldyBVaW50OEFycmF5KHZhbHVlKSwgb2Zmc2V0ICsgMyk7XG4gICAgICAgICAgICByZXR1cm4gMyArIGxlbmd0aF8yO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJpbiAzMlxuICAgICAgICBpZiAobGVuZ3RoXzIgPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4YzYpO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgMSwgbGVuZ3RoXzIpO1xuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkodmlldy5idWZmZXIpLnNldChuZXcgVWludDhBcnJheSh2YWx1ZSksIG9mZnNldCArIDUpO1xuICAgICAgICAgICAgcmV0dXJuIDUgKyBsZW5ndGhfMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBGbG9hdGluZyBQb2ludFxuICAgICAgICAvLyBOT1RFOiBXZSdyZSBhbHdheXMgdXNpbmcgZmxvYXQ2NFxuICAgICAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjYik7XG4gICAgICAgICAgICB2aWV3LnNldEZsb2F0NjQob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW50ZWdlcnNcbiAgICAgICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgICAgIC8vIHBvc2l0aXZlIGZpeG51bVxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1aW50IDhcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4MTAwKSB7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4Y2MpO1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdWludCAxNlxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGNkKTtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1aW50IDMyXG4gICAgICAgICAgICBpZiAodmFsdWUgPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGNlKTtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1aW50IDY0XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAweDEwMDAwMDAwMDAwMDAwMDAwKSB7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4Y2YpO1xuICAgICAgICAgICAgICAgIHNldFVpbnQ2NCh2aWV3LCBvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciB0b28gYmlnIDB4JyArIHZhbHVlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmVnYXRpdmUgZml4bnVtXG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMHgyMCkge1xuICAgICAgICAgICAgdmlldy5zZXRJbnQ4KG9mZnNldCwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW50IDhcbiAgICAgICAgaWYgKHZhbHVlID49IC0weDgwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkMCk7XG4gICAgICAgICAgICB2aWV3LnNldEludDgob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW50IDE2XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMHg4MDAwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkMSk7XG4gICAgICAgICAgICB2aWV3LnNldEludDE2KG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGludCAzMlxuICAgICAgICBpZiAodmFsdWUgPj0gLTB4ODAwMDAwMDApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGQyKTtcbiAgICAgICAgICAgIHZpZXcuc2V0SW50MzIob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW50IDY0XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMHg4MDAwMDAwMDAwMDAwMDAwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkMyk7XG4gICAgICAgICAgICBzZXRJbnQ2NCh2aWV3LCBvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciB0b28gc21hbGwgLTB4JyArICgtdmFsdWUpLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xuICAgIH1cbiAgICAvLyB1bmRlZmluZWQgLSB1c2UgZDQgKE5PTi1TVEFOREFSRClcbiAgICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHNwYXJzZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkNCk7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMSwgMHgwMCk7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMiwgMHgwMCk7XG4gICAgICAgIHJldHVybiAzO1xuICAgIH1cbiAgICAvLyBudWxsXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIGlmIChzcGFyc2UpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4YzApO1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgLy8gQm9vbGVhblxuICAgIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIHZhbHVlID8gMHhjMyA6IDB4YzIpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiB2YWx1ZS50b0pTT04pXG4gICAgICAgIHJldHVybiBfZW5jb2RlKHZhbHVlLnRvSlNPTigpLCB2aWV3LCBvZmZzZXQsIHNwYXJzZSk7XG4gICAgLy8gQ29udGFpbmVyIFR5cGVzXG4gICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBsZW5ndGhfMywgc2l6ZSA9IDA7XG4gICAgICAgIHZhciBrZXlzID0gdm9pZCAwO1xuICAgICAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgbGVuZ3RoXzMgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBrZXlzID0gZW5jb2RlYWJsZUtleXModmFsdWUsIHNwYXJzZSk7XG4gICAgICAgICAgICBsZW5ndGhfMyA9IGtleXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGhfMyA8IDB4MTApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCBsZW5ndGhfMyB8IChpc0FycmF5ID8gMHg5MCA6IDB4ODApKTtcbiAgICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aF8zIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIGlzQXJyYXkgPyAweGRjIDogMHhkZSk7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAxLCBsZW5ndGhfMyk7XG4gICAgICAgICAgICBzaXplID0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW5ndGhfMyA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgaXNBcnJheSA/IDB4ZGQgOiAweGRmKTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCArIDEsIGxlbmd0aF8zKTtcbiAgICAgICAgICAgIHNpemUgPSA1O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aF8zOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzaXplICs9IF9lbmNvZGUodmFsdWVbaV0sIHZpZXcsIG9mZnNldCArIHNpemUsIHNwYXJzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGhfMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgc2l6ZSArPSBfZW5jb2RlKGtleSwgdmlldywgb2Zmc2V0ICsgc2l6ZSk7XG4gICAgICAgICAgICAgICAgc2l6ZSArPSBfZW5jb2RlKHZhbHVlW2tleV0sIHZpZXcsIG9mZnNldCArIHNpemUsIHNwYXJzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gMDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZSAnICsgdHlwZSk7XG59XG5mdW5jdGlvbiBzaXplb2YodmFsdWUsIHNwYXJzZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIC8vIGZpeHN0ciBvciBzdHI4IG9yIHN0cjE2IG9yIHN0cjMyXG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBsZW5ndGhfNCA9IHV0ZjhCeXRlQ291bnQodmFsdWUpO1xuICAgICAgICBpZiAobGVuZ3RoXzQgPCAweDIwKSB7XG4gICAgICAgICAgICByZXR1cm4gMSArIGxlbmd0aF80O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGhfNCA8IDB4MTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMiArIGxlbmd0aF80O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGhfNCA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIHJldHVybiAzICsgbGVuZ3RoXzQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aF80IDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgIHJldHVybiA1ICsgbGVuZ3RoXzQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgICAgIC8vIGV4dHJhY3QgdGhlIGFycmF5YnVmZmVyIGFuZCBmYWxsdGhyb3VnaFxuICAgICAgICB2YWx1ZSA9IHZhbHVlLmJ1ZmZlcjtcbiAgICB9XG4gICAgLy8gYmluOCBvciBiaW4xNiBvciBiaW4zMlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHZhciBsZW5ndGhfNSA9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGhfNSA8IDB4MTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMiArIGxlbmd0aF81O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGhfNSA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIHJldHVybiAzICsgbGVuZ3RoXzU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aF81IDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgIHJldHVybiA1ICsgbGVuZ3RoXzU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gRmxvYXRpbmcgUG9pbnQgKDMyIGJpdHMpXG4gICAgICAgIC8vIGRvdWJsZVxuICAgICAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgIC8vIEludGVnZXJzXG4gICAgICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwb3NpdGl2ZSBmaXhpbnRcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4ODApXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAvLyB1aW50IDhcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4MTAwKVxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgLy8gdWludCAxNlxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHgxMDAwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgICAgIC8vIHVpbnQgMzJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4MTAwMDAwMDAwKVxuICAgICAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICAgICAgLy8gdWludCA2NFxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHgxMDAwMDAwMDAwMDAwMDAwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgICAgIC8vIFRvbyBiaWdcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIHRvbyBiaWcgMHgnICsgdmFsdWUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZWdhdGl2ZSBmaXhpbnRcbiAgICAgICAgaWYgKHZhbHVlID49IC0weDIwKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIC8vIGludCA4XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMHg4MClcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAvLyBpbnQgMTZcbiAgICAgICAgaWYgKHZhbHVlID49IC0weDgwMDApXG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgLy8gaW50IDMyXG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMHg4MDAwMDAwMClcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICAvLyBpbnQgNjRcbiAgICAgICAgaWYgKHZhbHVlID49IC0weDgwMDAwMDAwMDAwMDAwMDApXG4gICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgLy8gVG9vIHNtYWxsXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIHRvbyBzbWFsbCAtMHgnICsgdmFsdWUudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG4gICAgfVxuICAgIC8vIEJvb2xlYW5cbiAgICBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAvLyB1bmRlZmluZWQsIG51bGxcbiAgICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBzcGFyc2UgPyAwIDogMTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHNwYXJzZSA/IDAgOiAzO1xuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdmFsdWUudG9KU09OKVxuICAgICAgICByZXR1cm4gc2l6ZW9mKHZhbHVlLnRvSlNPTigpLCBzcGFyc2UpO1xuICAgIC8vIENvbnRhaW5lciBUeXBlc1xuICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgbGVuZ3RoXzYsIHNpemUgPSAwO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxlbmd0aF82ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGhfNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSArPSBzaXplb2YodmFsdWVbaV0sIHNwYXJzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IGVuY29kZWFibGVLZXlzKHZhbHVlLCBzcGFyc2UpO1xuICAgICAgICAgICAgbGVuZ3RoXzYgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoXzY7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIHNpemUgKz0gc2l6ZW9mKGtleSkgKyBzaXplb2YodmFsdWVba2V5XSwgc3BhcnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoXzYgPCAweDEwKSB7XG4gICAgICAgICAgICByZXR1cm4gMSArIHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aF82IDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgcmV0dXJuIDMgKyBzaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGhfNiA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gNSArIHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheSBvciBvYmplY3QgdG9vIGxvbmcgMHgnICsgbGVuZ3RoXzYudG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiAwO1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlICcgKyB0eXBlKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGU6IGRlY29kZSxcbiAgICBpbnNwZWN0OiBpbnNwZWN0LFxuICAgIHV0ZjhXcml0ZTogdXRmOFdyaXRlLFxuICAgIHV0ZjhSZWFkOiB1dGY4UmVhZCxcbiAgICB1dGY4Qnl0ZUNvdW50OiB1dGY4Qnl0ZUNvdW50LFxufTtcblxuXG4vKioqLyB9KSxcbi8qIDQyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vLyBDb21tb25cbnZhciByZXN0XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKSk7XG52YXIgcmVhbHRpbWVfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNTApKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG4vLyBQbGF0Zm9ybSBTcGVjaWZpY1xudmFyIGJ1ZmZlcnV0aWxzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KSk7XG4vLyBAdHMtaWdub3JlXG52YXIgY3J5cHRvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KSk7XG52YXIgaHR0cF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg2MikpO1xudmFyIGNvbmZpZ18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg2NCkpO1xuLy8gQHRzLWlnbm9yZVxudmFyIHRyYW5zcG9ydF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg2OCkpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgZGVmYXVsdHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG52YXIgd2Vic3RvcmFnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg2NSkpO1xudmFyIGRlZmF1bHRzXzIgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KSk7XG52YXIgbXNncGFja18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0MSkpO1xudmFyIENyeXB0byA9ICgwLCBjcnlwdG9fMS5kZWZhdWx0KShjb25maWdfMS5kZWZhdWx0LCBidWZmZXJ1dGlsc18xLmRlZmF1bHQpO1xucGxhdGZvcm1fMS5kZWZhdWx0LkNyeXB0byA9IENyeXB0bztcbnBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscyA9IGJ1ZmZlcnV0aWxzXzEuZGVmYXVsdDtcbnBsYXRmb3JtXzEuZGVmYXVsdC5IdHRwID0gaHR0cF8xLmRlZmF1bHQ7XG5wbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnID0gY29uZmlnXzEuZGVmYXVsdDtcbnBsYXRmb3JtXzEuZGVmYXVsdC5UcmFuc3BvcnRzID0gdHJhbnNwb3J0XzEuZGVmYXVsdDtcbnBsYXRmb3JtXzEuZGVmYXVsdC5XZWJTdG9yYWdlID0gd2Vic3RvcmFnZV8xLmRlZmF1bHQ7XG5yZXN0XzEuZGVmYXVsdC5DcnlwdG8gPSBDcnlwdG87XG5yZWFsdGltZV8xLmRlZmF1bHQuQ3J5cHRvID0gQ3J5cHRvO1xubG9nZ2VyXzEuZGVmYXVsdC5pbml0TG9nSGFuZGxlcnMoKTtcbnBsYXRmb3JtXzEuZGVmYXVsdC5EZWZhdWx0cyA9ICgwLCBkZWZhdWx0c18xLmdldERlZmF1bHRzKShkZWZhdWx0c18yLmRlZmF1bHQpO1xuaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuYWdlbnQpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcGxhdGZvcm1fMS5kZWZhdWx0LkRlZmF1bHRzLmFnZW50ICs9ICcgJyArIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuYWdlbnQ7XG59XG4vKiBJZiB1c2luZyBJRTgsIGRvbid0IGF0dGVtcHQgdG8gdXBncmFkZSBmcm9tIHhocl9wb2xsaW5nIHRvIHhocl9zdHJlYW1pbmcgLVxuICogd2hpbGUgaXQgY2FuIGRvIHN0cmVhbWluZywgdGhlIGxvdyBtYXggaHR0cC1jb25uZWN0aW9ucy1wZXItaG9zdCBsaW1pdCBtZWFuc1xuICogdGhhdCB0aGUgcG9sbGluZyB0cmFuc3BvcnQgaXMgY3JpcHBsZWQgZHVyaW5nIHRoZSB1cGdyYWRlIHByb2Nlc3MuIFNvIGp1c3RcbiAqIGxlYXZlIGl0IGF0IHRoZSBiYXNlIHRyYW5zcG9ydCAqL1xuaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubm9VcGdyYWRlKSB7XG4gICAgcGxhdGZvcm1fMS5kZWZhdWx0LkRlZmF1bHRzLnVwZ3JhZGVUcmFuc3BvcnRzID0gW107XG59XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgUmVzdDogcmVzdF8xLmRlZmF1bHQsXG4gICAgUmVhbHRpbWU6IHJlYWx0aW1lXzEuZGVmYXVsdCxcbiAgICBtc2dwYWNrOiBtc2dwYWNrXzEuZGVmYXVsdCxcbn07XG5cblxuLyoqKi8gfSksXG4vKiA0MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT04ucGFyc2UoXCJ7XFxcIm5hbWVcXFwiOlxcXCJhYmx5XFxcIixcXFwiZGVzY3JpcHRpb25cXFwiOlxcXCJSZWFsdGltZSBjbGllbnQgbGlicmFyeSBmb3IgQWJseSwgdGhlIHJlYWx0aW1lIG1lc3NhZ2luZyBzZXJ2aWNlXFxcIixcXFwidmVyc2lvblxcXCI6XFxcIjEuMi40M1xcXCIsXFxcImxpY2Vuc2VcXFwiOlxcXCJBcGFjaGUtMi4wXFxcIixcXFwiYnVnc1xcXCI6e1xcXCJ1cmxcXFwiOlxcXCJodHRwczovL2dpdGh1Yi5jb20vYWJseS9hYmx5LWpzL2lzc3Vlc1xcXCIsXFxcImVtYWlsXFxcIjpcXFwic3VwcG9ydEBhYmx5LmNvbVxcXCJ9LFxcXCJtYWluXFxcIjpcXFwiLi9idWlsZC9hYmx5LW5vZGUuanNcXFwiLFxcXCJ0eXBpbmdzXFxcIjpcXFwiLi9hYmx5LmQudHNcXFwiLFxcXCJyZWFjdC1uYXRpdmVcXFwiOntcXFwiLi9idWlsZC9hYmx5LW5vZGUuanNcXFwiOlxcXCIuL2J1aWxkL2FibHktcmVhY3RuYXRpdmUuanNcXFwifSxcXFwiYnJvd3NlclxcXCI6e1xcXCIuL2J1aWxkL2FibHktbm9kZS5qc1xcXCI6XFxcIi4vYnVpbGQvYWJseS1jb21tb25qcy5qc1xcXCJ9LFxcXCJmaWxlc1xcXCI6W1xcXCJidWlsZC8qKlxcXCIsXFxcImFibHkuZC50c1xcXCIsXFxcImNhbGxiYWNrcy5kLnRzXFxcIixcXFwiY2FsbGJhY2tzLmpzXFxcIixcXFwicHJvbWlzZXMuZC50c1xcXCIsXFxcInByb21pc2VzLmpzXFxcIixcXFwicmVzb3VyY2VzLyoqXFxcIl0sXFxcImRlcGVuZGVuY2llc1xcXCI6e1xcXCJAYWJseS9tc2dwYWNrLWpzXFxcIjpcXFwiXjAuNC4wXFxcIixcXFwiZ290XFxcIjpcXFwiXjExLjguNVxcXCIsXFxcIndzXFxcIjpcXFwiXjUuMVxcXCJ9LFxcXCJkZXZEZXBlbmRlbmNpZXNcXFwiOntcXFwiQGFibHkvdmNkaWZmLWRlY29kZXJcXFwiOlxcXCIxLjAuNFxcXCIsXFxcIkB0eXBlcy9jcnlwdG8tanNcXFwiOlxcXCJeNC4wLjFcXFwiLFxcXCJAdHlwZXMvbm9kZVxcXCI6XFxcIl4xNS4wLjBcXFwiLFxcXCJAdHlwZXMvcmVxdWVzdFxcXCI6XFxcIl4yLjQ4LjdcXFwiLFxcXCJAdHlwZXMvd3NcXFwiOlxcXCJeOC4yLjBcXFwiLFxcXCJAdHlwZXNjcmlwdC1lc2xpbnQvZXNsaW50LXBsdWdpblxcXCI6XFxcIl41LjE0LjBcXFwiLFxcXCJAdHlwZXNjcmlwdC1lc2xpbnQvcGFyc2VyXFxcIjpcXFwiXjUuMTQuMFxcXCIsXFxcImFzeW5jXFxcIjpcXFwiYWJseS1mb3Jrcy9hc3luYyNyZXF1aXJlanNcXFwiLFxcXCJhd3Mtc2RrXFxcIjpcXFwiXjIuMTQxMy4wXFxcIixcXFwiY2hhaVxcXCI6XFxcIl40LjIuMFxcXCIsXFxcImNvcHktd2VicGFjay1wbHVnaW5cXFwiOlxcXCJeNi40LjFcXFwiLFxcXCJjb3JzXFxcIjpcXFwiXjIuOC41XFxcIixcXFwiY3J5cHRvLWpzXFxcIjpcXFwiYWJseS1mb3Jrcy9jcnlwdG8tanMjY3J5cHRvLWxpdGVcXFwiLFxcXCJlc2xpbnRcXFwiOlxcXCJeNy4xMy4wXFxcIixcXFwiZXNsaW50LXBsdWdpbi1qc2RvY1xcXCI6XFxcIl40MC4wLjBcXFwiLFxcXCJlc2xpbnQtcGx1Z2luLXNlY3VyaXR5XFxcIjpcXFwiXjEuNC4wXFxcIixcXFwiZXhwcmVzc1xcXCI6XFxcIl40LjE3LjFcXFwiLFxcXCJnbG9iXFxcIjpcXFwifjQuNFxcXCIsXFxcImdvb2dsZS1jbG9zdXJlLWNvbXBpbGVyXFxcIjpcXFwiXjIwMTgwNjEwLjAuMVxcXCIsXFxcImdydW50XFxcIjpcXFwiXjEuNi4xXFxcIixcXFwiZ3J1bnQtYnVtcFxcXCI6XFxcIl4wLjMuMVxcXCIsXFxcImdydW50LWNsaVxcXCI6XFxcIn4xLjIuMFxcXCIsXFxcImdydW50LWNsb3N1cmUtdG9vbHNcXFwiOlxcXCJeMS4wLjBcXFwiLFxcXCJncnVudC1jb250cmliLWNvbmNhdFxcXCI6XFxcIn4wLjVcXFwiLFxcXCJncnVudC1zaGVsbFxcXCI6XFxcIn4xLjFcXFwiLFxcXCJncnVudC13ZWJwYWNrXFxcIjpcXFwiXjQuMC4yXFxcIixcXFwiaGV4eVxcXCI6XFxcIn4wLjJcXFwiLFxcXCJrZXhlY1xcXCI6XFxcImFibHktZm9ya3Mvbm9kZS1rZXhlYyN1cGRhdGUtZm9yLW5vZGUtMTJcXFwiLFxcXCJtaW5pbWlzdFxcXCI6XFxcIl4xLjIuNVxcXCIsXFxcIm1vY2hhXFxcIjpcXFwiXjguMS4zXFxcIixcXFwibnVsbC1sb2FkZXJcXFwiOlxcXCJeNC4wLjFcXFwiLFxcXCJwbGF5d3JpZ2h0XFxcIjpcXFwiXjEuMTAuMFxcXCIsXFxcInByZXR0aWVyXFxcIjpcXFwiXjIuNS4xXFxcIixcXFwicmVxdWlyZWpzXFxcIjpcXFwifjIuMVxcXCIsXFxcInNoZWxsanNcXFwiOlxcXCJ+MC44XFxcIixcXFwic291cmNlLW1hcC1leHBsb3JlclxcXCI6XFxcIl4yLjUuMlxcXCIsXFxcInRzLWxvYWRlclxcXCI6XFxcIl44LjIuMFxcXCIsXFxcInRzY29uZmlnLXBhdGhzLXdlYnBhY2stcGx1Z2luXFxcIjpcXFwiXjQuMC4xXFxcIixcXFwidHNsaWJcXFwiOlxcXCJeMi4zLjFcXFwiLFxcXCJ0eXBlZG9jXFxcIjpcXFwiXjAuMjMuOFxcXCIsXFxcInR5cGVzY3JpcHRcXFwiOlxcXCJeNC42LjRcXFwiLFxcXCJ3ZWJwYWNrXFxcIjpcXFwiXjQuNDQuMlxcXCIsXFxcIndlYnBhY2stY2xpXFxcIjpcXFwiXjQuMi4wXFxcIn0sXFxcImVuZ2luZXNcXFwiOntcXFwibm9kZVxcXCI6XFxcIj49NS4xMC54XFxcIn0sXFxcInJlcG9zaXRvcnlcXFwiOlxcXCJhYmx5L2FibHktanNcXFwiLFxcXCJqc3BtXFxcIjp7XFxcInJlZ2lzdHJ5XFxcIjpcXFwibnBtXFxcIixcXFwiZGlyZWN0b3JpZXNcXFwiOntcXFwibGliXFxcIjpcXFwiYnVpbGRcXFwifSxcXFwibWFpblxcXCI6XFxcImFibHlcXFwifSxcXFwic2NyaXB0c1xcXCI6e1xcXCJncnVudFxcXCI6XFxcImdydW50XFxcIixcXFwidGVzdFxcXCI6XFxcImdydW50IHRlc3RcXFwiLFxcXCJ0ZXN0Om5vZGVcXFwiOlxcXCJncnVudCB0ZXN0Om5vZGVcXFwiLFxcXCJ0ZXN0Om5vZGU6c2tpcC1idWlsZFxcXCI6XFxcImdydW50IG1vY2hhXFxcIixcXFwidGVzdDp3ZWJzZXJ2ZXJcXFwiOlxcXCJncnVudCB0ZXN0OndlYnNlcnZlclxcXCIsXFxcInRlc3Q6cGxheXdyaWdodFxcXCI6XFxcIm5vZGUgdGVzdC9zdXBwb3J0L3J1blBsYXl3cmlnaHRUZXN0cy5qc1xcXCIsXFxcImNvbmNhdFxcXCI6XFxcImdydW50IGNvbmNhdFxcXCIsXFxcImJ1aWxkXFxcIjpcXFwiZ3J1bnQgYnVpbGQ6YWxsXFxcIixcXFwiYnVpbGQ6bm9kZVxcXCI6XFxcImdydW50IGJ1aWxkOm5vZGVcXFwiLFxcXCJidWlsZDpicm93c2VyXFxcIjpcXFwiZ3J1bnQgYnVpbGQ6YnJvd3NlclxcXCIsXFxcInJlcXVpcmVqc1xcXCI6XFxcImdydW50IHJlcXVpcmVqc1xcXCIsXFxcImxpbnRcXFwiOlxcXCJlc2xpbnQgLlxcXCIsXFxcImxpbnQ6Zml4XFxcIjpcXFwiZXNsaW50IC0tZml4IC5cXFwiLFxcXCJjaGVjay1jbG9zdXJlLWNvbXBpbGVyXFxcIjpcXFwiZ3J1bnQgY2hlY2stY2xvc3VyZS1jb21waWxlclxcXCIsXFxcInByZXBhcmVcXFwiOlxcXCJucG0gcnVuIGJ1aWxkXFxcIixcXFwiZm9ybWF0XFxcIjpcXFwicHJldHRpZXIgLS13cml0ZSAtLWlnbm9yZS1wYXRoIC5naXRpZ25vcmUgLS1pZ25vcmUtcGF0aCAucHJldHRpZXJpZ25vcmUgc3JjIHRlc3QgYWJseS5kLnRzIHdlYnBhY2suY29uZmlnLmpzIEdydW50ZmlsZS5qcyBzY3JpcHRzL2Nkbl9kZXBsb3kuanMgZG9jcy9jaHJvbWUtbXYzLm1kXFxcIixcXFwiZm9ybWF0OmNoZWNrXFxcIjpcXFwicHJldHRpZXIgLS1jaGVjayAtLWlnbm9yZS1wYXRoIC5naXRpZ25vcmUgLS1pZ25vcmUtcGF0aCAucHJldHRpZXJpZ25vcmUgc3JjIHRlc3QgYWJseS5kLnRzIHdlYnBhY2suY29uZmlnLmpzIEdydW50ZmlsZS5qcyBzY3JpcHRzL2Nkbl9kZXBsb3kuanNcXFwiLFxcXCJzb3VyY2VtYXBcXFwiOlxcXCJzb3VyY2UtbWFwLWV4cGxvcmVyIGJ1aWxkL2FibHkubWluLmpzXFxcIixcXFwic291cmNlbWFwOm5vZW5jcnlwdGlvblxcXCI6XFxcInNvdXJjZS1tYXAtZXhwbG9yZXIgYnVpbGQvYWJseS5ub2VuY3J5cHRpb24ubWluLmpzXFxcIixcXFwiZG9jc1xcXCI6XFxcInR5cGVkb2MgLS1lbnRyeVBvaW50cyBhYmx5LmQudHMgLS1vdXQgZG9jcy9nZW5lcmF0ZWQvZGVmYXVsdCAtLXJlYWRtZSBkb2NzL2xhbmRpbmctcGFnZXMvZGVmYXVsdC5tZCAmJiB0eXBlZG9jIC0tZW50cnlQb2ludHMgcHJvbWlzZXMuZC50cyAtLW91dCBkb2NzL2dlbmVyYXRlZC9wcm9taXNlcyAtLW5hbWUgXFxcXFxcXCJhYmx5IChQcm9taXNlLWJhc2VkKVxcXFxcXFwiIC0tcmVhZG1lIGRvY3MvbGFuZGluZy1wYWdlcy9wcm9taXNlcy5tZCAmJiBjcCBkb2NzL2xhbmRpbmctcGFnZXMvY2hvb3NlLWxpYnJhcnkuaHRtbCBkb2NzL2dlbmVyYXRlZC9pbmRleC5odG1sXFxcIn19XCIpO1xuXG4vKioqLyB9KSxcbi8qIDQ0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblxuXG4vKioqLyB9KSxcbi8qIDQ1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSwgX193ZWJwYWNrX3JlcXVpcmVfXygzMiksIF9fd2VicGFja19yZXF1aXJlX18oMjQpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdHJldHVybiBDcnlwdG9KUy5IbWFjU0hBMjU2O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogNDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGRldmljZWRldGFpbHNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNDcpKTtcbnZhciByZXNvdXJjZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNCkpO1xudmFyIHBhZ2luYXRlZHJlc291cmNlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0OCkpO1xudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG52YXIgUHVzaCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQdXNoKHJlc3QpIHtcbiAgICAgICAgdGhpcy5yZXN0ID0gcmVzdDtcbiAgICAgICAgdGhpcy5hZG1pbiA9IG5ldyBBZG1pbihyZXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIFB1c2g7XG59KCkpO1xudmFyIEFkbWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFkbWluKHJlc3QpIHtcbiAgICAgICAgdGhpcy5yZXN0ID0gcmVzdDtcbiAgICAgICAgdGhpcy5kZXZpY2VSZWdpc3RyYXRpb25zID0gbmV3IERldmljZVJlZ2lzdHJhdGlvbnMocmVzdCk7XG4gICAgICAgIHRoaXMuY2hhbm5lbFN1YnNjcmlwdGlvbnMgPSBuZXcgQ2hhbm5lbFN1YnNjcmlwdGlvbnMocmVzdCk7XG4gICAgfVxuICAgIEFkbWluLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24gKHJlY2lwaWVudCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnJlc3Q7XG4gICAgICAgIHZhciBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdFBvc3RIZWFkZXJzKHJlc3Qub3B0aW9ucywgZm9ybWF0KSwgcGFyYW1zID0ge307XG4gICAgICAgIHZhciBib2R5ID0gVXRpbHMubWl4aW4oeyByZWNpcGllbnQ6IHJlY2lwaWVudCB9LCBwYXlsb2FkKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAncHVibGlzaCcsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBpZiAocmVzdC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgICAgICAgIFV0aWxzLm1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogJ3RydWUnIH0pO1xuICAgICAgICB2YXIgcmVxdWVzdEJvZHkgPSBVdGlscy5lbmNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdC5wb3N0KHJlc3QsICcvcHVzaC9wdWJsaXNoJywgcmVxdWVzdEJvZHksIGhlYWRlcnMsIHBhcmFtcywgbnVsbCwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQWRtaW47XG59KCkpO1xudmFyIERldmljZVJlZ2lzdHJhdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGV2aWNlUmVnaXN0cmF0aW9ucyhyZXN0KSB7XG4gICAgICAgIHRoaXMucmVzdCA9IHJlc3Q7XG4gICAgfVxuICAgIERldmljZVJlZ2lzdHJhdGlvbnMucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoZGV2aWNlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucmVzdDtcbiAgICAgICAgdmFyIGJvZHkgPSBkZXZpY2VkZXRhaWxzXzEuZGVmYXVsdC5mcm9tVmFsdWVzKGRldmljZSk7XG4gICAgICAgIHZhciBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdFBvc3RIZWFkZXJzKHJlc3Qub3B0aW9ucywgZm9ybWF0KSwgcGFyYW1zID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3NhdmUnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICAgICAgICBVdGlscy5taXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6ICd0cnVlJyB9KTtcbiAgICAgICAgdmFyIHJlcXVlc3RCb2R5ID0gVXRpbHMuZW5jb2RlQm9keShib2R5LCBmb3JtYXQpO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQucHV0KHJlc3QsICcvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zLycgKyBlbmNvZGVVUklDb21wb25lbnQoZGV2aWNlLmlkKSwgcmVxdWVzdEJvZHksIGhlYWRlcnMsIHBhcmFtcywgbnVsbCwgZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgIWVyclxuICAgICAgICAgICAgICAgID8gZGV2aWNlZGV0YWlsc18xLmRlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShib2R5LCB1bnBhY2tlZCA/IHVuZGVmaW5lZCA6IGZvcm1hdClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGV2aWNlUmVnaXN0cmF0aW9ucy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGRldmljZUlkT3JEZXRhaWxzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucmVzdCwgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzKHJlc3Qub3B0aW9ucywgZm9ybWF0KSwgZGV2aWNlSWQgPSBkZXZpY2VJZE9yRGV0YWlscy5pZCB8fCBkZXZpY2VJZE9yRGV0YWlscztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnZ2V0JywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRldmljZUlkICE9PSAnc3RyaW5nJyB8fCAhZGV2aWNlSWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnRmlyc3QgYXJndW1lbnQgdG8gRGV2aWNlUmVnaXN0cmF0aW9ucyNnZXQgbXVzdCBiZSBhIGRldmljZUlkIHN0cmluZyBvciBEZXZpY2VEZXRhaWxzJywgNDAwMDAsIDQwMCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LmdldChyZXN0LCAnL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZUlkKSwgaGVhZGVycywge30sIG51bGwsIGZ1bmN0aW9uIChlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsICFlcnJcbiAgICAgICAgICAgICAgICA/IGRldmljZWRldGFpbHNfMS5kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoYm9keSwgdW5wYWNrZWQgPyB1bmRlZmluZWQgOiBmb3JtYXQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERldmljZVJlZ2lzdHJhdGlvbnMucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucmVzdCwgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgZW52ZWxvcGUgPSB0aGlzLnJlc3QuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0LCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdEdldEhlYWRlcnMocmVzdC5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdsaXN0JywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV8xLmRlZmF1bHQocmVzdCwgJy9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMnLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24gKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGV2aWNlZGV0YWlsc18xLmRlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShib2R5LCB1bnBhY2tlZCA/IHVuZGVmaW5lZCA6IGZvcm1hdCk7XG4gICAgICAgIH0pLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIERldmljZVJlZ2lzdHJhdGlvbnMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChkZXZpY2VJZE9yRGV0YWlscywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnJlc3QsIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0R2V0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCksIHBhcmFtcyA9IHt9LCBkZXZpY2VJZCA9IGRldmljZUlkT3JEZXRhaWxzLmlkIHx8IGRldmljZUlkT3JEZXRhaWxzO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdyZW1vdmUnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGV2aWNlSWQgIT09ICdzdHJpbmcnIHx8ICFkZXZpY2VJZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdGaXJzdCBhcmd1bWVudCB0byBEZXZpY2VSZWdpc3RyYXRpb25zI3JlbW92ZSBtdXN0IGJlIGEgZGV2aWNlSWQgc3RyaW5nIG9yIERldmljZURldGFpbHMnLCA0MDAwMCwgNDAwKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBpZiAocmVzdC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgICAgICAgIFV0aWxzLm1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogJ3RydWUnIH0pO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHRbJ2RlbGV0ZSddKHJlc3QsICcvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zLycgKyBlbmNvZGVVUklDb21wb25lbnQoZGV2aWNlSWQpLCBoZWFkZXJzLCBwYXJhbXMsIG51bGwsIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH0pO1xuICAgIH07XG4gICAgRGV2aWNlUmVnaXN0cmF0aW9ucy5wcm90b3R5cGUucmVtb3ZlV2hlcmUgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucmVzdCwgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzKHJlc3Qub3B0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAncmVtb3ZlV2hlcmUnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICAgICAgICBVdGlscy5taXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6ICd0cnVlJyB9KTtcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0WydkZWxldGUnXShyZXN0LCAnL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucycsIGhlYWRlcnMsIHBhcmFtcywgbnVsbCwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGV2aWNlUmVnaXN0cmF0aW9ucztcbn0oKSk7XG52YXIgQ2hhbm5lbFN1YnNjcmlwdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhbm5lbFN1YnNjcmlwdGlvbnMocmVzdCkge1xuICAgICAgICAvKiBDaGFubmVsU3Vic2NyaXB0aW9ucyBoYXZlIG5vIHVuaXF1ZSBpZDsgcmVtb3Zpbmcgb25lIGlzIGVxdWl2YWxlbnQgdG8gcmVtb3ZlV2hlcmUgYnkgaXRzIHByb3BlcnRpZXMgKi9cbiAgICAgICAgdGhpcy5yZW1vdmUgPSBDaGFubmVsU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUucmVtb3ZlV2hlcmU7XG4gICAgICAgIHRoaXMucmVzdCA9IHJlc3Q7XG4gICAgfVxuICAgIENoYW5uZWxTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnJlc3Q7XG4gICAgICAgIHZhciBib2R5ID0gcHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fMS5kZWZhdWx0LmZyb21WYWx1ZXMoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0UG9zdEhlYWRlcnMocmVzdC5vcHRpb25zLCBmb3JtYXQpLCBwYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnc2F2ZScsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBpZiAocmVzdC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgICAgICAgIFV0aWxzLm1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogJ3RydWUnIH0pO1xuICAgICAgICB2YXIgcmVxdWVzdEJvZHkgPSBVdGlscy5lbmNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdC5wb3N0KHJlc3QsICcvcHVzaC9jaGFubmVsU3Vic2NyaXB0aW9ucycsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMsIG51bGwsIGZ1bmN0aW9uIChlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsICFlcnIgJiYgcHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fMS5kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoYm9keSwgdW5wYWNrZWQgPyB1bmRlZmluZWQgOiBmb3JtYXQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaGFubmVsU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5yZXN0LCBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBlbnZlbG9wZSA9IHRoaXMucmVzdC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQsIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0R2V0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2xpc3QnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgbmV3IHBhZ2luYXRlZHJlc291cmNlXzEuZGVmYXVsdChyZXN0LCAnL3B1c2gvY2hhbm5lbFN1YnNjcmlwdGlvbnMnLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24gKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gcHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fMS5kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoYm9keSwgdW5wYWNrZWQgPyB1bmRlZmluZWQgOiBmb3JtYXQpO1xuICAgICAgICB9KS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBDaGFubmVsU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUucmVtb3ZlV2hlcmUgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucmVzdCwgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzKHJlc3Qub3B0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAncmVtb3ZlV2hlcmUnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICAgICAgICBVdGlscy5taXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6ICd0cnVlJyB9KTtcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0WydkZWxldGUnXShyZXN0LCAnL3B1c2gvY2hhbm5lbFN1YnNjcmlwdGlvbnMnLCBoZWFkZXJzLCBwYXJhbXMsIG51bGwsIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH0pO1xuICAgIH07XG4gICAgQ2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLmxpc3RDaGFubmVscyA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5yZXN0LCBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBlbnZlbG9wZSA9IHRoaXMucmVzdC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQsIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0R2V0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2xpc3RDaGFubmVscycsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBpZiAocmVzdC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgICAgICAgIFV0aWxzLm1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogJ3RydWUnIH0pO1xuICAgICAgICBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfMS5kZWZhdWx0KHJlc3QsICcvcHVzaC9jaGFubmVscycsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbiAoYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWRCb2R5ID0gKCF1bnBhY2tlZCAmJiBmb3JtYXQgPyBVdGlscy5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCkgOiBib2R5KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyc2VkQm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBhcnNlZEJvZHlbaV0gPSBTdHJpbmcocGFyc2VkQm9keVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkQm9keTtcbiAgICAgICAgfSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgcmV0dXJuIENoYW5uZWxTdWJzY3JpcHRpb25zO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFB1c2g7XG5cblxuLyoqKi8gfSksXG4vKiA0NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBEZXZpY2VGb3JtRmFjdG9yO1xuKGZ1bmN0aW9uIChEZXZpY2VGb3JtRmFjdG9yKSB7XG4gICAgRGV2aWNlRm9ybUZhY3RvcltcIlBob25lXCJdID0gXCJwaG9uZVwiO1xuICAgIERldmljZUZvcm1GYWN0b3JbXCJUYWJsZXRcIl0gPSBcInRhYmxldFwiO1xuICAgIERldmljZUZvcm1GYWN0b3JbXCJEZXNrdG9wXCJdID0gXCJkZXNrdG9wXCI7XG4gICAgRGV2aWNlRm9ybUZhY3RvcltcIlRWXCJdID0gXCJ0dlwiO1xuICAgIERldmljZUZvcm1GYWN0b3JbXCJXYXRjaFwiXSA9IFwid2F0Y2hcIjtcbiAgICBEZXZpY2VGb3JtRmFjdG9yW1wiQ2FyXCJdID0gXCJjYXJcIjtcbiAgICBEZXZpY2VGb3JtRmFjdG9yW1wiRW1iZWRkZWRcIl0gPSBcImVtYmVkZGVkXCI7XG4gICAgRGV2aWNlRm9ybUZhY3RvcltcIk90aGVyXCJdID0gXCJvdGhlclwiO1xufSkoRGV2aWNlRm9ybUZhY3RvciB8fCAoRGV2aWNlRm9ybUZhY3RvciA9IHt9KSk7XG52YXIgRGV2aWNlUGxhdGZvcm07XG4oZnVuY3Rpb24gKERldmljZVBsYXRmb3JtKSB7XG4gICAgRGV2aWNlUGxhdGZvcm1bXCJBbmRyb2lkXCJdID0gXCJhbmRyb2lkXCI7XG4gICAgRGV2aWNlUGxhdGZvcm1bXCJJT1NcIl0gPSBcImlvc1wiO1xuICAgIERldmljZVBsYXRmb3JtW1wiQnJvd3NlclwiXSA9IFwiYnJvd3NlclwiO1xufSkoRGV2aWNlUGxhdGZvcm0gfHwgKERldmljZVBsYXRmb3JtID0ge30pKTtcbnZhciBEZXZpY2VEZXRhaWxzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERldmljZURldGFpbHMoKSB7XG4gICAgfVxuICAgIERldmljZURldGFpbHMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGRldmljZVNlY3JldDogdGhpcy5kZXZpY2VTZWNyZXQsXG4gICAgICAgICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgICAgICAgIGZvcm1GYWN0b3I6IHRoaXMuZm9ybUZhY3RvcixcbiAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRoaXMubWV0YWRhdGEsXG4gICAgICAgICAgICBkZXZpY2VJZGVudGl0eVRva2VuOiB0aGlzLmRldmljZUlkZW50aXR5VG9rZW4sXG4gICAgICAgICAgICBwdXNoOiB7XG4gICAgICAgICAgICAgICAgcmVjaXBpZW50OiAoX2EgPSB0aGlzLnB1c2gpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWNpcGllbnQsXG4gICAgICAgICAgICAgICAgc3RhdGU6IChfYiA9IHRoaXMucHVzaCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0YXRlLFxuICAgICAgICAgICAgICAgIGVycm9yOiAoX2MgPSB0aGlzLnB1c2gpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5lcnJvcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBEZXZpY2VEZXRhaWxzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJ1tEZXZpY2VEZXRhaWxzJztcbiAgICAgICAgaWYgKHRoaXMuaWQpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgaWQ9JyArIHRoaXMuaWQ7XG4gICAgICAgIGlmICh0aGlzLnBsYXRmb3JtKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IHBsYXRmb3JtPScgKyB0aGlzLnBsYXRmb3JtO1xuICAgICAgICBpZiAodGhpcy5mb3JtRmFjdG9yKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGZvcm1GYWN0b3I9JyArIHRoaXMuZm9ybUZhY3RvcjtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50SWQpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgY2xpZW50SWQ9JyArIHRoaXMuY2xpZW50SWQ7XG4gICAgICAgIGlmICh0aGlzLm1ldGFkYXRhKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IG1ldGFkYXRhPScgKyB0aGlzLm1ldGFkYXRhO1xuICAgICAgICBpZiAodGhpcy5kZXZpY2VJZGVudGl0eVRva2VuKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGRldmljZUlkZW50aXR5VG9rZW49JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZGV2aWNlSWRlbnRpdHlUb2tlbik7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLnB1c2gpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWNpcGllbnQpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgcHVzaC5yZWNpcGllbnQ9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMucHVzaC5yZWNpcGllbnQpO1xuICAgICAgICBpZiAoKF9iID0gdGhpcy5wdXNoKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhdGUpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgcHVzaC5zdGF0ZT0nICsgdGhpcy5wdXNoLnN0YXRlO1xuICAgICAgICBpZiAoKF9jID0gdGhpcy5wdXNoKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZXJyb3IpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgcHVzaC5lcnJvcj0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5wdXNoLmVycm9yKTtcbiAgICAgICAgaWYgKChfZCA9IHRoaXMucHVzaCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLm1ldGFkYXRhKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IHB1c2gubWV0YWRhdGE9JyArIHRoaXMucHVzaC5tZXRhZGF0YTtcbiAgICAgICAgcmVzdWx0ICs9ICddJztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIERldmljZURldGFpbHMuZnJvbVJlc3BvbnNlQm9keSA9IGZ1bmN0aW9uIChib2R5LCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgYm9keSA9IFV0aWxzLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVXRpbHMuaXNBcnJheShib2R5KSkge1xuICAgICAgICAgICAgcmV0dXJuIERldmljZURldGFpbHMuZnJvbVZhbHVlc0FycmF5KGJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIERldmljZURldGFpbHMuZnJvbVZhbHVlcyhib2R5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGV2aWNlRGV0YWlscy5mcm9tVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICB2YWx1ZXMuZXJyb3IgPSB2YWx1ZXMuZXJyb3IgJiYgZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHZhbHVlcy5lcnJvcik7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBEZXZpY2VEZXRhaWxzKCksIHZhbHVlcyk7XG4gICAgfTtcbiAgICBEZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXNBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gdmFsdWVzLmxlbmd0aCwgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKVxuICAgICAgICAgICAgcmVzdWx0W2ldID0gRGV2aWNlRGV0YWlscy5mcm9tVmFsdWVzKHZhbHVlc1tpXSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBEZXZpY2VEZXRhaWxzLnRvUmVxdWVzdEJvZHkgPSBVdGlscy5lbmNvZGVCb2R5O1xuICAgIHJldHVybiBEZXZpY2VEZXRhaWxzO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IERldmljZURldGFpbHM7XG5cblxuLyoqKi8gfSksXG4vKiA0OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgUHVzaENoYW5uZWxTdWJzY3JpcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHVzaENoYW5uZWxTdWJzY3JpcHRpb24oKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJsb2FkIHRvSlNPTigpIHRvIGludGVyY2VwdCBKU09OLnN0cmluZ2lmeSgpXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbm5lbDogdGhpcy5jaGFubmVsLFxuICAgICAgICAgICAgZGV2aWNlSWQ6IHRoaXMuZGV2aWNlSWQsXG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICdbUHVzaENoYW5uZWxTdWJzY3JpcHRpb24nO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGNoYW5uZWw9JyArIHRoaXMuY2hhbm5lbDtcbiAgICAgICAgaWYgKHRoaXMuZGV2aWNlSWQpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgZGV2aWNlSWQ9JyArIHRoaXMuZGV2aWNlSWQ7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudElkKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGNsaWVudElkPScgKyB0aGlzLmNsaWVudElkO1xuICAgICAgICByZXN1bHQgKz0gJ10nO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVJlc3BvbnNlQm9keSA9IGZ1bmN0aW9uIChib2R5LCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgYm9keSA9IFV0aWxzLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVXRpbHMuaXNBcnJheShib2R5KSkge1xuICAgICAgICAgICAgcmV0dXJuIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXNBcnJheShib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzKGJvZHkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgUHVzaENoYW5uZWxTdWJzY3JpcHRpb24oKSwgdmFsdWVzKTtcbiAgICB9O1xuICAgIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXNBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gdmFsdWVzLmxlbmd0aCwgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKVxuICAgICAgICAgICAgcmVzdWx0W2ldID0gUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUHVzaENoYW5uZWxTdWJzY3JpcHRpb24udG9SZXF1ZXN0Qm9keSA9IFV0aWxzLmVuY29kZUJvZHk7XG4gICAgcmV0dXJuIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uO1xuXG5cbi8qKiovIH0pLFxuLyogNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIE1lc3NhZ2VDb3VudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXNzYWdlQ291bnQodmFsdWVzKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSAodmFsdWVzICYmIHZhbHVlcy5jb3VudCkgfHwgMDtcbiAgICAgICAgdGhpcy5kYXRhID0gKHZhbHVlcyAmJiB2YWx1ZXMuZGF0YSkgfHwgMDtcbiAgICAgICAgdGhpcy51bmNvbXByZXNzZWREYXRhID0gKHZhbHVlcyAmJiB2YWx1ZXMudW5jb21wcmVzc2VkRGF0YSkgfHwgMDtcbiAgICAgICAgdGhpcy5mYWlsZWQgPSAodmFsdWVzICYmIHZhbHVlcy5mYWlsZWQpIHx8IDA7XG4gICAgICAgIHRoaXMucmVmdXNlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnJlZnVzZWQpIHx8IDA7XG4gICAgfVxuICAgIHJldHVybiBNZXNzYWdlQ291bnQ7XG59KCkpO1xudmFyIE1lc3NhZ2VDYXRlZ29yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZXNzYWdlQ2F0ZWdvcnksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZUNhdGVnb3J5KHZhbHVlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB2YWx1ZXMpIHx8IHRoaXM7XG4gICAgICAgIGlmICh2YWx1ZXMgJiYgdmFsdWVzLmNhdGVnb3J5KSB7XG4gICAgICAgICAgICBfdGhpcy5jYXRlZ29yeSA9IHt9O1xuICAgICAgICAgICAgVXRpbHMuZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllcyh2YWx1ZXMuY2F0ZWdvcnksIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2F0ZWdvcnlbcHJvcF0gPSBuZXcgTWVzc2FnZUNvdW50KHZhbHVlcy5jYXRlZ29yeVtwcm9wXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZXNzYWdlQ2F0ZWdvcnk7XG59KE1lc3NhZ2VDb3VudCkpO1xudmFyIFJlc291cmNlQ291bnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzb3VyY2VDb3VudCh2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5wZWFrID0gKHZhbHVlcyAmJiB2YWx1ZXMucGVhaykgfHwgMDtcbiAgICAgICAgdGhpcy5taW4gPSAodmFsdWVzICYmIHZhbHVlcy5taW4pIHx8IDA7XG4gICAgICAgIHRoaXMubWVhbiA9ICh2YWx1ZXMgJiYgdmFsdWVzLm1lYW4pIHx8IDA7XG4gICAgICAgIHRoaXMub3BlbmVkID0gKHZhbHVlcyAmJiB2YWx1ZXMub3BlbmVkKSB8fCAwO1xuICAgICAgICB0aGlzLnJlZnVzZWQgPSAodmFsdWVzICYmIHZhbHVlcy5yZWZ1c2VkKSB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gUmVzb3VyY2VDb3VudDtcbn0oKSk7XG52YXIgUmVxdWVzdENvdW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlcXVlc3RDb3VudCh2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5zdWNjZWVkZWQgPSAodmFsdWVzICYmIHZhbHVlcy5zdWNjZWVkZWQpIHx8IDA7XG4gICAgICAgIHRoaXMuZmFpbGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuZmFpbGVkKSB8fCAwO1xuICAgICAgICB0aGlzLnJlZnVzZWQgPSAodmFsdWVzICYmIHZhbHVlcy5yZWZ1c2VkKSB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gUmVxdWVzdENvdW50O1xufSgpKTtcbnZhciBDb25uZWN0aW9uVHlwZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGlvblR5cGVzKHZhbHVlcykge1xuICAgICAgICB0aGlzLnBsYWluID0gbmV3IFJlc291cmNlQ291bnQodmFsdWVzICYmIHZhbHVlcy5wbGFpbik7XG4gICAgICAgIHRoaXMudGxzID0gbmV3IFJlc291cmNlQ291bnQodmFsdWVzICYmIHZhbHVlcy50bHMpO1xuICAgICAgICB0aGlzLmFsbCA9IG5ldyBSZXNvdXJjZUNvdW50KHZhbHVlcyAmJiB2YWx1ZXMuYWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIENvbm5lY3Rpb25UeXBlcztcbn0oKSk7XG52YXIgTWVzc2FnZVR5cGVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VUeXBlcyh2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IG5ldyBNZXNzYWdlQ2F0ZWdvcnkodmFsdWVzICYmIHZhbHVlcy5tZXNzYWdlcyk7XG4gICAgICAgIHRoaXMucHJlc2VuY2UgPSBuZXcgTWVzc2FnZUNhdGVnb3J5KHZhbHVlcyAmJiB2YWx1ZXMucHJlc2VuY2UpO1xuICAgICAgICB0aGlzLmFsbCA9IG5ldyBNZXNzYWdlQ2F0ZWdvcnkodmFsdWVzICYmIHZhbHVlcy5hbGwpO1xuICAgIH1cbiAgICByZXR1cm4gTWVzc2FnZVR5cGVzO1xufSgpKTtcbnZhciBNZXNzYWdlVHJhZmZpYyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXNzYWdlVHJhZmZpYyh2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5yZWFsdGltZSA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5yZWFsdGltZSk7XG4gICAgICAgIHRoaXMucmVzdCA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5yZXN0KTtcbiAgICAgICAgdGhpcy53ZWJob29rID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLndlYmhvb2spO1xuICAgICAgICB0aGlzLnNoYXJlZFF1ZXVlID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLnNoYXJlZFF1ZXVlKTtcbiAgICAgICAgdGhpcy5leHRlcm5hbFF1ZXVlID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmV4dGVybmFsUXVldWUpO1xuICAgICAgICB0aGlzLmh0dHBFdmVudCA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5odHRwRXZlbnQpO1xuICAgICAgICB0aGlzLnB1c2ggPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMucHVzaCk7XG4gICAgICAgIHRoaXMuYWxsID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmFsbCk7XG4gICAgfVxuICAgIHJldHVybiBNZXNzYWdlVHJhZmZpYztcbn0oKSk7XG52YXIgTWVzc2FnZURpcmVjdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVzc2FnZURpcmVjdGlvbnModmFsdWVzKSB7XG4gICAgICAgIHRoaXMuYWxsID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmFsbCk7XG4gICAgICAgIHRoaXMuaW5ib3VuZCA9IG5ldyBNZXNzYWdlVHJhZmZpYyh2YWx1ZXMgJiYgdmFsdWVzLmluYm91bmQpO1xuICAgICAgICB0aGlzLm91dGJvdW5kID0gbmV3IE1lc3NhZ2VUcmFmZmljKHZhbHVlcyAmJiB2YWx1ZXMub3V0Ym91bmQpO1xuICAgIH1cbiAgICByZXR1cm4gTWVzc2FnZURpcmVjdGlvbnM7XG59KCkpO1xudmFyIFhjaGdNZXNzYWdlcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYY2hnTWVzc2FnZXModmFsdWVzKSB7XG4gICAgICAgIHRoaXMuYWxsID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmFsbCk7XG4gICAgICAgIHRoaXMucHJvZHVjZXJQYWlkID0gbmV3IE1lc3NhZ2VEaXJlY3Rpb25zKHZhbHVlcyAmJiB2YWx1ZXMucHJvZHVjZXJQYWlkKTtcbiAgICAgICAgdGhpcy5jb25zdW1lclBhaWQgPSBuZXcgTWVzc2FnZURpcmVjdGlvbnModmFsdWVzICYmIHZhbHVlcy5jb25zdW1lclBhaWQpO1xuICAgIH1cbiAgICByZXR1cm4gWGNoZ01lc3NhZ2VzO1xufSgpKTtcbnZhciBQdXNoU3RhdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHVzaFN0YXRzKHZhbHVlcykge1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gKHZhbHVlcyAmJiB2YWx1ZXMubWVzc2FnZXMpIHx8IDA7XG4gICAgICAgIHZhciBub3RpZmljYXRpb25zID0gdmFsdWVzICYmIHZhbHVlcy5ub3RpZmljYXRpb25zO1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSB7XG4gICAgICAgICAgICBpbnZhbGlkOiAobm90aWZpY2F0aW9ucyAmJiBub3RpZmljYXRpb25zLmludmFsaWQpIHx8IDAsXG4gICAgICAgICAgICBhdHRlbXB0ZWQ6IChub3RpZmljYXRpb25zICYmIG5vdGlmaWNhdGlvbnMuYXR0ZW1wdGVkKSB8fCAwLFxuICAgICAgICAgICAgc3VjY2Vzc2Z1bDogKG5vdGlmaWNhdGlvbnMgJiYgbm90aWZpY2F0aW9ucy5zdWNjZXNzZnVsKSB8fCAwLFxuICAgICAgICAgICAgZmFpbGVkOiAobm90aWZpY2F0aW9ucyAmJiBub3RpZmljYXRpb25zLmZhaWxlZCkgfHwgMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kaXJlY3RQdWJsaXNoZXMgPSAodmFsdWVzICYmIHZhbHVlcy5kaXJlY3RQdWJsaXNoZXMpIHx8IDA7XG4gICAgfVxuICAgIHJldHVybiBQdXNoU3RhdHM7XG59KCkpO1xudmFyIFByb2Nlc3NlZENvdW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByb2Nlc3NlZENvdW50KHZhbHVlcykge1xuICAgICAgICB0aGlzLnN1Y2NlZWRlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnN1Y2NlZWRlZCkgfHwgMDtcbiAgICAgICAgdGhpcy5za2lwcGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuc2tpcHBlZCkgfHwgMDtcbiAgICAgICAgdGhpcy5mYWlsZWQgPSAodmFsdWVzICYmIHZhbHVlcy5mYWlsZWQpIHx8IDA7XG4gICAgfVxuICAgIHJldHVybiBQcm9jZXNzZWRDb3VudDtcbn0oKSk7XG52YXIgUHJvY2Vzc2VkTWVzc2FnZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvY2Vzc2VkTWVzc2FnZXModmFsdWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGVsdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh2YWx1ZXMgJiYgdmFsdWVzLmRlbHRhKSB7XG4gICAgICAgICAgICB0aGlzLmRlbHRhID0ge307XG4gICAgICAgICAgICBVdGlscy5mb3JJbk93bk5vbk51bGxQcm9wZXJ0aWVzKHZhbHVlcy5kZWx0YSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kZWx0YVtwcm9wXSA9IG5ldyBQcm9jZXNzZWRDb3VudCh2YWx1ZXMuZGVsdGFbcHJvcF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb2Nlc3NlZE1lc3NhZ2VzO1xufSgpKTtcbnZhciBTdGF0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdGF0cywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdGF0cyh2YWx1ZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdmFsdWVzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wZXJzaXN0ZWQgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMucGVyc2lzdGVkKTtcbiAgICAgICAgX3RoaXMuY29ubmVjdGlvbnMgPSBuZXcgQ29ubmVjdGlvblR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuY29ubmVjdGlvbnMpO1xuICAgICAgICBfdGhpcy5jaGFubmVscyA9IG5ldyBSZXNvdXJjZUNvdW50KHZhbHVlcyAmJiB2YWx1ZXMuY2hhbm5lbHMpO1xuICAgICAgICBfdGhpcy5hcGlSZXF1ZXN0cyA9IG5ldyBSZXF1ZXN0Q291bnQodmFsdWVzICYmIHZhbHVlcy5hcGlSZXF1ZXN0cyk7XG4gICAgICAgIF90aGlzLnRva2VuUmVxdWVzdHMgPSBuZXcgUmVxdWVzdENvdW50KHZhbHVlcyAmJiB2YWx1ZXMudG9rZW5SZXF1ZXN0cyk7XG4gICAgICAgIF90aGlzLnhjaGdQcm9kdWNlciA9IG5ldyBYY2hnTWVzc2FnZXModmFsdWVzICYmIHZhbHVlcy54Y2hnUHJvZHVjZXIpO1xuICAgICAgICBfdGhpcy54Y2hnQ29uc3VtZXIgPSBuZXcgWGNoZ01lc3NhZ2VzKHZhbHVlcyAmJiB2YWx1ZXMueGNoZ0NvbnN1bWVyKTtcbiAgICAgICAgX3RoaXMucHVzaCA9IG5ldyBQdXNoU3RhdHModmFsdWVzICYmIHZhbHVlcy5wdXNoU3RhdHMpO1xuICAgICAgICBfdGhpcy5wcm9jZXNzZWQgPSBuZXcgUHJvY2Vzc2VkTWVzc2FnZXModmFsdWVzICYmIHZhbHVlcy5wcm9jZXNzZWQpO1xuICAgICAgICBfdGhpcy5pblByb2dyZXNzID0gKHZhbHVlcyAmJiB2YWx1ZXMuaW5Qcm9ncmVzcykgfHwgdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy51bml0ID0gKHZhbHVlcyAmJiB2YWx1ZXMudW5pdCkgfHwgdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5pbnRlcnZhbElkID0gKHZhbHVlcyAmJiB2YWx1ZXMuaW50ZXJ2YWxJZCkgfHwgdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN0YXRzLmZyb21WYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdHModmFsdWVzKTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0cztcbn0oTWVzc2FnZURpcmVjdGlvbnMpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0YXRzO1xuXG5cbi8qKiovIH0pLFxuLyogNTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIHJlc3RfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzApKTtcbnZhciBldmVudGVtaXR0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNykpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgY29ubmVjdGlvbl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg1MSkpO1xudmFyIHJlYWx0aW1lY2hhbm5lbF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzOCkpO1xudmFyIGRlZmF1bHRzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIHByb3RvY29sbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxMCkpO1xudmFyIGNvbm5lY3Rpb25tYW5hZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOSkpO1xudmFyIFJlYWx0aW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJlYWx0aW1lLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlYWx0aW1lKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdSZWFsdGltZSgpJywgJycpO1xuICAgICAgICBfdGhpcy5jb25uZWN0aW9uID0gbmV3IGNvbm5lY3Rpb25fMS5kZWZhdWx0KF90aGlzLCBfdGhpcy5vcHRpb25zKTtcbiAgICAgICAgX3RoaXMuY2hhbm5lbHMgPSBuZXcgQ2hhbm5lbHMoX3RoaXMpO1xuICAgICAgICBpZiAob3B0aW9ucy5hdXRvQ29ubmVjdCAhPT0gZmFsc2UpXG4gICAgICAgICAgICBfdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVhbHRpbWUucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUmVhbHRpbWUuY29ubmVjdCgpJywgJycpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdCgpO1xuICAgIH07XG4gICAgUmVhbHRpbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1JlYWx0aW1lLmNsb3NlKCknLCAnJyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgIH07XG4gICAgUmVhbHRpbWUuUHJvbWlzZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0c18xLmRlZmF1bHQub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5wcm9taXNlcyA9IHRydWU7XG4gICAgICAgIHJldHVybiBuZXcgUmVhbHRpbWUob3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWFsdGltZS5DYWxsYmFja3MgPSBSZWFsdGltZTtcbiAgICBSZWFsdGltZS5VdGlscyA9IFV0aWxzO1xuICAgIFJlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyID0gY29ubmVjdGlvbm1hbmFnZXJfMS5kZWZhdWx0O1xuICAgIFJlYWx0aW1lLlBsYXRmb3JtID0gcGxhdGZvcm1fMS5kZWZhdWx0O1xuICAgIFJlYWx0aW1lLlByb3RvY29sTWVzc2FnZSA9IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQ7XG4gICAgUmVhbHRpbWUuTWVzc2FnZSA9IG1lc3NhZ2VfMS5kZWZhdWx0O1xuICAgIHJldHVybiBSZWFsdGltZTtcbn0ocmVzdF8xLmRlZmF1bHQpKTtcbnZhciBDaGFubmVscyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDaGFubmVscywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDaGFubmVscyhyZWFsdGltZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWFsdGltZSA9IHJlYWx0aW1lO1xuICAgICAgICBfdGhpcy5hbGwgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICByZWFsdGltZS5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLm9uKCd0cmFuc3BvcnQuYWN0aXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMub25UcmFuc3BvcnRBY3RpdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2hhbm5lbHMucHJvdG90eXBlLmNoYW5uZWxTZXJpYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VyaWFscyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gVXRpbHMua2V5c0FycmF5KHRoaXMuYWxsLCB0cnVlKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW25hbWVfMV07XG4gICAgICAgICAgICBpZiAoY2hhbm5lbC5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWwpIHtcbiAgICAgICAgICAgICAgICBzZXJpYWxzW25hbWVfMV0gPSBjaGFubmVsLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWFscztcbiAgICB9O1xuICAgIC8vIHJlY292ZXJDaGFubmVscyBnZXRzIHRoZSBnaXZlbiBjaGFubmVscyBhbmQgc2V0cyB0aGVpciBjaGFubmVsIHNlcmlhbHMuXG4gICAgQ2hhbm5lbHMucHJvdG90eXBlLnJlY292ZXJDaGFubmVscyA9IGZ1bmN0aW9uIChjaGFubmVsU2VyaWFscykge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gVXRpbHMua2V5c0FycmF5KGNoYW5uZWxTZXJpYWxzLCB0cnVlKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lXzIgPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuZ2V0KG5hbWVfMik7XG4gICAgICAgICAgICBjaGFubmVsLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCA9IGNoYW5uZWxTZXJpYWxzW25hbWVfMl07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENoYW5uZWxzLnByb3RvdHlwZS5vbkNoYW5uZWxNZXNzYWdlID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB2YXIgY2hhbm5lbE5hbWUgPSBtc2cuY2hhbm5lbDtcbiAgICAgICAgaWYgKGNoYW5uZWxOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQ2hhbm5lbHMub25DaGFubmVsTWVzc2FnZSgpJywgJ3JlY2VpdmVkIGV2ZW50IHVuc3BlY2lmaWVkIGNoYW5uZWwsIGFjdGlvbiA9ICcgKyBtc2cuYWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxOYW1lXTtcbiAgICAgICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0NoYW5uZWxzLm9uQ2hhbm5lbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBldmVudCBmb3Igbm9uLWV4aXN0ZW50IGNoYW5uZWw6ICcgKyBjaGFubmVsTmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2hhbm5lbC5vbk1lc3NhZ2UobXNnKTtcbiAgICB9O1xuICAgIC8qIGNhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGJlY29tZXMgY29ubmVjdGVkOyByZWF0dGVtcHQgYXR0YWNoL2RldGFjaFxuICAgICAqIGZvciBjaGFubmVscyB0aGF0IGFyZSBhdHRhY2hpbmcgb3IgZGV0YWNoaW5nLiAqL1xuICAgIENoYW5uZWxzLnByb3RvdHlwZS5vblRyYW5zcG9ydEFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgY2hhbm5lbE5hbWUgaW4gdGhpcy5hbGwpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5hbGxbY2hhbm5lbE5hbWVdO1xuICAgICAgICAgICAgaWYgKGNoYW5uZWwuc3RhdGUgPT09ICdhdHRhY2hpbmcnIHx8IGNoYW5uZWwuc3RhdGUgPT09ICdkZXRhY2hpbmcnKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLl9hdHRhY2goZmFsc2UsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gJ2F0dGFjaGVkJykge1xuICAgICAgICAgICAgICAgIC8vIE5vdGUgZXhwbGljaXR5IHJlcXVlc3QgdGhlIHN0YXRlLCBjaGFubmVsLmF0dGFjaCgpIHdvdWxkIGRvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAvLyBhcyBpdHMgYWxyZWFkeSBhdHRhY2hlZC5cbiAgICAgICAgICAgICAgICBjaGFubmVsLnJlcXVlc3RTdGF0ZSgnYXR0YWNoaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qIENvbm5lY3Rpb24gaW50ZXJydXB0aW9ucyAoaWUgd2hlbiB0aGUgY29ubmVjdGlvbiB3aWxsIG5vIGxvbmdlciBxdWV1ZVxuICAgICAqIGV2ZW50cykgaW1wbHkgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VzIGZvciBhbnkgY2hhbm5lbCB3aGljaCBpcyBlaXRoZXJcbiAgICAgKiBhdHRhY2hlZCwgcGVuZGluZywgb3Igd2lsbCBhdHRlbXB0IHRvIGJlY29tZSBhdHRhY2hlZCBpbiB0aGUgZnV0dXJlICovXG4gICAgQ2hhbm5lbHMucHJvdG90eXBlLnByb3BvZ2F0ZUNvbm5lY3Rpb25JbnRlcnJ1cHRpb24gPSBmdW5jdGlvbiAoY29ubmVjdGlvblN0YXRlLCByZWFzb24pIHtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb25TdGF0ZVRvQ2hhbm5lbFN0YXRlID0ge1xuICAgICAgICAgICAgY2xvc2luZzogJ2RldGFjaGVkJyxcbiAgICAgICAgICAgIGNsb3NlZDogJ2RldGFjaGVkJyxcbiAgICAgICAgICAgIGZhaWxlZDogJ2ZhaWxlZCcsXG4gICAgICAgICAgICBzdXNwZW5kZWQ6ICdzdXNwZW5kZWQnLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgZnJvbUNoYW5uZWxTdGF0ZXMgPSBbJ2F0dGFjaGluZycsICdhdHRhY2hlZCcsICdkZXRhY2hpbmcnLCAnc3VzcGVuZGVkJ107XG4gICAgICAgIHZhciB0b0NoYW5uZWxTdGF0ZSA9IGNvbm5lY3Rpb25TdGF0ZVRvQ2hhbm5lbFN0YXRlW2Nvbm5lY3Rpb25TdGF0ZV07XG4gICAgICAgIGZvciAodmFyIGNoYW5uZWxJZCBpbiB0aGlzLmFsbCkge1xuICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsSWRdO1xuICAgICAgICAgICAgaWYgKFV0aWxzLmFyckluKGZyb21DaGFubmVsU3RhdGVzLCBjaGFubmVsLnN0YXRlKSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwubm90aWZ5U3RhdGUodG9DaGFubmVsU3RhdGUsIHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENoYW5uZWxzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcbiAgICAgICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICAgICAgICBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV0gPSBuZXcgcmVhbHRpbWVjaGFubmVsXzEuZGVmYXVsdCh0aGlzLnJlYWx0aW1lLCBuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChjaGFubmVsLl9zaG91bGRSZWF0dGFjaFRvU2V0T3B0aW9ucyhjaGFubmVsT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnQ2hhbm5lbHMuZ2V0KCkgY2Fubm90IGJlIHVzZWQgdG8gc2V0IGNoYW5uZWwgb3B0aW9ucyB0aGF0IHdvdWxkIGNhdXNlIHRoZSBjaGFubmVsIHRvIHJlYXR0YWNoLiBQbGVhc2UsIHVzZSBSZWFsdGltZUNoYW5uZWwuc2V0T3B0aW9ucygpIGluc3RlYWQuJywgNDAwMDAsIDQwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFubmVsLnNldE9wdGlvbnMoY2hhbm5lbE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFubmVsO1xuICAgIH07XG4gICAgQ2hhbm5lbHMucHJvdG90eXBlLmdldERlcml2ZWQgPSBmdW5jdGlvbiAobmFtZSwgZGVyaXZlT3B0aW9ucywgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGRlcml2ZU9wdGlvbnMuZmlsdGVyKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyID0gVXRpbHMudG9CYXNlNjQoZGVyaXZlT3B0aW9ucy5maWx0ZXIpO1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gVXRpbHMubWF0Y2hEZXJpdmVkQ2hhbm5lbChuYW1lKTtcbiAgICAgICAgICAgIG5hbWUgPSBcIltmaWx0ZXI9XCIuY29uY2F0KGZpbHRlcikuY29uY2F0KG1hdGNoLnF1YWxpZmllclBhcmFtLCBcIl1cIikuY29uY2F0KG1hdGNoLmNoYW5uZWxOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXQobmFtZSwgY2hhbm5lbE9wdGlvbnMpO1xuICAgIH07XG4gICAgLyogSW5jbHVkZWQgdG8gc3VwcG9ydCBjZXJ0YWluIG5pY2hlIHVzZS1jYXNlczsgbW9zdCB1c2VycyBzaG91bGQgaWdub3JlIHRoaXMuXG4gICAgICogUGxlYXNlIGRvIG5vdCB1c2UgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcgKi9cbiAgICBDaGFubmVscy5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XG4gICAgICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWxlYXNlRXJyID0gY2hhbm5lbC5nZXRSZWxlYXNlRXJyKCk7XG4gICAgICAgIGlmIChyZWxlYXNlRXJyKSB7XG4gICAgICAgICAgICB0aHJvdyByZWxlYXNlRXJyO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmFsbFtuYW1lXTtcbiAgICB9O1xuICAgIHJldHVybiBDaGFubmVscztcbn0oZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUmVhbHRpbWU7XG5cblxuLyoqKi8gfSksXG4vKiA1MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgZXZlbnRlbWl0dGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKTtcbnZhciBjb25uZWN0aW9ubWFuYWdlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzNSkpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgY29ubmVjdGlvbnN0YXRlY2hhbmdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxudmFyIENvbm5lY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ29ubmVjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25uZWN0aW9uKGFibHksIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMud2hlblN0YXRlID0gKGZ1bmN0aW9uIChzdGF0ZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudGVtaXR0ZXJfMS5kZWZhdWx0LnByb3RvdHlwZS53aGVuU3RhdGUuY2FsbChfdGhpcywgc3RhdGUsIF90aGlzLnN0YXRlLCBsaXN0ZW5lciwgbmV3IGNvbm5lY3Rpb25zdGF0ZWNoYW5nZV8xLmRlZmF1bHQodW5kZWZpbmVkLCBzdGF0ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuYWJseSA9IGFibHk7XG4gICAgICAgIF90aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IGNvbm5lY3Rpb25tYW5hZ2VyXzEuZGVmYXVsdChhYmx5LCBvcHRpb25zKTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSBfdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zdGF0ZTtcbiAgICAgICAgX3RoaXMua2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5pZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMuZXJyb3JSZWFzb24gPSBudWxsO1xuICAgICAgICBfdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbignY29ubmVjdGlvbnN0YXRlJywgZnVuY3Rpb24gKHN0YXRlQ2hhbmdlKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSAoX3RoaXMuc3RhdGUgPSBzdGF0ZUNoYW5nZS5jdXJyZW50KTtcbiAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoc3RhdGUsIHN0YXRlQ2hhbmdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuY29ubmVjdGlvbk1hbmFnZXIub24oJ3VwZGF0ZScsIGZ1bmN0aW9uIChzdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgndXBkYXRlJywgc3RhdGVDaGFuZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbi5jb25uZWN0KCknLCAnJyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVxdWVzdFN0YXRlKHsgc3RhdGU6ICdjb25uZWN0aW5nJyB9KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uLnBpbmcoKScsICcnKTtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWJseS5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAncGluZycsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5waW5nKG51bGwsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb24uY2xvc2UoKScsICdjb25uZWN0aW9uS2V5ID0gJyArIHRoaXMua2V5KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogJ2Nsb3NpbmcnIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3Rpb24ucHJvdG90eXBlLCBcInJlY292ZXJ5S2V5XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVSZWNvdmVyeUtleSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlUmVjb3ZlcnlLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNyZWF0ZVJlY292ZXJ5S2V5KCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGlvbjtcbn0oZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvbjtcblxuXG4vKioqLyB9KSxcbi8qIDUyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBlbmRpbmdNZXNzYWdlID0gdm9pZCAwO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHByb3RvY29sbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxMCkpO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgZXZlbnRlbWl0dGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIG1lc3NhZ2VxdWV1ZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzNikpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgYWN0aW9ucyA9IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuQWN0aW9uO1xudmFyIFBlbmRpbmdNZXNzYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBlbmRpbmdNZXNzYWdlKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5tZXJnZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFjdGlvbiA9IG1lc3NhZ2UuYWN0aW9uO1xuICAgICAgICB0aGlzLnNlbmRBdHRlbXB0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hY2tSZXF1aXJlZCA9IGFjdGlvbiA9PSBhY3Rpb25zLk1FU1NBR0UgfHwgYWN0aW9uID09IGFjdGlvbnMuUFJFU0VOQ0U7XG4gICAgfVxuICAgIHJldHVybiBQZW5kaW5nTWVzc2FnZTtcbn0oKSk7XG5leHBvcnRzLlBlbmRpbmdNZXNzYWdlID0gUGVuZGluZ01lc3NhZ2U7XG52YXIgUHJvdG9jb2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUHJvdG9jb2wsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJvdG9jb2wodHJhbnNwb3J0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgX3RoaXMubWVzc2FnZVF1ZXVlID0gbmV3IG1lc3NhZ2VxdWV1ZV8xLmRlZmF1bHQoKTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uKCdhY2snLCBmdW5jdGlvbiAoc2VyaWFsLCBjb3VudCkge1xuICAgICAgICAgICAgX3RoaXMub25BY2soc2VyaWFsLCBjb3VudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0cmFuc3BvcnQub24oJ25hY2snLCBmdW5jdGlvbiAoc2VyaWFsLCBjb3VudCwgZXJyKSB7XG4gICAgICAgICAgICBfdGhpcy5vbk5hY2soc2VyaWFsLCBjb3VudCwgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUHJvdG9jb2wucHJvdG90eXBlLm9uQWNrID0gZnVuY3Rpb24gKHNlcmlhbCwgY291bnQpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdQcm90b2NvbC5vbkFjaygpJywgJ3NlcmlhbCA9ICcgKyBzZXJpYWwgKyAnOyBjb3VudCA9ICcgKyBjb3VudCk7XG4gICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoc2VyaWFsLCBjb3VudCk7XG4gICAgfTtcbiAgICBQcm90b2NvbC5wcm90b3R5cGUub25OYWNrID0gZnVuY3Rpb24gKHNlcmlhbCwgY291bnQsIGVycikge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1Byb3RvY29sLm9uTmFjaygpJywgJ3NlcmlhbCA9ICcgKyBzZXJpYWwgKyAnOyBjb3VudCA9ICcgKyBjb3VudCArICc7IGVyciA9ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICBlcnIgPSBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVW5hYmxlIHRvIHNlbmQgbWVzc2FnZTsgY2hhbm5lbCBub3QgcmVzcG9uZGluZycsIDUwMDAxLCA1MDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoc2VyaWFsLCBjb3VudCwgZXJyKTtcbiAgICB9O1xuICAgIFByb3RvY29sLnByb3RvdHlwZS5vbmNlSWRsZSA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICB2YXIgbWVzc2FnZVF1ZXVlID0gdGhpcy5tZXNzYWdlUXVldWU7XG4gICAgICAgIGlmIChtZXNzYWdlUXVldWUuY291bnQoKSA9PT0gMCkge1xuICAgICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlUXVldWUub25jZSgnaWRsZScsIGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIFByb3RvY29sLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHBlbmRpbmdNZXNzYWdlKSB7XG4gICAgICAgIGlmIChwZW5kaW5nTWVzc2FnZS5hY2tSZXF1aXJlZCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlUXVldWUucHVzaChwZW5kaW5nTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvZ2dlcl8xLmRlZmF1bHQuc2hvdWxkTG9nKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdQcm90b2NvbC5zZW5kKCknLCAnc2VuZGluZyBtc2c7ICcgKyBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LnN0cmluZ2lmeShwZW5kaW5nTWVzc2FnZS5tZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcGVuZGluZ01lc3NhZ2Uuc2VuZEF0dGVtcHRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LnNlbmQocGVuZGluZ01lc3NhZ2UubWVzc2FnZSk7XG4gICAgfTtcbiAgICBQcm90b2NvbC5wcm90b3R5cGUuZ2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQ7XG4gICAgfTtcbiAgICBQcm90b2NvbC5wcm90b3R5cGUuZ2V0UGVuZGluZ01lc3NhZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlUXVldWUuY29weUFsbCgpO1xuICAgIH07XG4gICAgUHJvdG9jb2wucHJvdG90eXBlLmNsZWFyUGVuZGluZ01lc3NhZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlUXVldWUuY2xlYXIoKTtcbiAgICB9O1xuICAgIFByb3RvY29sLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydDtcbiAgICAgICAgdGhpcy5vbmNlSWRsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBQcm90b2NvbDtcbn0oZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUHJvdG9jb2w7XG5cblxuLyoqKi8gfSksXG4vKiA1MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIHRyYW5zcG9ydF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyNikpO1xudmFyIGRlZmF1bHRzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIHByb3RvY29sbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxMCkpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgc2hvcnROYW1lID0gJ3dlYl9zb2NrZXQnO1xuZnVuY3Rpb24gaXNOb2RlV2ViU29ja2V0KHdzKSB7XG4gICAgcmV0dXJuICEhd3Mub247XG59XG52YXIgV2ViU29ja2V0VHJhbnNwb3J0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFdlYlNvY2tldFRyYW5zcG9ydCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXZWJTb2NrZXRUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWU7XG4gICAgICAgIC8qIElmIGlzIGEgYnJvd3NlciwgY2FuJ3QgZGV0ZWN0IHBpbmdzLCBzbyByZXF1ZXN0IHByb3RvY29sIGhlYXJ0YmVhdHMgKi9cbiAgICAgICAgcGFyYW1zLmhlYXJ0YmVhdHMgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLnVzZVByb3RvY29sSGVhcnRiZWF0cztcbiAgICAgICAgX3RoaXMud3NIb3N0ID0gZGVmYXVsdHNfMS5kZWZhdWx0LmdldEhvc3QocGFyYW1zLm9wdGlvbnMsIHBhcmFtcy5ob3N0LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBXZWJTb2NrZXRUcmFuc3BvcnQuaXNBdmFpbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuV2ViU29ja2V0O1xuICAgIH07XG4gICAgV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5jcmVhdGVXZWJTb2NrZXQgPSBmdW5jdGlvbiAodXJpLCBjb25uZWN0UGFyYW1zKSB7XG4gICAgICAgIHRoaXMudXJpID0gdXJpICsgVXRpbHMudG9RdWVyeVN0cmluZyhjb25uZWN0UGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLldlYlNvY2tldCh0aGlzLnVyaSk7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1dlYlNvY2tldFRyYW5zcG9ydDsgdXJpPScgKyB0aGlzLnVyaTtcbiAgICB9O1xuICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpJywgJ3N0YXJ0aW5nJyk7XG4gICAgICAgIHRyYW5zcG9ydF8xLmRlZmF1bHQucHJvdG90eXBlLmNvbm5lY3QuY2FsbCh0aGlzKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBwYXJhbXMgPSB0aGlzLnBhcmFtcywgb3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zO1xuICAgICAgICB2YXIgd3NTY2hlbWUgPSBvcHRpb25zLnRscyA/ICd3c3M6Ly8nIDogJ3dzOi8vJztcbiAgICAgICAgdmFyIHdzVXJpID0gd3NTY2hlbWUgKyB0aGlzLndzSG9zdCArICc6JyArIGRlZmF1bHRzXzEuZGVmYXVsdC5nZXRQb3J0KG9wdGlvbnMpICsgJy8nO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5jb25uZWN0KCknLCAndXJpOiAnICsgd3NVcmkpO1xuICAgICAgICB0aGlzLmF1dGguZ2V0QXV0aFBhcmFtcyhmdW5jdGlvbiAoZXJyLCBhdXRoUGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhcmFtU3RyID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBwYXJhbSBpbiBhdXRoUGFyYW1zKVxuICAgICAgICAgICAgICAgIHBhcmFtU3RyICs9ICcgJyArIHBhcmFtICsgJzogJyArIGF1dGhQYXJhbXNbcGFyYW1dICsgJzsnO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpJywgJ2F1dGhQYXJhbXM6JyArIHBhcmFtU3RyICsgJyBlcnI6ICcgKyBlcnIpO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHNlbGYuZGlzY29ubmVjdChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb25uZWN0UGFyYW1zID0gcGFyYW1zLmdldENvbm5lY3RQYXJhbXMoYXV0aFBhcmFtcyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciB3c0Nvbm5lY3Rpb24gPSAoc2VsZi53c0Nvbm5lY3Rpb24gPSBzZWxmLmNyZWF0ZVdlYlNvY2tldCh3c1VyaSwgY29ubmVjdFBhcmFtcykpO1xuICAgICAgICAgICAgICAgIHdzQ29ubmVjdGlvbi5iaW5hcnlUeXBlID0gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5iaW5hcnlUeXBlO1xuICAgICAgICAgICAgICAgIHdzQ29ubmVjdGlvbi5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub25Xc09wZW4oKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHdzQ29ubmVjdGlvbi5vbmNsb3NlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub25Xc0Nsb3NlKGV2KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHdzQ29ubmVjdGlvbi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vbldzRGF0YShldi5kYXRhKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHdzQ29ubmVjdGlvbi5vbmVycm9yID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub25Xc0Vycm9yKGV2KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChpc05vZGVXZWJTb2NrZXQod3NDb25uZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAvKiBub2RlOyBicm93c2VycyBjdXJyZW50bHkgZG9uJ3QgaGF2ZSBhIGdlbmVyYWwgZXZlbnRlbWl0dGVyIGFuZCBjYW4ndCBkZXRlY3RcbiAgICAgICAgICAgICAgICAgICAgICogcGluZ3MuIEFsc28sIG5vIG5lZWQgdG8gcmVwbHkgd2l0aCBhIHBvbmcgZXhwbGljaXRseSwgd3MgbGliIGhhbmRsZXMgdGhhdCAqL1xuICAgICAgICAgICAgICAgICAgICB3c0Nvbm5lY3Rpb24ub24oJ3BpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9uQWN0aXZpdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5jb25uZWN0KCknLCAnVW5leHBlY3RlZCBleGNlcHRpb24gY3JlYXRpbmcgd2Vic29ja2V0OiBlcnIgPSAnICsgKGUuc3RhY2sgfHwgZS5tZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgc2VsZi5kaXNjb25uZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciB3c0Nvbm5lY3Rpb24gPSB0aGlzLndzQ29ubmVjdGlvbjtcbiAgICAgICAgaWYgKCF3c0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LnNlbmQoKScsICdObyBzb2NrZXQgY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3c0Nvbm5lY3Rpb24uc2VuZChwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LnNlcmlhbGl6ZShtZXNzYWdlLCB0aGlzLnBhcmFtcy5mb3JtYXQpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdFeGNlcHRpb24gZnJvbSB3cyBjb25uZWN0aW9uIHdoZW4gdHJ5aW5nIHRvIHNlbmQ6ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZSk7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5zZW5kKCknLCBtc2cpO1xuICAgICAgICAgICAgLyogRG9uJ3QgdHJ5IHRvIHJlcXVlc3QgYSBkaXNjb25uZWN0LCB0aGF0J2xsIGp1c3QgaW52b2x2ZSBzZW5kaW5nIGRhdGFcbiAgICAgICAgICAgICAqIGRvd24gdGhlIHdlYnNvY2tldCBhZ2Fpbi4gSnVzdCBmaW5pc2ggdGhlIHRyYW5zcG9ydC4gKi9cbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCdkaXNjb25uZWN0ZWQnLCBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDUwMDAwLCA1MDApKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5vbldzRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NEYXRhKCknLCAnZGF0YSByZWNlaXZlZDsgbGVuZ3RoID0gJyArIGRhdGEubGVuZ3RoICsgJzsgdHlwZSA9ICcgKyB0eXBlb2YgZGF0YSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLm9uUHJvdG9jb2xNZXNzYWdlKHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuZGVzZXJpYWxpemUoZGF0YSwgdGhpcy5mb3JtYXQpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0RhdGEoKScsICdVbmV4cGVjdGVkIGV4Y2VwdGlvbiBoYW5kaW5nIGNoYW5uZWwgbWVzc2FnZTogJyArIGUuc3RhY2spO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uV3NPcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5vbldzT3BlbigpJywgJ29wZW5lZCBXZWJTb2NrZXQnKTtcbiAgICAgICAgdGhpcy5lbWl0KCdwcmVjb25uZWN0Jyk7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uV3NDbG9zZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICB2YXIgd2FzQ2xlYW4sIGNvZGU7XG4gICAgICAgIGlmICh0eXBlb2YgZXYgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8qIFczQyBzcGVjLWNvbXBhdGlibGUgKi9cbiAgICAgICAgICAgIGNvZGUgPSBldi5jb2RlO1xuICAgICAgICAgICAgLy8gZXYud2FzQ2xlYW4gaXMgdW5kZWZpbmVkIGluIHJlYWN0bmF0aXZlXG4gICAgICAgICAgICB3YXNDbGVhbiA9IGV2Lndhc0NsZWFuIHx8IGNvZGUgPT09IDEwMDA7XG4gICAgICAgIH0gLyppZih0eXBlb2YoZXYpID09ICdudW1iZXInKSovXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogd3MgaW4gbm9kZSAqL1xuICAgICAgICAgICAgY29kZSA9IGV2O1xuICAgICAgICAgICAgd2FzQ2xlYW4gPSBjb2RlID09IDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMud3NDb25uZWN0aW9uO1xuICAgICAgICBpZiAod2FzQ2xlYW4pIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NDbG9zZSgpJywgJ0NsZWFubHkgY2xvc2VkIFdlYlNvY2tldCcpO1xuICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdXZWJzb2NrZXQgY2xvc2VkJywgODAwMDMsIDQwMCk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnVW5jbGVhbiBkaXNjb25uZWN0aW9uIG9mIFdlYlNvY2tldCA7IGNvZGUgPSAnICsgY29kZSwgZXJyID0gbmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA4MDAwMywgNDAwKTtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NDbG9zZSgpJywgbXNnKTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCdkaXNjb25uZWN0ZWQnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnZGlzcG9zZWQnKTtcbiAgICB9O1xuICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUub25Xc0Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5vbkVycm9yKCknLCAnRXJyb3IgZnJvbSBXZWJTb2NrZXQ6ICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgIC8qIFdhaXQgYSB0aWNrIGJlZm9yZSBhYm9ydGluZzogaWYgdGhlIHdlYnNvY2tldCB3YXMgY29ubmVjdGVkLCB0aGlzIGV2ZW50XG4gICAgICAgICAqIHdpbGwgYmUgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW4gb25jbG9zZSBldmVudCB3aXRoIGEgY2xvc2UgY29kZS4gQWxsb3dcbiAgICAgICAgICogdGhhdCB0byBjbG9zZSBpdCAoc28gd2Ugc2VlIHRoZSBjbG9zZSBjb2RlKSByYXRoZXIgdGhhbiBhbnRpY2lwYXRpbmcgaXQgKi9cbiAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5kaXNjb25uZWN0KEVycm9yKGVyci5tZXNzYWdlKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5kaXNwb3NlKCknLCAnJyk7XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHZhciB3c0Nvbm5lY3Rpb24gPSB0aGlzLndzQ29ubmVjdGlvbjtcbiAgICAgICAgaWYgKHdzQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgLyogSWdub3JlIGFueSBtZXNzYWdlcyB0aGF0IGNvbWUgdGhyb3VnaCBhZnRlciBkaXNwb3NlKCkgaXMgY2FsbGVkIGJ1dCBiZWZvcmVcbiAgICAgICAgICAgICAqIHdlYnNvY2tldCBpcyBhY3R1YWxseSBjbG9zZWQuIChtb3N0bHkgd291bGQgYmUgaGFybWxlc3MsIGJ1dCBpZiBpdCdzIGFcbiAgICAgICAgICAgICAqIENPTk5FQ1RFRCwgaXQnbGwgcmUtdGljayBpc0Nvbm5lY3RlZCBhbmQgY2F1c2UgYWxsIHNvcnRzIG9mIGhhdm9jKSAqL1xuICAgICAgICAgICAgd3NDb25uZWN0aW9uLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLndzQ29ubmVjdGlvbjtcbiAgICAgICAgICAgIC8qIGRlZmVyIHVudGlsIHRoZSBuZXh0IGV2ZW50IGxvb3AgY3ljbGUgYmVmb3JlIGNsb3NpbmcgdGhlIHNvY2tldCxcbiAgICAgICAgICAgICAqIGdpdmluZyBzb21lIGltcGxlbWVudGF0aW9ucyB0aGUgb3Bwb3J0dW5pdHkgdG8gc2VuZCBhbnkgb3V0c3RhbmRpbmcgY2xvc2UgbWVzc2FnZSAqL1xuICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdXZWJTb2NrZXRUcmFuc3BvcnQuZGlzcG9zZSgpJywgJ2Nsb3Npbmcgd2Vic29ja2V0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCF3c0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXRUcmFuc3BvcnQuZGlzcG9zZSgpOiB3c0Nvbm5lY3Rpb24gaXMgbm90IGRlZmluZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd3NDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFdlYlNvY2tldFRyYW5zcG9ydDtcbn0odHJhbnNwb3J0XzEuZGVmYXVsdCkpO1xuZnVuY3Rpb24gaW5pdGlhbGlzZVRyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlcikge1xuICAgIGlmIChXZWJTb2NrZXRUcmFuc3BvcnQuaXNBdmFpbGFibGUoKSlcbiAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0c1tzaG9ydE5hbWVdID0gV2ViU29ja2V0VHJhbnNwb3J0O1xuICAgIHJldHVybiBXZWJTb2NrZXRUcmFuc3BvcnQ7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBpbml0aWFsaXNlVHJhbnNwb3J0O1xuXG5cbi8qKiovIH0pLFxuLyogNTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIHByZXNlbmNlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KSk7XG52YXIgZXZlbnRlbWl0dGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIHByZXNlbmNlbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNSkpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgcmVhbHRpbWVjaGFubmVsXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KSk7XG52YXIgbXVsdGljYXN0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjMpKTtcbnZhciBjaGFubmVsc3RhdGVjaGFuZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzkpKTtcbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuZnVuY3Rpb24gZ2V0Q2xpZW50SWQocmVhbHRpbWVQcmVzZW5jZSkge1xuICAgIHJldHVybiByZWFsdGltZVByZXNlbmNlLmNoYW5uZWwucmVhbHRpbWUuYXV0aC5jbGllbnRJZDtcbn1cbmZ1bmN0aW9uIGlzQW5vbnltb3VzT3JXaWxkY2FyZChyZWFsdGltZVByZXNlbmNlKSB7XG4gICAgdmFyIHJlYWx0aW1lID0gcmVhbHRpbWVQcmVzZW5jZS5jaGFubmVsLnJlYWx0aW1lO1xuICAgIC8qIElmIG5vdCBjdXJyZW50bHkgY29ubmVjdGVkLCB3ZSBjYW4ndCBhc3N1bWUgdGhhdCB3ZSdyZSBhbiBhbm9ueW1vdXNcbiAgICAgKiBjbGllbnQsIGFzIHJlYWx0aW1lIG1heSBpbmZvcm0gdXMgb2Ygb3VyIGNsaWVudElkIGluIHRoZSBDT05ORUNURURcbiAgICAgKiBtZXNzYWdlLiBTbyBhc3N1bWUgd2UncmUgbm90IGFub255bW91cyBhbmQgbGVhdmUgaXQgdG8gcmVhbHRpbWUgdG9cbiAgICAgKiByZXR1cm4gYW4gZXJyb3IgaWYgd2UgYXJlICovXG4gICAgdmFyIGNsaWVudElkID0gcmVhbHRpbWUuYXV0aC5jbGllbnRJZDtcbiAgICByZXR1cm4gKCFjbGllbnRJZCB8fCBjbGllbnRJZCA9PT0gJyonKSAmJiByZWFsdGltZS5jb25uZWN0aW9uLnN0YXRlID09PSAnY29ubmVjdGVkJztcbn1cbi8qIENhbGxiYWNrIGlzIGNhbGxlZCBvbmx5IGluIHRoZSBldmVudCBvZiBhbiBlcnJvciAqL1xuZnVuY3Rpb24gd2FpdEF0dGFjaGVkKGNoYW5uZWwsIGNhbGxiYWNrLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGNoYW5uZWwuc3RhdGUpIHtcbiAgICAgICAgY2FzZSAnYXR0YWNoZWQnOlxuICAgICAgICBjYXNlICdzdXNwZW5kZWQnOlxuICAgICAgICAgICAgYWN0aW9uKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5pdGlhbGl6ZWQnOlxuICAgICAgICBjYXNlICdkZXRhY2hlZCc6XG4gICAgICAgIGNhc2UgJ2RldGFjaGluZyc6XG4gICAgICAgIGNhc2UgJ2F0dGFjaGluZyc6XG4gICAgICAgICAgICBjaGFubmVsLmF0dGFjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyhjaGFubmVsLmludmFsaWRTdGF0ZUVycm9yKCkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXdlclRoYW4oaXRlbSwgZXhpc3RpbmcpIHtcbiAgICAvKiBSVFAyYjE6IGlmIGVpdGhlciBpcyBzeW50aGVzaXNlZCwgY29tcGFyZSBieSB0aW1lc3RhbXAgKi9cbiAgICBpZiAoaXRlbS5pc1N5bnRoZXNpemVkKCkgfHwgZXhpc3RpbmcuaXNTeW50aGVzaXplZCgpKSB7XG4gICAgICAgIC8vIFJUUDJiMWE6IGlmIGVxdWFsLCBwcmVmZXIgdGhlIG5ld2x5LWFycml2ZWQgb25lXG4gICAgICAgIHJldHVybiBpdGVtLnRpbWVzdGFtcCA+PSBleGlzdGluZy50aW1lc3RhbXA7XG4gICAgfVxuICAgIC8qIFJUUDJiMiAqL1xuICAgIHZhciBpdGVtT3JkZXJpbmdzID0gaXRlbS5wYXJzZUlkKCksIGV4aXN0aW5nT3JkZXJpbmdzID0gZXhpc3RpbmcucGFyc2VJZCgpO1xuICAgIGlmIChpdGVtT3JkZXJpbmdzLm1zZ1NlcmlhbCA9PT0gZXhpc3RpbmdPcmRlcmluZ3MubXNnU2VyaWFsKSB7XG4gICAgICAgIHJldHVybiBpdGVtT3JkZXJpbmdzLmluZGV4ID4gZXhpc3RpbmdPcmRlcmluZ3MuaW5kZXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gaXRlbU9yZGVyaW5ncy5tc2dTZXJpYWwgPiBleGlzdGluZ09yZGVyaW5ncy5tc2dTZXJpYWw7XG4gICAgfVxufVxudmFyIFJlYWx0aW1lUHJlc2VuY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUmVhbHRpbWVQcmVzZW5jZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWFsdGltZVByZXNlbmNlKGNoYW5uZWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY2hhbm5lbCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIF90aGlzLnN5bmNDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5tZW1iZXJzID0gbmV3IFByZXNlbmNlTWFwKF90aGlzLCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5jbGllbnRJZCArICc6JyArIGl0ZW0uY29ubmVjdGlvbklkOyB9KTtcbiAgICAgICAgLy8gUlRQMTdoOiBTdG9yZSBvd24gbWVtYmVycyBieSBjbGllbnRJZCBvbmx5LlxuICAgICAgICBfdGhpcy5fbXlNZW1iZXJzID0gbmV3IFByZXNlbmNlTWFwKF90aGlzLCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5jbGllbnRJZDsgfSk7XG4gICAgICAgIF90aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICBfdGhpcy5wZW5kaW5nUHJlc2VuY2UgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5lbnRlciA9IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoaXNBbm9ueW1vdXNPcldpbGRjYXJkKHRoaXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnY2xpZW50SWQgbXVzdCBiZSBzcGVjaWZpZWQgdG8gZW50ZXIgYSBwcmVzZW5jZSBjaGFubmVsJywgNDAwMTIsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQodW5kZWZpbmVkLCB1bmRlZmluZWQsIGRhdGEsICdlbnRlcicsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoaXNBbm9ueW1vdXNPcldpbGRjYXJkKHRoaXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnY2xpZW50SWQgbXVzdCBiZSBzcGVjaWZpZWQgdG8gdXBkYXRlIHByZXNlbmNlIGRhdGEnLCA0MDAxMiwgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGF0YSwgJ3VwZGF0ZScsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmVudGVyQ2xpZW50ID0gZnVuY3Rpb24gKGNsaWVudElkLCBkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh1bmRlZmluZWQsIGNsaWVudElkLCBkYXRhLCAnZW50ZXInLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS51cGRhdGVDbGllbnQgPSBmdW5jdGlvbiAoY2xpZW50SWQsIGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KHVuZGVmaW5lZCwgY2xpZW50SWQsIGRhdGEsICd1cGRhdGUnLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5fZW50ZXJPclVwZGF0ZUNsaWVudCA9IGZ1bmN0aW9uIChpZCwgY2xpZW50SWQsIGRhdGEsIGFjdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbC5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ19lbnRlck9yVXBkYXRlQ2xpZW50JywgW2lkLCBjbGllbnRJZCwgZGF0YSwgYWN0aW9uXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcbiAgICAgICAgaWYgKCFjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZVByZXNlbmNlLicgKyBhY3Rpb24gKyAnQ2xpZW50KCknLCAnY2hhbm5lbCA9ICcgKyBjaGFubmVsLm5hbWUgKyAnLCBpZCA9ICcgKyBpZCArICcsIGNsaWVudCA9ICcgKyAoY2xpZW50SWQgfHwgJyhpbXBsaWNpdCkgJyArIGdldENsaWVudElkKHRoaXMpKSk7XG4gICAgICAgIHZhciBwcmVzZW5jZSA9IHByZXNlbmNlbWVzc2FnZV8xLmRlZmF1bHQuZnJvbURhdGEoZGF0YSk7XG4gICAgICAgIHByZXNlbmNlLmFjdGlvbiA9IGFjdGlvbjtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBwcmVzZW5jZS5pZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGllbnRJZCkge1xuICAgICAgICAgICAgcHJlc2VuY2UuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICAgICAgfVxuICAgICAgICBwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmVuY29kZShwcmVzZW5jZSwgY2hhbm5lbC5jaGFubmVsT3B0aW9ucywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChjaGFubmVsLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYXR0YWNoZWQnOlxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLnNlbmRQcmVzZW5jZShwcmVzZW5jZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdpbml0aWFsaXplZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGV0YWNoZWQnOlxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmF0dGFjaCgpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgICAgIGNhc2UgJ2F0dGFjaGluZyc6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBlbmRpbmdQcmVzZW5jZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbmNlOiBwcmVzZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGVyciA9IG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdVbmFibGUgdG8gJyArIGFjdGlvbiArICcgcHJlc2VuY2UgY2hhbm5lbCB3aGlsZSBpbiAnICsgY2hhbm5lbC5zdGF0ZSArICcgc3RhdGUnLCA5MDAwMSk7XG4gICAgICAgICAgICAgICAgICAgIGVyci5jb2RlID0gOTAwMDE7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUubGVhdmUgPSBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGlzQW5vbnltb3VzT3JXaWxkY2FyZCh0aGlzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ2NsaWVudElkIG11c3QgaGF2ZSBiZWVuIHNwZWNpZmllZCB0byBlbnRlciBvciBsZWF2ZSBhIHByZXNlbmNlIGNoYW5uZWwnLCA0MDAxMiwgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sZWF2ZUNsaWVudCh1bmRlZmluZWQsIGRhdGEsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmxlYXZlQ2xpZW50ID0gZnVuY3Rpb24gKGNsaWVudElkLCBkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnbGVhdmVDbGllbnQnLCBbY2xpZW50SWQsIGRhdGFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsO1xuICAgICAgICBpZiAoIWNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKGNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZVByZXNlbmNlLmxlYXZlQ2xpZW50KCknLCAnbGVhdmluZzsgY2hhbm5lbCA9ICcgKyB0aGlzLmNoYW5uZWwubmFtZSArICcsIGNsaWVudCA9ICcgKyBjbGllbnRJZCk7XG4gICAgICAgIHZhciBwcmVzZW5jZSA9IHByZXNlbmNlbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICBhY3Rpb246ICdsZWF2ZScsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNsaWVudElkKSB7XG4gICAgICAgICAgICBwcmVzZW5jZS5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoY2hhbm5lbC5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnYXR0YWNoZWQnOlxuICAgICAgICAgICAgICAgIGNoYW5uZWwuc2VuZFByZXNlbmNlKHByZXNlbmNlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhdHRhY2hpbmcnOlxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1ByZXNlbmNlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZTogcHJlc2VuY2UsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luaXRpYWxpemVkJzpcbiAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6IHtcbiAgICAgICAgICAgICAgICAvKiB3ZSdyZSBub3QgYXR0YWNoZWQ7IHRoZXJlZm9yZSB3ZSBsZXQgYW55IGVudGVyZWQgc3RhdHVzXG4gICAgICAgICAgICAgICAgICogdGltZW91dCBieSBpdHNlbGYgaW5zdGVhZCBvZiBhdHRhY2hpbmcganVzdCBpbiBvcmRlciB0byBsZWF2ZSAqL1xuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygnVW5hYmxlIHRvIGxlYXZlIHByZXNlbmNlIGNoYW5uZWwgKGluY29tcGF0aWJsZSBzdGF0ZSknLCA5MDAwMSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhjaGFubmVsLmludmFsaWRTdGF0ZUVycm9yKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBSZXR1cm4gdHlwZSBpcyBhbnkgdG8gYXZvaWQgY29uZmxpY3Qgd2l0aCBiYXNlIFByZXNlbmNlIGNsYXNzXG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT0gMSAmJiB0eXBlb2YgYXJnc1swXSA9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgYXJncy51bnNoaWZ0KG51bGwpO1xuICAgICAgICBwYXJhbXMgPSBhcmdzWzBdO1xuICAgICAgICBjYWxsYmFjayA9IGFyZ3NbMV07XG4gICAgICAgIHZhciB3YWl0Rm9yU3luYyA9ICFwYXJhbXMgfHwgKCd3YWl0Rm9yU3luYycgaW4gcGFyYW1zID8gcGFyYW1zLndhaXRGb3JTeW5jIDogdHJ1ZSk7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWwucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2dldCcsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJldHVybk1lbWJlcnMobWVtYmVycykge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcGFyYW1zID8gbWVtYmVycy5saXN0KHBhcmFtcykgOiBtZW1iZXJzLnZhbHVlcygpKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBTcGVjaWFsLWNhc2UgdGhlIHN1c3BlbmRlZCBzdGF0ZTogY2FuIHN0aWxsIGdldCAoc3RhbGUpIHByZXNlbmNlIHNldCBpZiB3YWl0Rm9yU3luYyBpcyBmYWxzZSAqL1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsLnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuICAgICAgICAgICAgaWYgKHdhaXRGb3JTeW5jKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogNDAwLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiA5MTAwNSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ1ByZXNlbmNlIHN0YXRlIGlzIG91dCBvZiBzeW5jIGR1ZSB0byBjaGFubmVsIGJlaW5nIGluIHRoZSBTVVNQRU5ERUQgc3RhdGUnLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybk1lbWJlcnModGhpcy5tZW1iZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YWl0QXR0YWNoZWQodGhpcy5jaGFubmVsLCBjYWxsYmFjaywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSBfdGhpcy5tZW1iZXJzO1xuICAgICAgICAgICAgaWYgKHdhaXRGb3JTeW5jKSB7XG4gICAgICAgICAgICAgICAgbWVtYmVycy53YWl0U3luYyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybk1lbWJlcnMobWVtYmVycyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm5NZW1iZXJzKG1lbWJlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmhpc3RvcnkgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2UuaGlzdG9yeSgpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5uYW1lKTtcbiAgICAgICAgLyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXG4gICAgICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWwucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdoaXN0b3J5JywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLnVudGlsQXR0YWNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsLnN0YXRlID09PSAnYXR0YWNoZWQnKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy51bnRpbEF0dGFjaDtcbiAgICAgICAgICAgICAgICBwYXJhbXMuZnJvbV9zZXJpYWwgPSB0aGlzLmNoYW5uZWwucHJvcGVydGllcy5hdHRhY2hTZXJpYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnb3B0aW9uIHVudGlsQXR0YWNoIHJlcXVpcmVzIHRoZSBjaGFubmVsIHRvIGJlIGF0dGFjaGVkLCB3YXM6ICcgKyB0aGlzLmNoYW5uZWwuc3RhdGUsIDQwMDAwLCA0MDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmVzZW5jZV8xLmRlZmF1bHQucHJvdG90eXBlLl9oaXN0b3J5LmNhbGwodGhpcywgcGFyYW1zLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5zZXRQcmVzZW5jZSA9IGZ1bmN0aW9uIChwcmVzZW5jZVNldCwgaXNTeW5jLCBzeW5jQ2hhbm5lbFNlcmlhbCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2Uuc2V0UHJlc2VuY2UoKScsICdyZWNlaXZlZCBwcmVzZW5jZSBmb3IgJyArIHByZXNlbmNlU2V0Lmxlbmd0aCArICcgcGFydGljaXBhbnRzOyBzeW5jQ2hhbm5lbFNlcmlhbCA9ICcgKyBzeW5jQ2hhbm5lbFNlcmlhbCk7XG4gICAgICAgIHZhciBzeW5jQ3Vyc29yLCBtYXRjaDtcbiAgICAgICAgdmFyIG1lbWJlcnMgPSB0aGlzLm1lbWJlcnMsIG15TWVtYmVycyA9IHRoaXMuX215TWVtYmVycywgYnJvYWRjYXN0TWVzc2FnZXMgPSBbXSwgY29ubklkID0gdGhpcy5jaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZDtcbiAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgdGhpcy5tZW1iZXJzLnN0YXJ0U3luYygpO1xuICAgICAgICAgICAgaWYgKHN5bmNDaGFubmVsU2VyaWFsICYmIChtYXRjaCA9IHN5bmNDaGFubmVsU2VyaWFsLm1hdGNoKC9eW1xcdy1dKzooLiopJC8pKSkge1xuICAgICAgICAgICAgICAgIHN5bmNDdXJzb3IgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXNlbmNlU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJlc2VuY2UgPSBwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMocHJlc2VuY2VTZXRbaV0pO1xuICAgICAgICAgICAgc3dpdGNoIChwcmVzZW5jZS5hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdsZWF2ZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXJzLnJlbW92ZShwcmVzZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyb2FkY2FzdE1lc3NhZ2VzLnB1c2gocHJlc2VuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVzZW5jZS5jb25uZWN0aW9uSWQgPT09IGNvbm5JZCAmJiAhcHJlc2VuY2UuaXNTeW50aGVzaXplZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBteU1lbWJlcnMucmVtb3ZlKHByZXNlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlbnRlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAncHJlc2VudCc6XG4gICAgICAgICAgICAgICAgY2FzZSAndXBkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlcnMucHV0KHByZXNlbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0TWVzc2FnZXMucHVzaChwcmVzZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXNlbmNlLmNvbm5lY3Rpb25JZCA9PT0gY29ubklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBteU1lbWJlcnMucHV0KHByZXNlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBpZiB0aGlzIGlzIHRoZSBsYXN0IChvciBvbmx5KSBtZXNzYWdlIGluIGEgc2VxdWVuY2Ugb2Ygc3luYyB1cGRhdGVzLCBlbmQgdGhlIHN5bmMgKi9cbiAgICAgICAgaWYgKGlzU3luYyAmJiAhc3luY0N1cnNvcikge1xuICAgICAgICAgICAgbWVtYmVycy5lbmRTeW5jKCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwuc3luY0NoYW5uZWxTZXJpYWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qIGJyb2FkY2FzdCB0byBsaXN0ZW5lcnMgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBicm9hZGNhc3RNZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHByZXNlbmNlID0gYnJvYWRjYXN0TWVzc2FnZXNbaV07XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZW1pdChwcmVzZW5jZS5hY3Rpb24sIHByZXNlbmNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUub25BdHRhY2hlZCA9IGZ1bmN0aW9uIChoYXNQcmVzZW5jZSkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1JlYWx0aW1lUHJlc2VuY2Uub25BdHRhY2hlZCgpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5jaGFubmVsLm5hbWUgKyAnLCBoYXNQcmVzZW5jZSA9ICcgKyBoYXNQcmVzZW5jZSk7XG4gICAgICAgIGlmIChoYXNQcmVzZW5jZSkge1xuICAgICAgICAgICAgdGhpcy5tZW1iZXJzLnN0YXJ0U3luYygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3ludGhlc2l6ZUxlYXZlcyh0aGlzLm1lbWJlcnMudmFsdWVzKCkpO1xuICAgICAgICAgICAgdGhpcy5tZW1iZXJzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUlRQMTdmOiBSZS1lbnRlciBvd24gbWVtYmVycyB3aGVuIG1vdmluZyBpbnRvIHRoZSBhdHRhY2hlZCBzdGF0ZS5cbiAgICAgICAgdGhpcy5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpO1xuICAgICAgICAvKiBOQiB0aGlzIG11c3QgYmUgYWZ0ZXIgdGhlIF9lbnN1cmVNeU1lbWJlcnNQcmVzZW50IGNhbGwsIHdoaWNoIG1heSBhZGQgaXRlbXMgdG8gcGVuZGluZ1ByZXNlbmNlICovXG4gICAgICAgIHZhciBwZW5kaW5nUHJlc2VuY2UgPSB0aGlzLnBlbmRpbmdQcmVzZW5jZSwgcGVuZGluZ1ByZXNDb3VudCA9IHBlbmRpbmdQcmVzZW5jZS5sZW5ndGg7XG4gICAgICAgIGlmIChwZW5kaW5nUHJlc0NvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdQcmVzZW5jZSA9IFtdO1xuICAgICAgICAgICAgdmFyIHByZXNlbmNlQXJyYXkgPSBbXTtcbiAgICAgICAgICAgIHZhciBtdWx0aWNhc3RlciA9IG11bHRpY2FzdGVyXzEuZGVmYXVsdC5jcmVhdGUoKTtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS5vbkF0dGFjaGVkJywgJ3NlbmRpbmcgJyArIHBlbmRpbmdQcmVzQ291bnQgKyAnIHF1ZXVlZCBwcmVzZW5jZSBtZXNzYWdlcycpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwZW5kaW5nUHJlc0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRfMSA9IHBlbmRpbmdQcmVzZW5jZVtpXTtcbiAgICAgICAgICAgICAgICBwcmVzZW5jZUFycmF5LnB1c2goZXZlbnRfMS5wcmVzZW5jZSk7XG4gICAgICAgICAgICAgICAgbXVsdGljYXN0ZXIucHVzaChldmVudF8xLmNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5zZW5kUHJlc2VuY2UocHJlc2VuY2VBcnJheSwgbXVsdGljYXN0ZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5hY3RPbkNoYW5uZWxTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgaGFzUHJlc2VuY2UsIGVycikge1xuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdhdHRhY2hlZCc6XG4gICAgICAgICAgICAgICAgdGhpcy5vbkF0dGFjaGVkKGhhc1ByZXNlbmNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RldGFjaGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJNeU1lbWJlcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lbWJlcnMuY2xlYXIoKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ3N1c3BlbmRlZCc6XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsUGVuZGluZ1ByZXNlbmNlKGVycik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmZhaWxQZW5kaW5nUHJlc2VuY2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdQcmVzZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLmZhaWxQZW5kaW5nUHJlc2VuY2UnLCAnY2hhbm5lbDsgbmFtZSA9ICcgKyB0aGlzLmNoYW5uZWwubmFtZSArICcsIGVyciA9ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGVuZGluZ1ByZXNlbmNlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1ByZXNlbmNlW2ldLmNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdQcmVzZW5jZSA9IFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5fY2xlYXJNeU1lbWJlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX215TWVtYmVycy5jbGVhcigpO1xuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBteU1lbWJlcnMgPSB0aGlzLl9teU1lbWJlcnMsIHJlZW50ZXJDYiA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ1ByZXNlbmNlIGF1dG8tcmUtZW50ZXIgZmFpbGVkOiAnICsgZXJyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgdmFyIHdyYXBwZWRFcnIgPSBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDkxMDA0LCA0MDApO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnUmVhbHRpbWVQcmVzZW5jZS5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpJywgbXNnKTtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlID0gbmV3IGNoYW5uZWxzdGF0ZWNoYW5nZV8xLmRlZmF1bHQoX3RoaXMuY2hhbm5lbC5zdGF0ZSwgX3RoaXMuY2hhbm5lbC5zdGF0ZSwgdHJ1ZSwgZmFsc2UsIHdyYXBwZWRFcnIpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNoYW5uZWwuZW1pdCgndXBkYXRlJywgY2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgbWVtYmVyS2V5IGluIG15TWVtYmVycy5tYXApIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IG15TWVtYmVycy5tYXBbbWVtYmVyS2V5XTtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpJywgJ0F1dG8tcmVlbnRlcmluZyBjbGllbnRJZCBcIicgKyBlbnRyeS5jbGllbnRJZCArICdcIiBpbnRvIHRoZSBwcmVzZW5jZSBzZXQnKTtcbiAgICAgICAgICAgIC8vIFJUUDE3ZzogU2VuZCBFTlRFUiBjb250YWluaW5nIHRoZSBtZW1iZXIgaWQsIGNsaWVudElkIGFuZCBkYXRhXG4gICAgICAgICAgICAvLyBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudChlbnRyeS5pZCwgZW50cnkuY2xpZW50SWQsIGVudHJ5LmRhdGEsICdlbnRlcicsIHJlZW50ZXJDYik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLl9zeW50aGVzaXplTGVhdmVzID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zO1xuICAgICAgICBVdGlscy5hcnJGb3JFYWNoKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgdmFyIHByZXNlbmNlID0gcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdsZWF2ZScsXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbklkOiBpdGVtLmNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgICAgICBjbGllbnRJZDogaXRlbS5jbGllbnRJZCxcbiAgICAgICAgICAgICAgICBkYXRhOiBpdGVtLmRhdGEsXG4gICAgICAgICAgICAgICAgZW5jb2Rpbmc6IGl0ZW0uZW5jb2RpbmcsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBVdGlscy5ub3coKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5lbWl0KCdsZWF2ZScsIHByZXNlbmNlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiBEZXByZWNhdGVkICovXG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZXByZWNhdGVkKCdwcmVzZW5jZS5vbicsICdwcmVzZW5jZS5zdWJzY3JpYmUnKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgICAvKiBEZXByZWNhdGVkICovXG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZGVwcmVjYXRlZCgncHJlc2VuY2Uub2ZmJywgJ3ByZXNlbmNlLnVuc3Vic2NyaWJlJyk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYXJncyA9IFtdOyAvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqL1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAgLyogW2V2ZW50XSwgbGlzdGVuZXIsIFtjYWxsYmFja10gKi87IF9pIDwgYXJndW1lbnRzLmxlbmd0aCAvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqLzsgX2krKyAvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqLykge1xuICAgICAgICAgICAgX2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTsgLyogW2V2ZW50XSwgbGlzdGVuZXIsIFtjYWxsYmFja10gKi9cbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJncyA9IHJlYWx0aW1lY2hhbm5lbF8xLmRlZmF1bHQucHJvY2Vzc0xpc3RlbmVyQXJncyhfYXJncyk7XG4gICAgICAgIHZhciBldmVudCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbMl07XG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsO1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdzdWJzY3JpYmUnLCBbZXZlbnQsIGxpc3RlbmVyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5uZWwuc3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMoY2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvcigpKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIGNoYW5uZWwuYXR0YWNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2FyZ3MgPSBbXTsgLyogW2V2ZW50XSwgbGlzdGVuZXIgKi9cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwIC8qIFtldmVudF0sIGxpc3RlbmVyICovOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGggLyogW2V2ZW50XSwgbGlzdGVuZXIgKi87IF9pKysgLyogW2V2ZW50XSwgbGlzdGVuZXIgKi8pIHtcbiAgICAgICAgICAgIF9hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07IC8qIFtldmVudF0sIGxpc3RlbmVyICovXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ3MgPSByZWFsdGltZWNoYW5uZWxfMS5kZWZhdWx0LnByb2Nlc3NMaXN0ZW5lckFyZ3MoX2FyZ3MpO1xuICAgICAgICB2YXIgZXZlbnQgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBhcmdzWzFdO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICByZXR1cm4gUmVhbHRpbWVQcmVzZW5jZTtcbn0ocHJlc2VuY2VfMS5kZWZhdWx0KSk7XG52YXIgUHJlc2VuY2VNYXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUHJlc2VuY2VNYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJlc2VuY2VNYXAocHJlc2VuY2UsIG1lbWJlcktleSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wcmVzZW5jZSA9IHByZXNlbmNlO1xuICAgICAgICBfdGhpcy5tYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBfdGhpcy5zeW5jSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBudWxsO1xuICAgICAgICBfdGhpcy5tZW1iZXJLZXkgPSBtZW1iZXJLZXk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUHJlc2VuY2VNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwW2tleV07XG4gICAgfTtcbiAgICBQcmVzZW5jZU1hcC5wcm90b3R5cGUuZ2V0Q2xpZW50ID0gZnVuY3Rpb24gKGNsaWVudElkKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLm1hcCwgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBtYXApIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gbWFwW2tleV07XG4gICAgICAgICAgICBpZiAoaXRlbS5jbGllbnRJZCA9PSBjbGllbnRJZCAmJiBpdGVtLmFjdGlvbiAhPSAnYWJzZW50JylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUHJlc2VuY2VNYXAucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLm1hcCwgY2xpZW50SWQgPSBwYXJhbXMgJiYgcGFyYW1zLmNsaWVudElkLCBjb25uZWN0aW9uSWQgPSBwYXJhbXMgJiYgcGFyYW1zLmNvbm5lY3Rpb25JZCwgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBtYXApIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gbWFwW2tleV07XG4gICAgICAgICAgICBpZiAoaXRlbS5hY3Rpb24gPT09ICdhYnNlbnQnKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGNsaWVudElkICYmIGNsaWVudElkICE9IGl0ZW0uY2xpZW50SWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbklkICYmIGNvbm5lY3Rpb25JZCAhPSBpdGVtLmNvbm5lY3Rpb25JZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1hcC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0uYWN0aW9uID09PSAnZW50ZXInIHx8IGl0ZW0uYWN0aW9uID09PSAndXBkYXRlJykge1xuICAgICAgICAgICAgaXRlbSA9IHByZXNlbmNlbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyhpdGVtKTtcbiAgICAgICAgICAgIGl0ZW0uYWN0aW9uID0gJ3ByZXNlbnQnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLm1hcCwga2V5ID0gdGhpcy5tZW1iZXJLZXkoaXRlbSk7XG4gICAgICAgIC8qIHdlJ3ZlIHNlZW4gdGhpcyBtZW1iZXIsIHNvIGRvIG5vdCByZW1vdmUgaXQgYXQgdGhlIGVuZCBvZiBzeW5jICovXG4gICAgICAgIGlmICh0aGlzLnJlc2lkdWFsTWVtYmVycylcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlc2lkdWFsTWVtYmVyc1trZXldO1xuICAgICAgICAvKiBjb21wYXJlIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG5ldyBpdGVtIHdpdGggYW55IGV4aXN0aW5nIG1lbWJlciAob3IgQUJTRU5UIHdpdG5lc3MpICovXG4gICAgICAgIHZhciBleGlzdGluZ0l0ZW0gPSBtYXBba2V5XTtcbiAgICAgICAgaWYgKGV4aXN0aW5nSXRlbSAmJiAhbmV3ZXJUaGFuKGl0ZW0sIGV4aXN0aW5nSXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBtYXBba2V5XSA9IGl0ZW07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgUHJlc2VuY2VNYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwLCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG1hcCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBtYXBba2V5XTtcbiAgICAgICAgICAgIGlmIChpdGVtLmFjdGlvbiAhPSAnYWJzZW50JylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUHJlc2VuY2VNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLm1hcCwga2V5ID0gdGhpcy5tZW1iZXJLZXkoaXRlbSk7XG4gICAgICAgIHZhciBleGlzdGluZ0l0ZW0gPSBtYXBba2V5XTtcbiAgICAgICAgaWYgKGV4aXN0aW5nSXRlbSAmJiAhbmV3ZXJUaGFuKGl0ZW0sIGV4aXN0aW5nSXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKiBSVFAyZiAqL1xuICAgICAgICBpZiAodGhpcy5zeW5jSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgaXRlbSA9IHByZXNlbmNlbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyhpdGVtKTtcbiAgICAgICAgICAgIGl0ZW0uYWN0aW9uID0gJ2Fic2VudCc7XG4gICAgICAgICAgICBtYXBba2V5XSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgbWFwW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1hcC5wcm90b3R5cGUuc3RhcnRTeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5tYXAsIHN5bmNJblByb2dyZXNzID0gdGhpcy5zeW5jSW5Qcm9ncmVzcztcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdQcmVzZW5jZU1hcC5zdGFydFN5bmMoKScsICdjaGFubmVsID0gJyArIHRoaXMucHJlc2VuY2UuY2hhbm5lbC5uYW1lICsgJzsgc3luY0luUHJvZ3Jlc3MgPSAnICsgc3luY0luUHJvZ3Jlc3MpO1xuICAgICAgICAvKiB3ZSBtaWdodCBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2hpbGUgYSBzeW5jIGlzIGluIHByb2dyZXNzICovXG4gICAgICAgIGlmICghdGhpcy5zeW5jSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgdGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBVdGlscy5jb3B5KG1hcCk7XG4gICAgICAgICAgICB0aGlzLnNldEluUHJvZ3Jlc3ModHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFByZXNlbmNlTWFwLnByb3RvdHlwZS5lbmRTeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5tYXAsIHN5bmNJblByb2dyZXNzID0gdGhpcy5zeW5jSW5Qcm9ncmVzcztcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdQcmVzZW5jZU1hcC5lbmRTeW5jKCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLnByZXNlbmNlLmNoYW5uZWwubmFtZSArICc7IHN5bmNJblByb2dyZXNzID0gJyArIHN5bmNJblByb2dyZXNzKTtcbiAgICAgICAgaWYgKHN5bmNJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAvKiB3ZSBjYW4gbm93IHN0cmlwIG91dCB0aGUgQUJTRU5UIG1lbWJlcnMsIGFzIHdlIGhhdmVcbiAgICAgICAgICAgICAqIHJlY2VpdmVkIGFsbCBvZiB0aGUgb3V0LW9mLW9yZGVyIHN5bmMgbWVzc2FnZXMgKi9cbiAgICAgICAgICAgIGZvciAodmFyIG1lbWJlcktleSBpbiBtYXApIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBtYXBbbWVtYmVyS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuYWN0aW9uID09PSAnYWJzZW50Jykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWFwW21lbWJlcktleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYW55IG1lbWJlcnMgdGhhdCB3ZXJlIHByZXNlbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBzeW5jLFxuICAgICAgICAgICAgICogYW5kIGhhdmUgbm90IGJlZW4gc2VlbiBpbiBzeW5jLCBjYW4gYmUgcmVtb3ZlZCwgYW5kIGxlYXZlIGV2ZW50cyBlbWl0dGVkICovXG4gICAgICAgICAgICB0aGlzLnByZXNlbmNlLl9zeW50aGVzaXplTGVhdmVzKFV0aWxzLnZhbHVlc0FycmF5KHRoaXMucmVzaWR1YWxNZW1iZXJzKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBtZW1iZXJLZXkgaW4gdGhpcy5yZXNpZHVhbE1lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbWFwW21lbWJlcktleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG4gICAgICAgICAgICAvKiBmaW5pc2gsIG5vdGlmeWluZyBhbnkgd2FpdGVycyAqL1xuICAgICAgICAgICAgdGhpcy5zZXRJblByb2dyZXNzKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3N5bmMnKTtcbiAgICB9O1xuICAgIFByZXNlbmNlTWFwLnByb3RvdHlwZS53YWl0U3luYyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1ByZXNlbmNlTWFwLndhaXRTeW5jKCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLnByZXNlbmNlLmNoYW5uZWwubmFtZSArICc7IHN5bmNJblByb2dyZXNzID0gJyArIHN5bmNJblByb2dyZXNzKTtcbiAgICAgICAgaWYgKCFzeW5jSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uY2UoJ3N5bmMnLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWFwID0ge307XG4gICAgICAgIHRoaXMuc2V0SW5Qcm9ncmVzcyhmYWxzZSk7XG4gICAgICAgIHRoaXMucmVzaWR1YWxNZW1iZXJzID0gbnVsbDtcbiAgICB9O1xuICAgIFByZXNlbmNlTWFwLnByb3RvdHlwZS5zZXRJblByb2dyZXNzID0gZnVuY3Rpb24gKGluUHJvZ3Jlc3MpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdQcmVzZW5jZU1hcC5zZXRJblByb2dyZXNzKCknLCAnaW5Qcm9ncmVzcyA9ICcgKyBpblByb2dyZXNzKTtcbiAgICAgICAgdGhpcy5zeW5jSW5Qcm9ncmVzcyA9IGluUHJvZ3Jlc3M7XG4gICAgICAgIHRoaXMucHJlc2VuY2Uuc3luY0NvbXBsZXRlID0gIWluUHJvZ3Jlc3M7XG4gICAgfTtcbiAgICByZXR1cm4gUHJlc2VuY2VNYXA7XG59KGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlYWx0aW1lUHJlc2VuY2U7XG5cblxuLyoqKi8gfSksXG4vKiA1NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIGVuY19oZXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xudmFyIGVuY191dGY4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcbnZhciBlbmNfYmFzZTY0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbnZhciBsaWJfdHlwZWRhcnJheXNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNSkpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciBCdWZmZXJVdGlscyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCdWZmZXJVdGlscygpIHtcbiAgICAgICAgdGhpcy5iYXNlNjRDaGFyU2V0ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuICAgICAgICB0aGlzLmhleENoYXJTZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZic7XG4gICAgfVxuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS5pc1dvcmRBcnJheSA9IGZ1bmN0aW9uIChvYikge1xuICAgICAgICByZXR1cm4gb2IgIT09IG51bGwgJiYgb2IgIT09IHVuZGVmaW5lZCAmJiBvYi5zaWdCeXRlcyAhPT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLmlzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAob2IpIHtcbiAgICAgICAgcmV0dXJuIG9iICE9PSBudWxsICYmIG9iICE9PSB1bmRlZmluZWQgJiYgb2IuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyO1xuICAgIH07XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLmlzVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChvYikge1xuICAgICAgICByZXR1cm4gISFBcnJheUJ1ZmZlciAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KG9iKTtcbiAgICB9O1xuICAgIC8vIC8vIGh0dHBzOi8vZ2lzdC5naXRodWJ1c2VyY29udGVudC5jb20vam9ubGVpZ2h0b24vOTU4ODQxL3Jhdy9mMjAwZTMwZGZlOTUyMTJjMDE2NWNjZjFhZTAwMGNhNTFlOWRlODAzL2dpc3RmaWxlMS5qc1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS51aW50OFZpZXdUb0Jhc2U2NCA9IGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICB2YXIgYmFzZTY0ID0gJyc7XG4gICAgICAgIHZhciBlbmNvZGluZ3MgPSB0aGlzLmJhc2U2NENoYXJTZXQ7XG4gICAgICAgIHZhciBieXRlTGVuZ3RoID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICAgICAgdmFyIGJ5dGVSZW1haW5kZXIgPSBieXRlTGVuZ3RoICUgMztcbiAgICAgICAgdmFyIG1haW5MZW5ndGggPSBieXRlTGVuZ3RoIC0gYnl0ZVJlbWFpbmRlcjtcbiAgICAgICAgdmFyIGEsIGIsIGMsIGQ7XG4gICAgICAgIHZhciBjaHVuaztcbiAgICAgICAgLy8gTWFpbiBsb29wIGRlYWxzIHdpdGggYnl0ZXMgaW4gY2h1bmtzIG9mIDNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYWluTGVuZ3RoOyBpID0gaSArIDMpIHtcbiAgICAgICAgICAgIC8vIENvbWJpbmUgdGhlIHRocmVlIGJ5dGVzIGludG8gYSBzaW5nbGUgaW50ZWdlclxuICAgICAgICAgICAgY2h1bmsgPSAoYnl0ZXNbaV0gPDwgMTYpIHwgKGJ5dGVzW2kgKyAxXSA8PCA4KSB8IGJ5dGVzW2kgKyAyXTtcbiAgICAgICAgICAgIC8vIFVzZSBiaXRtYXNrcyB0byBleHRyYWN0IDYtYml0IHNlZ21lbnRzIGZyb20gdGhlIHRyaXBsZXRcbiAgICAgICAgICAgIGEgPSAoY2h1bmsgJiAxNjUxNTA3MikgPj4gMTg7IC8vIDE2NTE1MDcyID0gKDJeNiAtIDEpIDw8IDE4XG4gICAgICAgICAgICBiID0gKGNodW5rICYgMjU4MDQ4KSA+PiAxMjsgLy8gMjU4MDQ4ICAgPSAoMl42IC0gMSkgPDwgMTJcbiAgICAgICAgICAgIGMgPSAoY2h1bmsgJiA0MDMyKSA+PiA2OyAvLyA0MDMyICAgICA9ICgyXjYgLSAxKSA8PCA2XG4gICAgICAgICAgICBkID0gY2h1bmsgJiA2MzsgLy8gNjMgICAgICAgPSAyXjYgLSAxXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSByYXcgYmluYXJ5IHNlZ21lbnRzIHRvIHRoZSBhcHByb3ByaWF0ZSBBU0NJSSBlbmNvZGluZ1xuICAgICAgICAgICAgYmFzZTY0ICs9IGVuY29kaW5nc1thXSArIGVuY29kaW5nc1tiXSArIGVuY29kaW5nc1tjXSArIGVuY29kaW5nc1tkXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWFsIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcyBhbmQgcGFkZGluZ1xuICAgICAgICBpZiAoYnl0ZVJlbWFpbmRlciA9PSAxKSB7XG4gICAgICAgICAgICBjaHVuayA9IGJ5dGVzW21haW5MZW5ndGhdO1xuICAgICAgICAgICAgYSA9IChjaHVuayAmIDI1MikgPj4gMjsgLy8gMjUyID0gKDJeNiAtIDEpIDw8IDJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgNCBsZWFzdCBzaWduaWZpY2FudCBiaXRzIHRvIHplcm9cbiAgICAgICAgICAgIGIgPSAoY2h1bmsgJiAzKSA8PCA0OyAvLyAzICAgPSAyXjIgLSAxXG4gICAgICAgICAgICBiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgJz09JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChieXRlUmVtYWluZGVyID09IDIpIHtcbiAgICAgICAgICAgIGNodW5rID0gKGJ5dGVzW21haW5MZW5ndGhdIDw8IDgpIHwgYnl0ZXNbbWFpbkxlbmd0aCArIDFdO1xuICAgICAgICAgICAgYSA9IChjaHVuayAmIDY0NTEyKSA+PiAxMDsgLy8gNjQ1MTIgPSAoMl42IC0gMSkgPDwgMTBcbiAgICAgICAgICAgIGIgPSAoY2h1bmsgJiAxMDA4KSA+PiA0OyAvLyAxMDA4ICA9ICgyXjYgLSAxKSA8PCA0XG4gICAgICAgICAgICAvLyBTZXQgdGhlIDIgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyB0byB6ZXJvXG4gICAgICAgICAgICBjID0gKGNodW5rICYgMTUpIDw8IDI7IC8vIDE1ICAgID0gMl40IC0gMVxuICAgICAgICAgICAgYmFzZTY0ICs9IGVuY29kaW5nc1thXSArIGVuY29kaW5nc1tiXSArIGVuY29kaW5nc1tjXSArICc9JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZTY0O1xuICAgIH07XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLmJhc2U2NFRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoYmFzZTY0KSB7XG4gICAgICAgIHZhciBiaW5hcnlfc3RyaW5nID0gYXRvYiA9PT0gbnVsbCB8fCBhdG9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdG9iKGJhc2U2NCk7IC8vIHRoaXMgd2lsbCBhbHdheXMgYmUgZGVmaW5lZCBpbiBicm93c2VyIHNvIGl0J3Mgc2FmZSB0byBjYXN0XG4gICAgICAgIHZhciBsZW4gPSBiaW5hcnlfc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGFzY2lpID0gYmluYXJ5X3N0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgYnl0ZXNbaV0gPSBhc2NpaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXMuYnVmZmVyO1xuICAgIH07XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLmlzQnVmZmVyID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0FycmF5QnVmZmVyKGJ1ZmZlcikgfHwgdGhpcy5pc1dvcmRBcnJheShidWZmZXIpIHx8IHRoaXMuaXNUeXBlZEFycmF5KGJ1ZmZlcik7XG4gICAgfTtcbiAgICAvKiBJbiBicm93c2VycywgcmV0dXJucyBhIFVpbnQ4QXJyYXkgKi9cbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIGlmICghQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbnZlcnQgdG8gQnVmZmVyOiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIG5lY2Vzc2FyeSB0eXBlc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0FycmF5QnVmZmVyKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVHlwZWRBcnJheShidWZmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNXb3JkQXJyYXkoYnVmZmVyKSkge1xuICAgICAgICAgICAgLyogQmFja3BvcnRlZCBmcm9tIHVucmVsZWFzZWQgQ3J5cHRvSlNcbiAgICAgICAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3NvdXJjZS9icm93c2UvYnJhbmNoZXMvMy54L3NyYy9saWItdHlwZWRhcnJheXMuanM/cj02NjEgKi9cbiAgICAgICAgICAgIHZhciBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXIuc2lnQnl0ZXMpO1xuICAgICAgICAgICAgdmFyIHVpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLnNpZ0J5dGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB1aW50OFZpZXdbaV0gPSAoYnVmZmVyLndvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1aW50OFZpZXc7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXJVdGlscy50b0J1ZmZlciBleHBlY3RlZCBhbiBhcnJheWJ1ZmZlciwgdHlwZWQgYXJyYXksIG9yIENyeXB0b0pTIHdvcmRhcnJheScpO1xuICAgIH07XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXlCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50b0J1ZmZlcihidWZmZXIpLmJ1ZmZlcjtcbiAgICB9O1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS50b1dvcmRBcnJheSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUeXBlZEFycmF5KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNXb3JkQXJyYXkoYnVmZmVyKSA/IGJ1ZmZlciA6IGxpYl90eXBlZGFycmF5c18xLmRlZmF1bHQuY3JlYXRlKGJ1ZmZlcik7XG4gICAgfTtcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUuYmFzZTY0RW5jb2RlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICBpZiAodGhpcy5pc1dvcmRBcnJheShidWZmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGVuY19iYXNlNjRfMS5zdHJpbmdpZnkpKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudWludDhWaWV3VG9CYXNlNjQodGhpcy50b0J1ZmZlcihidWZmZXIpKTtcbiAgICB9O1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS5iYXNlNjREZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIGlmIChBcnJheUJ1ZmZlciAmJiBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmF0b2IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2U2NFRvQXJyYXlCdWZmZXIoc3RyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGVuY19iYXNlNjRfMS5wYXJzZSkoc3RyKTtcbiAgICB9O1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS5oZXhFbmNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiAoMCwgZW5jX2hleF8xLnN0cmluZ2lmeSkodGhpcy50b1dvcmRBcnJheShidWZmZXIpKTtcbiAgICB9O1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS5oZXhEZWNvZGUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIHZhciB3b3JkQXJyYXkgPSAoMCwgZW5jX2hleF8xLnBhcnNlKShzdHJpbmcpO1xuICAgICAgICByZXR1cm4gQXJyYXlCdWZmZXIgPyB0aGlzLnRvQXJyYXlCdWZmZXIod29yZEFycmF5KSA6IHdvcmRBcnJheTtcbiAgICB9O1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS51dGY4RW5jb2RlID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICBpZiAocGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5UZXh0RW5jb2Rlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLlRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cmluZykuYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgZW5jX3V0ZjhfMS5wYXJzZSkoc3RyaW5nKTtcbiAgICB9O1xuICAgIC8qIEZvciB1dGY4IGRlY29kaW5nIHdlIGFwcGx5IHNsaWdodGx5IHN0cmljdGVyIGlucHV0IHZhbGlkYXRpb24gdGhhbiB0b1xuICAgICAqIGhleEVuY29kZS9iYXNlNjRFbmNvZGUvZXRjOiBpbiB0aG9zZSB3ZSBhY2NlcHQgYW55dGhpbmcgdGhhdCBCdWZmZXIuZnJvbVxuICAgICAqIGNhbiB0YWtlIChpbiBwYXJ0aWN1bGFyIGFsbG93aW5nIHN0cmluZ3MsIHdoaWNoIGFyZSBqdXN0IGludGVycHJldGVkIGFzXG4gICAgICogYmluYXJ5KTsgaGVyZSB3ZSBlbnN1cmUgdGhhdCB0aGUgaW5wdXQgaXMgYWN0dWFsbHkgYSBidWZmZXIgc2luY2UgdHJ5aW5nXG4gICAgICogdG8gdXRmOC1kZWNvZGUgYSBzdHJpbmcgdG8gYW5vdGhlciBzdHJpbmcgaXMgYWxtb3N0IGNlcnRhaW5seSBhIG1pc3Rha2UgKi9cbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUudXRmOERlY29kZSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5wdXQgb2YgdXRmOGRlY29kZSB0byBiZSBhbiBhcnJheWJ1ZmZlciwgdHlwZWQgYXJyYXksIG9yIENyeXB0b0pTIHdvcmRhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChUZXh0RGVjb2RlciAmJiAhdGhpcy5pc1dvcmRBcnJheShidWZmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyID0gdGhpcy50b1dvcmRBcnJheShidWZmZXIpO1xuICAgICAgICByZXR1cm4gKDAsIGVuY191dGY4XzEuc3RyaW5naWZ5KShidWZmZXIpO1xuICAgIH07XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLmJ1ZmZlckNvbXBhcmUgPSBmdW5jdGlvbiAoYnVmZmVyMSwgYnVmZmVyMikge1xuICAgICAgICBpZiAoIWJ1ZmZlcjEpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmICghYnVmZmVyMilcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB2YXIgd29yZEFycmF5MSA9IHRoaXMudG9Xb3JkQXJyYXkoYnVmZmVyMSk7XG4gICAgICAgIHZhciB3b3JkQXJyYXkyID0gdGhpcy50b1dvcmRBcnJheShidWZmZXIyKTtcbiAgICAgICAgd29yZEFycmF5MS5jbGFtcCgpO1xuICAgICAgICB3b3JkQXJyYXkyLmNsYW1wKCk7XG4gICAgICAgIHZhciBjbXAgPSB3b3JkQXJyYXkxLnNpZ0J5dGVzIC0gd29yZEFycmF5Mi5zaWdCeXRlcztcbiAgICAgICAgaWYgKGNtcCAhPSAwKVxuICAgICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgdmFyIHdvcmRzMSA9IHdvcmRBcnJheTEud29yZHM7XG4gICAgICAgIHZhciB3b3JkczIgPSB3b3JkQXJyYXkyLndvcmRzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY21wID0gd29yZHMxW2ldIC0gd29yZHMyW2ldO1xuICAgICAgICAgICAgaWYgKGNtcCAhPSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheUJ1ZmZlcihidWZmZXIpIHx8IHRoaXMuaXNUeXBlZEFycmF5KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzV29yZEFycmF5KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXIuc2lnQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgLyogUmV0dXJucyBBcnJheUJ1ZmZlciBvbiBicm93c2VyIGFuZCBCdWZmZXIgb24gTm9kZS5qcyAqL1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS50eXBlZEFycmF5VG9CdWZmZXIgPSBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuICAgICAgICByZXR1cm4gdHlwZWRBcnJheS5idWZmZXI7XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyVXRpbHM7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IEJ1ZmZlclV0aWxzKCk7XG5cblxuLyoqKi8gfSksXG4vKiA1NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0cmV0dXJuIENyeXB0b0pTLmVuYy5IZXg7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiA1NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfZW5jX2Jhc2U2NF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3J5cHRvX2pzX2J1aWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fKTtcblxuXG5cblxuXG5cbnZhciBDcnlwdG9GYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZywgYnVmZmVyVXRpbHMpIHtcbiAgdmFyIERFRkFVTFRfQUxHT1JJVEhNID0gJ2Flcyc7XG4gIHZhciBERUZBVUxUX0tFWUxFTkdUSCA9IDI1NjsgLy8gYml0c1xuICB2YXIgREVGQVVMVF9NT0RFID0gJ2NiYyc7XG4gIHZhciBERUZBVUxUX0JMT0NLTEVOR1RIID0gMTY7IC8vIGJ5dGVzXG4gIHZhciBERUZBVUxUX0JMT0NLTEVOR1RIX1dPUkRTID0gNDsgLy8gMzItYml0IHdvcmRzXG4gIHZhciBVSU5UMzJfU1VQID0gMHgxMDAwMDAwMDA7XG4gIHZhciBJTlQzMl9TVVAgPSAweDgwMDAwMDAwO1xuXG4gIC8qKlxuICAgKiBJbnRlcm5hbDogZ2VuZXJhdGUgYW4gYXJyYXkgb2Ygc2VjdXJlIHJhbmRvbSB3b3JkcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsZW5ndGggb2YgYnl0ZXNcbiAgICogQHBhcmFtIGJ5dGVzXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgdmFyIGdlbmVyYXRlUmFuZG9tO1xuICBpZiAoY29uZmlnLmdldFJhbmRvbVdvcmRBcnJheSkge1xuICAgIGdlbmVyYXRlUmFuZG9tID0gY29uZmlnLmdldFJhbmRvbVdvcmRBcnJheTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgVWludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIGNvbmZpZy5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICB2YXIgYmxvY2tSYW5kb21BcnJheSA9IG5ldyBVaW50MzJBcnJheShERUZBVUxUX0JMT0NLTEVOR1RIX1dPUkRTKTtcbiAgICBnZW5lcmF0ZVJhbmRvbSA9IGZ1bmN0aW9uIChieXRlcywgY2FsbGJhY2spIHtcbiAgICAgIHZhciB3b3JkcyA9IGJ5dGVzIC8gNCxcbiAgICAgICAgbmF0aXZlQXJyYXkgPSB3b3JkcyA9PSBERUZBVUxUX0JMT0NLTEVOR1RIX1dPUkRTID8gYmxvY2tSYW5kb21BcnJheSA6IG5ldyBVaW50MzJBcnJheSh3b3Jkcyk7XG4gICAgICBjb25maWcuZ2V0UmFuZG9tVmFsdWVzKG5hdGl2ZUFycmF5LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyLCBidWZmZXJVdGlscy50b1dvcmRBcnJheShuYXRpdmVBcnJheSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGdlbmVyYXRlUmFuZG9tID0gZnVuY3Rpb24gKGJ5dGVzLCBjYWxsYmFjaykge1xuICAgICAgX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0LmEubG9nQWN0aW9uKFxuICAgICAgICBfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQuYS5MT0dfTUFKT1IsXG4gICAgICAgICdBYmx5LkNyeXB0by5nZW5lcmF0ZVJhbmRvbSgpJyxcbiAgICAgICAgJ1dhcm5pbmc6IHRoZSBicm93c2VyIHlvdSBhcmUgdXNpbmcgZG9lcyBub3Qgc3VwcG9ydCBzZWN1cmUgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHJhbmRvbW5lc3MgZ2VuZXJhdGlvbjsgZmFsbGluZyBiYWNrIHRvIGluc2VjdXJlIE1hdGgucmFuZG9tKCknXG4gICAgICApO1xuICAgICAgdmFyIHdvcmRzID0gYnl0ZXMgLyA0LFxuICAgICAgICBhcnJheSA9IG5ldyBBcnJheSh3b3Jkcyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzOyBpKyspIHtcbiAgICAgICAgLyogY3J5cHRvanMgd29yZGFycmF5cyB1c2Ugc2lnbmVkIGludHMuIFdoZW4gV29yZEFycmF5LmNyZWF0ZSBpcyBmZWQgYVxuICAgICAgICAgKiBVaW50MzJBcnJheSB1bnNpZ25lZCBhcmUgY29udmVydGVkIHRvIHNpZ25lZCBhdXRvbWF0aWNhbGx5LCBidXQgd2hlblxuICAgICAgICAgKiBmZWQgYSBub3JtYWwgYXJyYXkgdGhleSBhcmVuJ3QsIHNvIG5lZWQgdG8gZG8gc28gb3Vyc2VsdmVzIGJ5XG4gICAgICAgICAqIHN1YnRyYWN0aW5nIElOVDMyX1NVUCAqL1xuICAgICAgICBhcnJheVtpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIFVJTlQzMl9TVVApIC0gSU5UMzJfU1VQO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShhcnJheSkpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWw6IGNhbGN1bGF0ZSB0aGUgcGFkZGVkIGxlbmd0aCBvZiBhIGdpdmVuIHBsYWludGV4dFxuICAgKiB1c2luZyBQS0NTNS5cbiAgICogQHBhcmFtIHBsYWludGV4dExlbmd0aFxuICAgKiBAcmV0dXJuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRQYWRkZWRMZW5ndGgocGxhaW50ZXh0TGVuZ3RoKSB7XG4gICAgcmV0dXJuIChwbGFpbnRleHRMZW5ndGggKyBERUZBVUxUX0JMT0NLTEVOR1RIKSAmIC1ERUZBVUxUX0JMT0NLTEVOR1RIO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsOiBjaGVja3MgdGhhdCB0aGUgY2lwaGVyUGFyYW1zIGFyZSBhIHZhbGlkIGNvbWJpbmF0aW9uLiBDdXJyZW50bHlcbiAgICoganVzdCBjaGVja3MgdGhhdCB0aGUgY2FsY3VsYXRlZCBrZXlMZW5ndGggaXMgYSB2YWxpZCBvbmUgZm9yIGFlcy1jYmNcbiAgICovXG4gIGZ1bmN0aW9uIHZhbGlkYXRlQ2lwaGVyUGFyYW1zKHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMuYWxnb3JpdGhtID09PSAnYWVzJyAmJiBwYXJhbXMubW9kZSA9PT0gJ2NiYycpIHtcbiAgICAgIGlmIChwYXJhbXMua2V5TGVuZ3RoID09PSAxMjggfHwgcGFyYW1zLmtleUxlbmd0aCA9PT0gMjU2KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1Vuc3VwcG9ydGVkIGtleSBsZW5ndGggJyArXG4gICAgICAgICAgcGFyYW1zLmtleUxlbmd0aCArXG4gICAgICAgICAgJyBmb3IgYWVzLWNiYyBlbmNyeXB0aW9uLiBFbmNyeXB0aW9uIGtleSBtdXN0IGJlIDEyOCBvciAyNTYgYml0cyAoMTYgb3IgMzIgQVNDSUkgY2hhcmFjdGVycyknXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGlzZUJhc2U2NChzdHJpbmcpIHtcbiAgICAvKiB1cmwtc2FmZSBiYXNlNjQgc3RyaW5ncyB1c2UgXyBhbmQgLSBpbnN0cmVhZCBvZiAvIGFuZCArICovXG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKCdfJywgJy8nKS5yZXBsYWNlKCctJywgJysnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbDogb2J0YWluIHRoZSBwa2NzNSBwYWRkaW5nIHN0cmluZyBmb3IgYSBnaXZlbiBwYWRkZWQgbGVuZ3RoO1xuICAgKi9cbiAgdmFyIHBrY3M1UGFkZGluZyA9IFtcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgxMDEwMTAxMCwgMHgxMDEwMTAxMCwgMHgxMDEwMTAxMCwgMHgxMDEwMTAxMF0sIDE2KSxcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwMTAwMDAwMF0sIDEpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDAyMDIwMDAwXSwgMiksXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDMwMzAzMDBdLCAzKSxcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwNDA0MDQwNF0sIDQpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDA1MDUwNTA1LCAweDA1MDAwMDAwXSwgNSksXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDYwNjA2MDYsIDB4MDYwNjAwMDBdLCA2KSxcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwNzA3MDcwNywgMHgwNzA3MDcwMF0sIDcpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDA4MDgwODA4LCAweDA4MDgwODA4XSwgOCksXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDkwOTA5MDksIDB4MDkwOTA5MDksIDB4MDkwMDAwMDBdLCA5KSxcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwYTBhMGEwYSwgMHgwYTBhMGEwYSwgMHgwYTBhMDAwMF0sIDEwKSxcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwYjBiMGIwYiwgMHgwYjBiMGIwYiwgMHgwYjBiMGIwMF0sIDExKSxcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwYzBjMGMwYywgMHgwYzBjMGMwYywgMHgwYzBjMGMwY10sIDEyKSxcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwZDBkMGQwZCwgMHgwZDBkMGQwZCwgMHgwZDBkMGQwZCwgMHgwZDAwMDAwMF0sIDEzKSxcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwZTBlMGUwZSwgMHgwZTBlMGUwZSwgMHgwZTBlMGUwZSwgMHgwZTBlMDAwMF0sIDE0KSxcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwZjBmMGYwZiwgMHgwZjBmMGYwZiwgMHgwZjBmMGYwZiwgMHgwZjBmMGYwZl0sIDE1KSxcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgxMDEwMTAxMCwgMHgxMDEwMTAxMCwgMHgxMDEwMTAxMCwgMHgxMDEwMTAxMF0sIDE2KSxcbiAgXTtcblxuICAvKipcbiAgICogVXRpbGl0eSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIGZvciBtZXNzYWdlIHBheWxvYWQgZW5jcnlwdGlvbi5cbiAgICpcbiAgICogVGhpcyBjbGFzcyBzdXBwb3J0cyBBRVMvQ0JDL1BLQ1M1IHdpdGggYSBkZWZhdWx0IGtleWxlbmd0aCBvZiAxMjggYml0c1xuICAgKiBidXQgc3VwcG9ydGluZyBvdGhlciBrZXlsZW5ndGhzLiBPdGhlciBhbGdvcml0aG1zIGFuZCBjaGFpbmluZyBtb2RlcyBhcmVcbiAgICogbm90IHN1cHBvcnRlZCBkaXJlY3RseSwgYnV0IHN1cHBvcnRhYmxlIGJ5IGV4dGVuZGluZy9pbXBsZW1lbnRpbmcgdGhlIGJhc2VcbiAgICogY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyBoZXJlLlxuICAgKi1cbiAgICogU2VjdXJlIHJhbmRvbSBkYXRhIGZvciBjcmVhdGlvbiBvZiBJbml0aWFsaXphdGlvbiBWZWN0b3JzIChJVnMpIGFuZCBrZXlzXG4gICAqIGlzIG9idGFpbmVkIGZyb20gd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgaWYgYXZhaWxhYmxlLCBvciBmcm9tXG4gICAqIE1hdGgucmFuZG9tKCkgaWYgbm90LiBDbGllbnRzIHdobyBkbyBub3Qgd2FudCB0byBkZXBlbmQgb24gTWF0aC5yYW5kb20oKVxuICAgKiBzaG91bGQgcG9seWZpbGwgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgd2l0aCBhIGxpYnJhcnkgdGhhdCBzZWVkc1xuICAgKiBhIFBSTkcgd2l0aCByZWFsIGVudHJvcHkuXG4gICAqXG4gICAqIEVhY2ggbWVzc2FnZSBwYXlsb2FkIGlzIGVuY3J5cHRlZCB3aXRoIGFuIElWIGluIENCQyBtb2RlLCBhbmQgdGhlIElWIGlzXG4gICAqIGNvbmNhdGVuYXRlZCB3aXRoIHRoZSByZXN1bHRpbmcgcmF3IGNpcGhlcnRleHQgdG8gY29uc3RydWN0IHRoZSBcImNpcGhlcnRleHRcIlxuICAgKiBkYXRhIHBhc3NlZCB0byB0aGUgcmVjaXBpZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gQ3J5cHRvKCkge31cblxuICAvKipcbiAgICogQSBjbGFzcyBlbmNhcHN1bGF0aW5nIHRoZSBjbGllbnQtc3BlY2lmaWFibGUgcGFyYW1ldGVycyBmb3JcbiAgICogdGhlIGNpcGhlci5cbiAgICpcbiAgICogYWxnb3JpdGhtIGlzIHRoZSBuYW1lIG9mIHRoZSBhbGdvcml0aG0gaW4gdGhlIGRlZmF1bHQgc3lzdGVtIHByb3ZpZGVyLFxuICAgKiBvciB0aGUgbG93ZXItY2FzZWQgdmVyc2lvbiBvZiBpdDsgZWcgXCJhZXNcIiBvciBcIkFFU1wiLlxuICAgKlxuICAgKiBDbGllbnRzIGFyZSByZWNvbW1lbmRlZCB0byBub3QgY2FsbCB0aGlzIGRpcmVjdGx5LCBidXQgaW5zdGVhZCB0byB1c2UgdGhlXG4gICAqIENyeXB0by5nZXREZWZhdWx0UGFyYW1zIGhlbHBlciwgd2hpY2ggd2lsbCBmaWxsIGluIGFueSBmaWVsZHMgbm90IHN1cHBsaWVkXG4gICAqIHdpdGggZGVmYXVsdCB2YWx1ZXMgYW5kIHZhbGlkYXRpb24gdGhlIHJlc3VsdC5cbiAgICovXG4gIGZ1bmN0aW9uIENpcGhlclBhcmFtcygpIHtcbiAgICB0aGlzLmFsZ29yaXRobSA9IG51bGw7XG4gICAgdGhpcy5rZXlMZW5ndGggPSBudWxsO1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy5rZXkgPSBudWxsO1xuICB9XG4gIENyeXB0by5DaXBoZXJQYXJhbXMgPSBDaXBoZXJQYXJhbXM7XG5cbiAgLyoqXG4gICAqIE9idGFpbiBhIGNvbXBsZXRlIENpcGhlclBhcmFtcyBpbnN0YW5jZSBmcm9tIHRoZSBwcm92aWRlZCBwYXJhbXMsIGZpbGxpbmdcbiAgICogaW4gYW55IG5vdCBwcm92aWRlZCB3aXRoIGRlZmF1bHQgdmFsdWVzLCBjYWxjdWxhdGluZyBhIGtleUxlbmd0aCBmcm9tXG4gICAqIHRoZSBzdXBwbGllZCBrZXksIGFuZCB2YWxpZGF0aW5nIHRoZSByZXN1bHQuXG4gICAqIEBwYXJhbSBwYXJhbXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYXQgYSBtaW5pbXVtIGEgYGtleWAga2V5IHdpdGggdmFsdWUgdGhlXG4gICAqIGtleSwgYXMgZWl0aGVyIGEgYmluYXJ5IChBcnJheUJ1ZmZlciwgQXJyYXksIFdvcmRBcnJheSkgb3IgYVxuICAgKiBiYXNlNjQtZW5jb2RlZCBzdHJpbmcuIE1heSBvcHRpb25hbGx5IGFsc28gY29udGFpbjogYWxnb3JpdGhtIChkZWZhdWx0cyB0b1xuICAgKiBBRVMpLCBtb2RlIChkZWZhdWx0cyB0byAnY2JjJylcbiAgICovXG4gIENyeXB0by5nZXREZWZhdWx0UGFyYW1zID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBrZXk7XG4gICAgLyogQmFja3dhcmQgY29tcGF0aWJpbGl0eSAqL1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBwYXJhbXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQuYS5kZXByZWNhdGVkKCdDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyhrZXksIGNhbGxiYWNrKScsICdDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyh7a2V5OiBrZXl9KScpO1xuICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgQ3J5cHRvLmdlbmVyYXRlUmFuZG9tS2V5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBwYXJhbXMobnVsbCwgQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMoeyBrZXk6IGtleSB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGFyZ3VtZW50c1sxXShudWxsLCBDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyh7IGtleTogcGFyYW1zIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMgZm9yIENyeXB0by5nZXREZWZhdWx0UGFyYW1zJyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMua2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zOiBhIGtleSBpcyByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGFyYW1zLmtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGtleSA9IE9iamVjdChjcnlwdG9fanNfYnVpbGRfZW5jX2Jhc2U2NF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wicGFyc2VcIl0pKG5vcm1hbGlzZUJhc2U2NChwYXJhbXMua2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IGJ1ZmZlclV0aWxzLnRvV29yZEFycmF5KHBhcmFtcy5rZXkpOyAvLyBFeHBlY3Qga2V5IHRvIGJlIGFuIEFycmF5LCBBcnJheUJ1ZmZlciwgb3IgV29yZEFycmF5IGF0IHRoaXMgcG9pbnRcbiAgICB9XG5cbiAgICB2YXIgY2lwaGVyUGFyYW1zID0gbmV3IENpcGhlclBhcmFtcygpO1xuICAgIGNpcGhlclBhcmFtcy5rZXkgPSBrZXk7XG4gICAgY2lwaGVyUGFyYW1zLmFsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0gfHwgREVGQVVMVF9BTEdPUklUSE07XG4gICAgY2lwaGVyUGFyYW1zLmtleUxlbmd0aCA9IGtleS53b3Jkcy5sZW5ndGggKiAoNCAqIDgpO1xuICAgIGNpcGhlclBhcmFtcy5tb2RlID0gcGFyYW1zLm1vZGUgfHwgREVGQVVMVF9NT0RFO1xuXG4gICAgaWYgKHBhcmFtcy5rZXlMZW5ndGggJiYgcGFyYW1zLmtleUxlbmd0aCAhPT0gY2lwaGVyUGFyYW1zLmtleUxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ3J5cHRvLmdldERlZmF1bHRQYXJhbXM6IGEga2V5TGVuZ3RoIG9mICcgK1xuICAgICAgICAgIHBhcmFtcy5rZXlMZW5ndGggK1xuICAgICAgICAgICcgd2FzIHNwZWNpZmllZCwgYnV0IHRoZSBrZXkgYWN0dWFsbHkgaGFzIGxlbmd0aCAnICtcbiAgICAgICAgICBjaXBoZXJQYXJhbXMua2V5TGVuZ3RoXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhbGlkYXRlQ2lwaGVyUGFyYW1zKGNpcGhlclBhcmFtcyk7XG4gICAgcmV0dXJuIGNpcGhlclBhcmFtcztcbiAgfTtcblxuICAvKipcbiAgICogR2VuZXJhdGUgYSByYW5kb20gZW5jcnlwdGlvbiBrZXkgZnJvbSB0aGUgc3VwcGxpZWQga2V5bGVuZ3RoIChvciB0aGVcbiAgICogZGVmYXVsdCBrZXlMZW5ndGggaWYgbm9uZSBzdXBwbGllZCkgYXMgYSBDcnlwdG9KUyBXb3JkQXJyYXlcbiAgICogQHBhcmFtIGtleUxlbmd0aCAob3B0aW9uYWwpIHRoZSByZXF1aXJlZCBrZXlMZW5ndGggaW4gYml0c1xuICAgKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSAoZXJyLCBrZXkpXG4gICAqL1xuICBDcnlwdG8uZ2VuZXJhdGVSYW5kb21LZXkgPSBmdW5jdGlvbiAoa2V5TGVuZ3RoLCBjYWxsYmFjaykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgdHlwZW9mIGtleUxlbmd0aCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGtleUxlbmd0aDtcbiAgICAgIGtleUxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBnZW5lcmF0ZVJhbmRvbSgoa2V5TGVuZ3RoIHx8IERFRkFVTFRfS0VZTEVOR1RIKSAvIDgsIGZ1bmN0aW9uIChlcnIsIGJ1Zikge1xuICAgICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyID8gY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX19kZWZhdWx0LmEuZnJvbVZhbHVlcyhlcnIpIDogbnVsbCwgYnVmKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogSW50ZXJuYWw7IGdldCBhIENoYW5uZWxDaXBoZXIgaW5zdGFuY2UgYmFzZWQgb24gdGhlIGdpdmVuIGNpcGhlclBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zIGVpdGhlciBhIENpcGhlclBhcmFtcyBpbnN0YW5jZSBvciBzb21lIHN1YnNldCBvZiBpdHNcbiAgICogZmllbGRzIHRoYXQgaW5jbHVkZXMgYSBrZXlcbiAgICovXG4gIENyeXB0by5nZXRDaXBoZXIgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdmFyIGNpcGhlclBhcmFtcyA9IHBhcmFtcyBpbnN0YW5jZW9mIENpcGhlclBhcmFtcyA/IHBhcmFtcyA6IENyeXB0by5nZXREZWZhdWx0UGFyYW1zKHBhcmFtcyk7XG5cbiAgICByZXR1cm4geyBjaXBoZXJQYXJhbXM6IGNpcGhlclBhcmFtcywgY2lwaGVyOiBuZXcgQ0JDQ2lwaGVyKGNpcGhlclBhcmFtcywgREVGQVVMVF9CTE9DS0xFTkdUSF9XT1JEUywgcGFyYW1zLml2KSB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIENCQ0NpcGhlcihwYXJhbXMsIGJsb2NrTGVuZ3RoV29yZHMsIGl2KSB7XG4gICAgdGhpcy5hbGdvcml0aG0gPSBwYXJhbXMuYWxnb3JpdGhtICsgJy0nICsgU3RyaW5nKHBhcmFtcy5rZXlMZW5ndGgpICsgJy0nICsgcGFyYW1zLm1vZGU7XG4gICAgdGhpcy5janNBbGdvcml0aG0gPSBwYXJhbXMuYWxnb3JpdGhtLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvLVxcZCskLywgJycpO1xuICAgIHRoaXMua2V5ID0gYnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkocGFyYW1zLmtleSk7XG4gICAgaWYgKGl2KSB7XG4gICAgICB0aGlzLml2ID0gYnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkoaXYpLmNsb25lKCk7XG4gICAgfVxuICAgIHRoaXMuYmxvY2tMZW5ndGhXb3JkcyA9IGJsb2NrTGVuZ3RoV29yZHM7XG4gIH1cblxuICBDQkNDaXBoZXIucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbiAocGxhaW50ZXh0LCBjYWxsYmFjaykge1xuICAgIF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdC5hLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQuYS5MT0dfTUlDUk8sICdDQkNDaXBoZXIuZW5jcnlwdCgpJywgJycpO1xuICAgIHBsYWludGV4dCA9IGJ1ZmZlclV0aWxzLnRvV29yZEFycmF5KHBsYWludGV4dCk7XG4gICAgdmFyIHBsYWludGV4dExlbmd0aCA9IHBsYWludGV4dC5zaWdCeXRlcyxcbiAgICAgIHBhZGRlZExlbmd0aCA9IGdldFBhZGRlZExlbmd0aChwbGFpbnRleHRMZW5ndGgpLFxuICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgdGhlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZ2V0SXYoZnVuY3Rpb24gKGVyciwgaXYpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaXBoZXJPdXQgPSBzZWxmLmVuY3J5cHRDaXBoZXIucHJvY2VzcyhwbGFpbnRleHQuY29uY2F0KHBrY3M1UGFkZGluZ1twYWRkZWRMZW5ndGggLSBwbGFpbnRleHRMZW5ndGhdKSk7XG4gICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gaXYuY29uY2F0KGNpcGhlck91dCk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGNpcGhlcnRleHQpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmICghdGhpcy5lbmNyeXB0Q2lwaGVyKSB7XG4gICAgICBpZiAodGhpcy5pdikge1xuICAgICAgICB0aGlzLmVuY3J5cHRDaXBoZXIgPSBjcnlwdG9fanNfYnVpbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0LmEuYWxnb1t0aGlzLmNqc0FsZ29yaXRobV0uY3JlYXRlRW5jcnlwdG9yKHRoaXMua2V5LCB7IGl2OiB0aGlzLml2IH0pO1xuICAgICAgICB0aGVuKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5lcmF0ZVJhbmRvbShERUZBVUxUX0JMT0NLTEVOR1RILCBmdW5jdGlvbiAoZXJyLCBpdikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuZW5jcnlwdENpcGhlciA9IGNyeXB0b19qc19idWlsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQuYS5hbGdvW3NlbGYuY2pzQWxnb3JpdGhtXS5jcmVhdGVFbmNyeXB0b3Ioc2VsZi5rZXksIHsgaXY6IGl2IH0pO1xuICAgICAgICAgIHNlbGYuaXYgPSBpdjtcbiAgICAgICAgICB0aGVuKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGVuKCk7XG4gICAgfVxuICB9O1xuXG4gIENCQ0NpcGhlci5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uIChjaXBoZXJ0ZXh0KSB7XG4gICAgX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0LmEubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdC5hLkxPR19NSUNSTywgJ0NCQ0NpcGhlci5kZWNyeXB0KCknLCAnJyk7XG4gICAgY2lwaGVydGV4dCA9IGJ1ZmZlclV0aWxzLnRvV29yZEFycmF5KGNpcGhlcnRleHQpO1xuICAgIHZhciBibG9ja0xlbmd0aFdvcmRzID0gdGhpcy5ibG9ja0xlbmd0aFdvcmRzLFxuICAgICAgY2lwaGVydGV4dFdvcmRzID0gY2lwaGVydGV4dC53b3JkcyxcbiAgICAgIGl2ID0gY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoY2lwaGVydGV4dFdvcmRzLnNsaWNlKDAsIGJsb2NrTGVuZ3RoV29yZHMpKSxcbiAgICAgIGNpcGhlcnRleHRCb2R5ID0gY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoY2lwaGVydGV4dFdvcmRzLnNsaWNlKGJsb2NrTGVuZ3RoV29yZHMpKTtcblxuICAgIHZhciBkZWNyeXB0Q2lwaGVyID0gY3J5cHRvX2pzX2J1aWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdC5hLmFsZ29bdGhpcy5janNBbGdvcml0aG1dLmNyZWF0ZURlY3J5cHRvcih0aGlzLmtleSwgeyBpdjogaXYgfSk7XG4gICAgdmFyIHBsYWludGV4dCA9IGRlY3J5cHRDaXBoZXIucHJvY2VzcyhjaXBoZXJ0ZXh0Qm9keSk7XG4gICAgdmFyIGVwaWxvZ3VlID0gZGVjcnlwdENpcGhlci5maW5hbGl6ZSgpO1xuICAgIGRlY3J5cHRDaXBoZXIucmVzZXQoKTtcbiAgICBpZiAoZXBpbG9ndWUgJiYgZXBpbG9ndWUuc2lnQnl0ZXMpIHBsYWludGV4dC5jb25jYXQoZXBpbG9ndWUpO1xuICAgIHJldHVybiBwbGFpbnRleHQ7XG4gIH07XG5cbiAgQ0JDQ2lwaGVyLnByb3RvdHlwZS5nZXRJdiA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLml2KSB7XG4gICAgICB2YXIgaXYgPSB0aGlzLml2O1xuICAgICAgdGhpcy5pdiA9IG51bGw7XG4gICAgICBjYWxsYmFjayhudWxsLCBpdik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyogU2luY2UgdGhlIGl2IGZvciBhIG5ldyBibG9jayBpcyB0aGUgY2lwaGVydGV4dCBvZiB0aGUgbGFzdCwgdGhpc1xuICAgICAqIHNldHMgYSBuZXcgaXYgKD0gYWVzKHJhbmRvbUJsb2NrIFhPUiBsYXN0Q2lwaGVyVGV4dCkpIGFzIHdlbGwgYXNcbiAgICAgKiByZXR1cm5pbmcgaXQgKi9cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgZ2VuZXJhdGVSYW5kb20oREVGQVVMVF9CTE9DS0xFTkdUSCwgZnVuY3Rpb24gKGVyciwgcmFuZG9tQmxvY2spIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgc2VsZi5lbmNyeXB0Q2lwaGVyLnByb2Nlc3MocmFuZG9tQmxvY2spKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQ3J5cHRvO1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDcnlwdG9GYWN0b3J5KTtcblxuXG4vKioqLyB9KSxcbi8qIDU4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cblx0ICAgIC8qKlxuXHQgICAgICogVVRGLTE2IEJFIGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgVXRmMTZCRSA9IENfZW5jLlV0ZjE2ID0gQ19lbmMuVXRmMTZCRSA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtMTYgQkUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi0xNiBCRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB1dGYxNlN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGYxNi5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHV0ZjE2Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMTYgLSAoaSAlIDQpICogOCkpICYgMHhmZmZmO1xuXHQgICAgICAgICAgICAgICAgdXRmMTZDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdXRmMTZDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBVVEYtMTYgQkUgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dGYxNlN0ciBUaGUgVVRGLTE2IEJFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmMTYucGFyc2UodXRmMTZTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmMTZTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIHV0ZjE2U3RyTGVuZ3RoID0gdXRmMTZTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXRmMTZTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMV0gfD0gdXRmMTZTdHIuY2hhckNvZGVBdChpKSA8PCAoMTYgLSAoaSAlIDIpICogMTYpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIHV0ZjE2U3RyTGVuZ3RoICogMik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVVEYtMTYgTEUgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIENfZW5jLlV0ZjE2TEUgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTE2IExFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtMTYgTEUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgdXRmMTZTdHIgPSBDcnlwdG9KUy5lbmMuVXRmMTZMRS5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHV0ZjE2Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gc3dhcEVuZGlhbigod29yZHNbaSA+Pj4gMl0gPj4+ICgxNiAtIChpICUgNCkgKiA4KSkgJiAweGZmZmYpO1xuXHQgICAgICAgICAgICAgICAgdXRmMTZDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdXRmMTZDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBVVEYtMTYgTEUgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dGYxNlN0ciBUaGUgVVRGLTE2IExFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmMTZMRS5wYXJzZSh1dGYxNlN0cik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGYxNlN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZTdHJMZW5ndGggPSB1dGYxNlN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1dGYxNlN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAxXSB8PSBzd2FwRW5kaWFuKHV0ZjE2U3RyLmNoYXJDb2RlQXQoaSkgPDwgKDE2IC0gKGkgJSAyKSAqIDE2KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgdXRmMTZTdHJMZW5ndGggKiAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBzd2FwRW5kaWFuKHdvcmQpIHtcblx0ICAgICAgICByZXR1cm4gKCh3b3JkIDw8IDgpICYgMHhmZjAwZmYwMCkgfCAoKHdvcmQgPj4+IDgpICYgMHgwMGZmMDBmZik7XG5cdCAgICB9XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLlV0ZjE2O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQ2lwaGVyUGFyYW1zID0gQ19saWIuQ2lwaGVyUGFyYW1zO1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cdCAgICB2YXIgSGV4ID0gQ19lbmMuSGV4O1xuXHQgICAgdmFyIENfZm9ybWF0ID0gQy5mb3JtYXQ7XG5cblx0ICAgIHZhciBIZXhGb3JtYXR0ZXIgPSBDX2Zvcm1hdC5IZXggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhlIGNpcGhlcnRleHQgb2YgYSBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc30gY2lwaGVyUGFyYW1zIFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuSGV4LnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuXHQgICAgICAgICAgICByZXR1cm4gY2lwaGVyUGFyYW1zLmNpcGhlcnRleHQudG9TdHJpbmcoSGV4KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgY2lwaGVydGV4dCBzdHJpbmcgdG8gYSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBUaGUgaGV4YWRlY2ltYWxseSBlbmNvZGVkIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMuZm9ybWF0LkhleC5wYXJzZShoZXhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoaW5wdXQpIHtcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBIZXgucGFyc2UoaW5wdXQpO1xuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGNpcGhlcnRleHQ6IGNpcGhlcnRleHQgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5mb3JtYXQuSGV4O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogNjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg2MSksIF9fd2VicGFja19yZXF1aXJlX18oMjcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmxvY2tDaXBoZXIgPSBDX2xpYi5CbG9ja0NpcGhlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIExvb2t1cCB0YWJsZXNcblx0ICAgIHZhciBTQk9YID0gW107XG5cdCAgICB2YXIgSU5WX1NCT1ggPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzAgPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzEgPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzIgPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzMgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8wID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMSA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzIgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8zID0gW107XG5cblx0ICAgIC8vIENvbXB1dGUgbG9va3VwIHRhYmxlc1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvLyBDb21wdXRlIGRvdWJsZSB0YWJsZVxuXHQgICAgICAgIHZhciBkID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHQgICAgICAgICAgICBpZiAoaSA8IDEyOCkge1xuXHQgICAgICAgICAgICAgICAgZFtpXSA9IGkgPDwgMTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGRbaV0gPSAoaSA8PCAxKSBeIDB4MTFiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gV2FsayBHRigyXjgpXG5cdCAgICAgICAgdmFyIHggPSAwO1xuXHQgICAgICAgIHZhciB4aSA9IDA7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHQgICAgICAgICAgICAvLyBDb21wdXRlIHNib3hcblx0ICAgICAgICAgICAgdmFyIHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNCk7XG5cdCAgICAgICAgICAgIHN4ID0gKHN4ID4+PiA4KSBeIChzeCAmIDB4ZmYpIF4gMHg2Mztcblx0ICAgICAgICAgICAgU0JPWFt4XSA9IHN4O1xuXHQgICAgICAgICAgICBJTlZfU0JPWFtzeF0gPSB4O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cblx0ICAgICAgICAgICAgdmFyIHgyID0gZFt4XTtcblx0ICAgICAgICAgICAgdmFyIHg0ID0gZFt4Ml07XG5cdCAgICAgICAgICAgIHZhciB4OCA9IGRbeDRdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgc3ViIGJ5dGVzLCBtaXggY29sdW1ucyB0YWJsZXNcblx0ICAgICAgICAgICAgdmFyIHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzBbeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfMVt4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfMlt4XSA9ICh0IDw8IDgpICB8ICh0ID4+PiAyNCk7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfM1t4XSA9IHQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG5cdCAgICAgICAgICAgIHZhciB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8wW3N4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfMVtzeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8yW3N4XSA9ICh0IDw8IDgpICB8ICh0ID4+PiAyNCk7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzNbc3hdID0gdDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG5leHQgY291bnRlclxuXHQgICAgICAgICAgICBpZiAoIXgpIHtcblx0ICAgICAgICAgICAgICAgIHggPSB4aSA9IDE7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB4ID0geDIgXiBkW2RbZFt4OCBeIHgyXV1dO1xuXHQgICAgICAgICAgICAgICAgeGkgXj0gZFtkW3hpXV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvLyBQcmVjb21wdXRlZCBSY29uIGxvb2t1cFxuXHQgICAgdmFyIFJDT04gPSBbMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQUVTIGJsb2NrIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBBRVMgPSBDX2FsZ28uQUVTID0gQmxvY2tDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgdDtcblxuXHQgICAgICAgICAgICAvLyBTa2lwIHJlc2V0IG9mIG5Sb3VuZHMgaGFzIGJlZW4gc2V0IGJlZm9yZSBhbmQga2V5IGRpZCBub3QgY2hhbmdlXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9uUm91bmRzICYmIHRoaXMuX2tleVByaW9yUmVzZXQgPT09IHRoaXMuX2tleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9rZXlQcmlvclJlc2V0ID0gdGhpcy5fa2V5O1xuXHQgICAgICAgICAgICB2YXIga2V5V29yZHMgPSBrZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBrZXlTaXplID0ga2V5LnNpZ0J5dGVzIC8gNDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG51bWJlciBvZiByb3VuZHNcblx0ICAgICAgICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzID0ga2V5U2l6ZSArIDY7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBudW1iZXIgb2Yga2V5IHNjaGVkdWxlIHJvd3Ncblx0ICAgICAgICAgICAgdmFyIGtzUm93cyA9IChuUm91bmRzICsgMSkgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUga2V5IHNjaGVkdWxlXG5cdCAgICAgICAgICAgIHZhciBrZXlTY2hlZHVsZSA9IHRoaXMuX2tleVNjaGVkdWxlID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlXb3Jkc1trc1Jvd107XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDFdO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEoa3NSb3cgJSBrZXlTaXplKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSb3Qgd29yZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAoU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFt0ICYgMHhmZl07XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWl4IFJjb25cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCBePSBSQ09OWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWIgd29yZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKFNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbdCAmIDB4ZmZdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbnYga2V5IHNjaGVkdWxlXG5cdCAgICAgICAgICAgIHZhciBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuX2ludktleVNjaGVkdWxlID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGludktzUm93ID0gMDsgaW52S3NSb3cgPCBrc1Jvd3M7IGludktzUm93KyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrc1JvdyA9IGtzUm93cyAtIGludktzUm93O1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoaW52S3NSb3cgJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gSU5WX1NVQl9NSVhfMFtTQk9YW3QgPj4+IDI0XV0gXiBJTlZfU1VCX01JWF8xW1NCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdXSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSU5WX1NVQl9NSVhfMltTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdXSBeIElOVl9TVUJfTUlYXzNbU0JPWFt0ICYgMHhmZl1dO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGVuY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9rZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZGVjcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFN3YXAgMm5kIGFuZCA0dGggcm93c1xuXHQgICAgICAgICAgICB2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSBNW29mZnNldCArIDNdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDtcblxuXHQgICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9pbnZLZXlTY2hlZHVsZSwgSU5WX1NVQl9NSVhfMCwgSU5WX1NVQl9NSVhfMSwgSU5WX1NVQl9NSVhfMiwgSU5WX1NVQl9NSVhfMywgSU5WX1NCT1gpO1xuXG5cdCAgICAgICAgICAgIC8vIEludiBzd2FwIDJuZCBhbmQgNHRoIHJvd3Ncblx0ICAgICAgICAgICAgdmFyIHQgPSBNW29mZnNldCArIDFdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0NyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQsIGtleVNjaGVkdWxlLCBTVUJfTUlYXzAsIFNVQl9NSVhfMSwgU1VCX01JWF8yLCBTVUJfTUlYXzMsIFNCT1gpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzO1xuXG5cdCAgICAgICAgICAgIC8vIEdldCBpbnB1dCwgYWRkIHJvdW5kIGtleVxuXHQgICAgICAgICAgICB2YXIgczAgPSBNW29mZnNldF0gICAgIF4ga2V5U2NoZWR1bGVbMF07XG5cdCAgICAgICAgICAgIHZhciBzMSA9IE1bb2Zmc2V0ICsgMV0gXiBrZXlTY2hlZHVsZVsxXTtcblx0ICAgICAgICAgICAgdmFyIHMyID0gTVtvZmZzZXQgKyAyXSBeIGtleVNjaGVkdWxlWzJdO1xuXHQgICAgICAgICAgICB2YXIgczMgPSBNW29mZnNldCArIDNdIF4ga2V5U2NoZWR1bGVbM107XG5cblx0ICAgICAgICAgICAgLy8gS2V5IHNjaGVkdWxlIHJvdyBjb3VudGVyXG5cdCAgICAgICAgICAgIHZhciBrc1JvdyA9IDQ7XG5cblx0ICAgICAgICAgICAgLy8gUm91bmRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIHJvdW5kID0gMTsgcm91bmQgPCBuUm91bmRzOyByb3VuZCsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zLCBhZGQgcm91bmQga2V5XG5cdCAgICAgICAgICAgICAgICB2YXIgdDAgPSBTVUJfTUlYXzBbczAgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczEgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMiA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMyAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgICAgICB2YXIgdDEgPSBTVUJfTUlYXzBbczEgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczIgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMyA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMCAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgICAgICB2YXIgdDIgPSBTVUJfTUlYXzBbczIgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczMgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMCA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMSAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgICAgICB2YXIgdDMgPSBTVUJfTUlYXzBbczMgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczAgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMSA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMiAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cblx0ICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuXHQgICAgICAgICAgICAgICAgczAgPSB0MDtcblx0ICAgICAgICAgICAgICAgIHMxID0gdDE7XG5cdCAgICAgICAgICAgICAgICBzMiA9IHQyO1xuXHQgICAgICAgICAgICAgICAgczMgPSB0Mztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgYWRkIHJvdW5kIGtleVxuXHQgICAgICAgICAgICB2YXIgdDAgPSAoKFNCT1hbczAgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczEgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMiA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczMgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgdmFyIHQxID0gKChTQk9YW3MxID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMyID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczMgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MwICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgIHZhciB0MiA9ICgoU0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMyA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMwID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMSAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICB2YXIgdDMgPSAoKFNCT1hbczMgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczAgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMSA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczIgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgb3V0cHV0XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0XSAgICAgPSB0MDtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IHQxO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDJdID0gdDI7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0Mztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAga2V5U2l6ZTogMjU2LzMyXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5BRVMuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5BRVMuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgKi9cblx0ICAgIEMuQUVTID0gQmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihBRVMpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLkFFUztcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDYxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKE1hdGgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBDb25zdGFudHMgdGFibGVcblx0ICAgIHZhciBUID0gW107XG5cblx0ICAgIC8vIENvbXB1dGUgY29uc3RhbnRzXG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuXHQgICAgICAgICAgICBUW2ldID0gKE1hdGguYWJzKE1hdGguc2luKGkgKyAxKSkgKiAweDEwMDAwMDAwMCkgfCAwO1xuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogTUQ1IGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgTUQ1ID0gQ19hbGdvLk1ENSA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoW1xuXHQgICAgICAgICAgICAgICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSxcblx0ICAgICAgICAgICAgICAgIDB4OThiYWRjZmUsIDB4MTAzMjU0NzZcblx0ICAgICAgICAgICAgXSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIG9mZnNldF9pID0gb2Zmc2V0ICsgaTtcblx0ICAgICAgICAgICAgICAgIHZhciBNX29mZnNldF9pID0gTVtvZmZzZXRfaV07XG5cblx0ICAgICAgICAgICAgICAgIE1bb2Zmc2V0X2ldID0gKFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgOCkgIHwgKE1fb2Zmc2V0X2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCAyNCkgfCAoTV9vZmZzZXRfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMCAgPSBNW29mZnNldCArIDBdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMSAgPSBNW29mZnNldCArIDFdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMiAgPSBNW29mZnNldCArIDJdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMyAgPSBNW29mZnNldCArIDNdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNCAgPSBNW29mZnNldCArIDRdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNSAgPSBNW29mZnNldCArIDVdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNiAgPSBNW29mZnNldCArIDZdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNyAgPSBNW29mZnNldCArIDddO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfOCAgPSBNW29mZnNldCArIDhdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfOSAgPSBNW29mZnNldCArIDldO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTAgPSBNW29mZnNldCArIDEwXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzExID0gTVtvZmZzZXQgKyAxMV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMiA9IE1bb2Zmc2V0ICsgMTJdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTMgPSBNW29mZnNldCArIDEzXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE0ID0gTVtvZmZzZXQgKyAxNF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xNSA9IE1bb2Zmc2V0ICsgMTVdO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFsYmVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgIDcsICBUWzBdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEsICAxMiwgVFsxXSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTcsIFRbMl0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMywgIDIyLCBUWzNdKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsICA3LCAgVFs0XSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF81LCAgMTIsIFRbNV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE3LCBUWzZdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzcsICAyMiwgVFs3XSk7XG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNywgIFRbOF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfOSwgIDEyLCBUWzldKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNywgVFsxMF0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTEsIDIyLCBUWzExXSk7XG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8xMiwgNywgIFRbMTJdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEzLCAxMiwgVFsxM10pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTQsIDE3LCBUWzE0XSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xNSwgMjIsIFRbMTVdKTtcblxuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgIDUsICBUWzE2XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF82LCAgOSwgIFRbMTddKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNCwgVFsxOF0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMCwgIDIwLCBUWzE5XSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF81LCAgNSwgIFRbMjBdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEwLCA5LCAgVFsyMV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTUsIDE0LCBUWzIyXSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF80LCAgMjAsIFRbMjNdKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzksICA1LCAgVFsyNF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTQsIDksICBUWzI1XSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTQsIFRbMjZdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzgsICAyMCwgVFsyN10pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfMTMsIDUsICBUWzI4XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8yLCAgOSwgIFRbMjldKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzcsICAxNCwgVFszMF0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMTIsIDIwLCBUWzMxXSk7XG5cblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA0LCAgVFszMl0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfOCwgIDExLCBUWzMzXSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8xMSwgMTYsIFRbMzRdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzE0LCAyMywgVFszNV0pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgIDQsICBUWzM2XSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF80LCAgMTEsIFRbMzddKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzcsICAxNiwgVFszOF0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTAsIDIzLCBUWzM5XSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNCwgIFRbNDBdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzAsICAxMSwgVFs0MV0pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgIDE2LCBUWzQyXSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF82LCAgMjMsIFRbNDNdKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzksICA0LCAgVFs0NF0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTIsIDExLCBUWzQ1XSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTYsIFRbNDZdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzIsICAyMywgVFs0N10pO1xuXG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNiwgIFRbNDhdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzcsICAxMCwgVFs0OV0pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTQsIDE1LCBUWzUwXSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF81LCAgMjEsIFRbNTFdKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA2LCAgVFs1Ml0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMywgIDEwLCBUWzUzXSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTUsIFRbNTRdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEsICAyMSwgVFs1NV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfOCwgIDYsICBUWzU2XSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xNSwgMTAsIFRbNTddKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsICAxNSwgVFs1OF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTMsIDIxLCBUWzU5XSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF80LCAgNiwgIFRbNjBdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzExLCAxMCwgVFs2MV0pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgIDE1LCBUWzYyXSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF85LCAgMjEsIFRbNjNdKTtcblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbEggPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsTCA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gKFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEggPDwgOCkgIHwgKG5CaXRzVG90YWxIID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEggPDwgMjQpIHwgKG5CaXRzVG90YWxIID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSAoXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsTCA8PCA4KSAgfCAobkJpdHNUb3RhbEwgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsTCA8PCAyNCkgfCAobkJpdHNUb3RhbEwgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICApO1xuXG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSAoZGF0YVdvcmRzLmxlbmd0aCArIDEpICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5faGFzaDtcblx0ICAgICAgICAgICAgdmFyIEggPSBoYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICAgICAgdmFyIEhfaSA9IEhbaV07XG5cblx0ICAgICAgICAgICAgICAgIEhbaV0gPSAoKChIX2kgPDwgOCkgIHwgKEhfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAoKChIX2kgPDwgMjQpIHwgKEhfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIGZ1bmN0aW9uIEZGKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoKGIgJiBjKSB8ICh+YiAmIGQpKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIEdHKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoKGIgJiBkKSB8IChjICYgfmQpKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIEhIKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoYiBeIGMgXiBkKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIElJKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoYyBeIChiIHwgfmQpKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5NRDUoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSh3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLk1ENSA9IEhhc2hlci5fY3JlYXRlSGVscGVyKE1ENSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjTUQ1KG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY01ENSA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihNRDUpO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5NRDU7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiA2MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGRlZmF1bHRzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKTtcbnZhciBlcnJvcmluZm9fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgSHR0cE1ldGhvZHNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTgpKTtcbnZhciB4aHJyZXF1ZXN0XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KSk7XG52YXIgWEhSU3RhdGVzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBqc29ucHRyYW5zcG9ydF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG52YXIgZmV0Y2hyZXF1ZXN0XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKSk7XG52YXIgSHR0cFN0YXR1c0NvZGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcbmZ1bmN0aW9uIHNob3VsZEZhbGxiYWNrKGVycm9ySW5mbykge1xuICAgIHZhciBzdGF0dXNDb2RlID0gZXJyb3JJbmZvLnN0YXR1c0NvZGU7XG4gICAgLyogNDAwICsgbm8gY29kZSA9IGEgZ2VuZXJpYyB4aHIgb25lcnJvci4gQnJvd3NlciBkb2Vzbid0IGdpdmUgdXMgZW5vdWdoXG4gICAgICogZGV0YWlsIHRvIGtub3cgd2hldGhlciBpdCdzIGZhbGxiYWNrLWZpeGFibGUsIGJ1dCBpdCBtYXkgYmUgKGVnIGlmIGFcbiAgICAgKiBuZXR3b3JrIGlzc3VlKSwgc28gdHJ5IGp1c3QgaW4gY2FzZSAqL1xuICAgIHJldHVybiAoKHN0YXR1c0NvZGUgPT09IDQwOCAmJiAhZXJyb3JJbmZvLmNvZGUpIHx8XG4gICAgICAgIChzdGF0dXNDb2RlID09PSA0MDAgJiYgIWVycm9ySW5mby5jb2RlKSB8fFxuICAgICAgICAoc3RhdHVzQ29kZSA+PSA1MDAgJiYgc3RhdHVzQ29kZSA8PSA1MDQpKTtcbn1cbmZ1bmN0aW9uIGdldEhvc3RzKGNsaWVudCkge1xuICAgIC8qIElmIHdlJ3JlIGEgY29ubmVjdGVkIHJlYWx0aW1lIGNsaWVudCwgdHJ5IHRoZSBlbmRwb2ludCB3ZSdyZSBjb25uZWN0ZWRcbiAgICAgKiB0byBmaXJzdCAtLSBidXQgc3RpbGwgaGF2ZSBmYWxsYmFja3MsIGJlaW5nIGNvbm5lY3RlZCBpcyBub3QgYW4gYWJzb2x1dGVcbiAgICAgKiBndWFyYW50ZWUgdGhhdCBhIGRhdGFjZW50ZXIgaGFzIGZyZWUgY2FwYWNpdHkgdG8gc2VydmljZSBSRVNUIHJlcXVlc3RzLiAqL1xuICAgIHZhciBjb25uZWN0aW9uID0gY2xpZW50LmNvbm5lY3Rpb24sIGNvbm5lY3Rpb25Ib3N0ID0gY29ubmVjdGlvbiAmJiBjb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLmhvc3Q7XG4gICAgaWYgKGNvbm5lY3Rpb25Ib3N0KSB7XG4gICAgICAgIHJldHVybiBbY29ubmVjdGlvbkhvc3RdLmNvbmNhdChkZWZhdWx0c18xLmRlZmF1bHQuZ2V0RmFsbGJhY2tIb3N0cyhjbGllbnQub3B0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdHNfMS5kZWZhdWx0LmdldEhvc3RzKGNsaWVudC5vcHRpb25zKTtcbn1cbnZhciBIdHRwID0gKF9hID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tzSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGl2aXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zdXBwb3J0c0F1dGhIZWFkZXJzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN1cHBvcnRzTGlua0hlYWRlcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2dldEhvc3RzID0gZ2V0SG9zdHM7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpdml0eUNoZWNrVXJsID0gdGhpcy5vcHRpb25zLmNvbm5lY3Rpdml0eUNoZWNrVXJsIHx8IGRlZmF1bHRzXzEuZGVmYXVsdC5jb25uZWN0aXZpdHlDaGVja1VybDtcbiAgICAgICAgICAgIHZhciBjb25uZWN0aXZpdHlDaGVja1BhcmFtcyA9IHRoaXMub3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1BhcmFtcztcbiAgICAgICAgICAgIHZhciBjb25uZWN0aXZpdHlVcmxJc0RlZmF1bHQgPSAhdGhpcy5vcHRpb25zLmNvbm5lY3Rpdml0eUNoZWNrVXJsO1xuICAgICAgICAgICAgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcueGhyU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdXBwb3J0c0F1dGhIZWFkZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLlJlcXVlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHhocnJlcXVlc3RfMS5kZWZhdWx0LmNyZWF0ZVJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIFhIUlN0YXRlc18xLmRlZmF1bHQuUkVRX1NFTkQsIHJlc3QgJiYgcmVzdC5vcHRpb25zLnRpbWVvdXRzLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICByZXEub25jZSgnY29tcGxldGUnLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5leGVjKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXE7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVDb25uZWN0aXZpdHlDaGVjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGl2aXR5ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aXZpdHkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnKFhIUlJlcXVlc3QpSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpJywgJ1NlbmRpbmc7ICcgKyBjb25uZWN0aXZpdHlDaGVja1VybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvVXJpKEh0dHBNZXRob2RzXzEuZGVmYXVsdC5HZXQsIG51bGwsIGNvbm5lY3Rpdml0eUNoZWNrVXJsLCBudWxsLCBudWxsLCBjb25uZWN0aXZpdHlDaGVja1BhcmFtcywgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2VUZXh0LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbm5lY3Rpdml0eVVybElzRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAhZXJyICYmICgwLCBIdHRwU3RhdHVzQ29kZXNfMS5pc1N1Y2Nlc3NDb2RlKShzdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICFlcnIgJiYgKHJlc3BvbnNlVGV4dCA9PT0gbnVsbCB8fCByZXNwb25zZVRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlVGV4dC5yZXBsYWNlKC9cXG4vLCAnJykpID09ICd5ZXMnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJyhYSFJSZXF1ZXN0KUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKScsICdSZXN1bHQ6ICcgKyByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmpzb25wU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5SZXF1ZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgcmVzdCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSAoMCwganNvbnB0cmFuc3BvcnRfMS5jcmVhdGVSZXF1ZXN0KSh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgWEhSU3RhdGVzXzEuZGVmYXVsdC5SRVFfU0VORCwgcmVzdCAmJiByZXN0Lm9wdGlvbnMudGltZW91dHMsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmNlKCdjb21wbGV0ZScsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuZXhlYygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZUNvbm5lY3Rpdml0eUNoZWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aXZpdHkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpdml0eSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cFVybCA9IGRlZmF1bHRzXzEuZGVmYXVsdC5qc29ucEludGVybmV0VXBVcmw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja3NJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja3NJblByb2dyZXNzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tzSW5Qcm9ncmVzcyA9IFtjYWxsYmFja107XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJyhKU09OUClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCknLCAnU2VuZGluZzsgJyArIHVwVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBuZXcganNvbnB0cmFuc3BvcnRfMS5SZXF1ZXN0KCdpc1RoZUludGVybmV0VXAnLCB1cFVybCwgbnVsbCwgbnVsbCwgbnVsbCwgWEhSU3RhdGVzXzEuZGVmYXVsdC5SRVFfU0VORCwgZGVmYXVsdHNfMS5kZWZhdWx0LlRJTUVPVVRTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmNlKCdjb21wbGV0ZScsIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICFlcnIgJiYgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICcoSlNPTlApSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpJywgJ1Jlc3VsdDogJyArIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5jaGVja3NJblByb2dyZXNzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jaGVja3NJblByb2dyZXNzW2ldKG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tzSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5leGVjKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmZldGNoU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdXBwb3J0c0F1dGhIZWFkZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLlJlcXVlc3QgPSBmZXRjaHJlcXVlc3RfMS5kZWZhdWx0O1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aXZpdHkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICcoRmV0Y2gpSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpJywgJ1NlbmRpbmc7ICcgKyBjb25uZWN0aXZpdHlDaGVja1VybCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9VcmkoSHR0cE1ldGhvZHNfMS5kZWZhdWx0LkdldCwgbnVsbCwgY29ubmVjdGl2aXR5Q2hlY2tVcmwsIG51bGwsIG51bGwsIG51bGwsIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICFlcnIgJiYgKHJlc3BvbnNlVGV4dCA9PT0gbnVsbCB8fCByZXNwb25zZVRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlVGV4dC5yZXBsYWNlKC9cXG4vLCAnJykpID09ICd5ZXMnO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICcoRmV0Y2gpSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpJywgJ1Jlc3VsdDogJyArIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5SZXF1ZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgcmVzdCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdubyBzdXBwb3J0ZWQgSFRUUCB0cmFuc3BvcnRzIGF2YWlsYWJsZScsIG51bGwsIDQwMCksIG51bGwpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogVW5saWtlIGZvciBkb1VyaSwgdGhlICdyZXN0JyBwYXJhbSBoZXJlIGlzIG1hbmRhdG9yeSwgYXMgaXQncyB1c2VkIHRvIGdlbmVyYXRlIHRoZSBob3N0cyAqL1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5kbyA9IGZ1bmN0aW9uIChtZXRob2QsIHJlc3QsIHBhdGgsIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgdXJpRnJvbUhvc3QgPSB0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgPyBwYXRoXG4gICAgICAgICAgICAgICAgOiBmdW5jdGlvbiAoaG9zdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdC5iYXNlVXJpKGhvc3QpICsgcGF0aDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRGYWxsYmFjayA9IHJlc3QuX2N1cnJlbnRGYWxsYmFjaztcbiAgICAgICAgICAgIGlmIChjdXJyZW50RmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEZhbGxiYWNrLnZhbGlkVW50aWwgPiBVdGlscy5ub3coKSkge1xuICAgICAgICAgICAgICAgICAgICAvKiBVc2Ugc3RvcmVkIGZhbGxiYWNrICovXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5SZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ1JlcXVlc3QgaW52b2tlZCBiZWZvcmUgYXNzaWduZWQgdG8nLCBudWxsLCA1MDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLlJlcXVlc3QobWV0aG9kLCByZXN0LCB1cmlGcm9tSG9zdChjdXJyZW50RmFsbGJhY2suaG9zdCksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgdHlwZWNhc3QgaXMgc2FmZSBiZWNhdXNlIEVycm5vRXhjZXB0aW9ucyBhcmUgb25seSB0aHJvd24gaW4gTm9kZUpTXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyICYmIHNob3VsZEZhbGxiYWNrKGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiB1bnN0b3JlIHRoZSBmYWxsYmFjayBhbmQgc3RhcnQgZnJvbSB0aGUgdG9wIHdpdGggdGhlIGRlZmF1bHQgc2VxdWVuY2UgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0Ll9jdXJyZW50RmFsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRvKG1ldGhvZCwgcmVzdCwgcGF0aCwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrLmFwcGx5KHZvaWQgMCwgdHNsaWJfMS5fX3NwcmVhZEFycmF5KFtlcnJdLCBhcmdzLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLyogRmFsbGJhY2sgZXhwaXJlZDsgcmVtb3ZlIGl0IGFuZCBmYWxsdGhyb3VnaCB0byBub3JtYWwgc2VxdWVuY2UgKi9cbiAgICAgICAgICAgICAgICAgICAgcmVzdC5fY3VycmVudEZhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaG9zdHMgPSBnZXRIb3N0cyhyZXN0KTtcbiAgICAgICAgICAgIC8qIGlmIHRoZXJlIGlzIG9ubHkgb25lIGhvc3QgZG8gaXQgKi9cbiAgICAgICAgICAgIGlmIChob3N0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvVXJpKG1ldGhvZCwgcmVzdCwgdXJpRnJvbUhvc3QoaG9zdHNbMF0pLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBob3N0cyBpcyBhbiBhcnJheSB3aXRoIHByZWZlcnJlZCBob3N0IHBsdXMgYXQgbGVhc3Qgb25lIGZhbGxiYWNrICovXG4gICAgICAgICAgICB2YXIgdHJ5QUhvc3QgPSBmdW5jdGlvbiAoY2FuZGlkYXRlSG9zdHMsIHBlcnNpc3RPblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgaG9zdCA9IGNhbmRpZGF0ZUhvc3RzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZG9VcmkobWV0aG9kLCByZXN0LCB1cmlGcm9tSG9zdChob3N0KSwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgdHlwZWNhc3QgaXMgc2FmZSBiZWNhdXNlIEVycm5vRXhjZXB0aW9ucyBhcmUgb25seSB0aHJvd24gaW4gTm9kZUpTXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgc2hvdWxkRmFsbGJhY2soZXJyKSAmJiBjYW5kaWRhdGVIb3N0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeUFIb3N0KGNhbmRpZGF0ZUhvc3RzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGVyc2lzdE9uU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogUlNDMTVmICovXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN0Ll9jdXJyZW50RmFsbGJhY2sgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogaG9zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZFVudGlsOiBVdGlscy5ub3coKSArIHJlc3Qub3B0aW9ucy50aW1lb3V0cy5mYWxsYmFja1JldHJ5VGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrLmFwcGx5KHZvaWQgMCwgdHNsaWJfMS5fX3NwcmVhZEFycmF5KFtlcnJdLCBhcmdzLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyeUFIb3N0KGhvc3RzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZG9VcmkgPSBmdW5jdGlvbiAobWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5SZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ1JlcXVlc3QgaW52b2tlZCBiZWZvcmUgYXNzaWduZWQgdG8nLCBudWxsLCA1MDApKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLlJlcXVlc3QobWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2xhc3NfMTtcbiAgICB9KCkpLFxuICAgIF9hLm1ldGhvZHMgPSBbSHR0cE1ldGhvZHNfMS5kZWZhdWx0LkdldCwgSHR0cE1ldGhvZHNfMS5kZWZhdWx0LkRlbGV0ZSwgSHR0cE1ldGhvZHNfMS5kZWZhdWx0LlBvc3QsIEh0dHBNZXRob2RzXzEuZGVmYXVsdC5QdXQsIEh0dHBNZXRob2RzXzEuZGVmYXVsdC5QYXRjaF0sXG4gICAgX2EubWV0aG9kc1dpdGhvdXRCb2R5ID0gW0h0dHBNZXRob2RzXzEuZGVmYXVsdC5HZXQsIEh0dHBNZXRob2RzXzEuZGVmYXVsdC5EZWxldGVdLFxuICAgIF9hLm1ldGhvZHNXaXRoQm9keSA9IFtIdHRwTWV0aG9kc18xLmRlZmF1bHQuUG9zdCwgSHR0cE1ldGhvZHNfMS5kZWZhdWx0LlB1dCwgSHR0cE1ldGhvZHNfMS5kZWZhdWx0LlBhdGNoXSxcbiAgICBfYSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIdHRwO1xuXG5cbi8qKiovIH0pLFxuLyogNjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciBkZWZhdWx0c18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg4KSk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbmZ1bmN0aW9uIGlzQWJseUVycm9yKHJlc3BvbnNlQm9keSwgaGVhZGVycykge1xuICAgIHJldHVybiAhIWhlYWRlcnMuZ2V0KCd4LWFibHktZXJyb3Jjb2RlJyk7XG59XG5mdW5jdGlvbiBnZXRBYmx5RXJyb3IocmVzcG9uc2VCb2R5LCBoZWFkZXJzKSB7XG4gICAgaWYgKGlzQWJseUVycm9yKHJlc3BvbnNlQm9keSwgaGVhZGVycykpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlQm9keS5lcnJvciAmJiBlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMocmVzcG9uc2VCb2R5LmVycm9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmZXRjaFJlcXVlc3QobWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmV0Y2hIZWFkZXJzID0gbmV3IEhlYWRlcnMoaGVhZGVycyB8fCB7fSk7XG4gICAgdmFyIF9tZXRob2QgPSBtZXRob2QgPyBtZXRob2QudG9VcHBlckNhc2UoKSA6IFV0aWxzLmlzRW1wdHlBcmcoYm9keSkgPyAnR0VUJyA6ICdQT1NUJztcbiAgICB2YXIgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdSZXF1ZXN0IHRpbWVkIG91dCcsIG51bGwsIDQwOCkpO1xuICAgIH0sIHJlc3QgPyByZXN0Lm9wdGlvbnMudGltZW91dHMuaHR0cFJlcXVlc3RUaW1lb3V0IDogZGVmYXVsdHNfMS5kZWZhdWx0LlRJTUVPVVRTLmh0dHBSZXF1ZXN0VGltZW91dCk7XG4gICAgdmFyIHJlcXVlc3RJbml0ID0ge1xuICAgICAgICBtZXRob2Q6IF9tZXRob2QsXG4gICAgICAgIGhlYWRlcnM6IGZldGNoSGVhZGVycyxcbiAgICAgICAgYm9keTogYm9keSxcbiAgICB9O1xuICAgIGlmICghcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pc1dlYndvcmtlcikge1xuICAgICAgICByZXF1ZXN0SW5pdC5jcmVkZW50aWFscyA9IGZldGNoSGVhZGVycy5oYXMoJ2F1dGhvcml6YXRpb24nKSA/ICdpbmNsdWRlJyA6ICdzYW1lLW9yaWdpbic7XG4gICAgfVxuICAgICgwLCB1dGlsc18xLmdldEdsb2JhbE9iamVjdCkoKVxuICAgICAgICAuZmV0Y2godXJpICsgJz8nICsgbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMgfHwge30pLCByZXF1ZXN0SW5pdClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHZhciBjb250ZW50VHlwZSA9IHJlcy5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJyk7XG4gICAgICAgIHZhciBwcm9tO1xuICAgICAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24veC1tc2dwYWNrJykgPiAtMSkge1xuICAgICAgICAgICAgcHJvbSA9IHJlcy5hcnJheUJ1ZmZlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xKSB7XG4gICAgICAgICAgICBwcm9tID0gcmVzLmpzb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb20gPSByZXMudGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHByb20udGhlbihmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICAgICAgdmFyIHVucGFja2VkID0gISFjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi94LW1zZ3BhY2snKSA9PT0gLTE7XG4gICAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBnZXRBYmx5RXJyb3IoYm9keSwgcmVzLmhlYWRlcnMpIHx8XG4gICAgICAgICAgICAgICAgICAgIG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdFcnJvciByZXNwb25zZSByZWNlaXZlZCBmcm9tIHNlcnZlcjogJyArIHJlcy5zdGF0dXMgKyAnIGJvZHkgd2FzOiAnICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KGJvZHkpLCBudWxsLCByZXMuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIGJvZHksIHJlcy5oZWFkZXJzLCB1bnBhY2tlZCwgcmVzLnN0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBib2R5LCByZXMuaGVhZGVycywgdW5wYWNrZWQsIHJlcy5zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBmZXRjaFJlcXVlc3Q7XG5cblxuLyoqKi8gfSksXG4vKiA2NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIG1zZ3BhY2tfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNDEpKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xuLy8gV29ya2Fyb3VuZCBmb3Igc2FsZXNmb3JjZSBsaWdodG5pbmcgbG9ja2VyIGNvbXBhdFxudmFyIGdsb2JhbE9iamVjdCA9IFV0aWxzLmdldEdsb2JhbE9iamVjdCgpO1xuaWYgKHR5cGVvZiBXaW5kb3cgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmxvZyhcIldhcm5pbmc6IHRoaXMgZGlzdHJpYnV0aW9uIG9mIEFibHkgaXMgaW50ZW5kZWQgZm9yIGJyb3dzZXJzLiBPbiBub2RlanMsIHBsZWFzZSB1c2UgdGhlICdhYmx5JyBwYWNrYWdlIG9uIG5wbVwiKTtcbn1cbmZ1bmN0aW9uIGFsbG93Q29tZXQoKSB7XG4gICAgLyogeGhyIHJlcXVlc3RzIGZyb20gbG9jYWwgZmlsZXMgYXJlIHVucmVsaWFibGUgaW4gc29tZSBicm93c2Vycywgc3VjaCBhcyBDaHJvbWUgNjUgYW5kIGhpZ2hlciAtLSBzZWUgZWdcbiAgICAgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTI1NjQyOS9jaHJvbWUtNjUtdW5hYmxlLXRvLW1ha2UtcG9zdC1yZXF1ZXN0cy1mcm9tLWxvY2FsLWZpbGVzLXRvLWZsYXNrXG4gICAgICogU28gaWYgd2Vic29ja2V0cyBhcmUgc3VwcG9ydGVkLCB0aGVuIGp1c3QgZm9yZ2V0IGFib3V0IGNvbWV0IHRyYW5zcG9ydHMgYW5kIHVzZSB0aGF0ICovXG4gICAgdmFyIGxvYyA9IGdsb2JhbE9iamVjdC5sb2NhdGlvbjtcbiAgICByZXR1cm4gIWdsb2JhbE9iamVjdC5XZWJTb2NrZXQgfHwgIWxvYyB8fCAhbG9jLm9yaWdpbiB8fCBsb2Mub3JpZ2luLmluZGV4T2YoJ2h0dHAnKSA+IC0xO1xufVxudmFyIHVzZXJBZ2VudCA9IGdsb2JhbE9iamVjdC5uYXZpZ2F0b3IgJiYgZ2xvYmFsT2JqZWN0Lm5hdmlnYXRvci51c2VyQWdlbnQudG9TdHJpbmcoKTtcbnZhciBjdXJyZW50VXJsID0gZ2xvYmFsT2JqZWN0LmxvY2F0aW9uICYmIGdsb2JhbE9iamVjdC5sb2NhdGlvbi5ocmVmO1xudmFyIENvbmZpZyA9IHtcbiAgICBhZ2VudDogJ2Jyb3dzZXInLFxuICAgIGxvZ1RpbWVzdGFtcHM6IHRydWUsXG4gICAgdXNlckFnZW50OiB1c2VyQWdlbnQsXG4gICAgY3VycmVudFVybDogY3VycmVudFVybCxcbiAgICBub1VwZ3JhZGU6IHVzZXJBZ2VudCAmJiAhIXVzZXJBZ2VudC5tYXRjaCgvTVNJRVxcczhcXC4wLyksXG4gICAgYmluYXJ5VHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICBXZWJTb2NrZXQ6IGdsb2JhbE9iamVjdC5XZWJTb2NrZXQsXG4gICAgZmV0Y2hTdXBwb3J0ZWQ6ICEhZ2xvYmFsT2JqZWN0LmZldGNoLFxuICAgIHhoclN1cHBvcnRlZDogZ2xvYmFsT2JqZWN0LlhNTEh0dHBSZXF1ZXN0ICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuICAgIGpzb25wU3VwcG9ydGVkOiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnLFxuICAgIGFsbG93Q29tZXQ6IGFsbG93Q29tZXQoKSxcbiAgICBzdHJlYW1pbmdTdXBwb3J0ZWQ6IHRydWUsXG4gICAgdXNlUHJvdG9jb2xIZWFydGJlYXRzOiB0cnVlLFxuICAgIGNyZWF0ZUhtYWM6IG51bGwsXG4gICAgbXNncGFjazogbXNncGFja18xLmRlZmF1bHQsXG4gICAgc3VwcG9ydHNCaW5hcnk6ICEhZ2xvYmFsT2JqZWN0LlRleHREZWNvZGVyLFxuICAgIHByZWZlckJpbmFyeTogZmFsc2UsXG4gICAgQXJyYXlCdWZmZXI6IGdsb2JhbE9iamVjdC5BcnJheUJ1ZmZlcixcbiAgICBhdG9iOiBnbG9iYWxPYmplY3QuYXRvYixcbiAgICBuZXh0VGljazogdHlwZW9mIGdsb2JhbE9iamVjdC5zZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gZ2xvYmFsT2JqZWN0LnNldEltbWVkaWF0ZS5iaW5kKGdsb2JhbE9iamVjdClcbiAgICAgICAgOiBmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgc2V0VGltZW91dChmLCAwKTtcbiAgICAgICAgfSxcbiAgICBhZGRFdmVudExpc3RlbmVyOiBnbG9iYWxPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcixcbiAgICBpbnNwZWN0OiBKU09OLnN0cmluZ2lmeSxcbiAgICBzdHJpbmdCeXRlU2l6ZTogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAvKiBzdHIubGVuZ3RoIHdpbGwgYmUgYW4gdW5kZXJlc3RpbWF0ZSBmb3Igbm9uLWFzY2lpIHN0cmluZ3MuIEJ1dCBpZiB3ZSdyZVxuICAgICAgICAgKiBpbiBhIGJyb3dzZXIgdG9vIG9sZCB0byBzdXBwb3J0IFRleHREZWNvZGVyLCBub3QgbXVjaCB3ZSBjYW4gZG8uIEJldHRlclxuICAgICAgICAgKiB0byB1bmRlcmVzdGltYXRlLCBzbyBpZiB3ZSBkbyBnbyBvdmVyLXNpemUsIHRoZSBzZXJ2ZXIgd2lsbCByZWplY3QgdGhlXG4gICAgICAgICAqIG1lc3NhZ2UgKi9cbiAgICAgICAgcmV0dXJuIChnbG9iYWxPYmplY3QuVGV4dERlY29kZXIgJiYgbmV3IGdsb2JhbE9iamVjdC5UZXh0RW5jb2RlcigpLmVuY29kZShzdHIpLmxlbmd0aCkgfHwgc3RyLmxlbmd0aDtcbiAgICB9LFxuICAgIFRleHRFbmNvZGVyOiBnbG9iYWxPYmplY3QuVGV4dEVuY29kZXIsXG4gICAgVGV4dERlY29kZXI6IGdsb2JhbE9iamVjdC5UZXh0RGVjb2RlcixcbiAgICBQcm9taXNlOiBnbG9iYWxPYmplY3QuUHJvbWlzZSxcbiAgICBnZXRSYW5kb21WYWx1ZXM6IChmdW5jdGlvbiAoY3J5cHRvKSB7XG4gICAgICAgIGlmIChjcnlwdG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pKGdsb2JhbE9iamVjdC5jcnlwdG8gfHwgbXNDcnlwdG8pLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IENvbmZpZztcblxuXG4vKioqLyB9KSxcbi8qIDY1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgdGVzdCA9ICdhYmx5anMtc3RvcmFnZS10ZXN0JztcbnZhciBXZWJzdG9yYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdlYnN0b3JhZ2UoKSB7XG4gICAgICAgIC8qIEV2ZW4ganVzdCBhY2Nlc3NpbmcgdGhlIHNlc3Npb24vbG9jYWxTdG9yYWdlIG9iamVjdCBjYW4gdGhyb3cgYVxuICAgICAgICAgKiBzZWN1cml0eSBleGNlcHRpb24gaW4gc29tZSBjaXJjdW1zdGFuY2VzIHdpdGggc29tZSBicm93c2Vycy4gSW5cbiAgICAgICAgICogb3RoZXJzLCBjYWxsaW5nIHNldEl0ZW0gd2lsbCB0aHJvdy4gU28gaGF2ZSB0byBjaGVjayBpbiB0aGlzXG4gICAgICAgICAqIHNvbWV3aGF0IHJvdW5kYWJvdXQgd2F5LiAoSWYgdW5zdXBwb3J0ZWQgb3Igbm8gZ2xvYmFsIG9iamVjdCxcbiAgICAgICAgICogd2lsbCB0aHJvdyBvbiBhY2Nlc3NpbmcgYSBwcm9wZXJ0eSBvZiB1bmRlZmluZWQpICovXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBnbG9iYWwuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSh0ZXN0LCB0ZXN0KTtcbiAgICAgICAgICAgIGdsb2JhbC5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHRlc3QpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0ZXN0LCB0ZXN0KTtcbiAgICAgICAgICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0ZXN0KTtcbiAgICAgICAgICAgIHRoaXMubG9jYWxTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgV2Vic3RvcmFnZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldChuYW1lLCBmYWxzZSk7XG4gICAgfTtcbiAgICBXZWJzdG9yYWdlLnByb3RvdHlwZS5nZXRTZXNzaW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldChuYW1lLCB0cnVlKTtcbiAgICB9O1xuICAgIFdlYnN0b3JhZ2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdmUobmFtZSwgZmFsc2UpO1xuICAgIH07XG4gICAgV2Vic3RvcmFnZS5wcm90b3R5cGUucmVtb3ZlU2Vzc2lvbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdmUobmFtZSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBXZWJzdG9yYWdlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHR0bCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0KG5hbWUsIHZhbHVlLCB0dGwsIGZhbHNlKTtcbiAgICB9O1xuICAgIFdlYnN0b3JhZ2UucHJvdG90eXBlLnNldFNlc3Npb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHR0bCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0KG5hbWUsIHZhbHVlLCB0dGwsIHRydWUpO1xuICAgIH07XG4gICAgV2Vic3RvcmFnZS5wcm90b3R5cGUuX3NldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgdHRsLCBzZXNzaW9uKSB7XG4gICAgICAgIHZhciB3cmFwcGVkVmFsdWUgPSB7IHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICBpZiAodHRsKSB7XG4gICAgICAgICAgICB3cmFwcGVkVmFsdWUuZXhwaXJlcyA9IFV0aWxzLm5vdygpICsgdHRsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2VJbnRlcmZhY2Uoc2Vzc2lvbikuc2V0SXRlbShuYW1lLCBKU09OLnN0cmluZ2lmeSh3cmFwcGVkVmFsdWUpKTtcbiAgICB9O1xuICAgIFdlYnN0b3JhZ2UucHJvdG90eXBlLl9nZXQgPSBmdW5jdGlvbiAobmFtZSwgc2Vzc2lvbikge1xuICAgICAgICBpZiAoc2Vzc2lvbiAmJiAhdGhpcy5zZXNzaW9uU3VwcG9ydGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXNzaW9uIFN0b3JhZ2Ugbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBpZiAoIXNlc3Npb24gJiYgIXRoaXMubG9jYWxTdXBwb3J0ZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvY2FsIFN0b3JhZ2Ugbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB2YXIgcmF3SXRlbSA9IHRoaXMuc3RvcmFnZUludGVyZmFjZShzZXNzaW9uKS5nZXRJdGVtKG5hbWUpO1xuICAgICAgICBpZiAoIXJhd0l0ZW0pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIHdyYXBwZWRWYWx1ZSA9IEpTT04ucGFyc2UocmF3SXRlbSk7XG4gICAgICAgIGlmICh3cmFwcGVkVmFsdWUuZXhwaXJlcyAmJiB3cmFwcGVkVmFsdWUuZXhwaXJlcyA8IFV0aWxzLm5vdygpKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2VJbnRlcmZhY2Uoc2Vzc2lvbikucmVtb3ZlSXRlbShuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cmFwcGVkVmFsdWUudmFsdWU7XG4gICAgfTtcbiAgICBXZWJzdG9yYWdlLnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24gKG5hbWUsIHNlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZUludGVyZmFjZShzZXNzaW9uKS5yZW1vdmVJdGVtKG5hbWUpO1xuICAgIH07XG4gICAgV2Vic3RvcmFnZS5wcm90b3R5cGUuc3RvcmFnZUludGVyZmFjZSA9IGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiBzZXNzaW9uID8gZ2xvYmFsLnNlc3Npb25TdG9yYWdlIDogZ2xvYmFsLmxvY2FsU3RvcmFnZTtcbiAgICB9O1xuICAgIHJldHVybiBXZWJzdG9yYWdlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBXZWJzdG9yYWdlKCk7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKSkpXG5cbi8qKiovIH0pLFxuLyogNjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBUcmFuc3BvcnROYW1lc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg2NykpO1xudmFyIERlZmF1bHRzID0ge1xuICAgIGNvbm5lY3Rpdml0eUNoZWNrVXJsOiAnaHR0cHM6Ly9pbnRlcm5ldC11cC5hYmx5LXJlYWx0aW1lLmNvbS9pcy10aGUtaW50ZXJuZXQtdXAudHh0JyxcbiAgICBqc29ucEludGVybmV0VXBVcmw6ICdodHRwczovL2ludGVybmV0LXVwLmFibHktcmVhbHRpbWUuY29tL2lzLXRoZS1pbnRlcm5ldC11cC0wLTkuanMnLFxuICAgIC8qIE9yZGVyIG1hdHRlcnMgaGVyZTogdGhlIGJhc2UgdHJhbnNwb3J0IGlzIHRoZSBsZWZ0bW9zdCBvbmUgaW4gdGhlXG4gICAgICogaW50ZXJzZWN0aW9uIG9mIGJhc2VUcmFuc3BvcnRPcmRlciBhbmQgdGhlIHRyYW5zcG9ydHMgY2xpZW50T3B0aW9uIHRoYXQnc1xuICAgICAqIHN1cHBvcnRlZC4gIFRoaXMgaXMgbm90IHF1aXRlIHRoZSBzYW1lIGFzIHRoZSBwcmVmZXJlbmNlIG9yZGVyIC0tIGUuZy5cbiAgICAgKiB4aHJfcG9sbGluZyBpcyBwcmVmZXJyZWQgdG8ganNvbnAsIGJ1dCBmb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGl0IHdlIHdhbnRcbiAgICAgKiB0aGUgYmFzZSB0cmFuc3BvcnQgdG8gYmUgeGhyX3BvbGxpbmcsIG5vdCBqc29ucCAqL1xuICAgIGRlZmF1bHRUcmFuc3BvcnRzOiBbXG4gICAgICAgIFRyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5YaHJQb2xsaW5nLFxuICAgICAgICBUcmFuc3BvcnROYW1lc18xLmRlZmF1bHQuWGhyU3RyZWFtaW5nLFxuICAgICAgICBUcmFuc3BvcnROYW1lc18xLmRlZmF1bHQuSnNvblAsXG4gICAgICAgIFRyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5XZWJTb2NrZXQsXG4gICAgXSxcbiAgICBiYXNlVHJhbnNwb3J0T3JkZXI6IFtcbiAgICAgICAgVHJhbnNwb3J0TmFtZXNfMS5kZWZhdWx0LlhoclBvbGxpbmcsXG4gICAgICAgIFRyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5YaHJTdHJlYW1pbmcsXG4gICAgICAgIFRyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5Kc29uUCxcbiAgICAgICAgVHJhbnNwb3J0TmFtZXNfMS5kZWZhdWx0LldlYlNvY2tldCxcbiAgICBdLFxuICAgIHRyYW5zcG9ydFByZWZlcmVuY2VPcmRlcjogW1xuICAgICAgICBUcmFuc3BvcnROYW1lc18xLmRlZmF1bHQuSnNvblAsXG4gICAgICAgIFRyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5YaHJQb2xsaW5nLFxuICAgICAgICBUcmFuc3BvcnROYW1lc18xLmRlZmF1bHQuWGhyU3RyZWFtaW5nLFxuICAgICAgICBUcmFuc3BvcnROYW1lc18xLmRlZmF1bHQuV2ViU29ja2V0LFxuICAgIF0sXG4gICAgdXBncmFkZVRyYW5zcG9ydHM6IFtUcmFuc3BvcnROYW1lc18xLmRlZmF1bHQuWGhyU3RyZWFtaW5nLCBUcmFuc3BvcnROYW1lc18xLmRlZmF1bHQuV2ViU29ja2V0XSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBEZWZhdWx0cztcblxuXG4vKioqLyB9KSxcbi8qIDY3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVHJhbnNwb3J0TmFtZXM7XG4oZnVuY3Rpb24gKFRyYW5zcG9ydE5hbWVzKSB7XG4gICAgVHJhbnNwb3J0TmFtZXNbXCJXZWJTb2NrZXRcIl0gPSBcIndlYl9zb2NrZXRcIjtcbiAgICBUcmFuc3BvcnROYW1lc1tcIkNvbWV0XCJdID0gXCJjb21ldFwiO1xuICAgIFRyYW5zcG9ydE5hbWVzW1wiWGhyU3RyZWFtaW5nXCJdID0gXCJ4aHJfc3RyZWFtaW5nXCI7XG4gICAgVHJhbnNwb3J0TmFtZXNbXCJYaHJQb2xsaW5nXCJdID0gXCJ4aHJfcG9sbGluZ1wiO1xuICAgIFRyYW5zcG9ydE5hbWVzW1wiSnNvblBcIl0gPSBcImpzb25wXCI7XG59KShUcmFuc3BvcnROYW1lcyB8fCAoVHJhbnNwb3J0TmFtZXMgPSB7fSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVHJhbnNwb3J0TmFtZXM7XG5cblxuLyoqKi8gfSksXG4vKiA2OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIEVTTSBDT01QQVQgRkxBR1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3BsYXRmb3JtL3dlYi9saWIvdHJhbnNwb3J0L2pzb25wdHJhbnNwb3J0LnRzXG52YXIganNvbnB0cmFuc3BvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcbnZhciBqc29ucHRyYW5zcG9ydF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqc29ucHRyYW5zcG9ydCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tbW9uL2xpYi91dGlsL3V0aWxzLnRzXG52YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbW1vbi9wbGF0Zm9ybS50c1xudmFyIHBsYXRmb3JtID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBwbGF0Zm9ybV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihwbGF0Zm9ybSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tbW9uL2xpYi90cmFuc3BvcnQvY29tZXR0cmFuc3BvcnQudHNcbnZhciBjb21ldHRyYW5zcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xudmFyIGNvbWV0dHJhbnNwb3J0X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvbWV0dHJhbnNwb3J0KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9wbGF0Zm9ybS93ZWIvbGliL3RyYW5zcG9ydC94aHJyZXF1ZXN0LnRzXG52YXIgeGhycmVxdWVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xudmFyIHhocnJlcXVlc3RfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oeGhycmVxdWVzdCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3BsYXRmb3JtL3dlYi9saWIvdHJhbnNwb3J0L3hocnBvbGxpbmd0cmFuc3BvcnQuanNcblxuXG5cblxuXG52YXIgeGhycG9sbGluZ3RyYW5zcG9ydF9YSFJQb2xsaW5nVHJhbnNwb3J0ID0gZnVuY3Rpb24gKGNvbm5lY3Rpb25NYW5hZ2VyKSB7XG4gIHZhciBzaG9ydE5hbWUgPSAneGhyX3BvbGxpbmcnO1xuXG4gIGZ1bmN0aW9uIFhIUlBvbGxpbmdUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xuICAgIHBhcmFtcy5zdHJlYW0gPSBmYWxzZTtcbiAgICBjb21ldHRyYW5zcG9ydF9kZWZhdWx0LmEuY2FsbCh0aGlzLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcbiAgICB0aGlzLnNob3J0TmFtZSA9IHNob3J0TmFtZTtcbiAgfVxuICB1dGlsc1tcImluaGVyaXRzXCJdKFhIUlBvbGxpbmdUcmFuc3BvcnQsIGNvbWV0dHJhbnNwb3J0X2RlZmF1bHQuYSk7XG5cbiAgWEhSUG9sbGluZ1RyYW5zcG9ydC5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGxhdGZvcm1fZGVmYXVsdC5hLkNvbmZpZy54aHJTdXBwb3J0ZWQgJiYgcGxhdGZvcm1fZGVmYXVsdC5hLkNvbmZpZy5hbGxvd0NvbWV0O1xuICB9O1xuXG4gIFhIUlBvbGxpbmdUcmFuc3BvcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnWEhSUG9sbGluZ1RyYW5zcG9ydDsgdXJpPScgKyB0aGlzLmJhc2VVcmkgKyAnOyBpc0Nvbm5lY3RlZD0nICsgdGhpcy5pc0Nvbm5lY3RlZDtcbiAgfTtcblxuICBYSFJQb2xsaW5nVHJhbnNwb3J0LnByb3RvdHlwZS5jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSkge1xuICAgIHJldHVybiB4aHJyZXF1ZXN0X2RlZmF1bHQuYS5jcmVhdGVSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGhpcy50aW1lb3V0cyk7XG4gIH07XG5cbiAgaWYgKHR5cGVvZiBjb25uZWN0aW9uTWFuYWdlciAhPT0gJ3VuZGVmaW5lZCcgJiYgWEhSUG9sbGluZ1RyYW5zcG9ydC5pc0F2YWlsYWJsZSgpKSB7XG4gICAgY29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0c1tzaG9ydE5hbWVdID0gWEhSUG9sbGluZ1RyYW5zcG9ydDtcbiAgfVxuXG4gIHJldHVybiBYSFJQb2xsaW5nVHJhbnNwb3J0O1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgeGhycG9sbGluZ3RyYW5zcG9ydCA9ICh4aHJwb2xsaW5ndHJhbnNwb3J0X1hIUlBvbGxpbmdUcmFuc3BvcnQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9wbGF0Zm9ybS93ZWIvbGliL3RyYW5zcG9ydC94aHJzdHJlYW1pbmd0cmFuc3BvcnQuanNcblxuXG5cblxuXG52YXIgeGhyc3RyZWFtaW5ndHJhbnNwb3J0X1hIUlN0cmVhbWluZ1RyYW5zcG9ydCA9IGZ1bmN0aW9uIChjb25uZWN0aW9uTWFuYWdlcikge1xuICB2YXIgc2hvcnROYW1lID0gJ3hocl9zdHJlYW1pbmcnO1xuXG4gIC8qIHB1YmxpYyBjb25zdHJ1Y3RvciAqL1xuICBmdW5jdGlvbiBYSFJTdHJlYW1pbmdUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xuICAgIGNvbWV0dHJhbnNwb3J0X2RlZmF1bHQuYS5jYWxsKHRoaXMsIGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuICAgIHRoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lO1xuICB9XG4gIHV0aWxzW1wiaW5oZXJpdHNcIl0oWEhSU3RyZWFtaW5nVHJhbnNwb3J0LCBjb21ldHRyYW5zcG9ydF9kZWZhdWx0LmEpO1xuXG4gIFhIUlN0cmVhbWluZ1RyYW5zcG9ydC5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGxhdGZvcm1fZGVmYXVsdC5hLkNvbmZpZy54aHJTdXBwb3J0ZWQgJiYgcGxhdGZvcm1fZGVmYXVsdC5hLkNvbmZpZy5zdHJlYW1pbmdTdXBwb3J0ZWQgJiYgcGxhdGZvcm1fZGVmYXVsdC5hLkNvbmZpZy5hbGxvd0NvbWV0O1xuICB9O1xuXG4gIFhIUlN0cmVhbWluZ1RyYW5zcG9ydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdYSFJTdHJlYW1pbmdUcmFuc3BvcnQ7IHVyaT0nICsgdGhpcy5iYXNlVXJpICsgJzsgaXNDb25uZWN0ZWQ9JyArIHRoaXMuaXNDb25uZWN0ZWQ7XG4gIH07XG5cbiAgWEhSU3RyZWFtaW5nVHJhbnNwb3J0LnByb3RvdHlwZS5jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSkge1xuICAgIHJldHVybiB4aHJyZXF1ZXN0X2RlZmF1bHQuYS5jcmVhdGVSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGhpcy50aW1lb3V0cyk7XG4gIH07XG5cbiAgaWYgKHR5cGVvZiBjb25uZWN0aW9uTWFuYWdlciAhPT0gJ3VuZGVmaW5lZCcgJiYgWEhSU3RyZWFtaW5nVHJhbnNwb3J0LmlzQXZhaWxhYmxlKCkpIHtcbiAgICBjb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzW3Nob3J0TmFtZV0gPSBYSFJTdHJlYW1pbmdUcmFuc3BvcnQ7XG4gIH1cblxuICByZXR1cm4gWEhSU3RyZWFtaW5nVHJhbnNwb3J0O1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgeGhyc3RyZWFtaW5ndHJhbnNwb3J0ID0gKHhocnN0cmVhbWluZ3RyYW5zcG9ydF9YSFJTdHJlYW1pbmdUcmFuc3BvcnQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9wbGF0Zm9ybS93ZWIvbGliL3RyYW5zcG9ydC9pbmRleC5qc1xuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BvcnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChbanNvbnB0cmFuc3BvcnRfZGVmYXVsdC5hLCB4aHJwb2xsaW5ndHJhbnNwb3J0LCB4aHJzdHJlYW1pbmd0cmFuc3BvcnRdKTtcblxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSlbXCJkZWZhdWx0XCJdO1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xuZnVuY3Rpb24gcHJvbWlzaWZ5T3B0aW9ucyhvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zLmluZGV4T2YoJzonKSA9PSAtMSA/IHsgdG9rZW46IG9wdGlvbnMgfSA6IHsga2V5OiBvcHRpb25zIH07XG4gIH1cbiAgb3B0aW9ucy5wcm9taXNlcyA9IHRydWU7XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKiBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBmaWxlIGltcG9ydGVkIGJlbG93IGlzIG9ubHkgZ2VuZXJhdGVkIGFmdGVyIHJ1bm5pbmdcbiAqIHRoZSBidWlsZCB0YXNrLiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbnZhciBBYmx5ID0gcmVxdWlyZSgnLi9idWlsZC9hYmx5LW5vZGUnKTtcblxudmFyIFJlc3RQcm9taXNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBBYmx5LlJlc3QocHJvbWlzaWZ5T3B0aW9ucyhvcHRpb25zKSk7XG59O1xuT2JqZWN0LmFzc2lnbihSZXN0UHJvbWlzZSwgQWJseS5SZXN0KTtcblxudmFyIFJlYWx0aW1lUHJvbWlzZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgQWJseS5SZWFsdGltZShwcm9taXNpZnlPcHRpb25zKG9wdGlvbnMpKTtcbn07XG5PYmplY3QuYXNzaWduKFJlYWx0aW1lUHJvbWlzZSwgQWJseS5SZWFsdGltZSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBSZXN0OiBSZXN0UHJvbWlzZSxcbiAgUmVhbHRpbWU6IFJlYWx0aW1lUHJvbWlzZSxcbn07XG4iLCJpbXBvcnQgYWJseSBmcm9tIFwiYWJseS9wcm9taXNlc1wiO1xyXG5cclxuY29uc3QgQVBJX0tFWSA9IFwiWjlvcS13LlNlQzBzQTpSV2NoUVZvZTVPVzZIQ3hfb2drLXBSdF9nMnFvQmt6RTNodWh4ZHNTSV9BXCI7XHJcblxyXG5jb25zdCBtZXNzYWdlcyA9IHtcclxuICBtb3ZlOiBcIm1vdmVcIixcclxuICBtZXNzYWdlOiBcIm1lc3NhZ2VcIixcclxufTtcclxuXHJcbmNsYXNzIFNlcnZlciB7XHJcbiAgYXN5bmMgaW5pdCgpIHtcclxuICAgIHRoaXMuc2VydmVyID0gYXdhaXQgdGhpcy5jb25uZWN0KCk7XHJcbiAgICBhd2FpdCB0aGlzLmNyZWF0ZUNoYW5uZWwoXCJnYW1lXCIpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgY29ubmVjdCgpIHtcclxuICAgIC8vIEZvciB0aGUgZnVsbCBjb2RlIHNhbXBsZSBzZWUgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL2FibHkvcXVpY2tzdGFydC1qc1xyXG4gICAgY29uc3Qgc2VydmVyID0gbmV3IGFibHkuUmVhbHRpbWUuUHJvbWlzZShBUElfS0VZKTtcclxuXHJcbiAgICBhd2FpdCBzZXJ2ZXIuY29ubmVjdGlvbi5vbmNlKFwiY29ubmVjdGVkXCIpO1xyXG4gICAgY29uc29sZS5sb2coXCJDb25uZWN0ZWQgdG8gQWJseSFcIik7XHJcblxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgKCkgPT4gYWJseS5jbG9zZSgpKTtcclxuXHJcbiAgICByZXR1cm4gc2VydmVyO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgY3JlYXRlQ2hhbm5lbChjaGFubmVsTmFtZSkge1xyXG4gICAgdGhpcy5jaGFubmVsID0gdGhpcy5zZXJ2ZXIuY2hhbm5lbHMuZ2V0KGNoYW5uZWxOYW1lKTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLmNoYW5uZWwuc3Vic2NyaWJlKG1lc3NhZ2VzLm1vdmUsIChtZXNzYWdlKSA9PlxyXG4gICAgICB0aGlzLm9uU2VydmVyTWVzc2FnZShtZXNzYWdlKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIG1ha2VNb3ZlKGRhdGEpIHtcclxuICAgIGF3YWl0IHRoaXMuY2hhbm5lbC5wdWJsaXNoKG1lc3NhZ2VzLm1vdmUsIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBzZXJ2ZXIgPSBuZXcgU2VydmVyKCk7XHJcbiIsImV4cG9ydCBjbGFzcyBWaWV3IHtcclxuICBhbGxDZWxsc0Z1bGwgPSAwO1xyXG4gIGNlbGxzID0gW107XHJcblxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMucGFyZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwYXJlbnRcIik7XHJcblxyXG4gICAgY29uc3QgdGljVGFjVG9lRGl2ID0gdGhpcy5jcmVhdGVEaXYoXCJ0aWN0YWN0b2VEaXZcIik7XHJcbiAgICB0aGlzLnBhcmVudC5hcHBlbmRDaGlsZCh0aWNUYWNUb2VEaXYpO1xyXG5cclxuICAgIHRoaXMuYnV0dG9uVG9waWMgPSB0aGlzLmNyZWF0ZUJ1dHRvbihcImJ1dHRvblRvcGljXCIpO1xyXG4gICAgdGljVGFjVG9lRGl2LmFwcGVuZENoaWxkKHRoaXMuYnV0dG9uVG9waWMpO1xyXG5cclxuICAgIGNvbnN0IHBsYXllckRpdiA9IHRoaXMuY3JlYXRlRGl2KFwicGxheWVyRGl2XCIpO1xyXG4gICAgdGljVGFjVG9lRGl2LmFwcGVuZENoaWxkKHBsYXllckRpdik7XHJcblxyXG4gICAgdGhpcy5wbGF5ZXIgPSB0aGlzLmNyZWF0ZURpdihcInBsYXllclwiKTtcclxuICAgIHRoaXMucGxheWVyLmlubmVySFRNTCA9IFwiWCBUdXJuXCI7XHJcbiAgICBwbGF5ZXJEaXYuYXBwZW5kQ2hpbGQodGhpcy5wbGF5ZXIpO1xyXG5cclxuICAgIHRoaXMuY29tbWVudHMgPSB0aGlzLmNyZWF0ZURpdihcInBsYXllclBcIik7XHJcbiAgICBwbGF5ZXJEaXYuYXBwZW5kQ2hpbGQodGhpcy5jb21tZW50cyk7XHJcblxyXG4gICAgY29uc3QgY2VsbERpdiA9IHRoaXMuY3JlYXRlRGl2KFwiY2VsbERpdlwiKTtcclxuICAgIHRpY1RhY1RvZURpdi5hcHBlbmRDaGlsZChjZWxsRGl2KTtcclxuXHJcbiAgICB0aGlzLmNyZWF0ZUNlbGxzKGNlbGxEaXYpO1xyXG5cclxuICAgIC8vIHRoaXMuYnV0dG9uUGxheUFnYWluID0gdGhpcy5jcmVhdGVCdXR0b24oXCJidXR0b25cIik7XHJcbiAgICAvLyB0aWNUYWNUb2VEaXYuYXBwZW5kQ2hpbGQodGhpcy5idXR0b25QbGF5QWdhaW4pO1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlRGl2KGNsYXNzTmFtZSkge1xyXG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgIGRpdi5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIGRpdjtcclxuICB9XHJcblxyXG4gIGNyZWF0ZUNlbGxzKGNlbGxzRGl2KSB7XHJcbiAgICBmb3IgKGxldCBjZWxsTnVtID0gMDsgY2VsbE51bSA8IDk7IGNlbGxOdW0rKykge1xyXG4gICAgICBjb25zdCBjZWxsID0gdGhpcy5jcmVhdGVCdXR0b24oXCJjZWxsIGZ1bGxcIik7XHJcblxyXG4gICAgICBjZWxsLm9uY2xpY2sgPSAoKSA9PiB0aGlzLm9uQ2VsbFByZXNzKGNlbGwpO1xyXG5cclxuICAgICAgY2VsbHNEaXYuYXBwZW5kQ2hpbGQoY2VsbCk7XHJcblxyXG4gICAgICB0aGlzLmNlbGxzLnB1c2goY2VsbCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjcmVhdGVCdXR0b24oY2xhc3NOYW1lLCBvbmNsaWNrKSB7XHJcbiAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xyXG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuXHJcbiAgICByZXR1cm4gYnV0dG9uO1xyXG4gIH1cclxuXHJcbiAgc2V0U3R5bGUoc3R5bGUpIHtcclxuICAgIGlmIChzdHlsZSA9PT0gXCJkYXJrXCIpIHtcclxuICAgICAgdGhpcy5wYXJlbnQuY2xhc3NMaXN0LmFkZChcImRhcmtcIik7XHJcbiAgICB9IGVsc2UgaWYgKHN0eWxlID09PSBcImxpZ2h0XCIpIHtcclxuICAgICAgdGhpcy5wYXJlbnQuY2xhc3NMaXN0LnJlbW92ZShcImRhcmtcIik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1cGRhdGVDZWxsKGNlbGwsIHN0ZXApIHtcclxuICAgIGlmIChzdGVwID09PSBcInhcIikge1xyXG4gICAgICBjZWxsLmNsYXNzTGlzdC5hZGQoXCJ4XCIsIFwiZW1wdHlcIiwgXCJzdGVwWFwiKTtcclxuICAgICAgY2VsbC5jbGFzc0xpc3QucmVtb3ZlKFwiZnVsbFwiKTtcclxuICAgICAgdGhpcy5wbGF5ZXIuaW5uZXJIVE1MID0gXCJPIFR1cm5cIjtcclxuICAgIH0gZWxzZSBpZiAoc3RlcCA9PT0gXCJvXCIpIHtcclxuICAgICAgY2VsbC5jbGFzc0xpc3QuYWRkKFwib1wiLCBcImVtcHR5XCIsIFwic3RlcE9cIik7XHJcbiAgICAgIGNlbGwuY2xhc3NMaXN0LnJlbW92ZShcImNlbGxXYWl0XCIsIFwiZnVsbFwiKTtcclxuXHJcbiAgICAgIHRoaXMucGxheWVyLmlubmVySFRNTCA9IFwiWCBUdXJuXCI7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXRXaW4od2luU3ltYm9sKSB7XHJcbiAgICBpZiAod2luU3ltYm9sID09PSBcInhcIikge1xyXG4gICAgICB0aGlzLnBsYXllci5pbm5lckhUTUwgPSBgWCBXb24hYDtcclxuICAgICAgdGhpcy5wYXJlbnQuY2xhc3NMaXN0LmFkZChcIndpblwiKTtcclxuICAgICAgdGhpcy5jb21tZW50cy5pbm5lckhUTUwgPSBcIk5leHQgdHVybiBPXCI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHdpblN5bWJvbCA9PT0gXCJvXCIpIHtcclxuICAgICAgdGhpcy5wbGF5ZXIuaW5uZXJIVE1MID0gXCJPIFdvbiFcIjtcclxuICAgICAgdGhpcy5wYXJlbnQuY2xhc3NMaXN0LmFkZChcIndpblwiKTtcclxuICAgICAgdGhpcy5jb21tZW50cy5pbm5lckhUTUwgPSBcIk5leHQgdHVybiBYXCI7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXREcmF3KG5leHRUdXJuKSB7XHJcbiAgICB0aGlzLnBsYXllci5pbm5lckhUTUwgPSBcIkRyYXchXCI7XHJcbiAgICB0aGlzLnBhcmVudC5jbGFzc0xpc3QuYWRkKFwiZHJhd1wiKTtcclxuXHJcbiAgICBpZiAobmV4dFR1cm4gPT09IFwieFwiKSB7XHJcbiAgICAgIHRoaXMuY29tbWVudHMuaW5uZXJIVE1MID0gXCJOZXh0IHR1cm4gWFwiO1xyXG4gICAgfSBlbHNlIGlmIChuZXh0VHVybiA9PT0gXCJvXCIpIHtcclxuICAgICAgdGhpcy5jb21tZW50cy5pbm5lckhUTUwgPSBcIk5leHQgdHVybiBPXCI7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjbGVhckNlbGxzKG5leHRUdXJuKSB7XHJcbiAgICBmb3IgKGNvbnN0IGNlbGwgb2YgdGhpcy5jZWxscykge1xyXG4gICAgICBjZWxsLmNsYXNzTGlzdC5hZGQoXCJmdWxsXCIpO1xyXG4gICAgICBjZWxsLmNsYXNzTGlzdC5yZW1vdmUoXCJvXCIsIFwieFwiLCBcInN0ZXBYXCIsIFwic3RlcE9cIiwgXCJlbXB0eVwiKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobmV4dFR1cm4gPT09IFwieFwiKSB7XHJcbiAgICAgIHRoaXMucGxheWVyLmlubmVySFRNTCA9IFwiWCBUdXJuXCI7XHJcbiAgICB9IGVsc2UgaWYgKG5leHRUdXJuID09PSBcIm9cIikge1xyXG4gICAgICB0aGlzLnBsYXllci5pbm5lckhUTUwgPSBcIk8gVHVyblwiO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucGFyZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJ3aW5cIiwgXCJkcmF3XCIpO1xyXG4gICAgdGhpcy5jb21tZW50cy5pbm5lckhUTUwgPSBcIlwiO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiY2xlYXJcIik7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgdmlldyA9IG5ldyBWaWV3KCk7XHJcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgeyBzZXJ2ZXIgfSBmcm9tIFwiLi9zZXJ2ZXJcIjtcclxuaW1wb3J0IHsgdmlldyB9IGZyb20gXCIuL3ZpZXdcIjtcclxuXHJcbmNsYXNzIENvbnRyb2xsZXIge1xyXG4gICAgc3R5bGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInN0eWxlXCIpID8/IFwibGlnaHRcIjtcclxuICAgIHN0ZXAgPSBcInhcIjtcclxuICAgIGNlbGxzRGF0YSA9IFtcImVtcHR5XCIsIFwiZW1wdHlcIiwgXCJlbXB0eVwiLCBcImVtcHR5XCIsIFwiZW1wdHlcIiwgXCJlbXB0eVwiLCBcImVtcHR5XCIsIFwiZW1wdHlcIiwgXCJlbXB0eVwiXTtcclxuICAgIGNlbGxzID0gdmlldy5jZWxscztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzZXJ2ZXIuaW5pdCgpO1xyXG5cclxuICAgICAgICBzZXJ2ZXIub25TZXJ2ZXJNZXNzYWdlID0gKG1lc3NhZ2UpID0+IHRoaXMub25TZXJ2ZXJNZXNzYWdlKG1lc3NhZ2UpO1xyXG5cclxuICAgICAgICB2aWV3LnNldFN0eWxlKHRoaXMuc3R5bGUpO1xyXG5cclxuICAgICAgICB2aWV3LmJ1dHRvblRvcGljLm9uY2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlID09PSBcImxpZ2h0XCIpIHtcclxuICAgICAgICAgICAgICAgIHZpZXcuc2V0U3R5bGUoXCJkYXJrXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZSA9IFwiZGFya1wiO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmlldy5zZXRTdHlsZShcImxpZ2h0XCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZSA9IFwibGlnaHRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB2aWV3LnNldFN0eWxlKHRoaXMuc3R5bGUgPT09IFwibGlnaHRcIiA/IFwiZGFya1wiIDogXCJsaWdodFwiKTtcclxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJzdHlsZVwiLCB0aGlzLnN0eWxlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyB2aWV3LmJ1dHRvblBsYXlBZ2Fpbi5vbmNsaWNrID0gKCkgPT4gdGhpcy5yZXNldEdhbWUoKTtcclxuXHJcbiAgICAgICAgdmlldy5vbkNlbGxQcmVzcyA9IChjZWxsKSA9PiB0aGlzLm9uQ2VsbFByZXNzKGNlbGwpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc2V0R2FtZSgpIHtcclxuICAgICAgICB0aGlzLmNlbGxzRGF0YS5maWxsKFwiZW1wdHlcIik7XHJcbiAgICAgICAgdmlldy5jbGVhckNlbGxzKHRoaXMuc3RlcCk7XHJcbiAgICB9XHJcblxyXG4gICAgb25TZXJ2ZXJNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpO1xyXG5cclxuICAgICAgICB0aGlzLnN0ZXAgPSBkYXRhLnN0ZXA7XHJcbiAgICAgICAgdGhpcy5jZWxsID0gdGhpcy5jZWxsc1tkYXRhLmNlbGxdO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5zdGVwID09PSBcInhcIiAmJiB0aGlzLmNlbGxzRGF0YVtkYXRhLmNlbGxdID09PSBcImVtcHR5XCIpIHtcclxuICAgICAgICAgICAgdmlldy51cGRhdGVDZWxsKHRoaXMuY2VsbHNbZGF0YS5jZWxsXSwgdGhpcy5zdGVwKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY2VsbHNEYXRhW2RhdGEuY2VsbF0gPSBcInhcIjtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RlcCA9IFwib1wiO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGVwID09PSBcIm9cIiAmJiB0aGlzLmNlbGxzRGF0YVtkYXRhLmNlbGxdID09PSBcImVtcHR5XCIpIHtcclxuICAgICAgICAgICAgdmlldy51cGRhdGVDZWxsKHRoaXMuY2VsbHNbZGF0YS5jZWxsXSwgdGhpcy5zdGVwKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY2VsbHNEYXRhW2RhdGEuY2VsbF0gPSBcIm9cIjtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RlcCA9IFwieFwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jaGVja0RyYXcoKTtcclxuICAgICAgICB0aGlzLmNoZWNrV2luKCk7XHJcbiAgICB9XHJcblxyXG4gICAgb25DZWxsUHJlc3MoY2VsbCkge1xyXG4gICAgICAgIHNlcnZlci5tYWtlTW92ZSh7XHJcbiAgICAgICAgICAgIGNlbGw6IHRoaXMuY2VsbHMuaW5kZXhPZihjZWxsKSxcclxuICAgICAgICAgICAgc3RlcDogdGhpcy5zdGVwLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNoZWNrV2luKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNoZWNrV2lubmluZ1Bvc2l0aW9ucyhcInhcIikpIHtcclxuICAgICAgICAgICAgdmlldy5zZXRXaW4oXCJ4XCIpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jZWxsc0RhdGEuZmlsbChcImZ1bGxcIik7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuc3RlcCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVzZXRHYW1lKCksIDUwMDApO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ3aW4hIVhcIik7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNoZWNrV2lubmluZ1Bvc2l0aW9ucyhcIm9cIikpIHtcclxuICAgICAgICAgICAgdmlldy5zZXRXaW4oXCJvXCIpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jZWxsc0RhdGEuZmlsbChcImZ1bGxcIik7XHJcblxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVzZXRHYW1lKCksIDUwMDApO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ3aW4hIU9cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNoZWNrV2lubmluZ1Bvc2l0aW9ucyh3aW5uaW5nTWFyaykge1xyXG4gICAgICAgIGxldCB3aW5uaW5nUG9zaXRpb25zID0gW1xyXG4gICAgICAgICAgICBbMCwgMSwgMl0sXHJcbiAgICAgICAgICAgIFszLCA0LCA1XSxcclxuICAgICAgICAgICAgWzYsIDcsIDhdLFxyXG4gICAgICAgICAgICBbMCwgMywgNl0sXHJcbiAgICAgICAgICAgIFsxLCA0LCA3XSxcclxuICAgICAgICAgICAgWzIsIDUsIDhdLFxyXG4gICAgICAgICAgICBbMCwgNCwgOF0sXHJcbiAgICAgICAgICAgIFsyLCA0LCA2XSxcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpbm5pbmdQb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgW3BvczEsIHBvczIsIHBvczNdID0gd2lubmluZ1Bvc2l0aW9uc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIHRoaXMuY2VsbHNEYXRhW3BvczFdID09PSB3aW5uaW5nTWFyayAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jZWxsc0RhdGFbcG9zMl0gPT09IHdpbm5pbmdNYXJrICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxzRGF0YVtwb3MzXSA9PT0gd2lubmluZ01hcmtcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNoZWNrRHJhdygpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2VsbHNEYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNlbGxzRGF0YVtpXSAhPT0gXCJ4XCIgJiYgdGhpcy5jZWxsc0RhdGFbaV0gIT09IFwib1wiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJEUkFXXCIpO1xyXG5cclxuICAgICAgICB2aWV3LnNldERyYXcodGhpcy5zdGVwKTtcclxuXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlc2V0R2FtZSgpLCA1MDAwKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlcigpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==