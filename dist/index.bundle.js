/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/ably/build/ably-commonjs.js":
/*!**************************************************!*\
  !*** ./node_modules/ably/build/ably-commonjs.js ***!
  \**************************************************/
/***/ ((module) => {

/*!
 * @license Copyright 2015-2022 Ably Real-time Ltd (ably.com)
 * 
 * Ably JavaScript Library v1.2.43
 * https://github.com/ably/ably-js
 * 
 * Released under the Apache Licence v2.0
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_723__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_723__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_723__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_723__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_723__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_723__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_723__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__nested_webpack_require_723__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __nested_webpack_require_723__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__nested_webpack_require_723__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_723__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_723__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_723__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_723__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_723__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_723__(__nested_webpack_require_723__.s = 42);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_4200__) {

"use strict";
__nested_webpack_require_4200__.r(__nested_webpack_exports__);
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__spreadArray", function() { return __spreadArray; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}


/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_19043__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.allToUpperCase = exports.allToLowerCase = exports.encodeBody = exports.decodeBody = exports.Format = exports.promisify = exports.trim = exports.arrChooseN = exports.randomHexString = exports.randomString = exports.cheapRandStr = exports.dataSizeBytes = exports.inspectBody = exports.inspectError = exports.isErrorInfoOrPartialErrorInfo = exports.now = exports.parseQueryString = exports.toQueryString = exports.arrPopRandomElement = exports.defaultPostHeaders = exports.defaultGetHeaders = exports.allSame = exports.arrEvery = exports.arrFilter = exports.arrMap = exports.safeArrForEach = exports.arrForEach = exports.forInOwnNonNullProperties = exports.valuesArray = exports.keysArray = exports.arrWithoutValue = exports.arrDeleteValue = exports.arrIn = exports.arrIndexOf = exports.arrSubtract = exports.arrIntersectOb = exports.arrIntersect = exports.intersect = exports.containsValue = exports.inherits = exports.prototypicalClone = exports.shallowClone = exports.isEmptyArg = exports.isOnlyPropIn = exports.isEmpty = exports.isObject = exports.ensureArray = exports.isArray = exports.copy = exports.mixin = void 0;
exports.toBase64 = exports.matchDerivedChannel = exports.shallowEquals = exports.getGlobalObject = exports.getRetryTime = exports.getJitterCoefficient = exports.getBackoffCoefficient = void 0;
var tslib_1 = __nested_webpack_require_19043__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_19043__(3));
var defaults_1 = tslib_1.__importStar(__nested_webpack_require_19043__(8));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_19043__(4));
var enc_base64_1 = __nested_webpack_require_19043__(11);
var enc_utf8_1 = __nested_webpack_require_19043__(31);
function randomPosn(arrOrStr) {
    return Math.floor(Math.random() * arrOrStr.length);
}
/*
 * Add a set of properties to a target object
 * target: the target object
 * props:  an object whose enumerable properties are
 *         added, by reference only
 */
function mixin(target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < args.length; i++) {
        var source = args[i];
        if (!source) {
            break;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        for (var key in source) {
            if (!hasOwnProperty || hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }
    return target;
}
exports.mixin = mixin;
/*
 * Add a set of properties to a target object
 * target: the target object
 * props:  an object whose enumerable properties are
 *         added, by reference only
 */
function copy(src) {
    return mixin({}, src);
}
exports.copy = copy;
/*
 * Determine whether or not a given object is
 * an array.
 */
exports.isArray = Array.isArray ||
    function (value) {
        return Object.prototype.toString.call(value) == '[object Array]';
    };
/*
 * Ensures that an Array object is always returned
 * returning the original Array of obj is an Array
 * else wrapping the obj in a single element Array
 */
function ensureArray(obj) {
    if (isEmptyArg(obj)) {
        return [];
    }
    if ((0, exports.isArray)(obj)) {
        return obj;
    }
    return [obj];
}
exports.ensureArray = ensureArray;
function isObject(ob) {
    return Object.prototype.toString.call(ob) == '[object Object]';
}
exports.isObject = isObject;
/*
 * Determine whether or not an object contains
 * any enumerable properties.
 * ob: the object
 */
function isEmpty(ob) {
    for (var prop in ob)
        return false;
    return true;
}
exports.isEmpty = isEmpty;
function isOnlyPropIn(ob, property) {
    for (var prop in ob) {
        if (prop !== property) {
            return false;
        }
    }
    return true;
}
exports.isOnlyPropIn = isOnlyPropIn;
/*
 * Determine whether or not an argument to an overloaded function is
 * undefined (missing) or null.
 * This method is useful when constructing functions such as (WebIDL terminology):
 *   off([TreatUndefinedAs=Null] DOMString? event)
 * as you can then confirm the argument using:
 *   Utils.isEmptyArg(event)
 */
function isEmptyArg(arg) {
    return arg === null || arg === undefined;
}
exports.isEmptyArg = isEmptyArg;
/*
 * Perform a simple shallow clone of an object.
 * Result is an object irrespective of whether
 * the input is an object or array. All
 * enumerable properties are copied.
 * ob: the object
 */
function shallowClone(ob) {
    var result = new Object();
    for (var prop in ob)
        result[prop] = ob[prop];
    return result;
}
exports.shallowClone = shallowClone;
/*
 * Clone an object by creating a new object with the
 * given object as its prototype. Optionally
 * a set of additional own properties can be
 * supplied to be added to the newly created clone.
 * ob:            the object to be cloned
 * ownProperties: optional object with additional
 *                properties to add
 */
function prototypicalClone(ob, ownProperties) {
    var F = /** @class */ (function () {
        function F() {
        }
        return F;
    }());
    F.prototype = ob;
    var result = new F();
    if (ownProperties)
        mixin(result, ownProperties);
    return result;
}
exports.prototypicalClone = prototypicalClone;
/*
 * Declare a constructor to represent a subclass
 * of another constructor
 * If platform has a built-in version we use that from Platform, else we
 * define here (so can make use of other Utils fns)
 * See node.js util.inherits
 */
var inherits = function (ctor, superCtor) {
    if (platform_1.default.Config.inherits) {
        platform_1.default.Config.inherits(ctor, superCtor);
        return;
    }
    ctor.super_ = superCtor;
    ctor.prototype = prototypicalClone(superCtor.prototype, { constructor: ctor });
};
exports.inherits = inherits;
/*
 * Determine whether or not an object has an enumerable
 * property whose value equals a given value.
 * ob:  the object
 * val: the value to find
 */
function containsValue(ob, val) {
    for (var i in ob) {
        if (ob[i] == val)
            return true;
    }
    return false;
}
exports.containsValue = containsValue;
function intersect(arr, ob) {
    return (0, exports.isArray)(ob) ? arrIntersect(arr, ob) : arrIntersectOb(arr, ob);
}
exports.intersect = intersect;
function arrIntersect(arr1, arr2) {
    var result = [];
    for (var i = 0; i < arr1.length; i++) {
        var member = arr1[i];
        if ((0, exports.arrIndexOf)(arr2, member) != -1)
            result.push(member);
    }
    return result;
}
exports.arrIntersect = arrIntersect;
function arrIntersectOb(arr, ob) {
    var result = [];
    for (var i = 0; i < arr.length; i++) {
        var member = arr[i];
        if (member in ob)
            result.push(member);
    }
    return result;
}
exports.arrIntersectOb = arrIntersectOb;
function arrSubtract(arr1, arr2) {
    var result = [];
    for (var i = 0; i < arr1.length; i++) {
        var element = arr1[i];
        if ((0, exports.arrIndexOf)(arr2, element) == -1)
            result.push(element);
    }
    return result;
}
exports.arrSubtract = arrSubtract;
exports.arrIndexOf = Array.prototype.indexOf
    ? function (arr, elem, fromIndex) {
        return arr.indexOf(elem, fromIndex);
    }
    : function (arr, elem, fromIndex) {
        fromIndex = fromIndex || 0;
        var len = arr.length;
        for (; fromIndex < len; fromIndex++) {
            if (arr[fromIndex] === elem) {
                return fromIndex;
            }
        }
        return -1;
    };
function arrIn(arr, val) {
    return (0, exports.arrIndexOf)(arr, val) !== -1;
}
exports.arrIn = arrIn;
function arrDeleteValue(arr, val) {
    var idx = (0, exports.arrIndexOf)(arr, val);
    var res = idx != -1;
    if (res)
        arr.splice(idx, 1);
    return res;
}
exports.arrDeleteValue = arrDeleteValue;
function arrWithoutValue(arr, val) {
    var newArr = arr.slice();
    arrDeleteValue(newArr, val);
    return newArr;
}
exports.arrWithoutValue = arrWithoutValue;
/*
 * Construct an array of the keys of the enumerable
 * properties of a given object, optionally limited
 * to only the own properties.
 * ob:      the object
 * ownOnly: boolean, get own properties only
 */
function keysArray(ob, ownOnly) {
    var result = [];
    for (var prop in ob) {
        if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))
            continue;
        result.push(prop);
    }
    return result;
}
exports.keysArray = keysArray;
/*
 * Construct an array of the values of the enumerable
 * properties of a given object, optionally limited
 * to only the own properties.
 * ob:      the object
 * ownOnly: boolean, get own properties only
 */
function valuesArray(ob, ownOnly) {
    var result = [];
    for (var prop in ob) {
        if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))
            continue;
        result.push(ob[prop]);
    }
    return result;
}
exports.valuesArray = valuesArray;
function forInOwnNonNullProperties(ob, fn) {
    for (var prop in ob) {
        if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {
            fn(prop);
        }
    }
}
exports.forInOwnNonNullProperties = forInOwnNonNullProperties;
exports.arrForEach = Array.prototype.forEach
    ? function (arr, fn) {
        arr.forEach(fn);
    }
    : function (arr, fn) {
        var len = arr.length;
        for (var i = 0; i < len; i++) {
            fn(arr[i], i, arr);
        }
    };
/* Useful when the function may mutate the array */
function safeArrForEach(arr, fn) {
    return (0, exports.arrForEach)(arr.slice(), fn);
}
exports.safeArrForEach = safeArrForEach;
exports.arrMap = Array.prototype.map
    ? function (arr, fn) {
        return arr.map(fn);
    }
    : function (arr, fn) {
        var result = [];
        var len = arr.length;
        for (var i = 0; i < len; i++) {
            result.push(fn(arr[i], i, arr));
        }
        return result;
    };
exports.arrFilter = Array.prototype.filter
    ? function (arr, fn) {
        return arr.filter(fn);
    }
    : function (arr, fn) {
        var result = [], len = arr.length;
        for (var i = 0; i < len; i++) {
            if (fn(arr[i])) {
                result.push(arr[i]);
            }
        }
        return result;
    };
exports.arrEvery = Array.prototype.every
    ? function (arr, fn) {
        return arr.every(fn);
    }
    : function (arr, fn) {
        var len = arr.length;
        for (var i = 0; i < len; i++) {
            if (!fn(arr[i], i, arr)) {
                return false;
            }
        }
        return true;
    };
function allSame(arr, prop) {
    if (arr.length === 0) {
        return true;
    }
    var first = arr[0][prop];
    return (0, exports.arrEvery)(arr, function (item) {
        return item[prop] === first;
    });
}
exports.allSame = allSame;
var contentTypes = {
    json: 'application/json',
    jsonp: 'application/javascript',
    xml: 'application/xml',
    html: 'text/html',
    msgpack: 'application/x-msgpack',
};
function defaultGetHeaders(options, format) {
    var accept = contentTypes[format || Format.json];
    return {
        accept: accept,
        'X-Ably-Version': defaults_1.default.protocolVersion.toString(),
        'Ably-Agent': (0, defaults_1.getAgentString)(options),
    };
}
exports.defaultGetHeaders = defaultGetHeaders;
function defaultPostHeaders(options, format) {
    var contentType;
    var accept = (contentType = contentTypes[format || Format.json]);
    return {
        accept: accept,
        'content-type': contentType,
        'X-Ably-Version': defaults_1.default.protocolVersion.toString(),
        'Ably-Agent': (0, defaults_1.getAgentString)(options),
    };
}
exports.defaultPostHeaders = defaultPostHeaders;
function arrPopRandomElement(arr) {
    return arr.splice(randomPosn(arr), 1)[0];
}
exports.arrPopRandomElement = arrPopRandomElement;
function toQueryString(params) {
    var parts = [];
    if (params) {
        for (var key in params)
            parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));
    }
    return parts.length ? '?' + parts.join('&') : '';
}
exports.toQueryString = toQueryString;
function parseQueryString(query) {
    var match;
    var search = /([^?&=]+)=?([^&]*)/g;
    var result = {};
    while ((match = search.exec(query)))
        result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);
    return result;
}
exports.parseQueryString = parseQueryString;
exports.now = Date.now ||
    function () {
        /* IE 8 */
        return new Date().getTime();
    };
function isErrorInfoOrPartialErrorInfo(err) {
    return (typeof err == 'object' &&
        err !== null &&
        (err.constructor.name == 'ErrorInfo' || err.constructor.name == 'PartialErrorInfo'));
}
exports.isErrorInfoOrPartialErrorInfo = isErrorInfoOrPartialErrorInfo;
function inspectError(err) {
    var _a, _b;
    if (err instanceof Error ||
        ((_a = err === null || err === void 0 ? void 0 : err.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'ErrorInfo' ||
        ((_b = err === null || err === void 0 ? void 0 : err.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'PartialErrorInfo')
        return err.toString();
    return platform_1.default.Config.inspect(err);
}
exports.inspectError = inspectError;
function inspectBody(body) {
    if (platform_1.default.BufferUtils.isBuffer(body)) {
        return body.toString();
    }
    else if (typeof body === 'string') {
        return body;
    }
    else {
        return platform_1.default.Config.inspect(body);
    }
}
exports.inspectBody = inspectBody;
/* Data is assumed to be either a string or a buffer. */
function dataSizeBytes(data) {
    if (platform_1.default.BufferUtils.isBuffer(data)) {
        return platform_1.default.BufferUtils.byteLength(data);
    }
    if (typeof data === 'string') {
        return platform_1.default.Config.stringByteSize(data);
    }
    throw new Error('Expected input of Utils.dataSizeBytes to be a buffer or string, but was: ' + typeof data);
}
exports.dataSizeBytes = dataSizeBytes;
function cheapRandStr() {
    return String(Math.random()).substr(2);
}
exports.cheapRandStr = cheapRandStr;
/* Takes param the minimum number of bytes of entropy the string must
 * include, not the length of the string. String length produced is not
 * guaranteed. */
var randomString = function (numBytes) {
    if (platform_1.default.Config.getRandomValues && typeof Uint8Array !== 'undefined') {
        var uIntArr = new Uint8Array(numBytes);
        platform_1.default.Config.getRandomValues(uIntArr);
        return platform_1.default.BufferUtils.base64Encode(uIntArr);
    }
    /* Old browser; fall back to Math.random. Could just use a
     * CryptoJS version of the above, but want this to still work in nocrypto
     * versions of the library */
    var charset = platform_1.default.BufferUtils.base64CharSet;
    /* base64 has 33% overhead; round length up */
    var length = Math.round((numBytes * 4) / 3);
    var result = '';
    for (var i = 0; i < length; i++) {
        result += charset[randomPosn(charset)];
    }
    return result;
};
exports.randomString = randomString;
var randomHexString = function (numBytes) {
    if (platform_1.default.Config.getRandomValues && typeof Uint8Array !== 'undefined') {
        var uIntArr = new Uint8Array(numBytes);
        platform_1.default.Config.getRandomValues(uIntArr);
        return platform_1.default.BufferUtils.hexEncode(uIntArr);
    }
    var charset = platform_1.default.BufferUtils.hexCharSet;
    var length = numBytes * 2;
    var result = '';
    for (var i = 0; i < length; i++) {
        result += charset[randomPosn(charset)];
    }
    return result;
};
exports.randomHexString = randomHexString;
/* Pick n elements at random without replacement from an array */
function arrChooseN(arr, n) {
    var numItems = Math.min(n, arr.length), mutableArr = arr.slice(), result = [];
    for (var i = 0; i < numItems; i++) {
        result.push(arrPopRandomElement(mutableArr));
    }
    return result;
}
exports.arrChooseN = arrChooseN;
exports.trim = String.prototype.trim
    ? function (str) {
        return str.trim();
    }
    : function (str) {
        return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
    };
function promisify(ob, fnName, args) {
    return new Promise(function (resolve, reject) {
        ob[fnName].apply(ob, tslib_1.__spreadArray(tslib_1.__spreadArray([], args, false), [function (err, res) {
                err ? reject(err) : resolve(res);
            }], false));
    });
}
exports.promisify = promisify;
var Format;
(function (Format) {
    Format["msgpack"] = "msgpack";
    Format["json"] = "json";
})(Format = exports.Format || (exports.Format = {}));
function decodeBody(body, format) {
    return format == 'msgpack' ? platform_1.default.Config.msgpack.decode(body) : JSON.parse(String(body));
}
exports.decodeBody = decodeBody;
function encodeBody(body, format) {
    return format == 'msgpack' ? platform_1.default.Config.msgpack.encode(body, true) : JSON.stringify(body);
}
exports.encodeBody = encodeBody;
function allToLowerCase(arr) {
    return arr.map(function (element) {
        return element && element.toLowerCase();
    });
}
exports.allToLowerCase = allToLowerCase;
function allToUpperCase(arr) {
    return arr.map(function (element) {
        return element && element.toUpperCase();
    });
}
exports.allToUpperCase = allToUpperCase;
function getBackoffCoefficient(count) {
    return Math.min((count + 2) / 3, 2);
}
exports.getBackoffCoefficient = getBackoffCoefficient;
function getJitterCoefficient() {
    return 1 - Math.random() * 0.2;
}
exports.getJitterCoefficient = getJitterCoefficient;
/**
 *
 * @param initialTimeout initial timeout value
 * @param retryAttempt integer indicating retryAttempt
 * @returns RetryTimeout value for given timeout and retryAttempt.
 * If x is the value generated then,
 * Upper bound = min((retryAttempt + 2) / 3, 2) * initialTimeout,
 * Lower bound = 0.8 * Upper bound,
 * Lower bound < x < Upper bound
 */
function getRetryTime(initialTimeout, retryAttempt) {
    return initialTimeout * getBackoffCoefficient(retryAttempt) * getJitterCoefficient();
}
exports.getRetryTime = getRetryTime;
function getGlobalObject() {
    if (global) {
        return global;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    return self;
}
exports.getGlobalObject = getGlobalObject;
function shallowEquals(source, target) {
    return (Object.keys(source).every(function (key) { return source[key] === target[key]; }) &&
        Object.keys(target).every(function (key) { return target[key] === source[key]; }));
}
exports.shallowEquals = shallowEquals;
function matchDerivedChannel(name) {
    /**
     * This regex check is to retain existing channel params if any e.g [?rewind=1]foo to
     * [filter=xyz?rewind=1]foo. This is to keep channel compatibility around use of
     * channel params that work with derived channels.
     *
     * This eslint unsafe regex warning is triggered because the RegExp uses nested quantifiers,
     * but it does not create any situation where the regex engine has to
     * explore a large number of possible matches so it’s safe to ignore
     */
    var regex = /^(\[([^?]*)(?:(.*))\])?(.+)$/; // eslint-disable-line
    var match = name.match(regex);
    if (!match || !match.length || match.length < 5) {
        throw new errorinfo_1.default('regex match failed', 400, 40010);
    }
    // Fail if there is already a channel qualifier, eg [meta]foo should fail instead of just overriding with [filter=xyz]foo
    if (match[2]) {
        throw new errorinfo_1.default("cannot use a derived option with a ".concat(match[2], " channel"), 400, 40010);
    }
    // Return match values to be added to derive channel quantifier.
    return {
        qualifierParam: match[3] || '',
        channelName: match[4],
    };
}
exports.matchDerivedChannel = matchDerivedChannel;
function toBase64(str) {
    if (platform_1.default.Config.createHmac) {
        return Buffer.from(str, 'ascii').toString('base64');
    }
    return (0, enc_base64_1.stringify)((0, enc_utf8_1.parse)(str));
}
exports.toBase64 = toBase64;

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_19043__(13)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __nested_webpack_require_39587__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_39587__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_39587__(3));
// Workaround for salesforce lightning locker compatibility
// This is a shorthand version of Utils.getGlobalObject (which we can't use here without creating a circular import)
var globalObject = global || (typeof window !== 'undefined' ? window : self);
var LogLevels;
(function (LogLevels) {
    LogLevels[LogLevels["None"] = 0] = "None";
    LogLevels[LogLevels["Error"] = 1] = "Error";
    LogLevels[LogLevels["Major"] = 2] = "Major";
    LogLevels[LogLevels["Minor"] = 3] = "Minor";
    LogLevels[LogLevels["Micro"] = 4] = "Micro";
})(LogLevels || (LogLevels = {}));
function pad(timeSegment, three) {
    return "".concat(timeSegment).padStart(three ? 3 : 2, '0');
}
function getHandler(logger) {
    return platform_1.default.Config.logTimestamps
        ? function (msg) {
            var time = new Date();
            logger(pad(time.getHours()) +
                ':' +
                pad(time.getMinutes()) +
                ':' +
                pad(time.getSeconds()) +
                '.' +
                pad(time.getMilliseconds(), 1) +
                ' ' +
                msg);
        }
        : logger;
}
var getDefaultLoggers = function () {
    var _a, _b;
    var consoleLogger;
    var errorLogger;
    /* Can't just check for console && console.log; fails in IE <=9 */
    if ((typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') /* node */ ||
        typeof ((_b = (_a = globalObject === null || globalObject === void 0 ? void 0 : globalObject.console) === null || _a === void 0 ? void 0 : _a.log) === null || _b === void 0 ? void 0 : _b.apply) === 'function' /* sensible browsers */) {
        consoleLogger = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            console.log.apply(console, args);
        };
        errorLogger = console.warn
            ? function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                console.warn.apply(console, args);
            }
            : consoleLogger;
    }
    else if (globalObject === null || globalObject === void 0 ? void 0 : globalObject.console.log) {
        /* IE <= 9 with the console open -- console.log does not
         * inherit from Function, so has no apply method */
        consoleLogger = errorLogger = function () {
            Function.prototype.apply.call(console.log, console, arguments);
        };
    }
    else {
        /* IE <= 9 when dev tools are closed - window.console not even defined */
        consoleLogger = errorLogger = function () { };
    }
    return [consoleLogger, errorLogger].map(getHandler);
};
var Logger = /** @class */ (function () {
    function Logger() {
        Logger.logLevel = Logger.LOG_DEFAULT;
    }
    Logger.initLogHandlers = function () {
        var _a = getDefaultLoggers(), logHandler = _a[0], logErrorHandler = _a[1];
        this.logHandler = logHandler;
        this.logErrorHandler = logErrorHandler;
    };
    Logger.logLevel = LogLevels.Error; // default logLevel
    // public constants
    Logger.LOG_NONE = LogLevels.None;
    Logger.LOG_ERROR = LogLevels.Error;
    Logger.LOG_MAJOR = LogLevels.Major;
    Logger.LOG_MINOR = LogLevels.Minor;
    Logger.LOG_MICRO = LogLevels.Micro;
    // aliases
    Logger.LOG_DEFAULT = LogLevels.Error;
    Logger.LOG_DEBUG = LogLevels.Micro;
    /* public static functions */
    Logger.logAction = function (level, action, message) {
        if (Logger.shouldLog(level)) {
            (level === LogLevels.Error ? Logger.logErrorHandler : Logger.logHandler)('Ably: ' + action + ': ' + message);
        }
    };
    Logger.deprecated = function (original, replacement) {
        Logger.deprecatedWithMsg(original, "Please use '" + replacement + "' instead.");
    };
    Logger.deprecatedWithMsg = function (funcName, msg) {
        if (Logger.shouldLog(LogLevels.Error)) {
            Logger.logErrorHandler("Ably: Deprecation warning - '" + funcName + "' is deprecated and will be removed from a future version. " + msg);
        }
    };
    /* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent
         the object being serialised if the log level will not output the message */
    Logger.shouldLog = function (level) {
        return level <= Logger.logLevel;
    };
    Logger.setLog = function (level, handler) {
        if (level !== undefined)
            Logger.logLevel = level;
        if (handler !== undefined)
            Logger.logHandler = Logger.logErrorHandler = handler;
    };
    return Logger;
}());
exports.default = Logger;

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_39587__(13)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Platform = /** @class */ (function () {
    function Platform() {
    }
    return Platform;
}());
exports.default = Platform;


/***/ }),
/* 4 */
/***/ (function(module, exports, __nested_webpack_require_45001__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PartialErrorInfo = void 0;
var tslib_1 = __nested_webpack_require_45001__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_45001__(3));
var Utils = tslib_1.__importStar(__nested_webpack_require_45001__(1));
function toString(err) {
    var result = '[' + err.constructor.name;
    if (err.message)
        result += ': ' + err.message;
    if (err.statusCode)
        result += '; statusCode=' + err.statusCode;
    if (err.code)
        result += '; code=' + err.code;
    if (err.cause)
        result += '; cause=' + Utils.inspectError(err.cause);
    if (err.href && !(err.message && err.message.indexOf('help.ably.io') > -1))
        result += '; see ' + err.href + ' ';
    result += ']';
    return result;
}
var ErrorInfo = /** @class */ (function (_super) {
    tslib_1.__extends(ErrorInfo, _super);
    function ErrorInfo(message, code, statusCode, cause) {
        var _this = _super.call(this, message) || this;
        if (typeof Object.setPrototypeOf !== 'undefined') {
            Object.setPrototypeOf(_this, ErrorInfo.prototype);
        }
        _this.code = code;
        _this.statusCode = statusCode;
        _this.cause = cause;
        return _this;
    }
    ErrorInfo.prototype.toString = function () {
        return toString(this);
    };
    ErrorInfo.fromValues = function (values) {
        var _a = values, message = _a.message, code = _a.code, statusCode = _a.statusCode;
        if (typeof message !== 'string' || typeof code !== 'number' || typeof statusCode !== 'number') {
            throw new Error('ErrorInfo.fromValues(): invalid values: ' + platform_1.default.Config.inspect(values));
        }
        var result = Object.assign(new ErrorInfo(message, code, statusCode), values);
        if (result.code && !result.href) {
            result.href = 'https://help.ably.io/error/' + result.code;
        }
        return result;
    };
    return ErrorInfo;
}(Error));
exports.default = ErrorInfo;
var PartialErrorInfo = /** @class */ (function (_super) {
    tslib_1.__extends(PartialErrorInfo, _super);
    function PartialErrorInfo(message, code, statusCode, cause) {
        var _this = _super.call(this, message) || this;
        if (typeof Object.setPrototypeOf !== 'undefined') {
            Object.setPrototypeOf(_this, PartialErrorInfo.prototype);
        }
        _this.code = code;
        _this.statusCode = statusCode;
        _this.cause = cause;
        return _this;
    }
    PartialErrorInfo.prototype.toString = function () {
        return toString(this);
    };
    return PartialErrorInfo;
}(Error));
exports.PartialErrorInfo = PartialErrorInfo;


/***/ }),
/* 5 */
/***/ (function(module, exports, __nested_webpack_require_47756__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_47756__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));

/***/ }),
/* 6 */
/***/ (function(module, exports, __nested_webpack_require_49894__) {

/* WEBPACK VAR INJECTION */(function(global) {;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof global !== 'undefined' && global.crypto) {
	        crypto = global.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __nested_webpack_require_49894__(44);
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_49894__(13)))

/***/ }),
/* 7 */
/***/ (function(module, exports, __nested_webpack_require_73260__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_73260__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_73260__(1));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_73260__(2));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_73260__(3));
/* Call the listener, catch any exceptions and log, but continue operation*/
function callListener(eventThis, listener, args) {
    try {
        listener.apply(eventThis, args);
    }
    catch (e) {
        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'EventEmitter.emit()', 'Unexpected listener exception: ' + e + '; stack = ' + (e && e.stack));
    }
}
/**
 * Remove listeners that match listener
 * @param targetListeners is an array of listener arrays or event objects with arrays of listeners
 * @param listener the listener callback to remove
 * @param eventFilter (optional) event name instructing the function to only remove listeners for the specified event
 */
function removeListener(targetListeners, listener, eventFilter) {
    var listeners;
    var index;
    var eventName;
    for (var targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {
        listeners = targetListeners[targetListenersIndex];
        if (eventFilter) {
            listeners = listeners[eventFilter];
        }
        if (Utils.isArray(listeners)) {
            while ((index = Utils.arrIndexOf(listeners, listener)) !== -1) {
                listeners.splice(index, 1);
            }
            /* If events object has an event name key with no listeners then
                          remove the key to stop the list growing indefinitely */
            if (eventFilter && listeners.length === 0) {
                delete targetListeners[targetListenersIndex][eventFilter];
            }
        }
        else if (Utils.isObject(listeners)) {
            /* events */
            for (eventName in listeners) {
                if (Object.prototype.hasOwnProperty.call(listeners, eventName) && Utils.isArray(listeners[eventName])) {
                    removeListener([listeners], listener, eventName);
                }
            }
        }
    }
}
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        this.any = [];
        this.events = Object.create(null);
        this.anyOnce = [];
        this.eventsOnce = Object.create(null);
    }
    EventEmitter.prototype.on = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            var listener = args[0];
            if (typeof listener === 'function') {
                this.any.push(listener);
            }
            else {
                throw new Error('EventListener.on(): Invalid arguments: ' + platform_1.default.Config.inspect(args));
            }
        }
        if (args.length === 2) {
            var event_1 = args[0], listener_1 = args[1];
            if (typeof listener_1 !== 'function') {
                throw new Error('EventListener.on(): Invalid arguments: ' + platform_1.default.Config.inspect(args));
            }
            if (Utils.isEmptyArg(event_1)) {
                this.any.push(listener_1);
            }
            else if (Utils.isArray(event_1)) {
                event_1.forEach(function (eventName) {
                    _this.on(eventName, listener_1);
                });
            }
            else {
                if (typeof event_1 !== 'string') {
                    throw new Error('EventListener.on(): Invalid arguments: ' + platform_1.default.Config.inspect(args));
                }
                var listeners = this.events[event_1] || (this.events[event_1] = []);
                listeners.push(listener_1);
            }
        }
    };
    EventEmitter.prototype.off = function () {
        var _a;
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length == 0 || (Utils.isEmptyArg(args[0]) && Utils.isEmptyArg(args[1]))) {
            this.any = [];
            this.events = Object.create(null);
            this.anyOnce = [];
            this.eventsOnce = Object.create(null);
            return;
        }
        var firstArg = args[0], secondArg = args[1];
        var listener = null;
        var event = null;
        if (args.length === 1 || !secondArg) {
            if (typeof firstArg === 'function') {
                /* we take this to be the listener and treat the event as "any" .. */
                listener = firstArg;
            }
            else {
                event = firstArg;
            }
            /* ... or we take event to be the actual event name and listener to be all */
        }
        else {
            if (typeof secondArg !== 'function') {
                throw new Error('EventEmitter.off(): invalid arguments:' + platform_1.default.Config.inspect(args));
            }
            _a = [firstArg, secondArg], event = _a[0], listener = _a[1];
        }
        if (listener && Utils.isEmptyArg(event)) {
            removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);
            return;
        }
        if (Utils.isArray(event)) {
            event.forEach(function (eventName) {
                _this.off(eventName, listener);
            });
            return;
        }
        /* "normal" case where event is an actual event */
        if (typeof event !== 'string') {
            throw new Error('EventEmitter.off(): invalid arguments:' + platform_1.default.Config.inspect(args));
        }
        if (listener) {
            removeListener([this.events, this.eventsOnce], listener, event);
        }
        else {
            delete this.events[event];
            delete this.eventsOnce[event];
        }
    };
    /**
     * Get the array of listeners for a given event; excludes once events
     * @param event (optional) the name of the event, or none for 'any'
     * @return array of events, or null if none
     */
    EventEmitter.prototype.listeners = function (event) {
        if (event) {
            var listeners = this.events[event] || [];
            if (this.eventsOnce[event])
                Array.prototype.push.apply(listeners, this.eventsOnce[event]);
            return listeners.length ? listeners : null;
        }
        return this.any.length ? this.any : null;
    };
    /**
     * Emit an event
     * @param event the event name
     * @param args the arguments to pass to the listener
     */
    EventEmitter.prototype.emit = function (event) {
        var args = []; /* , args... */
        for (var _i = 1 /* , args... */; _i < arguments.length /* , args... */; _i++ /* , args... */) {
            args[_i - 1] = arguments[_i]; /* , args... */
        }
        var eventThis = { event: event };
        var listeners = [];
        if (this.anyOnce.length) {
            Array.prototype.push.apply(listeners, this.anyOnce);
            this.anyOnce = [];
        }
        if (this.any.length) {
            Array.prototype.push.apply(listeners, this.any);
        }
        var eventsOnceListeners = this.eventsOnce[event];
        if (eventsOnceListeners) {
            Array.prototype.push.apply(listeners, eventsOnceListeners);
            delete this.eventsOnce[event];
        }
        var eventsListeners = this.events[event];
        if (eventsListeners) {
            Array.prototype.push.apply(listeners, eventsListeners);
        }
        Utils.arrForEach(listeners, function (listener) {
            callListener(eventThis, listener, args);
        });
    };
    EventEmitter.prototype.once = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var argCount = args.length;
        if ((argCount === 0 || (argCount === 1 && typeof args[0] !== 'function')) && platform_1.default.Config.Promise) {
            var event_2 = args[0];
            return new platform_1.default.Config.Promise(function (resolve) {
                _this.once(event_2, resolve);
            });
        }
        var firstArg = args[0], secondArg = args[1];
        if (args.length === 1 && typeof firstArg === 'function') {
            this.anyOnce.push(firstArg);
        }
        else if (Utils.isEmptyArg(firstArg)) {
            if (typeof secondArg !== 'function') {
                throw new Error('EventEmitter.once(): Invalid arguments:' + platform_1.default.Config.inspect(args));
            }
            this.anyOnce.push(secondArg);
        }
        else if (Utils.isArray(firstArg)) {
            var self_1 = this;
            var listenerWrapper_1 = function () {
                var innerArgs = Array.prototype.slice.call(arguments);
                Utils.arrForEach(firstArg, function (eventName) {
                    self_1.off(eventName, listenerWrapper_1);
                });
                if (typeof secondArg !== 'function') {
                    throw new Error('EventEmitter.once(): Invalid arguments:' + platform_1.default.Config.inspect(args));
                }
                secondArg.apply(this, innerArgs);
            };
            Utils.arrForEach(firstArg, function (eventName) {
                self_1.on(eventName, listenerWrapper_1);
            });
        }
        else {
            if (typeof firstArg !== 'string') {
                throw new Error('EventEmitter.once(): Invalid arguments:' + platform_1.default.Config.inspect(args));
            }
            var listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);
            if (secondArg) {
                if (typeof secondArg !== 'function') {
                    throw new Error('EventEmitter.once(): Invalid arguments:' + platform_1.default.Config.inspect(args));
                }
                listeners.push(secondArg);
            }
        }
    };
    /**
     * Private API
     *
     * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState
     * @param targetState the name of the state event to listen to
     * @param currentState the name of the current state of this object
     * @param listener the listener to be called
     * @param listenerArgs
     */
    EventEmitter.prototype.whenState = function (targetState, currentState, listener) {
        var _this = this;
        var listenerArgs = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            listenerArgs[_i - 3] = arguments[_i];
        }
        var eventThis = { event: targetState };
        if (typeof targetState !== 'string' || typeof currentState !== 'string') {
            throw 'whenState requires a valid event String argument';
        }
        if (typeof listener !== 'function' && platform_1.default.Config.Promise) {
            return new platform_1.default.Config.Promise(function (resolve) {
                EventEmitter.prototype.whenState.apply(_this, [targetState, currentState, resolve].concat(listenerArgs));
            });
        }
        if (targetState === currentState) {
            callListener(eventThis, listener, listenerArgs);
        }
        else {
            this.once(targetState, listener);
        }
    };
    return EventEmitter;
}());
exports.default = EventEmitter;


/***/ }),
/* 8 */
/***/ (function(module, exports, __nested_webpack_require_84856__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaults = exports.normaliseOptions = exports.objectifyOptions = exports.getAgentString = exports.getHosts = exports.getFallbackHosts = exports.environmentFallbackHosts = exports.getHttpScheme = exports.getPort = exports.getHost = void 0;
var tslib_1 = __nested_webpack_require_84856__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_84856__(3));
var Utils = tslib_1.__importStar(__nested_webpack_require_84856__(1));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_84856__(2));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_84856__(4));
var package_json_1 = __nested_webpack_require_84856__(43);
var agent = 'ably-js/' + package_json_1.version;
var Defaults = {
    ENVIRONMENT: '',
    REST_HOST: 'rest.ably.io',
    REALTIME_HOST: 'realtime.ably.io',
    FALLBACK_HOSTS: [
        'A.ably-realtime.com',
        'B.ably-realtime.com',
        'C.ably-realtime.com',
        'D.ably-realtime.com',
        'E.ably-realtime.com',
    ],
    PORT: 80,
    TLS_PORT: 443,
    TIMEOUTS: {
        /* Documented as options params: */
        disconnectedRetryTimeout: 15000,
        suspendedRetryTimeout: 30000,
        /* Undocumented, but part of the api and can be used by customers: */
        httpRequestTimeout: 15000,
        channelRetryTimeout: 15000,
        fallbackRetryTimeout: 600000,
        /* For internal / test use only: */
        connectionStateTtl: 120000,
        realtimeRequestTimeout: 10000,
        recvTimeout: 90000,
        preferenceConnectTimeout: 6000,
        parallelUpgradeDelay: 6000,
    },
    httpMaxRetryCount: 3,
    maxMessageSize: 65536,
    version: package_json_1.version,
    protocolVersion: 2,
    agent: agent,
    getHost: getHost,
    getPort: getPort,
    getHttpScheme: getHttpScheme,
    environmentFallbackHosts: environmentFallbackHosts,
    getFallbackHosts: getFallbackHosts,
    getHosts: getHosts,
    checkHost: checkHost,
    objectifyOptions: objectifyOptions,
    normaliseOptions: normaliseOptions,
};
function getHost(options, host, ws) {
    if (ws)
        host = (host == options.restHost && options.realtimeHost) || host || options.realtimeHost;
    else
        host = host || options.restHost;
    return host;
}
exports.getHost = getHost;
function getPort(options, tls) {
    return tls || options.tls ? options.tlsPort : options.port;
}
exports.getPort = getPort;
function getHttpScheme(options) {
    return options.tls ? 'https://' : 'http://';
}
exports.getHttpScheme = getHttpScheme;
// construct environment fallback hosts as per RSC15i
function environmentFallbackHosts(environment) {
    return [
        environment + '-a-fallback.ably-realtime.com',
        environment + '-b-fallback.ably-realtime.com',
        environment + '-c-fallback.ably-realtime.com',
        environment + '-d-fallback.ably-realtime.com',
        environment + '-e-fallback.ably-realtime.com',
    ];
}
exports.environmentFallbackHosts = environmentFallbackHosts;
function getFallbackHosts(options) {
    var fallbackHosts = options.fallbackHosts, httpMaxRetryCount = typeof options.httpMaxRetryCount !== 'undefined' ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;
    return fallbackHosts ? Utils.arrChooseN(fallbackHosts, httpMaxRetryCount) : [];
}
exports.getFallbackHosts = getFallbackHosts;
function getHosts(options) {
    return [options.restHost].concat(getFallbackHosts(options));
}
exports.getHosts = getHosts;
function checkHost(host) {
    if (typeof host !== 'string') {
        throw new errorinfo_1.default('host must be a string; was a ' + typeof host, 40000, 400);
    }
    if (!host.length) {
        throw new errorinfo_1.default('host must not be zero-length', 40000, 400);
    }
}
function getRealtimeHost(options, production, environment) {
    if (options.realtimeHost)
        return options.realtimeHost;
    /* prefer setting realtimeHost to restHost as a custom restHost typically indicates
     * a development environment is being used that can't be inferred by the library */
    if (options.restHost) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Defaults.normaliseOptions', 'restHost is set to "' +
            options.restHost +
            '" but realtimeHost is not set, so setting realtimeHost to "' +
            options.restHost +
            '" too. If this is not what you want, please set realtimeHost explicitly.');
        return options.restHost;
    }
    return production ? Defaults.REALTIME_HOST : environment + '-' + Defaults.REALTIME_HOST;
}
function getTimeouts(options) {
    /* Allow values passed in options to override default timeouts */
    var timeouts = {};
    for (var prop in Defaults.TIMEOUTS) {
        timeouts[prop] = options[prop] || Defaults.TIMEOUTS[prop];
    }
    return timeouts;
}
function getAgentString(options) {
    var agentStr = Defaults.agent;
    if (options.agents) {
        for (var agent in options.agents) {
            agentStr += ' ' + agent + '/' + options.agents[agent];
        }
    }
    return agentStr;
}
exports.getAgentString = getAgentString;
function objectifyOptions(options) {
    if (typeof options == 'string') {
        return options.indexOf(':') == -1 ? { token: options } : { key: options };
    }
    return options;
}
exports.objectifyOptions = objectifyOptions;
function normaliseOptions(options) {
    /* Deprecated options */
    if (options.host) {
        logger_1.default.deprecated('host', 'restHost');
        options.restHost = options.host;
    }
    if (options.wsHost) {
        logger_1.default.deprecated('wsHost', 'realtimeHost');
        options.realtimeHost = options.wsHost;
    }
    if (options.queueEvents) {
        logger_1.default.deprecated('queueEvents', 'queueMessages');
        options.queueMessages = options.queueEvents;
    }
    if (options.fallbackHostsUseDefault) {
        /* fallbackHostsUseDefault and fallbackHosts are mutually exclusive as per TO3k7 */
        if (options.fallbackHosts) {
            var msg = 'fallbackHosts and fallbackHostsUseDefault cannot both be set';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Defaults.normaliseOptions', msg);
            throw new errorinfo_1.default(msg, 40000, 400);
        }
        /* default fallbacks can't be used with custom ports */
        if (options.port || options.tlsPort) {
            var msg = 'fallbackHostsUseDefault cannot be set when port or tlsPort are set';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Defaults.normaliseOptions', msg);
            throw new errorinfo_1.default(msg, 40000, 400);
        }
        /* emit an appropriate deprecation warning */
        if (options.environment) {
            logger_1.default.deprecatedWithMsg('fallbackHostsUseDefault', 'There is no longer a need to set this when the environment option is also set since the library will now generate the correct fallback hosts using the environment option.');
        }
        else {
            logger_1.default.deprecated('fallbackHostsUseDefault', 'fallbackHosts: Ably.Defaults.FALLBACK_HOSTS');
        }
        /* use the default fallback hosts as requested */
        options.fallbackHosts = Defaults.FALLBACK_HOSTS;
    }
    /* options.recover as a boolean is deprecated, and therefore is not part of the public typing */
    if (options.recover === true) {
        logger_1.default.deprecated('{recover: true}', '{recover: function(lastConnectionDetails, cb) { cb(true); }}');
        options.recover = function (lastConnectionDetails, cb) {
            cb(true);
        };
    }
    if (typeof options.recover === 'function' && options.closeOnUnload === true) {
        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Defaults.normaliseOptions', 'closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter');
        options.recover = undefined;
    }
    if (!('closeOnUnload' in options)) {
        /* Have closeOnUnload default to true unless we have any indication that
         * the user may want to recover the connection */
        options.closeOnUnload = !options.recover;
    }
    if (options.transports && Utils.arrIn(options.transports, 'xhr')) {
        logger_1.default.deprecated('transports: ["xhr"]', 'transports: ["xhr_streaming"]');
        Utils.arrDeleteValue(options.transports, 'xhr');
        options.transports.push('xhr_streaming');
    }
    if (!('queueMessages' in options))
        options.queueMessages = true;
    /* infer hosts and fallbacks based on the configured environment */
    var environment = (options.environment && String(options.environment).toLowerCase()) || Defaults.ENVIRONMENT;
    var production = !environment || environment === 'production';
    if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {
        options.fallbackHosts = production ? Defaults.FALLBACK_HOSTS : environmentFallbackHosts(environment);
    }
    var restHost = options.restHost || (production ? Defaults.REST_HOST : environment + '-' + Defaults.REST_HOST);
    var realtimeHost = getRealtimeHost(options, production, environment);
    Utils.arrForEach((options.fallbackHosts || []).concat(restHost, realtimeHost), checkHost);
    options.port = options.port || Defaults.PORT;
    options.tlsPort = options.tlsPort || Defaults.TLS_PORT;
    if (!('tls' in options))
        options.tls = true;
    var timeouts = getTimeouts(options);
    if ('useBinaryProtocol' in options) {
        options.useBinaryProtocol = platform_1.default.Config.supportsBinary && options.useBinaryProtocol;
    }
    else {
        options.useBinaryProtocol = platform_1.default.Config.preferBinary;
    }
    if (options.clientId) {
        var headers = (options.headers = options.headers || {});
        headers['X-Ably-ClientId'] = platform_1.default.BufferUtils.base64Encode(platform_1.default.BufferUtils.utf8Encode(options.clientId));
    }
    if (!('idempotentRestPublishing' in options)) {
        options.idempotentRestPublishing = true;
    }
    if (options.promises && !platform_1.default.Config.Promise) {
        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Defaults.normaliseOptions', '{promises: true} was specified, but no Promise constructor found; disabling promises');
        options.promises = false;
    }
    var connectivityCheckParams = null;
    var connectivityCheckUrl = options.connectivityCheckUrl;
    if (options.connectivityCheckUrl) {
        var _a = options.connectivityCheckUrl.split('?'), uri = _a[0], qs = _a[1];
        connectivityCheckParams = qs ? Utils.parseQueryString(qs) : {};
        if (uri.indexOf('://') === -1) {
            uri = 'https://' + uri;
        }
        connectivityCheckUrl = uri;
    }
    return tslib_1.__assign(tslib_1.__assign({}, options), { useBinaryProtocol: 'useBinaryProtocol' in options
            ? platform_1.default.Config.supportsBinary && options.useBinaryProtocol
            : platform_1.default.Config.preferBinary, realtimeHost: realtimeHost, restHost: restHost, maxMessageSize: options.maxMessageSize || Defaults.maxMessageSize, timeouts: timeouts, connectivityCheckParams: connectivityCheckParams, connectivityCheckUrl: connectivityCheckUrl });
}
exports.normaliseOptions = normaliseOptions;
exports.default = Defaults;
function getDefaults(platformDefaults) {
    return Object.assign(Defaults, platformDefaults);
}
exports.getDefaults = getDefaults;


/***/ }),
/* 9 */
/***/ (function(module, exports, __nested_webpack_require_96442__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_96442__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_96442__(3));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_96442__(2));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_96442__(4));
var Utils = tslib_1.__importStar(__nested_webpack_require_96442__(1));
function normaliseContext(context) {
    if (!context || !context.channelOptions) {
        return {
            channelOptions: context,
            plugins: {},
            baseEncodedPreviousPayload: undefined,
        };
    }
    return context;
}
function normalizeCipherOptions(options) {
    if (options && options.cipher) {
        if (!platform_1.default.Crypto)
            throw new Error('Encryption not enabled; use ably.encryption.js instead');
        var cipher = platform_1.default.Crypto.getCipher(options.cipher);
        return {
            cipher: cipher.cipherParams,
            channelCipher: cipher.cipher,
        };
    }
    return options !== null && options !== void 0 ? options : {};
}
function getMessageSize(msg) {
    var size = 0;
    if (msg.name) {
        size += msg.name.length;
    }
    if (msg.clientId) {
        size += msg.clientId.length;
    }
    if (msg.extras) {
        size += JSON.stringify(msg.extras).length;
    }
    if (msg.data) {
        size += Utils.dataSizeBytes(msg.data);
    }
    return size;
}
var Message = /** @class */ (function () {
    function Message() {
    }
    /**
     * Overload toJSON() to intercept JSON.stringify()
     * @return {*}
     */
    Message.prototype.toJSON = function () {
        /* encode data to base64 if present and we're returning real JSON;
         * although msgpack calls toJSON(), we know it is a stringify()
         * call if it has a non-empty arguments list */
        var encoding = this.encoding;
        var data = this.data;
        if (data && platform_1.default.BufferUtils.isBuffer(data)) {
            if (arguments.length > 0) {
                /* stringify call */
                encoding = encoding ? encoding + '/base64' : 'base64';
                data = platform_1.default.BufferUtils.base64Encode(data);
            }
            else {
                /* Called by msgpack. toBuffer returns a datatype understandable by
                 * that platform's msgpack implementation (Buffer in node, Uint8Array
                 * in browsers) */
                data = platform_1.default.BufferUtils.toBuffer(data);
            }
        }
        return {
            name: this.name,
            id: this.id,
            clientId: this.clientId,
            connectionId: this.connectionId,
            connectionKey: this.connectionKey,
            extras: this.extras,
            encoding: encoding,
            data: data,
        };
    };
    Message.prototype.toString = function () {
        var result = '[Message';
        if (this.name)
            result += '; name=' + this.name;
        if (this.id)
            result += '; id=' + this.id;
        if (this.timestamp)
            result += '; timestamp=' + this.timestamp;
        if (this.clientId)
            result += '; clientId=' + this.clientId;
        if (this.connectionId)
            result += '; connectionId=' + this.connectionId;
        if (this.encoding)
            result += '; encoding=' + this.encoding;
        if (this.extras)
            result += '; extras =' + JSON.stringify(this.extras);
        if (this.data) {
            if (typeof this.data == 'string')
                result += '; data=' + this.data;
            else if (platform_1.default.BufferUtils.isBuffer(this.data))
                result += '; data (buffer)=' + platform_1.default.BufferUtils.base64Encode(this.data);
            else
                result += '; data (json)=' + JSON.stringify(this.data);
        }
        if (this.extras)
            result += '; extras=' + JSON.stringify(this.extras);
        result += ']';
        return result;
    };
    Message.encrypt = function (msg, options, callback) {
        var data = msg.data, encoding = msg.encoding, cipher = options.channelCipher;
        encoding = encoding ? encoding + '/' : '';
        if (!platform_1.default.BufferUtils.isBuffer(data)) {
            data = platform_1.default.BufferUtils.utf8Encode(String(data));
            encoding = encoding + 'utf-8/';
        }
        cipher.encrypt(data, function (err, data) {
            if (err) {
                callback(err);
                return;
            }
            msg.data = data;
            msg.encoding = encoding + 'cipher+' + cipher.algorithm;
            callback(null, msg);
        });
    };
    Message.encode = function (msg, options, callback) {
        var data = msg.data;
        var nativeDataType = typeof data == 'string' || platform_1.default.BufferUtils.isBuffer(data) || data === null || data === undefined;
        if (!nativeDataType) {
            if (Utils.isObject(data) || Utils.isArray(data)) {
                msg.data = JSON.stringify(data);
                msg.encoding = msg.encoding ? msg.encoding + '/json' : 'json';
            }
            else {
                throw new errorinfo_1.default('Data type is unsupported', 40013, 400);
            }
        }
        if (options != null && options.cipher) {
            Message.encrypt(msg, options, callback);
        }
        else {
            callback(null, msg);
        }
    };
    Message.encodeArray = function (messages, options, callback) {
        var processed = 0;
        for (var i = 0; i < messages.length; i++) {
            Message.encode(messages[i], options, function (err) {
                if (err) {
                    callback(err);
                    return;
                }
                processed++;
                if (processed == messages.length) {
                    callback(null, messages);
                }
            });
        }
    };
    Message.decode = function (message, inputContext) {
        var context = normaliseContext(inputContext);
        var lastPayload = message.data;
        var encoding = message.encoding;
        if (encoding) {
            var xforms = encoding.split('/');
            var lastProcessedEncodingIndex = void 0, encodingsToProcess = xforms.length, data = message.data;
            var xform = '';
            try {
                while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {
                    // eslint-disable-next-line security/detect-unsafe-regex
                    var match = xforms[--encodingsToProcess].match(/([-\w]+)(\+([\w-]+))?/);
                    if (!match)
                        break;
                    xform = match[1];
                    switch (xform) {
                        case 'base64':
                            data = platform_1.default.BufferUtils.base64Decode(String(data));
                            if (lastProcessedEncodingIndex == xforms.length) {
                                lastPayload = data;
                            }
                            continue;
                        case 'utf-8':
                            data = platform_1.default.BufferUtils.utf8Decode(data);
                            continue;
                        case 'json':
                            data = JSON.parse(data);
                            continue;
                        case 'cipher':
                            if (context.channelOptions != null &&
                                context.channelOptions.cipher &&
                                context.channelOptions.channelCipher) {
                                var xformAlgorithm = match[3], cipher = context.channelOptions.channelCipher;
                                /* don't attempt to decrypt unless the cipher params are compatible */
                                if (xformAlgorithm != cipher.algorithm) {
                                    throw new Error('Unable to decrypt message with given cipher; incompatible cipher params');
                                }
                                data = cipher.decrypt(data);
                                continue;
                            }
                            else {
                                throw new Error('Unable to decrypt message; not an encrypted channel');
                            }
                        case 'vcdiff':
                            if (!context.plugins || !context.plugins.vcdiff) {
                                throw new errorinfo_1.default('Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)', 40019, 400);
                            }
                            if (typeof Uint8Array === 'undefined') {
                                throw new errorinfo_1.default('Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)', 40020, 400);
                            }
                            try {
                                var deltaBase = context.baseEncodedPreviousPayload;
                                if (typeof deltaBase === 'string') {
                                    deltaBase = platform_1.default.BufferUtils.utf8Encode(deltaBase);
                                }
                                /* vcdiff expects Uint8Arrays, can't copy with ArrayBuffers. (also, if we
                                 * don't have a TextDecoder, deltaBase might be a WordArray here, so need
                                 * to process it into a buffer anyway) */
                                deltaBase = platform_1.default.BufferUtils.toBuffer(deltaBase);
                                data = platform_1.default.BufferUtils.toBuffer(data);
                                data = platform_1.default.BufferUtils.typedArrayToBuffer(context.plugins.vcdiff.decode(data, deltaBase));
                                lastPayload = data;
                            }
                            catch (e) {
                                throw new errorinfo_1.default('Vcdiff delta decode failed with ' + e, 40018, 400);
                            }
                            continue;
                        default:
                            throw new Error('Unknown encoding');
                    }
                }
            }
            catch (e) {
                var err = e;
                throw new errorinfo_1.default('Error processing the ' + xform + ' encoding, decoder returned ‘' + err.message + '’', err.code || 40013, 400);
            }
            finally {
                message.encoding =
                    lastProcessedEncodingIndex <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join('/');
                message.data = data;
            }
        }
        context.baseEncodedPreviousPayload = lastPayload;
    };
    Message.fromResponseBody = function (body, options, format) {
        if (format) {
            body = Utils.decodeBody(body, format);
        }
        for (var i = 0; i < body.length; i++) {
            var msg = (body[i] = Message.fromValues(body[i]));
            try {
                Message.decode(msg, options);
            }
            catch (e) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Message.fromResponseBody()', e.toString());
            }
        }
        return body;
    };
    Message.fromValues = function (values) {
        return Object.assign(new Message(), values);
    };
    Message.fromValuesArray = function (values) {
        var count = values.length, result = new Array(count);
        for (var i = 0; i < count; i++)
            result[i] = Message.fromValues(values[i]);
        return result;
    };
    Message.fromEncoded = function (encoded, inputOptions) {
        var msg = Message.fromValues(encoded);
        var options = normalizeCipherOptions(inputOptions !== null && inputOptions !== void 0 ? inputOptions : null);
        /* if decoding fails at any point, catch and return the message decoded to
         * the fullest extent possible */
        try {
            Message.decode(msg, options);
        }
        catch (e) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Message.fromEncoded()', e.toString());
        }
        return msg;
    };
    Message.fromEncodedArray = function (encodedArray, options) {
        return encodedArray.map(function (encoded) {
            return Message.fromEncoded(encoded, options);
        });
    };
    /* This should be called on encode()d (and encrypt()d) Messages (as it
     * assumes the data is a string or buffer) */
    Message.getMessagesSize = function (messages) {
        var msg, total = 0;
        for (var i = 0; i < messages.length; i++) {
            msg = messages[i];
            total += msg.size || (msg.size = getMessageSize(msg));
        }
        return total;
    };
    Message.serialize = Utils.encodeBody;
    return Message;
}());
exports.default = Message;


/***/ }),
/* 10 */
/***/ (function(module, exports, __nested_webpack_require_109505__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_109505__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_109505__(1));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_109505__(4));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_109505__(9));
var presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_109505__(15));
var actions = {
    HEARTBEAT: 0,
    ACK: 1,
    NACK: 2,
    CONNECT: 3,
    CONNECTED: 4,
    DISCONNECT: 5,
    DISCONNECTED: 6,
    CLOSE: 7,
    CLOSED: 8,
    ERROR: 9,
    ATTACH: 10,
    ATTACHED: 11,
    DETACH: 12,
    DETACHED: 13,
    PRESENCE: 14,
    MESSAGE: 15,
    SYNC: 16,
    AUTH: 17,
    ACTIVATE: 18,
};
var ActionName = [];
Object.keys(actions).forEach(function (name) {
    ActionName[actions[name]] = name;
});
var flags = {
    /* Channel attach state flags */
    HAS_PRESENCE: 1 << 0,
    HAS_BACKLOG: 1 << 1,
    RESUMED: 1 << 2,
    TRANSIENT: 1 << 4,
    ATTACH_RESUME: 1 << 5,
    /* Channel mode flags */
    PRESENCE: 1 << 16,
    PUBLISH: 1 << 17,
    SUBSCRIBE: 1 << 18,
    PRESENCE_SUBSCRIBE: 1 << 19,
};
var flagNames = Object.keys(flags);
flags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;
function toStringArray(array) {
    var result = [];
    if (array) {
        for (var i = 0; i < array.length; i++) {
            result.push(array[i].toString());
        }
    }
    return '[ ' + result.join(', ') + ' ]';
}
var simpleAttributes = 'id channel channelSerial connectionId count msgSerial timestamp'.split(' ');
var ProtocolMessage = /** @class */ (function () {
    function ProtocolMessage() {
        var _this = this;
        this.hasFlag = function (flag) {
            return (_this.flags & flags[flag]) > 0;
        };
    }
    ProtocolMessage.prototype.setFlag = function (flag) {
        return (this.flags = this.flags | flags[flag]);
    };
    ProtocolMessage.prototype.getMode = function () {
        return this.flags && this.flags & flags.MODE_ALL;
    };
    ProtocolMessage.prototype.encodeModesToFlags = function (modes) {
        var _this = this;
        modes.forEach(function (mode) { return _this.setFlag(mode); });
    };
    ProtocolMessage.prototype.decodeModesFromFlags = function () {
        var _this = this;
        var modes = [];
        ProtocolMessage.channelModes.forEach(function (mode) {
            if (_this.hasFlag(mode)) {
                modes.push(mode);
            }
        });
        return modes.length > 0 ? modes : undefined;
    };
    ProtocolMessage.fromValues = function (values) {
        return Object.assign(new ProtocolMessage(), values);
    };
    ProtocolMessage.Action = actions;
    ProtocolMessage.channelModes = ['PRESENCE', 'PUBLISH', 'SUBSCRIBE', 'PRESENCE_SUBSCRIBE'];
    ProtocolMessage.ActionName = ActionName;
    ProtocolMessage.serialize = Utils.encodeBody;
    ProtocolMessage.deserialize = function (serialized, format) {
        var deserialized = Utils.decodeBody(serialized, format);
        return ProtocolMessage.fromDeserialized(deserialized);
    };
    ProtocolMessage.fromDeserialized = function (deserialized) {
        var error = deserialized.error;
        if (error)
            deserialized.error = errorinfo_1.default.fromValues(error);
        var messages = deserialized.messages;
        if (messages)
            for (var i = 0; i < messages.length; i++)
                messages[i] = message_1.default.fromValues(messages[i]);
        var presence = deserialized.presence;
        if (presence)
            for (var i = 0; i < presence.length; i++)
                presence[i] = presencemessage_1.default.fromValues(presence[i], true);
        return Object.assign(new ProtocolMessage(), deserialized);
    };
    ProtocolMessage.stringify = function (msg) {
        var result = '[ProtocolMessage';
        if (msg.action !== undefined)
            result += '; action=' + ProtocolMessage.ActionName[msg.action] || 0;
        var attribute;
        for (var attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {
            attribute = simpleAttributes[attribIndex];
            if (msg[attribute] !== undefined)
                result += '; ' + attribute + '=' + msg[attribute];
        }
        if (msg.messages)
            result += '; messages=' + toStringArray(message_1.default.fromValuesArray(msg.messages));
        if (msg.presence)
            result += '; presence=' + toStringArray(presencemessage_1.default.fromValuesArray(msg.presence));
        if (msg.error)
            result += '; error=' + errorinfo_1.default.fromValues(msg.error).toString();
        if (msg.auth && msg.auth.accessToken)
            result += '; token=' + msg.auth.accessToken;
        if (msg.flags)
            result += '; flags=' + flagNames.filter(msg.hasFlag).join(',');
        if (msg.params) {
            var stringifiedParams_1 = '';
            Utils.forInOwnNonNullProperties(msg.params, function (prop) {
                if (stringifiedParams_1.length > 0) {
                    stringifiedParams_1 += '; ';
                }
                stringifiedParams_1 += prop + '=' + msg.params[prop];
            });
            if (stringifiedParams_1.length > 0) {
                result += '; params=[' + stringifiedParams_1 + ']';
            }
        }
        result += ']';
        return result;
    };
    return ProtocolMessage;
}());
exports.default = ProtocolMessage;


/***/ }),
/* 11 */
/***/ (function(module, exports, __nested_webpack_require_115059__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_115059__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        }
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              var bitsCombined = bits1 | bits2;
	              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),
/* 12 */
/***/ (function(module, exports, __nested_webpack_require_119082__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_119082__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_119082__(1));
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(10));
var transport_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(26));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(2));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(8));
var connectionerrors_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(20));
var auth_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(17));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(4));
var XHRStates_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(21));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(3));
/* TODO: can remove once realtime sends protocol message responses for comet errors */
function shouldBeErrorAction(err) {
    var UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];
    if (err.code) {
        if (auth_1.default.isTokenErr(err))
            return false;
        if (Utils.arrIn(UNRESOLVABLE_ERROR_CODES, err.code))
            return true;
        return err.code >= 40000 && err.code < 50000;
    }
    else {
        /* Likely a network or transport error of some kind. Certainly not fatal to the connection */
        return false;
    }
}
function protocolMessageFromRawError(err) {
    /* err will be either a legacy (non-protocolmessage) comet error response
     * (which will have an err.code), or a xhr/network error (which won't). */
    if (shouldBeErrorAction(err)) {
        return [protocolmessage_1.default.fromValues({ action: protocolmessage_1.default.Action.ERROR, error: err })];
    }
    else {
        return [protocolmessage_1.default.fromValues({ action: protocolmessage_1.default.Action.DISCONNECTED, error: err })];
    }
}
/*
 * A base comet transport class
 */
var CometTransport = /** @class */ (function (_super) {
    tslib_1.__extends(CometTransport, _super);
    function CometTransport(connectionManager, auth, params) {
        var _this = _super.call(this, connectionManager, auth, params, /* binary not supported for comet so force JSON protocol */ true) || this;
        /* For comet, we could do the auth update by aborting the current recv and
         * starting a new one with the new token, that'd be sufficient for realtime.
         * Problem is JSONP - you can't cancel truly abort a recv once started. So
         * we need to send an AUTH for jsonp. In which case it's simpler to keep all
         * comet transports the same and do it for all of them. So we send the AUTH
         * instead, and don't need to abort the recv */
        _this.onAuthUpdated = function (tokenDetails) {
            _this.authParams = { access_token: tokenDetails.token };
        };
        _this.stream = 'stream' in params ? params.stream : true;
        _this.sendRequest = null;
        _this.recvRequest = null;
        _this.pendingCallback = null;
        _this.pendingItems = null;
        return _this;
    }
    CometTransport.prototype.connect = function () {
        var _this = this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.connect()', 'starting');
        transport_1.default.prototype.connect.call(this);
        var params = this.params;
        var options = params.options;
        var host = defaults_1.default.getHost(options, params.host);
        var port = defaults_1.default.getPort(options);
        var cometScheme = options.tls ? 'https://' : 'http://';
        this.baseUri = cometScheme + host + ':' + port + '/comet/';
        var connectUri = this.baseUri + 'connect';
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.connect()', 'uri: ' + connectUri);
        this.auth.getAuthParams(function (err, authParams) {
            if (err) {
                _this.disconnect(err);
                return;
            }
            if (_this.isDisposed) {
                return;
            }
            _this.authParams = authParams;
            var connectParams = _this.params.getConnectParams(authParams);
            if ('stream' in connectParams)
                _this.stream = connectParams.stream;
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.connect()', 'connectParams:' + Utils.toQueryString(connectParams));
            /* this will be the 'recvRequest' so this connection can stream messages */
            var preconnected = false;
            var connectRequest = (_this.recvRequest = _this.createRequest(connectUri, null, connectParams, null, _this.stream ? XHRStates_1.default.REQ_RECV_STREAM : XHRStates_1.default.REQ_RECV));
            connectRequest.on('data', function (data) {
                if (!_this.recvRequest) {
                    /* the transport was disposed before we connected */
                    return;
                }
                if (!preconnected) {
                    preconnected = true;
                    _this.emit('preconnect');
                }
                _this.onData(data);
            });
            connectRequest.on('complete', function (err) {
                if (!_this.recvRequest) {
                    /* the transport was disposed before we connected */
                    err = err || new errorinfo_1.default('Request cancelled', 80003, 400);
                }
                _this.recvRequest = null;
                /* Connect request may complete without a emitting 'data' event since that is not
                 * emitted for e.g. a non-streamed error response. Still implies preconnect. */
                if (!preconnected && !err) {
                    preconnected = true;
                    _this.emit('preconnect');
                }
                _this.onActivity();
                if (err) {
                    if (err.code) {
                        /* A protocol error received from realtime. TODO: once realtime
                         * consistendly sends errors wrapped in protocol messages, should be
                         * able to remove this */
                        _this.onData(protocolMessageFromRawError(err));
                    }
                    else {
                        /* A network/xhr error. Don't bother wrapping in a protocol message,
                         * just disconnect the transport */
                        _this.disconnect(err);
                    }
                    return;
                }
                platform_1.default.Config.nextTick(function () {
                    _this.recv();
                });
            });
            connectRequest.exec();
        });
    };
    CometTransport.prototype.requestClose = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.requestClose()');
        this._requestCloseOrDisconnect(true);
    };
    CometTransport.prototype.requestDisconnect = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.requestDisconnect()');
        this._requestCloseOrDisconnect(false);
    };
    CometTransport.prototype._requestCloseOrDisconnect = function (closing) {
        var _this = this;
        var closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;
        if (closeOrDisconnectUri) {
            var request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, XHRStates_1.default.REQ_SEND);
            request.on('complete', function (err) {
                if (err) {
                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'CometTransport.request' + (closing ? 'Close()' : 'Disconnect()'), 'request returned err = ' + Utils.inspectError(err));
                    _this.finish('disconnected', err);
                }
            });
            request.exec();
        }
    };
    CometTransport.prototype.dispose = function () {
        var _this = this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.dispose()', '');
        if (!this.isDisposed) {
            this.isDisposed = true;
            if (this.recvRequest) {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.dispose()', 'aborting recv request');
                this.recvRequest.abort();
                this.recvRequest = null;
            }
            /* In almost all cases the transport will be finished before it's
             * disposed. Finish here just to make sure. */
            this.finish('disconnected', connectionerrors_1.default.disconnected());
            platform_1.default.Config.nextTick(function () {
                _this.emit('disposed');
            });
        }
    };
    CometTransport.prototype.onConnect = function (message) {
        var _a;
        /* if this transport has been disposed whilst awaiting connection, do nothing */
        if (this.isDisposed) {
            return;
        }
        /* the connectionKey in a comet connected response is really
         * <instId>-<connectionKey> */
        var connectionStr = (_a = message.connectionDetails) === null || _a === void 0 ? void 0 : _a.connectionKey;
        transport_1.default.prototype.onConnect.call(this, message);
        var baseConnectionUri = this.baseUri + connectionStr;
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'CometTransport.onConnect()', 'baseUri = ' + baseConnectionUri);
        this.sendUri = baseConnectionUri + '/send';
        this.recvUri = baseConnectionUri + '/recv';
        this.closeUri = baseConnectionUri + '/close';
        this.disconnectUri = baseConnectionUri + '/disconnect';
    };
    CometTransport.prototype.send = function (message) {
        if (this.sendRequest) {
            /* there is a pending send, so queue this message */
            this.pendingItems = this.pendingItems || [];
            this.pendingItems.push(message);
            return;
        }
        /* send this, plus any pending, now */
        var pendingItems = this.pendingItems || [];
        pendingItems.push(message);
        this.pendingItems = null;
        this.sendItems(pendingItems);
    };
    CometTransport.prototype.sendAnyPending = function () {
        var pendingItems = this.pendingItems;
        if (!pendingItems) {
            return;
        }
        this.pendingItems = null;
        this.sendItems(pendingItems);
    };
    CometTransport.prototype.sendItems = function (items) {
        var _this = this;
        var sendRequest = (this.sendRequest = this.createRequest(this.sendUri, null, this.authParams, this.encodeRequest(items), XHRStates_1.default.REQ_SEND));
        sendRequest.on('complete', function (err, data) {
            if (err)
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'CometTransport.sendItems()', 'on complete: err = ' + Utils.inspectError(err));
            _this.sendRequest = null;
            /* the result of the request, even if a nack, is usually a protocol response
             * contained in the data. An err is anomolous, and indicates some issue with the
             * network,transport, or connection */
            if (err) {
                if (err.code) {
                    /* A protocol error received from realtime. TODO: once realtime
                     * consistendly sends errors wrapped in protocol messages, should be
                     * able to remove this */
                    _this.onData(protocolMessageFromRawError(err));
                }
                else {
                    /* A network/xhr error. Don't bother wrapping in a protocol message,
                     * just disconnect the transport */
                    _this.disconnect(err);
                }
                return;
            }
            if (data) {
                _this.onData(data);
            }
            if (_this.pendingItems) {
                platform_1.default.Config.nextTick(function () {
                    /* If there's a new send request by now, any pending items will have
                     * been picked up by that; any new ones added since then will be
                     * picked up after that one completes */
                    if (!_this.sendRequest) {
                        _this.sendAnyPending();
                    }
                });
            }
        });
        sendRequest.exec();
    };
    CometTransport.prototype.recv = function () {
        var _this = this;
        /* do nothing if there is an active request, which might be streaming */
        if (this.recvRequest)
            return;
        /* If we're no longer connected, do nothing */
        if (!this.isConnected)
            return;
        var recvRequest = (this.recvRequest = this.createRequest(this.recvUri, null, this.authParams, null, this.stream ? XHRStates_1.default.REQ_RECV_STREAM : XHRStates_1.default.REQ_RECV_POLL));
        recvRequest.on('data', function (data) {
            _this.onData(data);
        });
        recvRequest.on('complete', function (err) {
            _this.recvRequest = null;
            /* A request completing must be considered activity, as realtime sends
             * heartbeats every 15s since a request began, not every 15s absolutely */
            _this.onActivity();
            if (err) {
                if (err.code) {
                    /* A protocol error received from realtime. TODO: once realtime
                     * consistently sends errors wrapped in protocol messages, should be
                     * able to remove this */
                    _this.onData(protocolMessageFromRawError(err));
                }
                else {
                    /* A network/xhr error. Don't bother wrapping in a protocol message,
                     * just disconnect the transport */
                    _this.disconnect(err);
                }
                return;
            }
            platform_1.default.Config.nextTick(function () {
                _this.recv();
            });
        });
        recvRequest.exec();
    };
    CometTransport.prototype.onData = function (responseData) {
        try {
            var items = this.decodeResponse(responseData);
            if (items && items.length)
                for (var i = 0; i < items.length; i++)
                    this.onProtocolMessage(protocolmessage_1.default.fromDeserialized(items[i]));
        }
        catch (e) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'CometTransport.onData()', 'Unexpected exception handing channel event: ' + e.stack);
        }
    };
    CometTransport.prototype.encodeRequest = function (requestItems) {
        return JSON.stringify(requestItems);
    };
    CometTransport.prototype.decodeResponse = function (responseData) {
        if (typeof responseData == 'string')
            return JSON.parse(responseData);
        return responseData;
    };
    return CometTransport;
}(transport_1.default));
exports.default = CometTransport;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 14 */
/***/ (function(module, exports, __nested_webpack_require_134706__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_134706__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_134706__(3));
var Utils = tslib_1.__importStar(__nested_webpack_require_134706__(1));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_134706__(2));
var auth_1 = tslib_1.__importDefault(__nested_webpack_require_134706__(17));
var HttpMethods_1 = tslib_1.__importDefault(__nested_webpack_require_134706__(18));
var errorinfo_1 = __nested_webpack_require_134706__(4);
function withAuthDetails(rest, headers, params, errCallback, opCallback) {
    if (rest.http.supportsAuthHeaders) {
        rest.auth.getAuthHeaders(function (err, authHeaders) {
            if (err)
                errCallback(err);
            else
                opCallback(Utils.mixin(authHeaders, headers), params);
        });
    }
    else {
        rest.auth.getAuthParams(function (err, authParams) {
            if (err)
                errCallback(err);
            else
                opCallback(headers, Utils.mixin(authParams, params));
        });
    }
}
function unenvelope(callback, format) {
    return function (err, body, outerHeaders, unpacked, outerStatusCode) {
        if (err && !body) {
            callback(err);
            return;
        }
        if (!unpacked) {
            try {
                body = Utils.decodeBody(body, format);
            }
            catch (e) {
                if (Utils.isErrorInfoOrPartialErrorInfo(e)) {
                    callback(e);
                }
                else {
                    callback(new errorinfo_1.PartialErrorInfo(Utils.inspectError(e), null));
                }
                return;
            }
        }
        if (!body) {
            callback(new errorinfo_1.PartialErrorInfo('unenvelope(): Response body is missing', null));
            return;
        }
        var _a = body, wrappedStatusCode = _a.statusCode, response = _a.response, wrappedHeaders = _a.headers;
        if (wrappedStatusCode === undefined) {
            /* Envelope already unwrapped by the transport */
            callback(err, body, outerHeaders, true, outerStatusCode);
            return;
        }
        if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {
            /* handle wrapped errors */
            var wrappedErr = (response && response.error) || err;
            if (!wrappedErr) {
                wrappedErr = new Error('Error in unenveloping ' + body);
                wrappedErr.statusCode = wrappedStatusCode;
            }
            callback(wrappedErr, response, wrappedHeaders, true, wrappedStatusCode);
            return;
        }
        callback(err, response, wrappedHeaders, true, wrappedStatusCode);
    };
}
function paramString(params) {
    var paramPairs = [];
    if (params) {
        for (var needle in params) {
            paramPairs.push(needle + '=' + params[needle]);
        }
    }
    return paramPairs.join('&');
}
function urlFromPathAndParams(path, params) {
    return path + (params ? '?' : '') + paramString(params);
}
function logResponseHandler(callback, method, path, params) {
    return function (err, body, headers, unpacked, statusCode) {
        if (err) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Received Error; ' + urlFromPathAndParams(path, params) + '; Error: ' + Utils.inspectError(err));
        }
        else {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Received; ' +
                urlFromPathAndParams(path, params) +
                '; Headers: ' +
                paramString(headers) +
                '; StatusCode: ' +
                statusCode +
                '; Body: ' +
                (platform_1.default.BufferUtils.isBuffer(body) ? body.toString() : body));
        }
        if (callback) {
            callback(err, body, headers, unpacked, statusCode);
        }
    };
}
var Resource = /** @class */ (function () {
    function Resource() {
    }
    Resource.get = function (rest, path, headers, params, envelope, callback) {
        Resource.do(HttpMethods_1.default.Get, rest, path, null, headers, params, envelope, callback);
    };
    Resource.delete = function (rest, path, headers, params, envelope, callback) {
        Resource.do(HttpMethods_1.default.Delete, rest, path, null, headers, params, envelope, callback);
    };
    Resource.post = function (rest, path, body, headers, params, envelope, callback) {
        Resource.do(HttpMethods_1.default.Post, rest, path, body, headers, params, envelope, callback);
    };
    Resource.patch = function (rest, path, body, headers, params, envelope, callback) {
        Resource.do(HttpMethods_1.default.Patch, rest, path, body, headers, params, envelope, callback);
    };
    Resource.put = function (rest, path, body, headers, params, envelope, callback) {
        Resource.do(HttpMethods_1.default.Put, rest, path, body, headers, params, envelope, callback);
    };
    Resource.do = function (method, rest, path, body, headers, params, envelope, callback) {
        if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {
            callback = logResponseHandler(callback, method, path, params);
        }
        if (envelope) {
            callback = callback && unenvelope(callback, envelope);
            (params = params || {})['envelope'] = envelope;
        }
        function doRequest(headers, params) {
            var _a;
            if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Sending; ' + urlFromPathAndParams(path, params));
            }
            if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {
                var decodedBody = body;
                if (((_a = headers['content-type']) === null || _a === void 0 ? void 0 : _a.indexOf('msgpack')) > 0) {
                    try {
                        decodedBody = platform_1.default.Config.msgpack.decode(body);
                    }
                    catch (decodeErr) {
                        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Sending MsgPack Decoding Error: ' + Utils.inspectError(decodeErr));
                    }
                }
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Sending; ' + urlFromPathAndParams(path, params) + '; Body: ' + decodedBody);
            }
            rest.http.do(method, rest, path, headers, body, params, function (err, res, headers, unpacked, statusCode) {
                if (err && auth_1.default.isTokenErr(err)) {
                    /* token has expired, so get a new one */
                    rest.auth.authorize(null, null, function (err) {
                        if (err) {
                            callback(err);
                            return;
                        }
                        /* retry ... */
                        withAuthDetails(rest, headers, params, callback, doRequest);
                    });
                    return;
                }
                callback(err, res, headers, unpacked, statusCode);
            });
        }
        withAuthDetails(rest, headers, params, callback, doRequest);
    };
    return Resource;
}());
exports.default = Resource;


/***/ }),
/* 15 */
/***/ (function(module, exports, __nested_webpack_require_142181__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_142181__(0);
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_142181__(2));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_142181__(3));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_142181__(9));
var Utils = tslib_1.__importStar(__nested_webpack_require_142181__(1));
function toActionValue(actionString) {
    return PresenceMessage.Actions.indexOf(actionString);
}
var PresenceMessage = /** @class */ (function () {
    function PresenceMessage() {
    }
    /* Returns whether this presenceMessage is synthesized, i.e. was not actually
     * sent by the connection (usually means a leave event sent 15s after a
     * disconnection). This is useful because synthesized messages cannot be
     * compared for newness by id lexicographically - RTP2b1
     */
    PresenceMessage.prototype.isSynthesized = function () {
        if (!this.id || !this.connectionId) {
            return true;
        }
        return this.id.substring(this.connectionId.length, 0) !== this.connectionId;
    };
    /* RTP2b2 */
    PresenceMessage.prototype.parseId = function () {
        if (!this.id)
            throw new Error('parseId(): Presence message does not contain an id');
        var parts = this.id.split(':');
        return {
            connectionId: parts[0],
            msgSerial: parseInt(parts[1], 10),
            index: parseInt(parts[2], 10),
        };
    };
    /**
     * Overload toJSON() to intercept JSON.stringify()
     * @return {*}
     */
    PresenceMessage.prototype.toJSON = function () {
        /* encode data to base64 if present and we're returning real JSON;
         * although msgpack calls toJSON(), we know it is a stringify()
         * call if it has a non-empty arguments list */
        var data = this.data;
        var encoding = this.encoding;
        if (data && platform_1.default.BufferUtils.isBuffer(data)) {
            if (arguments.length > 0) {
                /* stringify call */
                encoding = encoding ? encoding + '/base64' : 'base64';
                data = platform_1.default.BufferUtils.base64Encode(data);
            }
            else {
                /* Called by msgpack. toBuffer returns a datatype understandable by
                 * that platform's msgpack implementation (Buffer in node, Uint8Array
                 * in browsers) */
                data = platform_1.default.BufferUtils.toBuffer(data);
            }
        }
        return {
            id: this.id,
            clientId: this.clientId,
            /* Convert presence action back to an int for sending to Ably */
            action: toActionValue(this.action),
            data: data,
            encoding: encoding,
            extras: this.extras,
        };
    };
    PresenceMessage.prototype.toString = function () {
        var result = '[PresenceMessage';
        result += '; action=' + this.action;
        if (this.id)
            result += '; id=' + this.id;
        if (this.timestamp)
            result += '; timestamp=' + this.timestamp;
        if (this.clientId)
            result += '; clientId=' + this.clientId;
        if (this.connectionId)
            result += '; connectionId=' + this.connectionId;
        if (this.encoding)
            result += '; encoding=' + this.encoding;
        if (this.data) {
            if (typeof this.data == 'string')
                result += '; data=' + this.data;
            else if (platform_1.default.BufferUtils.isBuffer(this.data))
                result += '; data (buffer)=' + platform_1.default.BufferUtils.base64Encode(this.data);
            else
                result += '; data (json)=' + JSON.stringify(this.data);
        }
        if (this.extras) {
            result += '; extras=' + JSON.stringify(this.extras);
        }
        result += ']';
        return result;
    };
    PresenceMessage.fromResponseBody = function (body, options, format) {
        var messages = [];
        if (format) {
            body = Utils.decodeBody(body, format);
        }
        for (var i = 0; i < body.length; i++) {
            var msg = (messages[i] = PresenceMessage.fromValues(body[i], true));
            try {
                PresenceMessage.decode(msg, options);
            }
            catch (e) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'PresenceMessage.fromResponseBody()', e.toString());
            }
        }
        return messages;
    };
    PresenceMessage.fromValues = function (values, stringifyAction) {
        if (stringifyAction) {
            values.action = PresenceMessage.Actions[values.action];
        }
        return Object.assign(new PresenceMessage(), values);
    };
    PresenceMessage.fromValuesArray = function (values) {
        var count = values.length, result = new Array(count);
        for (var i = 0; i < count; i++)
            result[i] = PresenceMessage.fromValues(values[i]);
        return result;
    };
    PresenceMessage.fromEncoded = function (encoded, options) {
        var msg = PresenceMessage.fromValues(encoded, true);
        /* if decoding fails at any point, catch and return the message decoded to
         * the fullest extent possible */
        try {
            PresenceMessage.decode(msg, options !== null && options !== void 0 ? options : {});
        }
        catch (e) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'PresenceMessage.fromEncoded()', e.toString());
        }
        return msg;
    };
    PresenceMessage.fromEncodedArray = function (encodedArray, options) {
        return encodedArray.map(function (encoded) {
            return PresenceMessage.fromEncoded(encoded, options);
        });
    };
    PresenceMessage.fromData = function (data) {
        if (data instanceof PresenceMessage) {
            return data;
        }
        return PresenceMessage.fromValues({
            data: data,
        });
    };
    PresenceMessage.Actions = ['absent', 'present', 'enter', 'leave', 'update'];
    PresenceMessage.encode = message_1.default.encode;
    PresenceMessage.decode = message_1.default.decode;
    PresenceMessage.getMessagesSize = message_1.default.getMessagesSize;
    return PresenceMessage;
}());
exports.default = PresenceMessage;


/***/ }),
/* 16 */
/***/ (function(module, exports, __nested_webpack_require_148575__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_148575__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_148575__(1));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_148575__(7));
var errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_148575__(4));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_148575__(2));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_148575__(8));
var XHRStates_1 = tslib_1.__importDefault(__nested_webpack_require_148575__(21));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_148575__(3));
function isAblyError(responseBody, headers) {
    return Utils.arrIn(Utils.allToLowerCase(Utils.keysArray(headers)), 'x-ably-errorcode');
}
function getAblyError(responseBody, headers) {
    if (isAblyError(responseBody, headers)) {
        return responseBody.error && errorinfo_1.default.fromValues(responseBody.error);
    }
}
var noop = function () { };
var idCounter = 0;
var pendingRequests = {};
var isIE = typeof global !== 'undefined' && global.XDomainRequest;
function ieVersion() {
    var match = navigator.userAgent.toString().match(/MSIE\s([\d.]+)/);
    return match && Number(match[1]);
}
function needJsonEnvelope() {
    /* IE 10 xhr bug: http://stackoverflow.com/a/16320339 */
    var version;
    return isIE && (version = ieVersion()) && version === 10;
}
function getHeader(xhr, header) {
    return xhr.getResponseHeader && xhr.getResponseHeader(header);
}
/* Safari mysteriously returns 'Identity' for transfer-encoding when in fact
 * it is 'chunked'. So instead, decide that it is chunked when
 * transfer-encoding is present or content-length is absent.  ('or' because
 * when using http2 streaming, there's no transfer-encoding header, but can
 * still deduce streaming from lack of content-length) */
function isEncodingChunked(xhr) {
    return (xhr.getResponseHeader && (xhr.getResponseHeader('transfer-encoding') || !xhr.getResponseHeader('content-length')));
}
function getHeadersAsObject(xhr) {
    var headerPairs = Utils.trim(xhr.getAllResponseHeaders()).split('\r\n');
    var headers = {};
    for (var i = 0; i < headerPairs.length; i++) {
        var parts = headerPairs[i].split(':').map(Utils.trim);
        headers[parts[0].toLowerCase()] = parts[1];
    }
    return headers;
}
var XHRRequest = /** @class */ (function (_super) {
    tslib_1.__extends(XHRRequest, _super);
    function XHRRequest(uri, headers, params, body, requestMode, timeouts, method) {
        var _this = _super.call(this) || this;
        params = params || {};
        params.rnd = Utils.cheapRandStr();
        if (needJsonEnvelope() && !params.envelope)
            params.envelope = 'json';
        _this.uri = uri + Utils.toQueryString(params);
        _this.headers = headers || {};
        _this.body = body;
        _this.method = method ? method.toUpperCase() : Utils.isEmptyArg(body) ? 'GET' : 'POST';
        _this.requestMode = requestMode;
        _this.timeouts = timeouts;
        _this.timedOut = false;
        _this.requestComplete = false;
        _this.id = String(++idCounter);
        pendingRequests[_this.id] = _this;
        return _this;
    }
    XHRRequest.createRequest = function (uri, headers, params, body, requestMode, timeouts, method) {
        /* XHR requests are used either with the context being a realtime
         * transport, or with timeouts passed in (for when used by a rest client),
         * or completely standalone.  Use the appropriate timeouts in each case */
        var _timeouts = timeouts || defaults_1.default.TIMEOUTS;
        return new XHRRequest(uri, headers, Utils.copy(params), body, requestMode, _timeouts, method);
    };
    XHRRequest.prototype.complete = function (err, body, headers, unpacked, statusCode) {
        if (!this.requestComplete) {
            this.requestComplete = true;
            if (!err && body) {
                this.emit('data', body);
            }
            this.emit('complete', err, body, headers, unpacked, statusCode);
            this.dispose();
        }
    };
    XHRRequest.prototype.abort = function () {
        this.dispose();
    };
    XHRRequest.prototype.exec = function () {
        var _this = this;
        var headers = this.headers;
        var timeout = this.requestMode == XHRStates_1.default.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout, timer = (this.timer = setTimeout(function () {
            _this.timedOut = true;
            xhr.abort();
        }, timeout)), method = this.method, xhr = (this.xhr = new XMLHttpRequest()), accept = headers['accept'];
        var body = this.body;
        var responseType = 'text';
        if (!accept) {
            // Default to JSON
            headers['accept'] = 'application/json';
        }
        else if (accept.indexOf('application/x-msgpack') === 0) {
            // Msgpack responses will be typed as ArrayBuffer
            responseType = 'arraybuffer';
        }
        if (body) {
            var contentType = headers['content-type'] || (headers['content-type'] = 'application/json');
            if (contentType.indexOf('application/json') > -1 && typeof body != 'string')
                body = JSON.stringify(body);
        }
        // Can probably remove this directive if https://github.com/nodesecurity/eslint-plugin-security/issues/26 is resolved
        // eslint-disable-next-line security/detect-non-literal-fs-filename
        xhr.open(method, this.uri, true);
        xhr.responseType = responseType;
        if ('authorization' in headers) {
            xhr.withCredentials = true;
        }
        for (var h in headers)
            xhr.setRequestHeader(h, headers[h]);
        var errorHandler = function (errorEvent, message, code, statusCode) {
            var _a;
            var errorMessage = message + ' (event type: ' + errorEvent.type + ')';
            if ((_a = _this === null || _this === void 0 ? void 0 : _this.xhr) === null || _a === void 0 ? void 0 : _a.statusText)
                errorMessage += ', current statusText is ' + _this.xhr.statusText;
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Request.on' + errorEvent.type + '()', errorMessage);
            _this.complete(new errorinfo_1.PartialErrorInfo(errorMessage, code, statusCode));
        };
        xhr.onerror = function (errorEvent) {
            errorHandler(errorEvent, 'XHR error occurred', null, 400);
        };
        xhr.onabort = function (errorEvent) {
            if (_this.timedOut) {
                errorHandler(errorEvent, 'Request aborted due to request timeout expiring', null, 408);
            }
            else {
                errorHandler(errorEvent, 'Request cancelled', null, 400);
            }
        };
        xhr.ontimeout = function (errorEvent) {
            errorHandler(errorEvent, 'Request timed out', null, 408);
        };
        var streaming;
        var statusCode;
        var successResponse;
        var streamPos = 0;
        var unpacked = false;
        var onResponse = function () {
            clearTimeout(timer);
            successResponse = statusCode < 400;
            if (statusCode == 204) {
                _this.complete(null, null, null, null, statusCode);
                return;
            }
            streaming = _this.requestMode == XHRStates_1.default.REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr);
        };
        var onEnd = function () {
            var parsedResponse;
            try {
                var contentType = getHeader(xhr, 'content-type');
                /* Be liberal in what we accept; buggy auth servers may respond
                 * without the correct contenttype, but assume they're still
                 * responding with json */
                var json = contentType ? contentType.indexOf('application/json') >= 0 : xhr.responseType == 'text';
                if (json) {
                    /* If we requested msgpack but server responded with json, then since
                     * we set the responseType expecting msgpack, the response will be
                     * an ArrayBuffer containing json */
                    var jsonResponseBody = xhr.responseType === 'arraybuffer'
                        ? platform_1.default.BufferUtils.utf8Decode(xhr.response)
                        : String(xhr.responseText);
                    if (jsonResponseBody.length) {
                        parsedResponse = JSON.parse(jsonResponseBody);
                    }
                    else {
                        parsedResponse = jsonResponseBody;
                    }
                    unpacked = true;
                }
                else {
                    parsedResponse = xhr.response;
                }
                if (parsedResponse.response !== undefined) {
                    /* unwrap JSON envelope */
                    statusCode = parsedResponse.statusCode;
                    successResponse = statusCode < 400;
                    headers = parsedResponse.headers;
                    parsedResponse = parsedResponse.response;
                }
                else {
                    headers = getHeadersAsObject(xhr);
                }
            }
            catch (e) {
                _this.complete(new errorinfo_1.PartialErrorInfo('Malformed response body from server: ' + e.message, null, 400));
                return;
            }
            /* If response is an array, it's an array of protocol messages -- even if
             * is contains an error action (hence the nonsuccess statuscode), we can
             * consider the request to have succeeded, just pass it on to
             * onProtocolMessage to decide what to do */
            if (successResponse || Utils.isArray(parsedResponse)) {
                _this.complete(null, parsedResponse, headers, unpacked, statusCode);
                return;
            }
            var err = getAblyError(parsedResponse, headers);
            if (!err) {
                err = new errorinfo_1.PartialErrorInfo('Error response received from server: ' +
                    statusCode +
                    ' body was: ' +
                    platform_1.default.Config.inspect(parsedResponse), null, statusCode);
            }
            _this.complete(err, parsedResponse, headers, unpacked, statusCode);
        };
        function onProgress() {
            var responseText = xhr.responseText;
            var bodyEnd = responseText.length - 1;
            var idx, chunk;
            while (streamPos < bodyEnd && (idx = responseText.indexOf('\n', streamPos)) > -1) {
                chunk = responseText.slice(streamPos, idx);
                streamPos = idx + 1;
                onChunk(chunk);
            }
        }
        var onChunk = function (chunk) {
            try {
                chunk = JSON.parse(chunk);
            }
            catch (e) {
                _this.complete(new errorinfo_1.PartialErrorInfo('Malformed response body from server: ' + e.message, null, 400));
                return;
            }
            _this.emit('data', chunk);
        };
        var onStreamEnd = function () {
            onProgress();
            _this.streamComplete = true;
            platform_1.default.Config.nextTick(function () {
                _this.complete();
            });
        };
        xhr.onreadystatechange = function () {
            var readyState = xhr.readyState;
            if (readyState < 3)
                return;
            if (xhr.status !== 0) {
                if (statusCode === undefined) {
                    statusCode = xhr.status;
                    /* IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450 */
                    if (statusCode === 1223)
                        statusCode = 204;
                    onResponse();
                }
                if (readyState == 3 && streaming) {
                    onProgress();
                }
                else if (readyState == 4) {
                    if (streaming)
                        onStreamEnd();
                    else
                        onEnd();
                }
            }
        };
        xhr.send(body);
    };
    XHRRequest.prototype.dispose = function () {
        var xhr = this.xhr;
        if (xhr) {
            xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop;
            this.xhr = null;
            var timer = this.timer;
            if (timer) {
                clearTimeout(timer);
                this.timer = null;
            }
            if (!this.requestComplete)
                xhr.abort();
        }
        delete pendingRequests[this.id];
    };
    return XHRRequest;
}(eventemitter_1.default));
exports.default = XHRRequest;

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_148575__(13)))

/***/ }),
/* 17 */
/***/ (function(module, exports, __nested_webpack_require_161531__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_161531__(0);
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(2));
var Utils = tslib_1.__importStar(__nested_webpack_require_161531__(1));
var multicaster_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(23));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(4));
var hmac_sha256_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(45));
var enc_base64_1 = __nested_webpack_require_161531__(11);
var HttpMethods_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(18));
var HttpStatusCodes_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(25));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(3));
var resource_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(14));
var MAX_TOKEN_LENGTH = Math.pow(2, 17);
function noop() { }
function random() {
    return ('000000' + Math.floor(Math.random() * 1e16)).slice(-16);
}
function isRealtime(client) {
    return !!client.connection;
}
/* A client auth callback may give errors in any number of formats; normalise to an ErrorInfo or PartialErrorInfo */
function normaliseAuthcallbackError(err) {
    if (!Utils.isErrorInfoOrPartialErrorInfo(err)) {
        return new errorinfo_1.default(Utils.inspectError(err), err.code || 40170, err.statusCode || 401);
    }
    /* network errors will not have an inherent error code */
    if (!err.code) {
        if (err.statusCode === 403) {
            err.code = 40300;
        }
        else {
            err.code = 40170;
            /* normalise statusCode to 401 per RSA4e */
            err.statusCode = 401;
        }
    }
    return err;
}
var hmac = function (text, key) {
    if (platform_1.default.Config.createHmac) {
        var inst = platform_1.default.Config.createHmac('SHA256', key);
        inst.update(text);
        return inst.digest('base64');
    }
    return (0, enc_base64_1.stringify)((0, hmac_sha256_1.default)(text, key));
};
function c14n(capability) {
    if (!capability)
        return '';
    if (typeof capability == 'string')
        capability = JSON.parse(capability);
    var c14nCapability = Object.create(null);
    var keys = Utils.keysArray(capability, true);
    if (!keys)
        return '';
    keys.sort();
    for (var i = 0; i < keys.length; i++) {
        c14nCapability[keys[i]] = capability[keys[i]].sort();
    }
    return JSON.stringify(c14nCapability);
}
function logAndValidateTokenAuthMethod(authOptions) {
    if (authOptions.authCallback) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'using token auth with authCallback');
    }
    else if (authOptions.authUrl) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'using token auth with authUrl');
    }
    else if (authOptions.key) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'using token auth with client-side signing');
    }
    else if (authOptions.tokenDetails) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'using token auth with supplied token only');
    }
    else {
        var msg = 'authOptions must include valid authentication parameters';
        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', msg);
        throw new Error(msg);
    }
}
function basicAuthForced(options) {
    return 'useTokenAuth' in options && !options.useTokenAuth;
}
/* RSA4 */
function useTokenAuth(options) {
    return (options.useTokenAuth ||
        (!basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails)));
}
/* RSA4a */
function noWayToRenew(options) {
    return !options.key && !options.authCallback && !options.authUrl;
}
var trId = 0;
function getTokenRequestId() {
    return trId++;
}
var Auth = /** @class */ (function () {
    function Auth(client, options) {
        // This initialization is always overwritten and only used to prevent a TypeScript compiler error
        this.authOptions = {};
        this.client = client;
        this.tokenParams = options.defaultTokenParams || {};
        /* The id of the current token request if one is in progress, else null */
        this.currentTokenRequestId = null;
        this.waitingForTokenRequest = null;
        if (useTokenAuth(options)) {
            /* Token auth */
            if (options.key && !hmac) {
                var msg = 'client-side token request signing not supported';
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', msg);
                throw new Error(msg);
            }
            if (noWayToRenew(options)) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', 'Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help');
            }
            this._saveTokenOptions(options.defaultTokenParams, options);
            logAndValidateTokenAuthMethod(this.authOptions);
        }
        else {
            /* Basic auth */
            if (!options.key) {
                var msg = 'No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)';
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', msg);
                throw new errorinfo_1.default(msg, 40160, 401);
            }
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'anonymous, using basic auth');
            this._saveBasicOptions(options);
        }
    }
    Auth.prototype.authorize = function (tokenParams, authOptions, callback) {
        var _this = this;
        var _authOptions;
        /* shuffle and normalise arguments as necessary */
        if (typeof tokenParams == 'function' && !callback) {
            callback = tokenParams;
            _authOptions = tokenParams = null;
        }
        else if (typeof authOptions == 'function' && !callback) {
            callback = authOptions;
            _authOptions = null;
        }
        else {
            _authOptions = authOptions;
        }
        if (!callback) {
            if (this.client.options.promises) {
                return Utils.promisify(this, 'authorize', arguments);
            }
        }
        /* RSA10a: authorize() call implies token auth. If a key is passed it, we
         * just check if it doesn't clash and assume we're generating a token from it */
        if (_authOptions && _authOptions.key && this.authOptions.key !== _authOptions.key) {
            throw new errorinfo_1.default('Unable to update auth options with incompatible key', 40102, 401);
        }
        if (_authOptions && 'force' in _authOptions) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.authorize', 'Deprecation warning: specifying {force: true} in authOptions is no longer necessary, authorize() now always gets a new token. Please remove this, as in version 1.0 and later, having a non-null authOptions will overwrite stored library authOptions, which may not be what you want');
            /* Emulate the old behaviour: if 'force' was the only member of authOptions,
             * set it to null so it doesn't overwrite stored. TODO: remove in version 1.0 */
            if (Utils.isOnlyPropIn(_authOptions, 'force')) {
                _authOptions = null;
            }
        }
        this._forceNewToken(tokenParams, _authOptions, function (err, tokenDetails) {
            if (err) {
                if (_this.client.connection && err.statusCode === HttpStatusCodes_1.default.Forbidden) {
                    /* Per RSA4d & RSA4d1, if the auth server explicitly repudiates our right to
                     * stay connecticed by returning a 403, we actively disconnect the connection
                     * even though we may well still have time left in the old token. */
                    _this.client.connection.connectionManager.actOnErrorFromAuthorize(err);
                }
                callback === null || callback === void 0 ? void 0 : callback(err);
                return;
            }
            /* RTC8
             * - When authorize called by an end user and have a realtime connection,
             * don't call back till new token has taken effect.
             * - Use this.client.connection as a proxy for (this.client instanceof Realtime),
             * which doesn't work in node as Realtime isn't part of the vm context for Rest clients */
            if (isRealtime(_this.client)) {
                _this.client.connection.connectionManager.onAuthUpdated(tokenDetails, callback || noop);
            }
            else {
                callback === null || callback === void 0 ? void 0 : callback(null, tokenDetails);
            }
        });
    };
    Auth.prototype.authorise = function (tokenParams, authOptions, callback) {
        logger_1.default.deprecated('Auth.authorise', 'Auth.authorize');
        this.authorize(tokenParams, authOptions, callback);
    };
    /* For internal use, eg by connectionManager - useful when want to call back
     * as soon as we have the new token, rather than waiting for it to take
     * effect on the connection as #authorize does */
    Auth.prototype._forceNewToken = function (tokenParams, authOptions, callback) {
        var _this = this;
        /* get rid of current token even if still valid */
        this.tokenDetails = null;
        /* _save normalises the tokenParams and authOptions and updates the auth
         * object. All subsequent operations should use the values on `this`,
         * not the passed in ones. */
        this._saveTokenOptions(tokenParams, authOptions);
        logAndValidateTokenAuthMethod(this.authOptions);
        this._ensureValidAuthCredentials(true, function (err, tokenDetails) {
            /* RSA10g */
            delete _this.tokenParams.timestamp;
            delete _this.authOptions.queryTime;
            callback(err, tokenDetails);
        });
    };
    Auth.prototype.requestToken = function (tokenParams, authOptions, callback) {
        var _this = this;
        /* shuffle and normalise arguments as necessary */
        if (typeof tokenParams == 'function' && !callback) {
            callback = tokenParams;
            authOptions = tokenParams = null;
        }
        else if (typeof authOptions == 'function' && !callback) {
            callback = authOptions;
            authOptions = null;
        }
        if (!callback && this.client.options.promises) {
            return Utils.promisify(this, 'requestToken', arguments);
        }
        /* RSA8e: if authOptions passed in, they're used instead of stored, don't merge them */
        authOptions = authOptions || this.authOptions;
        tokenParams = tokenParams || Utils.copy(this.tokenParams);
        var _callback = callback || noop;
        /* first set up whatever callback will be used to get signed
         * token requests */
        var tokenRequestCallback, client = this.client;
        if (authOptions.authCallback) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authCallback');
            tokenRequestCallback = authOptions.authCallback;
        }
        else if (authOptions.authUrl) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authUrl');
            tokenRequestCallback = function (params, cb) {
                var authHeaders = Utils.mixin({ accept: 'application/json, text/plain' }, authOptions.authHeaders);
                var usePost = authOptions.authMethod && authOptions.authMethod.toLowerCase() === 'post';
                var providedQsParams;
                /* Combine authParams with any qs params given in the authUrl */
                var queryIdx = authOptions.authUrl.indexOf('?');
                if (queryIdx > -1) {
                    providedQsParams = Utils.parseQueryString(authOptions.authUrl.slice(queryIdx));
                    authOptions.authUrl = authOptions.authUrl.slice(0, queryIdx);
                    if (!usePost) {
                        /* In case of conflict, authParams take precedence over qs params in the authUrl */
                        authOptions.authParams = Utils.mixin(providedQsParams, authOptions.authParams);
                    }
                }
                /* RSA8c2 */
                var authParams = Utils.mixin({}, authOptions.authParams || {}, params);
                var authUrlRequestCallback = function (err, body, headers, unpacked) {
                    var contentType;
                    if (err) {
                        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received Error: ' + Utils.inspectError(err));
                    }
                    else {
                        contentType = headers['content-type'];
                        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received; content-type: ' + contentType + '; body: ' + Utils.inspectBody(body));
                    }
                    if (err || unpacked)
                        return cb(err, body);
                    if (platform_1.default.BufferUtils.isBuffer(body))
                        body = body.toString();
                    if (!contentType) {
                        cb(new errorinfo_1.default('authUrl response is missing a content-type header', 40170, 401));
                        return;
                    }
                    var json = contentType.indexOf('application/json') > -1, text = contentType.indexOf('text/plain') > -1 || contentType.indexOf('application/jwt') > -1;
                    if (!json && !text) {
                        cb(new errorinfo_1.default('authUrl responded with unacceptable content-type ' +
                            contentType +
                            ', should be either text/plain, application/jwt or application/json', 40170, 401));
                        return;
                    }
                    if (json) {
                        if (body.length > MAX_TOKEN_LENGTH) {
                            cb(new errorinfo_1.default('authUrl response exceeded max permitted length', 40170, 401));
                            return;
                        }
                        try {
                            body = JSON.parse(body);
                        }
                        catch (e) {
                            cb(new errorinfo_1.default('Unexpected error processing authURL response; err = ' + e.message, 40170, 401));
                            return;
                        }
                    }
                    cb(null, body, contentType);
                };
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Requesting token from ' +
                    authOptions.authUrl +
                    '; Params: ' +
                    JSON.stringify(authParams) +
                    '; method: ' +
                    (usePost ? 'POST' : 'GET'));
                if (usePost) {
                    /* send body form-encoded */
                    var headers = authHeaders || {};
                    headers['content-type'] = 'application/x-www-form-urlencoded';
                    var body = Utils.toQueryString(authParams).slice(1); /* slice is to remove the initial '?' */
                    _this.client.http.doUri(HttpMethods_1.default.Post, client, authOptions.authUrl, headers, body, providedQsParams, authUrlRequestCallback);
                }
                else {
                    _this.client.http.doUri(HttpMethods_1.default.Get, client, authOptions.authUrl, authHeaders || {}, null, authParams, authUrlRequestCallback);
                }
            };
        }
        else if (authOptions.key) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.requestToken()', 'using token auth with client-side signing');
            tokenRequestCallback = function (params, cb) {
                _this.createTokenRequest(params, authOptions, cb);
            };
        }
        else {
            var msg = 'Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', 'library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help');
            _callback(new errorinfo_1.default(msg, 40171, 403));
            return;
        }
        /* normalise token params */
        if ('capability' in tokenParams)
            tokenParams.capability = c14n(tokenParams.capability);
        var tokenRequest = function (signedTokenParams, tokenCb) {
            var keyName = signedTokenParams.keyName, path = '/keys/' + keyName + '/requestToken', tokenUri = function (host) {
                return client.baseUri(host) + path;
            };
            var requestHeaders = Utils.defaultPostHeaders(_this.client.options);
            if (authOptions.requestHeaders)
                Utils.mixin(requestHeaders, authOptions.requestHeaders);
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Auth.requestToken().requestToken', 'Sending POST to ' + path + '; Token params: ' + JSON.stringify(signedTokenParams));
            _this.client.http.do(HttpMethods_1.default.Post, client, tokenUri, requestHeaders, JSON.stringify(signedTokenParams), null, tokenCb);
        };
        var tokenRequestCallbackTimeoutExpired = false, timeoutLength = this.client.options.timeouts.realtimeRequestTimeout, tokenRequestCallbackTimeout = setTimeout(function () {
            tokenRequestCallbackTimeoutExpired = true;
            var msg = 'Token request callback timed out after ' + timeoutLength / 1000 + ' seconds';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', msg);
            _callback(new errorinfo_1.default(msg, 40170, 401));
        }, timeoutLength);
        tokenRequestCallback(tokenParams, function (err, tokenRequestOrDetails, contentType) {
            if (tokenRequestCallbackTimeoutExpired)
                return;
            clearTimeout(tokenRequestCallbackTimeout);
            if (err) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', 'token request signing call returned error; err = ' + Utils.inspectError(err));
                _callback(normaliseAuthcallbackError(err));
                return;
            }
            /* the response from the callback might be a token string, a signed request or a token details */
            if (typeof tokenRequestOrDetails === 'string') {
                if (tokenRequestOrDetails.length === 0) {
                    _callback(new errorinfo_1.default('Token string is empty', 40170, 401));
                }
                else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {
                    _callback(new errorinfo_1.default('Token string exceeded max permitted length (was ' + tokenRequestOrDetails.length + ' bytes)', 40170, 401));
                }
                else if (tokenRequestOrDetails === 'undefined' || tokenRequestOrDetails === 'null') {
                    /* common failure mode with poorly-implemented authCallbacks */
                    _callback(new errorinfo_1.default('Token string was literal null/undefined', 40170, 401));
                }
                else if (tokenRequestOrDetails[0] === '{' && !(contentType && contentType.indexOf('application/jwt') > -1)) {
                    _callback(new errorinfo_1.default("Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details", 40170, 401));
                }
                else {
                    _callback(null, { token: tokenRequestOrDetails });
                }
                return;
            }
            if (typeof tokenRequestOrDetails !== 'object') {
                var msg = 'Expected token request callback to call back with a token string or token request/details object, but got a ' +
                    typeof tokenRequestOrDetails;
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', msg);
                _callback(new errorinfo_1.default(msg, 40170, 401));
                return;
            }
            var objectSize = JSON.stringify(tokenRequestOrDetails).length;
            if (objectSize > MAX_TOKEN_LENGTH && !authOptions.suppressMaxLengthCheck) {
                _callback(new errorinfo_1.default('Token request/details object exceeded max permitted stringified size (was ' + objectSize + ' bytes)', 40170, 401));
                return;
            }
            if ('issued' in tokenRequestOrDetails) {
                /* a tokenDetails object */
                _callback(null, tokenRequestOrDetails);
                return;
            }
            if (!('keyName' in tokenRequestOrDetails)) {
                var msg = 'Expected token request callback to call back with a token string, token request object, or token details object';
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', msg);
                _callback(new errorinfo_1.default(msg, 40170, 401));
                return;
            }
            /* it's a token request, so make the request */
            tokenRequest(tokenRequestOrDetails, function (err, tokenResponse, headers, unpacked) {
                if (err) {
                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', 'token request API call returned error; err = ' + Utils.inspectError(err));
                    _callback(normaliseAuthcallbackError(err));
                    return;
                }
                if (!unpacked)
                    tokenResponse = JSON.parse(tokenResponse);
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.getToken()', 'token received');
                _callback(null, tokenResponse);
            });
        });
    };
    /**
     * Create and sign a token request based on the given options.
     * NOTE this can only be used when the key value is available locally.
     * Otherwise, signed token requests must be obtained from the key
     * owner (either using the token request callback or url).
     *
     * @param authOptions
     * an object containing the request options:
     * - key:           the key to use. If not specified, a key passed in constructing
     *                  the Rest interface will be used
     *
     * - queryTime      (optional) boolean indicating that the ably system should be
     *                  queried for the current time when none is specified explicitly
     *
     * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
     *                  requestToken request
     *
     * @param tokenParams
     * an object containing the parameters for the requested token:
     * - ttl:       (optional) the requested life of the token in ms. If none is specified
     *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request
     *                  exceeding that lifetime will be rejected with an error.
     *
     * - capability:    (optional) the capability to associate with the access token.
     *                  If none is specified, a token will be requested with all of the
     *                  capabilities of the specified key.
     *
     * - clientId:      (optional) a client ID to associate with the token; if not
     *                  specified, a clientId passed in constructing the Rest interface will be used
     *
     * - timestamp:     (optional) the time in ms since the epoch. If none is specified,
     *                  the system will be queried for a time value to use.
     *
     * @param callback
     */
    Auth.prototype.createTokenRequest = function (tokenParams, authOptions, callback) {
        var _this = this;
        /* shuffle and normalise arguments as necessary */
        if (typeof tokenParams == 'function' && !callback) {
            callback = tokenParams;
            authOptions = tokenParams = null;
        }
        else if (typeof authOptions == 'function' && !callback) {
            callback = authOptions;
            authOptions = null;
        }
        if (!callback && this.client.options.promises) {
            return Utils.promisify(this, 'createTokenRequest', arguments);
        }
        /* RSA9h: if authOptions passed in, they're used instead of stored, don't merge them */
        authOptions = authOptions || this.authOptions;
        tokenParams = tokenParams || Utils.copy(this.tokenParams);
        var key = authOptions.key;
        if (!key) {
            callback(new errorinfo_1.default('No key specified', 40101, 403));
            return;
        }
        var keyParts = key.split(':'), keyName = keyParts[0], keySecret = keyParts[1];
        if (!keySecret) {
            callback(new errorinfo_1.default('Invalid key specified', 40101, 403));
            return;
        }
        if (tokenParams.clientId === '') {
            callback(new errorinfo_1.default('clientId can’t be an empty string', 40012, 400));
            return;
        }
        if ('capability' in tokenParams) {
            tokenParams.capability = c14n(tokenParams.capability);
        }
        var request = Utils.mixin({ keyName: keyName }, tokenParams), clientId = tokenParams.clientId || '', ttl = tokenParams.ttl || '', capability = tokenParams.capability || '';
        (function (authoriseCb) {
            if (request.timestamp) {
                authoriseCb();
                return;
            }
            _this.getTimestamp(authOptions && authOptions.queryTime, function (err, time) {
                if (err) {
                    callback(err);
                    return;
                }
                request.timestamp = time;
                authoriseCb();
            });
        })(function () {
            /* nonce */
            /* NOTE: there is no expectation that the client
             * specifies the nonce; this is done by the library
             * However, this can be overridden by the client
             * simply for testing purposes. */
            var nonce = request.nonce || (request.nonce = random()), timestamp = request.timestamp;
            var signText = request.keyName + '\n' + ttl + '\n' + capability + '\n' + clientId + '\n' + timestamp + '\n' + nonce + '\n';
            /* mac */
            /* NOTE: there is no expectation that the client
             * specifies the mac; this is done by the library
             * However, this can be overridden by the client
             * simply for testing purposes. */
            request.mac = request.mac || hmac(signText, keySecret);
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.getTokenRequest()', 'generated signed request');
            callback(null, request);
        });
    };
    /**
     * Get the auth query params to use for a websocket connection,
     * based on the current auth parameters
     */
    Auth.prototype.getAuthParams = function (callback) {
        if (this.method == 'basic')
            callback(null, { key: this.key });
        else
            this._ensureValidAuthCredentials(false, function (err, tokenDetails) {
                if (err) {
                    callback(err);
                    return;
                }
                if (!tokenDetails) {
                    throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');
                }
                callback(null, { access_token: tokenDetails.token });
            });
    };
    /**
     * Get the authorization header to use for a REST or comet request,
     * based on the current auth parameters
     */
    Auth.prototype.getAuthHeaders = function (callback) {
        if (this.method == 'basic') {
            callback(null, { authorization: 'Basic ' + this.basicKey });
        }
        else {
            this._ensureValidAuthCredentials(false, function (err, tokenDetails) {
                if (err) {
                    callback(err);
                    return;
                }
                if (!tokenDetails) {
                    throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');
                }
                callback(null, { authorization: 'Bearer ' + Utils.toBase64(tokenDetails.token) });
            });
        }
    };
    /**
     * Get the current time based on the local clock,
     * or if the option queryTime is true, return the server time.
     * The server time offset from the local time is stored so that
     * only one request to the server to get the time is ever needed
     */
    Auth.prototype.getTimestamp = function (queryTime, callback) {
        if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {
            this.client.time(callback);
        }
        else {
            callback(null, this.getTimestampUsingOffset());
        }
    };
    Auth.prototype.getTimestampUsingOffset = function () {
        return Utils.now() + (this.client.serverTimeOffset || 0);
    };
    Auth.prototype.isTimeOffsetSet = function () {
        return this.client.serverTimeOffset !== null;
    };
    Auth.prototype._saveBasicOptions = function (authOptions) {
        this.method = 'basic';
        this.key = authOptions.key;
        this.basicKey = Utils.toBase64(authOptions.key);
        this.authOptions = authOptions || {};
        if ('clientId' in authOptions) {
            this._userSetClientId(authOptions.clientId);
        }
    };
    Auth.prototype._saveTokenOptions = function (tokenParams, authOptions) {
        this.method = 'token';
        if (tokenParams) {
            /* We temporarily persist tokenParams.timestamp in case a new token needs
             * to be requested, then null it out in the callback of
             * _ensureValidAuthCredentials for RSA10g compliance */
            this.tokenParams = tokenParams;
        }
        if (authOptions) {
            /* normalise */
            if (authOptions.token) {
                /* options.token may contain a token string or, for convenience, a TokenDetails */
                authOptions.tokenDetails =
                    typeof authOptions.token === 'string'
                        ? { token: authOptions.token }
                        : authOptions.token;
            }
            if (authOptions.tokenDetails) {
                this.tokenDetails = authOptions.tokenDetails;
            }
            if ('clientId' in authOptions) {
                this._userSetClientId(authOptions.clientId);
            }
            this.authOptions = authOptions;
        }
    };
    /* @param forceSupersede: force a new token request even if there's one in
     * progress, making all pending callbacks wait for the new one */
    Auth.prototype._ensureValidAuthCredentials = function (forceSupersede, callback) {
        var _this = this;
        var token = this.tokenDetails;
        if (token) {
            if (this._tokenClientIdMismatch(token.clientId)) {
                /* 403 to trigger a permanently failed client - RSA15c */
                callback(new errorinfo_1.default('Mismatch between clientId in token (' + token.clientId + ') and current clientId (' + this.clientId + ')', 40102, 403));
                return;
            }
            /* RSA4b1 -- if we have a server time offset set already, we can
             * automatically remove expired tokens. Else just use the cached token. If it is
             * expired Ably will tell us and we'll discard it then. */
            if (!this.isTimeOffsetSet() || !token.expires || token.expires >= this.getTimestampUsingOffset()) {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.getToken()', 'using cached token; expires = ' + token.expires);
                callback(null, token);
                return;
            }
            /* expired, so remove and fallthrough to getting a new one */
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.getToken()', 'deleting expired token');
            this.tokenDetails = null;
        }
        (this.waitingForTokenRequest || (this.waitingForTokenRequest = multicaster_1.default.create())).push(callback);
        if (this.currentTokenRequestId !== null && !forceSupersede) {
            return;
        }
        /* Request a new token */
        var tokenRequestId = (this.currentTokenRequestId = getTokenRequestId());
        this.requestToken(this.tokenParams, this.authOptions, function (err, tokenResponse) {
            if (_this.currentTokenRequestId > tokenRequestId) {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth._ensureValidAuthCredentials()', 'Discarding token request response; overtaken by newer one');
                return;
            }
            _this.currentTokenRequestId = null;
            var callbacks = _this.waitingForTokenRequest || noop;
            _this.waitingForTokenRequest = null;
            if (err) {
                callbacks(err);
                return;
            }
            callbacks(null, (_this.tokenDetails = tokenResponse));
        });
    };
    /* User-set: check types, '*' is disallowed, throw any errors */
    Auth.prototype._userSetClientId = function (clientId) {
        if (!(typeof clientId === 'string' || clientId === null)) {
            throw new errorinfo_1.default('clientId must be either a string or null', 40012, 400);
        }
        else if (clientId === '*') {
            throw new errorinfo_1.default('Can’t use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: "*"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: "*"}, authOptions)', 40012, 400);
        }
        else {
            var err = this._uncheckedSetClientId(clientId);
            if (err)
                throw err;
        }
    };
    /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */
    Auth.prototype._uncheckedSetClientId = function (clientId) {
        if (this._tokenClientIdMismatch(clientId)) {
            /* Should never happen in normal circumstances as realtime should
             * recognise mismatch and return an error */
            var msg = 'Unexpected clientId mismatch: client has ' + this.clientId + ', requested ' + clientId;
            var err = new errorinfo_1.default(msg, 40102, 401);
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth._uncheckedSetClientId()', msg);
            return err;
        }
        else {
            /* RSA7a4: if options.clientId is provided and is not
             * null, it overrides defaultTokenParams.clientId */
            this.clientId = this.tokenParams.clientId = clientId;
            return null;
        }
    };
    Auth.prototype._tokenClientIdMismatch = function (tokenClientId) {
        return !!(this.clientId &&
            this.clientId !== '*' &&
            tokenClientId &&
            tokenClientId !== '*' &&
            this.clientId !== tokenClientId);
    };
    Auth.isTokenErr = function (error) {
        return error.code && error.code >= 40140 && error.code < 40150;
    };
    Auth.prototype.revokeTokens = function (specifiers, optionsOrCallbackArg, callbackArg) {
        if (useTokenAuth(this.client.options)) {
            throw new errorinfo_1.default('Cannot revoke tokens when using token auth', 40162, 401);
        }
        var keyName = this.client.options.keyName;
        var resolvedOptions;
        if (typeof optionsOrCallbackArg === 'function') {
            callbackArg = optionsOrCallbackArg;
            resolvedOptions = {};
        }
        else {
            resolvedOptions = optionsOrCallbackArg !== null && optionsOrCallbackArg !== void 0 ? optionsOrCallbackArg : {};
        }
        if (callbackArg === undefined) {
            if (this.client.options.promises) {
                return Utils.promisify(this, 'revokeTokens', [specifiers, resolvedOptions]);
            }
            callbackArg = noop;
        }
        var callback = callbackArg;
        var requestBodyDTO = tslib_1.__assign({ targets: specifiers.map(function (specifier) { return "".concat(specifier.type, ":").concat(specifier.value); }) }, resolvedOptions);
        var format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(this.client.options, format);
        if (this.client.options.headers)
            Utils.mixin(headers, this.client.options.headers);
        var requestBody = Utils.encodeBody(requestBodyDTO, format);
        resource_1.default.post(this.client, "/keys/".concat(keyName, "/revokeTokens"), requestBody, headers, { newBatchResponse: 'true' }, null, function (err, body, headers, unpacked) {
            if (err) {
                // TODO remove this type assertion after fixing https://github.com/ably/ably-js/issues/1405
                callback(err);
                return;
            }
            var batchResult = (unpacked ? body : Utils.decodeBody(body, format));
            callback(null, batchResult);
        });
    };
    return Auth;
}());
exports.default = Auth;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var HttpMethods;
(function (HttpMethods) {
    HttpMethods["Get"] = "get";
    HttpMethods["Delete"] = "delete";
    HttpMethods["Post"] = "post";
    HttpMethods["Put"] = "put";
    HttpMethods["Patch"] = "patch";
})(HttpMethods || (HttpMethods = {}));
exports.default = HttpMethods;


/***/ }),
/* 19 */
/***/ (function(module, exports, __nested_webpack_require_199902__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpPaginatedResponse = exports.PaginatedResult = void 0;
var tslib_1 = __nested_webpack_require_199902__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_199902__(1));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_199902__(2));
var resource_1 = tslib_1.__importDefault(__nested_webpack_require_199902__(14));
function getRelParams(linkUrl) {
    var urlMatch = linkUrl.match(/^\.\/(\w+)\?(.*)$/);
    return urlMatch && urlMatch[2] && Utils.parseQueryString(urlMatch[2]);
}
function parseRelLinks(linkHeader) {
    if (typeof linkHeader == 'string')
        linkHeader = linkHeader.split(',');
    var relParams = {};
    for (var i = 0; i < linkHeader.length; i++) {
        var linkMatch = linkHeader[i].match(/^\s*<(.+)>;\s*rel="(\w+)"$/);
        if (linkMatch) {
            var params = getRelParams(linkMatch[1]);
            if (params)
                relParams[linkMatch[2]] = params;
        }
    }
    return relParams;
}
function returnErrOnly(err, body, useHPR) {
    /* If using httpPaginatedResponse, errors from Ably are returned as part of
     * the HPR, only do callback(err) for network errors etc. which don't
     * return a body and/or have no ably-originated error code (non-numeric
     * error codes originate from node) */
    return !(useHPR && (body || typeof err.code === 'number'));
}
var PaginatedResource = /** @class */ (function () {
    function PaginatedResource(rest, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {
        this.rest = rest;
        this.path = path;
        this.headers = headers;
        this.envelope = envelope !== null && envelope !== void 0 ? envelope : null;
        this.bodyHandler = bodyHandler;
        this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;
    }
    PaginatedResource.prototype.get = function (params, callback) {
        var _this = this;
        resource_1.default.get(this.rest, this.path, this.headers, params, this.envelope, function (err, body, headers, unpacked, statusCode) {
            _this.handlePage(err, body, headers, unpacked, statusCode, callback);
        });
    };
    PaginatedResource.prototype.delete = function (params, callback) {
        var _this = this;
        resource_1.default.delete(this.rest, this.path, this.headers, params, this.envelope, function (err, body, headers, unpacked, statusCode) {
            _this.handlePage(err, body, headers, unpacked, statusCode, callback);
        });
    };
    PaginatedResource.prototype.post = function (params, body, callback) {
        var _this = this;
        resource_1.default.post(this.rest, this.path, body, this.headers, params, this.envelope, function (err, responseBody, headers, unpacked, statusCode) {
            if (callback) {
                _this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);
            }
        });
    };
    PaginatedResource.prototype.put = function (params, body, callback) {
        var _this = this;
        resource_1.default.put(this.rest, this.path, body, this.headers, params, this.envelope, function (err, responseBody, headers, unpacked, statusCode) {
            if (callback) {
                _this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);
            }
        });
    };
    PaginatedResource.prototype.patch = function (params, body, callback) {
        var _this = this;
        resource_1.default.patch(this.rest, this.path, body, this.headers, params, this.envelope, function (err, responseBody, headers, unpacked, statusCode) {
            if (callback) {
                _this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);
            }
        });
    };
    PaginatedResource.prototype.handlePage = function (err, body, headers, unpacked, statusCode, callback) {
        if (err && returnErrOnly(err, body, this.useHttpPaginatedResponse)) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'PaginatedResource.handlePage()', 'Unexpected error getting resource: err = ' + Utils.inspectError(err));
            callback === null || callback === void 0 ? void 0 : callback(err);
            return;
        }
        var items, linkHeader, relParams;
        try {
            items = this.bodyHandler(body, headers || {}, unpacked);
        }
        catch (e) {
            /* If we got an error, the failure to parse the body is almost certainly
             * due to that, so callback with that in preference over the parse error */
            callback === null || callback === void 0 ? void 0 : callback(err || e);
            return;
        }
        if (headers && (linkHeader = headers['Link'] || headers['link'])) {
            relParams = parseRelLinks(linkHeader);
        }
        if (this.useHttpPaginatedResponse) {
            callback(null, new HttpPaginatedResponse(this, items, headers || {}, statusCode, relParams, err));
        }
        else {
            callback(null, new PaginatedResult(this, items, relParams));
        }
    };
    return PaginatedResource;
}());
var PaginatedResult = /** @class */ (function () {
    function PaginatedResult(resource, items, relParams) {
        var _this = this;
        this.resource = resource;
        this.items = items;
        var self = this;
        if (relParams) {
            if ('first' in relParams) {
                this.first = function (callback) {
                    if (!callback && self.resource.rest.options.promises) {
                        return Utils.promisify(self, 'first', []);
                    }
                    self.get(relParams.first, callback);
                };
            }
            if ('current' in relParams) {
                this.current = function (callback) {
                    if (!callback && self.resource.rest.options.promises) {
                        return Utils.promisify(self, 'current', []);
                    }
                    self.get(relParams.current, callback);
                };
            }
            this.next = function (callback) {
                if (!callback && self.resource.rest.options.promises) {
                    return Utils.promisify(self, 'next', []);
                }
                if ('next' in relParams) {
                    self.get(relParams.next, callback);
                }
                else {
                    callback(null);
                }
            };
            this.hasNext = function () {
                return 'next' in relParams;
            };
            this.isLast = function () {
                var _a;
                return !((_a = _this.hasNext) === null || _a === void 0 ? void 0 : _a.call(_this));
            };
        }
    }
    /* We assume that only the initial request can be a POST, and that accessing
     * the rest of a multipage set of results can always be done with GET */
    PaginatedResult.prototype.get = function (params, callback) {
        var res = this.resource;
        resource_1.default.get(res.rest, res.path, res.headers, params, res.envelope, function (err, body, headers, unpacked, statusCode) {
            res.handlePage(err, body, headers, unpacked, statusCode, callback);
        });
    };
    return PaginatedResult;
}());
exports.PaginatedResult = PaginatedResult;
var HttpPaginatedResponse = /** @class */ (function (_super) {
    tslib_1.__extends(HttpPaginatedResponse, _super);
    function HttpPaginatedResponse(resource, items, headers, statusCode, relParams, err) {
        var _this = _super.call(this, resource, items, relParams) || this;
        _this.statusCode = statusCode;
        _this.success = statusCode < 300 && statusCode >= 200;
        _this.headers = headers;
        _this.errorCode = err && err.code;
        _this.errorMessage = err && err.message;
        return _this;
    }
    HttpPaginatedResponse.prototype.toJSON = function () {
        return {
            items: this.items,
            statusCode: this.statusCode,
            success: this.success,
            headers: this.headers,
            errorCode: this.errorCode,
            errorMessage: this.errorMessage,
        };
    };
    return HttpPaginatedResponse;
}(PaginatedResult));
exports.HttpPaginatedResponse = HttpPaginatedResponse;
exports.default = PaginatedResource;


/***/ }),
/* 20 */
/***/ (function(module, exports, __nested_webpack_require_208317__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isRetriable = void 0;
var tslib_1 = __nested_webpack_require_208317__(0);
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_208317__(4));
var ConnectionErrorCodes = {
    DISCONNECTED: 80003,
    SUSPENDED: 80002,
    FAILED: 80000,
    CLOSING: 80017,
    CLOSED: 80017,
    UNKNOWN_CONNECTION_ERR: 50002,
    UNKNOWN_CHANNEL_ERR: 50001,
};
var ConnectionErrors = {
    disconnected: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 400,
            code: ConnectionErrorCodes.DISCONNECTED,
            message: 'Connection to server temporarily unavailable',
        });
    },
    suspended: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 400,
            code: ConnectionErrorCodes.SUSPENDED,
            message: 'Connection to server unavailable',
        });
    },
    failed: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 400,
            code: ConnectionErrorCodes.FAILED,
            message: 'Connection failed or disconnected by server',
        });
    },
    closing: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 400,
            code: ConnectionErrorCodes.CLOSING,
            message: 'Connection closing',
        });
    },
    closed: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 400,
            code: ConnectionErrorCodes.CLOSED,
            message: 'Connection closed',
        });
    },
    unknownConnectionErr: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 500,
            code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,
            message: 'Internal connection error',
        });
    },
    unknownChannelErr: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 500,
            code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,
            message: 'Internal channel error',
        });
    },
};
function isRetriable(err) {
    if (!err.statusCode || !err.code || err.statusCode >= 500) {
        return true;
    }
    return Object.values(ConnectionErrorCodes).includes(err.code);
}
exports.isRetriable = isRetriable;
exports.default = ConnectionErrors;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var XHRStates;
(function (XHRStates) {
    XHRStates[XHRStates["REQ_SEND"] = 0] = "REQ_SEND";
    XHRStates[XHRStates["REQ_RECV"] = 1] = "REQ_RECV";
    XHRStates[XHRStates["REQ_RECV_POLL"] = 2] = "REQ_RECV_POLL";
    XHRStates[XHRStates["REQ_RECV_STREAM"] = 3] = "REQ_RECV_STREAM";
})(XHRStates || (XHRStates = {}));
exports.default = XHRStates;


/***/ }),
/* 22 */
/***/ (function(module, exports, __nested_webpack_require_211239__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_211239__(6), __nested_webpack_require_211239__(5), __nested_webpack_require_211239__(58), __nested_webpack_require_211239__(11), __nested_webpack_require_211239__(40), __nested_webpack_require_211239__(32), __nested_webpack_require_211239__(24), __nested_webpack_require_211239__(27), __nested_webpack_require_211239__(28), __nested_webpack_require_211239__(59), __nested_webpack_require_211239__(60));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS;

}));

/***/ }),
/* 23 */
/***/ (function(module, exports, __nested_webpack_require_211750__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_211750__(0);
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_211750__(2));
var Multicaster = /** @class */ (function () {
    // Private constructor; use static Multicaster.create instead
    function Multicaster(members) {
        this.members = members || [];
    }
    Multicaster.prototype.call = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        for (var _a = 0, _b = this.members; _a < _b.length; _a++) {
            var member = _b[_a];
            if (member) {
                try {
                    member.apply(void 0, args);
                }
                catch (e) {
                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Multicaster multiple callback handler', 'Unexpected exception: ' + e + '; stack = ' + e.stack);
                }
            }
        }
    };
    Multicaster.prototype.push = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        (_a = this.members).push.apply(_a, args);
    };
    Multicaster.create = function (members) {
        var instance = new Multicaster(members);
        return Object.assign(function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return instance.call.apply(instance, args);
        }, {
            push: function (fn) { return instance.push(fn); },
        });
    };
    return Multicaster;
}());
exports.default = Multicaster;


/***/ }),
/* 24 */
/***/ (function(module, exports, __nested_webpack_require_213579__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_213579__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isSuccessCode = void 0;
var HttpStatusCodes;
(function (HttpStatusCodes) {
    HttpStatusCodes[HttpStatusCodes["Success"] = 200] = "Success";
    HttpStatusCodes[HttpStatusCodes["NoContent"] = 204] = "NoContent";
    HttpStatusCodes[HttpStatusCodes["BadRequest"] = 400] = "BadRequest";
    HttpStatusCodes[HttpStatusCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpStatusCodes[HttpStatusCodes["Forbidden"] = 403] = "Forbidden";
    HttpStatusCodes[HttpStatusCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpStatusCodes[HttpStatusCodes["InternalServerError"] = 500] = "InternalServerError";
})(HttpStatusCodes || (HttpStatusCodes = {}));
function isSuccessCode(statusCode) {
    return statusCode >= HttpStatusCodes.Success && statusCode < HttpStatusCodes.BadRequest;
}
exports.isSuccessCode = isSuccessCode;
exports.default = HttpStatusCodes;


/***/ }),
/* 26 */
/***/ (function(module, exports, __nested_webpack_require_218497__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_218497__(0);
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_218497__(10));
var Utils = tslib_1.__importStar(__nested_webpack_require_218497__(1));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_218497__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_218497__(2));
var connectionerrors_1 = tslib_1.__importDefault(__nested_webpack_require_218497__(20));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_218497__(4));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_218497__(3));
var actions = protocolmessage_1.default.Action;
var closeMessage = protocolmessage_1.default.fromValues({ action: actions.CLOSE });
var disconnectMessage = protocolmessage_1.default.fromValues({ action: actions.DISCONNECT });
/*
 * Transport instances inherit from EventEmitter and emit the following events:
 *
 * event name       data
 * closed           error
 * failed           error
 * disposed
 * connected        null error, connectionSerial, connectionId, connectionDetails
 * event            channel message object
 */
var Transport = /** @class */ (function (_super) {
    tslib_1.__extends(Transport, _super);
    function Transport(connectionManager, auth, params, forceJsonProtocol) {
        var _this = _super.call(this) || this;
        if (forceJsonProtocol) {
            params.format = undefined;
            params.heartbeats = true;
        }
        _this.connectionManager = connectionManager;
        connectionManager.registerProposedTransport(_this);
        _this.auth = auth;
        _this.params = params;
        _this.timeouts = params.options.timeouts;
        _this.format = params.format;
        _this.isConnected = false;
        _this.isFinished = false;
        _this.isDisposed = false;
        _this.maxIdleInterval = null;
        _this.idleTimer = null;
        _this.lastActivity = null;
        return _this;
    }
    Transport.prototype.connect = function () { };
    Transport.prototype.close = function () {
        if (this.isConnected) {
            this.requestClose();
        }
        this.finish('closed', connectionerrors_1.default.closed());
    };
    Transport.prototype.disconnect = function (err) {
        /* Used for network/transport issues that need to result in the transport
         * being disconnected, but should not transition the connection to 'failed' */
        if (this.isConnected) {
            this.requestDisconnect();
        }
        this.finish('disconnected', err || connectionerrors_1.default.disconnected());
    };
    Transport.prototype.fail = function (err) {
        /* Used for client-side-detected fatal connection issues */
        if (this.isConnected) {
            this.requestDisconnect();
        }
        this.finish('failed', err || connectionerrors_1.default.failed());
    };
    Transport.prototype.finish = function (event, err) {
        var _a;
        if (this.isFinished) {
            return;
        }
        this.isFinished = true;
        this.isConnected = false;
        this.maxIdleInterval = null;
        clearTimeout((_a = this.idleTimer) !== null && _a !== void 0 ? _a : undefined);
        this.idleTimer = null;
        this.emit(event, err);
        this.dispose();
    };
    Transport.prototype.onProtocolMessage = function (message) {
        if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Transport.onProtocolMessage()', 'received on ' +
                this.shortName +
                ': ' +
                protocolmessage_1.default.stringify(message) +
                '; connectionId = ' +
                this.connectionManager.connectionId);
        }
        this.onActivity();
        switch (message.action) {
            case actions.HEARTBEAT:
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Transport.onProtocolMessage()', this.shortName + ' heartbeat; connectionId = ' + this.connectionManager.connectionId);
                this.emit('heartbeat', message.id);
                break;
            case actions.CONNECTED:
                this.onConnect(message);
                this.emit('connected', message.error, message.connectionId, message.connectionDetails, message);
                break;
            case actions.CLOSED:
                this.onClose(message);
                break;
            case actions.DISCONNECTED:
                this.onDisconnect(message);
                break;
            case actions.ACK:
                this.emit('ack', message.msgSerial, message.count);
                break;
            case actions.NACK:
                this.emit('nack', message.msgSerial, message.count, message.error);
                break;
            case actions.SYNC:
                this.connectionManager.onChannelMessage(message, this);
                break;
            case actions.ACTIVATE:
                // Ignored.
                break;
            case actions.AUTH:
                this.auth.authorize(function (err) {
                    if (err) {
                        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Transport.onProtocolMessage()', 'Ably requested re-authentication, but unable to obtain a new token: ' + Utils.inspectError(err));
                    }
                });
                break;
            case actions.ERROR:
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.onProtocolMessage()', 'received error action; connectionId = ' +
                    this.connectionManager.connectionId +
                    '; err = ' +
                    platform_1.default.Config.inspect(message.error) +
                    (message.channel ? ', channel: ' + message.channel : ''));
                if (message.channel === undefined) {
                    this.onFatalError(message);
                    break;
                }
                /* otherwise it's a channel-specific error, so handle it in the channel */
                this.connectionManager.onChannelMessage(message, this);
                break;
            default:
                /* all other actions are channel-specific */
                this.connectionManager.onChannelMessage(message, this);
        }
    };
    Transport.prototype.onConnect = function (message) {
        this.isConnected = true;
        if (!message.connectionDetails) {
            throw new Error('Transport.onConnect(): Connect message recieved without connectionDetails');
        }
        var maxPromisedIdle = message.connectionDetails.maxIdleInterval;
        if (maxPromisedIdle) {
            this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;
            this.onActivity();
        }
        /* else Realtime declines to guarantee any maximum idle interval - CD2h */
    };
    Transport.prototype.onDisconnect = function (message) {
        /* Used for when the server has disconnected the client (usually with a
         * DISCONNECTED action) */
        var err = message && message.error;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.onDisconnect()', 'err = ' + Utils.inspectError(err));
        this.finish('disconnected', err);
    };
    Transport.prototype.onFatalError = function (message) {
        /* On receipt of a fatal connection error, we can assume that the server
         * will close the connection and the transport, and do not need to request
         * a disconnection - RTN15i */
        var err = message && message.error;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.onFatalError()', 'err = ' + Utils.inspectError(err));
        this.finish('failed', err);
    };
    Transport.prototype.onClose = function (message) {
        var err = message && message.error;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.onClose()', 'err = ' + Utils.inspectError(err));
        this.finish('closed', err);
    };
    Transport.prototype.requestClose = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.requestClose()', '');
        this.send(closeMessage);
    };
    Transport.prototype.requestDisconnect = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.requestDisconnect()', '');
        this.send(disconnectMessage);
    };
    Transport.prototype.ping = function (id) {
        var msg = { action: protocolmessage_1.default.Action.HEARTBEAT };
        if (id)
            msg.id = id;
        this.send(protocolmessage_1.default.fromValues(msg));
    };
    Transport.prototype.dispose = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.dispose()', '');
        this.isDisposed = true;
        this.off();
    };
    Transport.prototype.onActivity = function () {
        if (!this.maxIdleInterval) {
            return;
        }
        this.lastActivity = this.connectionManager.lastActivity = Utils.now();
        this.setIdleTimer(this.maxIdleInterval + 100);
    };
    Transport.prototype.setIdleTimer = function (timeout) {
        var _this = this;
        if (!this.idleTimer) {
            this.idleTimer = setTimeout(function () {
                _this.onIdleTimerExpire();
            }, timeout);
        }
    };
    Transport.prototype.onIdleTimerExpire = function () {
        if (!this.lastActivity || !this.maxIdleInterval) {
            throw new Error('Transport.onIdleTimerExpire(): lastActivity/maxIdleInterval not set');
        }
        this.idleTimer = null;
        var sinceLast = Utils.now() - this.lastActivity;
        var timeRemaining = this.maxIdleInterval - sinceLast;
        if (timeRemaining <= 0) {
            var msg = 'No activity seen from realtime in ' + sinceLast + 'ms; assuming connection has dropped';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Transport.onIdleTimerExpire()', msg);
            this.disconnect(new errorinfo_1.default(msg, 80003, 408));
        }
        else {
            this.setIdleTimer(timeRemaining + 100);
        }
    };
    Transport.tryConnect = function (transportCtor, connectionManager, auth, transportParams, callback) {
        var transport = new transportCtor(connectionManager, auth, transportParams);
        var transportAttemptTimer;
        var errorCb = function (err) {
            clearTimeout(transportAttemptTimer);
            callback({ event: this.event, error: err });
        };
        var realtimeRequestTimeout = connectionManager.options.timeouts.realtimeRequestTimeout;
        transportAttemptTimer = setTimeout(function () {
            transport.off(['preconnect', 'disconnected', 'failed']);
            transport.dispose();
            errorCb.call({ event: 'disconnected' }, new errorinfo_1.default('Timeout waiting for transport to indicate itself viable', 50000, 500));
        }, realtimeRequestTimeout);
        transport.on(['failed', 'disconnected'], errorCb);
        transport.on('preconnect', function () {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.tryConnect()', 'viable transport ' + transport);
            clearTimeout(transportAttemptTimer);
            transport.off(['failed', 'disconnected'], errorCb);
            callback(null, transport);
        });
        transport.connect();
    };
    return Transport;
}(eventemitter_1.default));
exports.default = Transport;


/***/ }),
/* 27 */
/***/ (function(module, exports, __nested_webpack_require_230082__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_230082__(6), __nested_webpack_require_230082__(40), __nested_webpack_require_230082__(24));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            var block;

	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));

/***/ }),
/* 28 */
/***/ (function(module, exports, __nested_webpack_require_233971__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_233971__(6), __nested_webpack_require_233971__(27));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            var block;

	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            var modeCreator;

	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            var finalProcessedBlocks;

	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            var wordArray;

	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            var salt;

	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));

/***/ }),
/* 29 */
/***/ (function(module, exports, __nested_webpack_require_263517__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Request = exports.createRequest = void 0;
var tslib_1 = __nested_webpack_require_263517__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_263517__(1));
var comettransport_1 = tslib_1.__importDefault(__nested_webpack_require_263517__(12));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_263517__(3));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_263517__(7));
var errorinfo_1 = __nested_webpack_require_263517__(4);
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_263517__(8));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_263517__(2));
var XHRStates_1 = tslib_1.__importDefault(__nested_webpack_require_263517__(21));
// Workaround for salesforce lightning locker compatibility
var globalObject = Utils.getGlobalObject();
var noop = function () { };
/* Can't just use window.Ably, as that won't exist if using the commonjs version. */
var _ = (globalObject._ablyjs_jsonp = {});
/* express strips out parantheses from the callback!
 * Kludge to still alow its responses to work, while not keeping the
 * function form for normal use and not cluttering window.Ably
 * https://github.com/expressjs/express/blob/5b4d4b4ab1324743534fbcd4709f4e75bb4b4e9d/lib/response.js#L305
 */
_._ = function (id) {
    return _['_' + id] || noop;
};
var idCounter = 1;
var shortName = 'jsonp';
function createRequest(uri, headers, params, body, requestMode, timeouts, method) {
    /* JSONP requests are used either with the context being a realtime
     * transport, or with timeouts passed in (for when used by a rest client),
     * or completely standalone.  Use the appropriate timeouts in each case */
    timeouts = timeouts || defaults_1.default.TIMEOUTS;
    return new Request(undefined, uri, headers, Utils.copy(params), body, requestMode, timeouts, method);
}
exports.createRequest = createRequest;
var JSONPTransport = /** @class */ (function (_super) {
    tslib_1.__extends(JSONPTransport, _super);
    function JSONPTransport(connectionManager, auth, params) {
        var _this = _super.call(this, connectionManager, auth, params) || this;
        _this.shortName = shortName;
        params.stream = false;
        return _this;
    }
    JSONPTransport.isAvailable = function () {
        return platform_1.default.Config.jsonpSupported && platform_1.default.Config.allowComet;
    };
    JSONPTransport.prototype.toString = function () {
        return 'JSONPTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
    };
    JSONPTransport.prototype.createRequest = function (uri, headers, params, body, requestMode, timeouts, method) {
        /* JSONP requests are used either with the context being a realtime
         * transport, or with timeouts passed in (for when used by a rest client),
         * or completely standalone.  Use the appropriate timeouts in each case */
        timeouts = (this === null || this === void 0 ? void 0 : this.timeouts) || timeouts || defaults_1.default.TIMEOUTS;
        return createRequest(uri, headers, params, body, requestMode, timeouts, method);
    };
    return JSONPTransport;
}(comettransport_1.default));
var Request = /** @class */ (function (_super) {
    tslib_1.__extends(Request, _super);
    function Request(id, uri, headers, params, body, requestMode, timeouts, method) {
        var _this = _super.call(this) || this;
        if (id === undefined)
            id = idCounter++;
        _this.id = id;
        _this.uri = uri;
        _this.params = params || {};
        _this.params.rnd = Utils.cheapRandStr();
        if (headers) {
            /* JSONP doesn't allow headers. Cherry-pick a couple to turn into qs params */
            if (headers['X-Ably-Version'])
                _this.params.v = headers['X-Ably-Version'];
            if (headers['X-Ably-Lib'])
                _this.params.lib = headers['X-Ably-Lib'];
        }
        _this.body = body;
        _this.method = method;
        _this.requestMode = requestMode;
        _this.timeouts = timeouts;
        _this.requestComplete = false;
        return _this;
    }
    Request.prototype.exec = function () {
        var _this = this;
        var id = this.id, body = this.body, method = this.method, uri = this.uri, params = this.params;
        params.callback = '_ablyjs_jsonp._(' + id + ')';
        params.envelope = 'jsonp';
        if (body) {
            params.body = body;
        }
        if (method && method !== 'get') {
            params.method = method;
        }
        var script = (this.script = document.createElement('script'));
        var src = uri + Utils.toQueryString(params);
        script.src = src;
        if (script.src.split('/').slice(-1)[0] !== src.split('/').slice(-1)[0]) {
            /* The src has been truncated. Can't abort, but can at least emit an
             * error so the user knows what's gone wrong. (Can't compare strings
             * directly as src may have a port, script.src won't) */
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'JSONP Request.exec()', 'Warning: the browser appears to have truncated the script URI. This will likely result in the request failing due to an unparseable body param');
        }
        script.async = true;
        script.type = 'text/javascript';
        script.charset = 'UTF-8';
        script.onerror = function (err) {
            _this.complete(new errorinfo_1.PartialErrorInfo('JSONP script error (event: ' + platform_1.default.Config.inspect(err) + ')', null, 400));
        };
        _['_' + id] = function (message) {
            if (message.statusCode) {
                /* Handle as enveloped jsonp, as all jsonp transport uses should be */
                var response = message.response;
                if (message.statusCode == 204) {
                    _this.complete(null, null, null, message.statusCode);
                }
                else if (!response) {
                    _this.complete(new errorinfo_1.PartialErrorInfo('Invalid server response: no envelope detected', null, 500));
                }
                else if (message.statusCode < 400 || Utils.isArray(response)) {
                    /* If response is an array, it's an array of protocol messages -- even if
                     * it contains an error action (hence the nonsuccess statuscode), we can
                     * consider the request to have succeeded, just pass it on to
                     * onProtocolMessage to decide what to do */
                    _this.complete(null, response, message.headers, message.statusCode);
                }
                else {
                    var err = response.error || new errorinfo_1.PartialErrorInfo('Error response received from server', null, message.statusCode);
                    _this.complete(err);
                }
            }
            else {
                /* Handle as non-enveloped -- as will be eg from a customer's authUrl server */
                _this.complete(null, message);
            }
        };
        var timeout = this.requestMode == XHRStates_1.default.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout;
        this.timer = setTimeout(this.abort.bind(this), timeout);
        var head = document.getElementsByTagName('head')[0];
        head.insertBefore(script, head.firstChild);
    };
    Request.prototype.complete = function (err, body, headers, statusCode) {
        headers = headers || {};
        if (!this.requestComplete) {
            this.requestComplete = true;
            var contentType = void 0;
            if (body) {
                contentType = typeof body == 'string' ? 'text/plain' : 'application/json';
                headers['content-type'] = contentType;
                this.emit('data', body);
            }
            this.emit('complete', err, body, headers, /* unpacked: */ true, statusCode);
            this.dispose();
        }
    };
    Request.prototype.abort = function () {
        this.dispose();
    };
    Request.prototype.dispose = function () {
        var timer = this.timer;
        if (timer) {
            clearTimeout(timer);
            this.timer = null;
        }
        var script = this.script;
        if (script.parentNode)
            script.parentNode.removeChild(script);
        delete _[this.id];
        this.emit('disposed');
    };
    return Request;
}(eventemitter_1.default));
exports.Request = Request;
function default_1(connectionManager) {
    globalObject.JSONPTransport = JSONPTransport;
    if (JSONPTransport.isAvailable()) {
        connectionManager.supportedTransports[shortName] = JSONPTransport;
    }
    return JSONPTransport;
}
exports.default = default_1;


/***/ }),
/* 30 */
/***/ (function(module, exports, __nested_webpack_require_272270__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_272270__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_272270__(1));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(2));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(8));
var auth_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(17));
var push_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(46));
var paginatedresource_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(19));
var channel_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(33));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(4));
var stats_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(49));
var HttpMethods_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(18));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(3));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(9));
var presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(15));
var resource_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(14));
var noop = function () { };
var Rest = /** @class */ (function () {
    function Rest(options) {
        if (!options) {
            var msg = 'no options provided';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Rest()', msg);
            throw new Error(msg);
        }
        var optionsObj = defaults_1.default.objectifyOptions(options);
        if (optionsObj.log) {
            logger_1.default.setLog(optionsObj.log.level, optionsObj.log.handler);
        }
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Rest()', 'initialized with clientOptions ' + platform_1.default.Config.inspect(options));
        var normalOptions = (this.options = defaults_1.default.normaliseOptions(optionsObj));
        /* process options */
        if (normalOptions.key) {
            var keyMatch = normalOptions.key.match(/^([^:\s]+):([^:.\s]+)$/);
            if (!keyMatch) {
                var msg = 'invalid key parameter';
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Rest()', msg);
                throw new errorinfo_1.default(msg, 40400, 404);
            }
            normalOptions.keyName = keyMatch[1];
            normalOptions.keySecret = keyMatch[2];
        }
        if ('clientId' in normalOptions) {
            if (!(typeof normalOptions.clientId === 'string' || normalOptions.clientId === null))
                throw new errorinfo_1.default('clientId must be either a string or null', 40012, 400);
            else if (normalOptions.clientId === '*')
                throw new errorinfo_1.default('Can’t use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: "*"}})', 40012, 400);
        }
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Rest()', 'started; version = ' + defaults_1.default.version);
        this.baseUri = this.authority = function (host) {
            return defaults_1.default.getHttpScheme(normalOptions) + host + ':' + defaults_1.default.getPort(normalOptions, false);
        };
        this._currentFallback = null;
        this.serverTimeOffset = null;
        this.http = new platform_1.default.Http(normalOptions);
        this.auth = new auth_1.default(this, normalOptions);
        this.channels = new Channels(this);
        this.push = new push_1.default(this);
    }
    Rest.prototype.stats = function (params, callback) {
        /* params and callback are optional; see if params contains the callback */
        if (callback === undefined) {
            if (typeof params == 'function') {
                callback = params;
                params = null;
            }
            else {
                if (this.options.promises) {
                    return Utils.promisify(this, 'stats', [params]);
                }
                callback = noop;
            }
        }
        var headers = Utils.defaultGetHeaders(this.options), format = this.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.http.supportsLinkHeaders ? undefined : format;
        if (this.options.headers)
            Utils.mixin(headers, this.options.headers);
        new paginatedresource_1.default(this, '/stats', headers, envelope, function (body, headers, unpacked) {
            var statsValues = unpacked ? body : JSON.parse(body);
            for (var i = 0; i < statsValues.length; i++)
                statsValues[i] = stats_1.default.fromValues(statsValues[i]);
            return statsValues;
        }).get(params, callback);
    };
    Rest.prototype.time = function (params, callback) {
        var _this = this;
        /* params and callback are optional; see if params contains the callback */
        if (callback === undefined) {
            if (typeof params == 'function') {
                callback = params;
                params = null;
            }
            else {
                if (this.options.promises) {
                    return Utils.promisify(this, 'time', [params]);
                }
            }
        }
        var _callback = callback || noop;
        var headers = Utils.defaultGetHeaders(this.options);
        if (this.options.headers)
            Utils.mixin(headers, this.options.headers);
        var timeUri = function (host) {
            return _this.authority(host) + '/time';
        };
        this.http.do(HttpMethods_1.default.Get, this, timeUri, headers, null, params, function (err, res, headers, unpacked) {
            if (err) {
                _callback(err);
                return;
            }
            if (!unpacked)
                res = JSON.parse(res);
            var time = res[0];
            if (!time) {
                _callback(new errorinfo_1.default('Internal error (unexpected result type from GET /time)', 50000, 500));
                return;
            }
            /* calculate time offset only once for this device by adding to the prototype */
            _this.serverTimeOffset = time - Utils.now();
            _callback(null, time);
        });
    };
    Rest.prototype.request = function (method, path, params, body, customHeaders, callback) {
        var useBinary = this.options.useBinaryProtocol, encoder = useBinary ? platform_1.default.Config.msgpack.encode : JSON.stringify, decoder = useBinary ? platform_1.default.Config.msgpack.decode : JSON.parse, format = useBinary ? Utils.Format.msgpack : Utils.Format.json, envelope = this.http.supportsLinkHeaders ? undefined : format;
        params = params || {};
        var _method = method.toLowerCase();
        var headers = _method == 'get' ? Utils.defaultGetHeaders(this.options, format) : Utils.defaultPostHeaders(this.options, format);
        if (callback === undefined) {
            if (this.options.promises) {
                return Utils.promisify(this, 'request', [method, path, params, body, customHeaders]);
            }
            callback = noop;
        }
        if (typeof body !== 'string') {
            body = encoder(body);
        }
        if (this.options.headers) {
            Utils.mixin(headers, this.options.headers);
        }
        if (customHeaders) {
            Utils.mixin(headers, customHeaders);
        }
        var paginatedResource = new paginatedresource_1.default(this, path, headers, envelope, function (resbody, headers, unpacked) {
            return Utils.ensureArray(unpacked ? resbody : decoder(resbody));
        }, 
        /* useHttpPaginatedResponse: */ true);
        if (!Utils.arrIn(platform_1.default.Http.methods, _method)) {
            throw new errorinfo_1.default('Unsupported method ' + _method, 40500, 405);
        }
        if (Utils.arrIn(platform_1.default.Http.methodsWithBody, _method)) {
            paginatedResource[_method](params, body, callback);
        }
        else {
            paginatedResource[_method](params, callback);
        }
    };
    Rest.prototype.batchPublish = function (specOrSpecs, callbackArg) {
        if (callbackArg === undefined) {
            if (this.options.promises) {
                return Utils.promisify(this, 'batchPublish', [specOrSpecs]);
            }
            callbackArg = noop;
        }
        var callback = callbackArg;
        var requestBodyDTO;
        var singleSpecMode;
        if (Utils.isArray(specOrSpecs)) {
            requestBodyDTO = specOrSpecs;
            singleSpecMode = false;
        }
        else {
            requestBodyDTO = [specOrSpecs];
            singleSpecMode = true;
        }
        var format = this.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(this.options, format);
        if (this.options.headers)
            Utils.mixin(headers, this.options.headers);
        var requestBody = Utils.encodeBody(requestBodyDTO, format);
        resource_1.default.post(this, '/messages', requestBody, headers, { newBatchResponse: 'true' }, null, function (err, body, headers, unpacked) {
            if (err) {
                // TODO remove this type assertion after fixing https://github.com/ably/ably-js/issues/1405
                callback(err);
                return;
            }
            var batchResults = (unpacked ? body : Utils.decodeBody(body, format));
            // I don't love the below type assertions for `callback` but not sure how to avoid them
            if (singleSpecMode) {
                callback(null, batchResults[0]);
            }
            else {
                callback(null, batchResults);
            }
        });
    };
    Rest.prototype.batchPresence = function (channels, callbackArg) {
        if (callbackArg === undefined) {
            if (this.options.promises) {
                return Utils.promisify(this, 'batchPresence', [channels]);
            }
            callbackArg = noop;
        }
        var callback = callbackArg;
        var format = this.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(this.options, format);
        if (this.options.headers)
            Utils.mixin(headers, this.options.headers);
        var channelsParam = channels.join(',');
        resource_1.default.get(this, '/presence', headers, { newBatchResponse: 'true', channels: channelsParam }, null, function (err, body, headers, unpacked) {
            if (err) {
                // TODO remove this type assertion after fixing https://github.com/ably/ably-js/issues/1405
                callback(err);
                return;
            }
            var batchResult = (unpacked ? body : Utils.decodeBody(body, format));
            callback(null, batchResult);
        });
    };
    Rest.prototype.setLog = function (logOptions) {
        logger_1.default.setLog(logOptions.level, logOptions.handler);
    };
    Rest.Promise = function (options) {
        options = defaults_1.default.objectifyOptions(options);
        options.promises = true;
        return new Rest(options);
    };
    Rest.Callbacks = Rest;
    Rest.Platform = platform_1.default;
    Rest.Message = message_1.default;
    Rest.PresenceMessage = presencemessage_1.default;
    return Rest;
}());
var Channels = /** @class */ (function () {
    function Channels(rest) {
        this.rest = rest;
        this.all = Object.create(null);
    }
    Channels.prototype.get = function (name, channelOptions) {
        name = String(name);
        var channel = this.all[name];
        if (!channel) {
            this.all[name] = channel = new channel_1.default(this.rest, name, channelOptions);
        }
        else if (channelOptions) {
            channel.setOptions(channelOptions);
        }
        return channel;
    };
    /* Included to support certain niche use-cases; most users should ignore this.
     * Please do not use this unless you know what you're doing */
    Channels.prototype.release = function (name) {
        delete this.all[String(name)];
    };
    return Channels;
}());
exports.default = Rest;


/***/ }),
/* 31 */
/***/ (function(module, exports, __nested_webpack_require_284415__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_284415__(6));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Utf8;

}));

/***/ }),
/* 32 */
/***/ (function(module, exports, __nested_webpack_require_284686__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_284686__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));

/***/ }),
/* 33 */
/***/ (function(module, exports, __nested_webpack_require_290135__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_290135__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_290135__(1));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(2));
var presence_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(34));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(9));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(4));
var paginatedresource_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(19));
var resource_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(14));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(3));
function noop() { }
var MSG_ID_ENTROPY_BYTES = 9;
function allEmptyIds(messages) {
    return Utils.arrEvery(messages, function (message) {
        return !message.id;
    });
}
function normaliseChannelOptions(options) {
    var channelOptions = options || {};
    if (channelOptions.cipher) {
        if (!platform_1.default.Crypto)
            throw new Error('Encryption not enabled; use ably.encryption.js instead');
        var cipher = platform_1.default.Crypto.getCipher(channelOptions.cipher);
        channelOptions.cipher = cipher.cipherParams;
        channelOptions.channelCipher = cipher.cipher;
    }
    else if ('cipher' in channelOptions) {
        /* Don't deactivate an existing cipher unless options
         * has a 'cipher' key that's falsey */
        channelOptions.cipher = undefined;
        channelOptions.channelCipher = null;
    }
    return channelOptions;
}
var Channel = /** @class */ (function (_super) {
    tslib_1.__extends(Channel, _super);
    function Channel(rest, name, channelOptions) {
        var _this = _super.call(this) || this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Channel()', 'started; name = ' + name);
        _this.rest = rest;
        _this.name = name;
        _this.basePath = '/channels/' + encodeURIComponent(name);
        _this.presence = new presence_1.default(_this);
        _this.channelOptions = normaliseChannelOptions(channelOptions);
        return _this;
    }
    Channel.prototype.setOptions = function (options) {
        this.channelOptions = normaliseChannelOptions(options);
    };
    Channel.prototype.history = function (params, callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Channel.history()', 'channel = ' + this.name);
        /* params and callback are optional; see if params contains the callback */
        if (callback === undefined) {
            if (typeof params == 'function') {
                callback = params;
                params = null;
            }
            else {
                if (this.rest.options.promises) {
                    return Utils.promisify(this, 'history', arguments);
                }
                callback = noop;
            }
        }
        this._history(params, callback);
    };
    Channel.prototype._history = function (params, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        var options = this.channelOptions;
        new paginatedresource_1.default(rest, this.basePath + '/messages', headers, envelope, function (body, headers, unpacked) {
            return message_1.default.fromResponseBody(body, options, unpacked ? undefined : format);
        }).get(params, callback);
    };
    Channel.prototype.publish = function () {
        var _this = this;
        var argCount = arguments.length, first = arguments[0], second = arguments[1];
        var callback = arguments[argCount - 1];
        var messages;
        var params;
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'publish', arguments);
            }
            callback = noop;
        }
        if (typeof first === 'string' || first === null) {
            /* (name, data, ...) */
            messages = [message_1.default.fromValues({ name: first, data: second })];
            params = arguments[2];
        }
        else if (Utils.isObject(first)) {
            messages = [message_1.default.fromValues(first)];
            params = arguments[1];
        }
        else if (Utils.isArray(first)) {
            messages = message_1.default.fromValuesArray(first);
            params = arguments[1];
        }
        else {
            throw new errorinfo_1.default('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);
        }
        if (typeof params !== 'object' || !params) {
            /* No params supplied (so after-message argument is just the callback or undefined) */
            params = {};
        }
        var rest = this.rest, options = rest.options, format = options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, idempotentRestPublishing = rest.options.idempotentRestPublishing, headers = Utils.defaultPostHeaders(rest.options, format);
        if (options.headers)
            Utils.mixin(headers, options.headers);
        if (idempotentRestPublishing && allEmptyIds(messages)) {
            var msgIdBase_1 = Utils.randomString(MSG_ID_ENTROPY_BYTES);
            Utils.arrForEach(messages, function (message, index) {
                message.id = msgIdBase_1 + ':' + index.toString();
            });
        }
        message_1.default.encodeArray(messages, this.channelOptions, function (err) {
            if (err) {
                callback(err);
                return;
            }
            /* RSL1i */
            var size = message_1.default.getMessagesSize(messages), maxMessageSize = options.maxMessageSize;
            if (size > maxMessageSize) {
                callback(new errorinfo_1.default('Maximum size of messages that can be published at once exceeded ( was ' +
                    size +
                    ' bytes; limit is ' +
                    maxMessageSize +
                    ' bytes)', 40009, 400));
                return;
            }
            _this._publish(message_1.default.serialize(messages, format), headers, params, callback);
        });
    };
    Channel.prototype._publish = function (requestBody, headers, params, callback) {
        resource_1.default.post(this.rest, this.basePath + '/messages', requestBody, headers, params, null, callback);
    };
    Channel.prototype.status = function (callback) {
        if (typeof callback !== 'function' && this.rest.options.promises) {
            return Utils.promisify(this, 'status', []);
        }
        var format = this.rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json;
        var headers = Utils.defaultPostHeaders(this.rest.options, format);
        resource_1.default.get(this.rest, this.basePath, headers, {}, format, callback || noop);
    };
    return Channel;
}(eventemitter_1.default));
exports.default = Channel;


/***/ }),
/* 34 */
/***/ (function(module, exports, __nested_webpack_require_297440__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_297440__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_297440__(1));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_297440__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_297440__(2));
var paginatedresource_1 = tslib_1.__importDefault(__nested_webpack_require_297440__(19));
var presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_297440__(15));
function noop() { }
var Presence = /** @class */ (function (_super) {
    tslib_1.__extends(Presence, _super);
    function Presence(channel) {
        var _this = _super.call(this) || this;
        _this.channel = channel;
        _this.basePath = channel.basePath + '/presence';
        return _this;
    }
    Presence.prototype.get = function (params, callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Presence.get()', 'channel = ' + this.channel.name);
        /* params and callback are optional; see if params contains the callback */
        if (callback === undefined) {
            if (typeof params == 'function') {
                callback = params;
                params = null;
            }
            else {
                if (this.channel.rest.options.promises) {
                    return Utils.promisify(this, 'get', arguments);
                }
                callback = noop;
            }
        }
        var rest = this.channel.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.channel.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        var options = this.channel.channelOptions;
        new paginatedresource_1.default(rest, this.basePath, headers, envelope, function (body, headers, unpacked) {
            return presencemessage_1.default.fromResponseBody(body, options, unpacked ? undefined : format);
        }).get(params, callback);
    };
    Presence.prototype.history = function (params, callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Presence.history()', 'channel = ' + this.channel.name);
        return this._history(params, callback);
    };
    Presence.prototype._history = function (params, callback) {
        /* params and callback are optional; see if params contains the callback */
        if (callback === undefined) {
            if (typeof params == 'function') {
                callback = params;
                params = null;
            }
            else {
                if (this.channel.rest.options.promises) {
                    return Utils.promisify(this, '_history', [params]);
                }
                callback = noop;
            }
        }
        var rest = this.channel.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.channel.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        var options = this.channel.channelOptions;
        new paginatedresource_1.default(rest, this.basePath + '/history', headers, envelope, function (body, headers, unpacked) {
            return presencemessage_1.default.fromResponseBody(body, options, unpacked ? undefined : format);
        }).get(params, callback);
    };
    return Presence;
}(eventemitter_1.default));
exports.default = Presence;


/***/ }),
/* 35 */
/***/ (function(module, exports, __nested_webpack_require_301120__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransportParams = void 0;
var tslib_1 = __nested_webpack_require_301120__(0);
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(10));
var Utils = tslib_1.__importStar(__nested_webpack_require_301120__(1));
var protocol_1 = tslib_1.__importStar(__nested_webpack_require_301120__(52));
var defaults_1 = tslib_1.__importStar(__nested_webpack_require_301120__(8));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(3));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(7));
var messagequeue_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(36));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(2));
var connectionstatechange_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(37));
var connectionerrors_1 = tslib_1.__importStar(__nested_webpack_require_301120__(20));
var errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_301120__(4));
var auth_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(17));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(9));
var multicaster_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(23));
var websockettransport_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(53));
var transport_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(26));
var HttpStatusCodes_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(25));
var haveWebStorage = function () { var _a; return typeof platform_1.default.WebStorage !== 'undefined' && ((_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.localSupported); };
var haveSessionStorage = function () { var _a; return typeof platform_1.default.WebStorage !== 'undefined' && ((_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.sessionSupported); };
var actions = protocolmessage_1.default.Action;
var noop = function () { };
var transportPreferenceName = 'ably-transport-preference';
var sessionRecoveryName = 'ably-connection-recovery';
function getSessionRecoverData() {
    var _a, _b;
    return haveSessionStorage() && ((_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.getSession) === null || _b === void 0 ? void 0 : _b.call(_a, sessionRecoveryName));
}
function setSessionRecoverData(value) {
    var _a, _b;
    return haveSessionStorage() && ((_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.setSession) === null || _b === void 0 ? void 0 : _b.call(_a, sessionRecoveryName, value));
}
function clearSessionRecoverData() {
    var _a, _b;
    return haveSessionStorage() && ((_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.removeSession) === null || _b === void 0 ? void 0 : _b.call(_a, sessionRecoveryName));
}
function betterTransportThan(a, b) {
    return (Utils.arrIndexOf(platform_1.default.Defaults.transportPreferenceOrder, a.shortName) >
        Utils.arrIndexOf(platform_1.default.Defaults.transportPreferenceOrder, b.shortName));
}
function bundleWith(dest, src, maxSize) {
    var action;
    if (dest.channel !== src.channel) {
        /* RTL6d3 */
        return false;
    }
    if ((action = dest.action) !== actions.PRESENCE && action !== actions.MESSAGE) {
        /* RTL6d - can only bundle messages or presence */
        return false;
    }
    if (action !== src.action) {
        /* RTL6d4 */
        return false;
    }
    var kind = action === actions.PRESENCE ? 'presence' : 'messages', proposed = dest[kind].concat(src[kind]), size = message_1.default.getMessagesSize(proposed);
    if (size > maxSize) {
        /* RTL6d1 */
        return false;
    }
    if (!Utils.allSame(proposed, 'clientId')) {
        /* RTL6d2 */
        return false;
    }
    if (!Utils.arrEvery(proposed, function (msg) {
        return !msg.id;
    })) {
        /* RTL6d7 */
        return false;
    }
    /* we're good to go! */
    dest[kind] = proposed;
    return true;
}
function decodeRecoveryKey(recoveryKey) {
    try {
        return JSON.parse(recoveryKey);
    }
    catch (e) {
        return null;
    }
}
var TransportParams = /** @class */ (function () {
    function TransportParams(options, host, mode, connectionKey) {
        this.options = options;
        this.host = host;
        this.mode = mode;
        this.connectionKey = connectionKey;
        this.format = options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json;
    }
    TransportParams.prototype.getConnectParams = function (authParams) {
        var params = authParams ? Utils.copy(authParams) : {};
        var options = this.options;
        switch (this.mode) {
            case 'upgrade':
                params.upgrade = this.connectionKey;
                break;
            case 'resume':
                params.resume = this.connectionKey;
                break;
            case 'recover': {
                var recoveryContext = decodeRecoveryKey(options.recover);
                if (recoveryContext) {
                    params.recover = recoveryContext.connectionKey;
                }
                break;
            }
            default:
        }
        if (options.clientId !== undefined) {
            params.clientId = options.clientId;
        }
        if (options.echoMessages === false) {
            params.echo = 'false';
        }
        if (this.format !== undefined) {
            params.format = this.format;
        }
        if (this.stream !== undefined) {
            params.stream = this.stream;
        }
        if (this.heartbeats !== undefined) {
            params.heartbeats = this.heartbeats;
        }
        params.v = defaults_1.default.protocolVersion;
        params.agent = encodeURIComponent((0, defaults_1.getAgentString)(this.options));
        if (options.transportParams !== undefined) {
            Utils.mixin(params, options.transportParams);
        }
        return params;
    };
    TransportParams.prototype.toString = function () {
        var result = '[mode=' + this.mode;
        if (this.host) {
            result += ',host=' + this.host;
        }
        if (this.connectionKey) {
            result += ',connectionKey=' + this.connectionKey;
        }
        if (this.format) {
            result += ',format=' + this.format;
        }
        result += ']';
        return result;
    };
    return TransportParams;
}());
exports.TransportParams = TransportParams;
var ConnectionManager = /** @class */ (function (_super) {
    tslib_1.__extends(ConnectionManager, _super);
    function ConnectionManager(realtime, options) {
        var _this = _super.call(this) || this;
        _this.disconnectedRetryCount = 0;
        ConnectionManager.initTransports();
        _this.realtime = realtime;
        _this.options = options;
        var timeouts = options.timeouts;
        /* connectingTimeout: leave preferenceConnectTimeout (~6s) to try the
         * preference transport, then realtimeRequestTimeout (~10s) to establish
         * the base transport in case that fails */
        var connectingTimeout = timeouts.preferenceConnectTimeout + timeouts.realtimeRequestTimeout;
        _this.states = {
            initialized: {
                state: 'initialized',
                terminal: false,
                queueEvents: true,
                sendEvents: false,
                failState: 'disconnected',
            },
            connecting: {
                state: 'connecting',
                terminal: false,
                queueEvents: true,
                sendEvents: false,
                retryDelay: connectingTimeout,
                failState: 'disconnected',
            },
            connected: {
                state: 'connected',
                terminal: false,
                queueEvents: false,
                sendEvents: true,
                failState: 'disconnected',
            },
            synchronizing: {
                state: 'connected',
                terminal: false,
                queueEvents: true,
                sendEvents: false,
                forceQueueEvents: true,
                failState: 'disconnected',
            },
            disconnected: {
                state: 'disconnected',
                terminal: false,
                queueEvents: true,
                sendEvents: false,
                retryDelay: timeouts.disconnectedRetryTimeout,
                failState: 'disconnected',
            },
            suspended: {
                state: 'suspended',
                terminal: false,
                queueEvents: false,
                sendEvents: false,
                retryDelay: timeouts.suspendedRetryTimeout,
                failState: 'suspended',
            },
            closing: {
                state: 'closing',
                terminal: false,
                queueEvents: false,
                sendEvents: false,
                retryDelay: timeouts.realtimeRequestTimeout,
                failState: 'closed',
            },
            closed: { state: 'closed', terminal: true, queueEvents: false, sendEvents: false, failState: 'closed' },
            failed: { state: 'failed', terminal: true, queueEvents: false, sendEvents: false, failState: 'failed' },
        };
        _this.state = _this.states.initialized;
        _this.errorReason = null;
        _this.queuedMessages = new messagequeue_1.default();
        _this.msgSerial = 0;
        _this.connectionDetails = undefined;
        _this.connectionId = undefined;
        _this.connectionKey = undefined;
        _this.connectionStateTtl = timeouts.connectionStateTtl;
        _this.maxIdleInterval = null;
        _this.transports = Utils.intersect(options.transports || defaults_1.default.defaultTransports, ConnectionManager.supportedTransports);
        /* baseTransports selects the leftmost transport in the Defaults.baseTransportOrder list
         * that's both requested and supported. Normally this will be xhr_polling;
         * if xhr isn't supported it will be jsonp. If the user has forced a
         * transport, it'll just be that one. */
        _this.baseTransport = Utils.intersect(defaults_1.default.baseTransportOrder, _this.transports)[0];
        _this.upgradeTransports = Utils.intersect(_this.transports, defaults_1.default.upgradeTransports);
        _this.transportPreference = null;
        _this.httpHosts = defaults_1.default.getHosts(options);
        _this.activeProtocol = null;
        _this.proposedTransports = [];
        _this.pendingTransports = [];
        _this.host = null;
        _this.lastAutoReconnectAttempt = null;
        _this.lastActivity = null;
        _this.forceFallbackHost = false;
        _this.connectCounter = 0;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Realtime.ConnectionManager()', 'started');
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Realtime.ConnectionManager()', 'requested transports = [' + (options.transports || defaults_1.default.defaultTransports) + ']');
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Realtime.ConnectionManager()', 'available transports = [' + _this.transports + ']');
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Realtime.ConnectionManager()', 'http hosts = [' + _this.httpHosts + ']');
        if (!_this.transports.length) {
            var msg = 'no requested transports available';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'realtime.ConnectionManager()', msg);
            throw new Error(msg);
        }
        var addEventListener = platform_1.default.Config.addEventListener;
        if (addEventListener) {
            /* intercept close event in browser to persist connection id if requested */
            if (haveSessionStorage() && typeof options.recover === 'function') {
                /* Usually can't use bind as not supported in IE8, but IE doesn't support sessionStorage, so... */
                addEventListener('beforeunload', _this.persistConnection.bind(_this));
            }
            if (options.closeOnUnload === true) {
                addEventListener('beforeunload', function () {
                    logger_1.default.logAction(logger_1.default.LOG_MAJOR, 'Realtime.ConnectionManager()', 'beforeunload event has triggered the connection to close as closeOnUnload is true');
                    _this.requestState({ state: 'closing' });
                });
            }
            /* Listen for online and offline events */
            addEventListener('online', function () {
                if (_this.state == _this.states.disconnected || _this.state == _this.states.suspended) {
                    logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager caught browser ‘online’ event', 'reattempting connection');
                    _this.requestState({ state: 'connecting' });
                }
                else if (_this.state == _this.states.connecting) {
                    // RTN20c: if 'online' event recieved while CONNECTING, abandon connection attempt and retry
                    _this.pendingTransports.forEach(function (transport) {
                        // Detach transport listeners to avoid connection state side effects from calling dispose
                        transport.off();
                    });
                    _this.disconnectAllTransports();
                    _this.startConnect();
                }
            });
            addEventListener('offline', function () {
                if (_this.state == _this.states.connected) {
                    logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager caught browser ‘offline’ event', 'disconnecting active transport');
                    // Not sufficient to just go to the 'disconnected' state, want to
                    // force all transports to reattempt the connection. Will immediately
                    // retry.
                    _this.disconnectAllTransports();
                }
            });
        }
        return _this;
    }
    ConnectionManager.initTransports = function () {
        (0, websockettransport_1.default)(ConnectionManager);
        Utils.arrForEach(platform_1.default.Transports, function (initFn) {
            initFn(ConnectionManager);
        });
    };
    ConnectionManager.prototype.createTransportParams = function (host, mode) {
        return new TransportParams(this.options, host, mode, this.connectionKey);
    };
    ConnectionManager.prototype.getTransportParams = function (callback) {
        var _this = this;
        var decideMode = function (modeCb) {
            if (_this.connectionKey) {
                modeCb('resume');
                return;
            }
            if (typeof _this.options.recover === 'string') {
                modeCb('recover');
                return;
            }
            var recoverFn = _this.options.recover, lastSessionData = getSessionRecoverData();
            if (lastSessionData && typeof recoverFn === 'function') {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Calling clientOptions-provided recover function with last session data');
                recoverFn(lastSessionData, function (shouldRecover) {
                    if (shouldRecover) {
                        _this.options.recover = lastSessionData.recoveryKey;
                        modeCb('recover');
                    }
                    else {
                        modeCb('clean');
                    }
                });
                return;
            }
            modeCb('clean');
        };
        decideMode(function (mode) {
            var transportParams = _this.createTransportParams(null, mode);
            if (mode === 'recover') {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Transport recovery mode = recover; recoveryKey = ' + _this.options.recover);
                var recoveryContext = decodeRecoveryKey(_this.options.recover);
                if (recoveryContext) {
                    _this.msgSerial = recoveryContext.msgSerial;
                }
            }
            else {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Transport params = ' + transportParams.toString());
            }
            callback(transportParams);
        });
    };
    /**
     * Attempt to connect using a given transport
     * @param transportParams
     * @param candidate, the transport to try
     * @param callback
     */
    ConnectionManager.prototype.tryATransport = function (transportParams, candidate, callback) {
        var _this = this;
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.tryATransport()', 'trying ' + candidate);
        transport_1.default.tryConnect(ConnectionManager.supportedTransports[candidate], this, this.realtime.auth, transportParams, function (wrappedErr, transport) {
            var state = _this.state;
            if (state == _this.states.closing || state == _this.states.closed || state == _this.states.failed) {
                if (transport) {
                    logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.tryATransport()', 'connection ' + state.state + ' while we were attempting the transport; closing ' + transport);
                    transport.close();
                }
                callback(true);
                return;
            }
            if (wrappedErr) {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.tryATransport()', 'transport ' + candidate + ' ' + wrappedErr.event + ', err: ' + wrappedErr.error.toString());
                /* Comet transport onconnect token errors can be dealt with here.
                 * Websocket ones only happen after the transport claims to be viable,
                 * so are dealt with as non-onconnect token errors */
                if (auth_1.default.isTokenErr(wrappedErr.error) &&
                    !(_this.errorReason && auth_1.default.isTokenErr(_this.errorReason))) {
                    _this.errorReason = wrappedErr.error;
                    /* re-get a token and try again */
                    _this.realtime.auth._forceNewToken(null, null, function (err) {
                        if (err) {
                            _this.actOnErrorFromAuthorize(err);
                            return;
                        }
                        _this.tryATransport(transportParams, candidate, callback);
                    });
                }
                else if (wrappedErr.event === 'failed') {
                    /* Error that's fatal to the connection */
                    _this.notifyState({ state: 'failed', error: wrappedErr.error });
                    callback(true);
                }
                else if (wrappedErr.event === 'disconnected') {
                    if (!(0, connectionerrors_1.isRetriable)(wrappedErr.error)) {
                        /* Error received from the server that does not call for trying a fallback host, eg a rate limit */
                        _this.notifyState({ state: _this.states.connecting.failState, error: wrappedErr.error });
                        callback(true);
                    }
                    else {
                        /* Error with that transport only; continue trying other fallback hosts */
                        callback(false);
                    }
                }
                return;
            }
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.tryATransport()', 'viable transport ' + candidate + '; setting pending');
            _this.setTransportPending(transport, transportParams);
            callback(null, transport);
        });
    };
    /**
     * Called when a transport is indicated to be viable, and the ConnectionManager
     * expects to activate this transport as soon as it is connected.
     * @param transport
     * @param transportParams
     */
    ConnectionManager.prototype.setTransportPending = function (transport, transportParams) {
        var _this = this;
        var mode = transportParams.mode;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.setTransportPending()', 'transport = ' + transport + '; mode = ' + mode);
        Utils.arrDeleteValue(this.proposedTransports, transport);
        this.pendingTransports.push(transport);
        var optimalTransport = platform_1.default.Defaults.transportPreferenceOrder[platform_1.default.Defaults.transportPreferenceOrder.length - 1];
        transport.once('connected', function (error, connectionId, connectionDetails) {
            if (mode == 'upgrade' && _this.activeProtocol) {
                /*  if ws and xhrs are connecting in parallel, delay xhrs activation to let ws go ahead */
                if (transport.shortName !== optimalTransport &&
                    Utils.arrIn(_this.getUpgradePossibilities(), optimalTransport) &&
                    _this.activeProtocol) {
                    setTimeout(function () {
                        _this.scheduleTransportActivation(error, transport, connectionId, connectionDetails);
                    }, _this.options.timeouts.parallelUpgradeDelay);
                }
                else {
                    _this.scheduleTransportActivation(error, transport, connectionId, connectionDetails);
                }
            }
            else {
                _this.activateTransport(error, transport, connectionId, connectionDetails);
                /* allow connectImpl to start the upgrade process if needed, but allow
                 * other event handlers, including activating the transport, to run first */
                platform_1.default.Config.nextTick(function () {
                    _this.connectImpl(transportParams);
                });
            }
            if (mode === 'recover' && _this.options.recover) {
                /* After a successful recovery, we unpersist, as a recovery key cannot
                 * be used more than once */
                _this.options.recover = null;
                _this.unpersistConnection();
            }
        });
        var self = this;
        transport.on(['disconnected', 'closed', 'failed'], function (error) {
            self.deactivateTransport(transport, this.event, error);
        });
        this.emit('transport.pending', transport);
    };
    /**
     * Called when an upgrade transport is connected,
     * to schedule the activation of that transport.
     * @param error
     * @param transport
     * @param connectionId
     * @param connectionDetails
     */
    ConnectionManager.prototype.scheduleTransportActivation = function (error, transport, connectionId, connectionDetails) {
        var _this = this;
        var currentTransport = this.activeProtocol && this.activeProtocol.getTransport(), abandon = function () {
            transport.disconnect();
            Utils.arrDeleteValue(_this.pendingTransports, transport);
        };
        if (this.state !== this.states.connected && this.state !== this.states.connecting) {
            /* This is most likely to happen for the delayed XHRs, when XHRs and ws are scheduled in parallel*/
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' +
                this.state.state +
                (this.state === this.states.synchronizing ? ', but with an upgrade already in progress' : '') +
                ') is not valid to upgrade in; abandoning upgrade to ' +
                transport.shortName);
            abandon();
            return;
        }
        if (currentTransport && !betterTransportThan(transport, currentTransport)) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' +
                transport.shortName +
                ' is no better than current active transport ' +
                currentTransport.shortName +
                ' - abandoning upgrade');
            abandon();
            return;
        }
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Scheduling transport upgrade; transport = ' + transport);
        var oldProtocol = null;
        if (!transport.isConnected) {
            /* This is only possible if the xhr streaming transport was disconnected during the parallelUpgradeDelay */
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' + transport.shortName + 'is no longer connected; abandoning upgrade');
            abandon();
            return;
        }
        if (this.state === this.states.connected) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Currently connected, so temporarily pausing events until the upgrade is complete');
            this.state = this.states.synchronizing;
            oldProtocol = this.activeProtocol;
        }
        else if (this.state !== this.states.connecting) {
            /* Note: upgrading from the connecting state is valid if the old active
             * transport was deactivated after the upgrade transport first connected;
             * see logic in deactivateTransport */
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' +
                this.state.state +
                (this.state === this.states.synchronizing ? ', but with an upgrade already in progress' : '') +
                ') is not valid to upgrade in; abandoning upgrade to ' +
                transport.shortName);
            abandon();
            return;
        }
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Syncing transport; transport = ' + transport);
        var finishUpgrade = function () {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Activating transport; transport = ' + transport);
            // Send ACTIVATE to tell the server to make this transport the
            // active transport, which suspends channels until we re-attach.
            transport.send(protocolmessage_1.default.fromValues({
                action: actions.ACTIVATE,
            }));
            _this.activateTransport(error, transport, connectionId, connectionDetails);
            /* Restore pre-sync state. If state has changed in the meantime,
             * don't touch it -- since the websocket transport waits a tick before
             * disposing itself, it's possible for it to have happily synced
             * without err while, unknown to it, the connection has closed in the
             * meantime and the ws transport is scheduled for death */
            if (_this.state === _this.states.synchronizing) {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, sending queued messages on upgraded transport; transport = ' + transport);
                _this.state = _this.states.connected;
            }
            else {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, but state is now ' + _this.state.state + ', so leaving unchanged');
            }
            if (_this.state.sendEvents) {
                _this.sendQueuedMessages();
            }
        };
        /* Wait until sync is done and old transport is idle before activating new transport. This
         * guarantees that messages arrive at realtime in the same order they are sent.
         *
         * If a message times out on the old transport, since it's still the active transport the
         * message will be requeued. deactivateTransport will see the pending transport and notify
         * the `connecting` state without starting a new connection, so the new transport can take
         * over once deactivateTransport clears the old protocol's queue.
         *
         * If there is no old protocol, that meant that we weren't in the connected state at the
         * beginning of the sync - likely the base transport died just before the sync. So can just
         * finish the upgrade. If we're actually in closing/failed rather than connecting, that's
         * fine, activatetransport will deal with that. */
        if (oldProtocol) {
            /* Most of the time this will be already true: the new-transport sync will have given
             * enough time for in-flight messages on the old transport to complete. */
            oldProtocol.onceIdle(finishUpgrade);
        }
        else {
            finishUpgrade();
        }
    };
    /**
     * Called when a transport is connected, and the connectionmanager decides that
     * it will now be the active transport. Returns whether or not it activated
     * the transport (if the connection is closing/closed it will choose not to).
     * @param transport the transport instance
     * @param connectionId the id of the new active connection
     * @param connectionDetails the details of the new active connection
     */
    ConnectionManager.prototype.activateTransport = function (error, transport, connectionId, connectionDetails) {
        var _this = this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.activateTransport()', 'transport = ' + transport);
        if (error) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', 'error = ' + error);
        }
        if (connectionId) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionId =  ' + connectionId);
        }
        if (connectionDetails) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionDetails =  ' + JSON.stringify(connectionDetails));
        }
        this.persistTransportPreference(transport);
        /* if the connectionmanager moved to the closing/closed state before this
         * connection event, then we won't activate this transport */
        var existingState = this.state, connectedState = this.states.connected.state;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.activateTransport()', 'current state = ' + existingState.state);
        if (existingState.state == this.states.closing.state ||
            existingState.state == this.states.closed.state ||
            existingState.state == this.states.failed.state) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.activateTransport()', 'Disconnecting transport and abandoning');
            transport.disconnect();
            return false;
        }
        /* remove this transport from pending transports */
        Utils.arrDeleteValue(this.pendingTransports, transport);
        /* if the transport is not connected then don't activate it */
        if (!transport.isConnected) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.activateTransport()', 'Declining to activate transport ' + transport + ' since it appears to no longer be connected');
            return false;
        }
        /* the given transport is connected; this will immediately
         * take over as the active transport */
        var existingActiveProtocol = this.activeProtocol;
        this.activeProtocol = new protocol_1.default(transport);
        this.host = transport.params.host;
        var connectionKey = connectionDetails.connectionKey;
        if (connectionKey && this.connectionKey != connectionKey) {
            this.setConnection(connectionId, connectionDetails, !!error);
        }
        /* Rebroadcast any new connectionDetails from the active transport, which
         * can come at any time (eg following a reauth), and emit an RTN24 UPDATE
         * event. (Listener added on nextTick because we're in a transport.on('connected')
         * callback at the moment; if we add it now we'll be adding it to the end
         * of the listeners array and it'll be called immediately) */
        this.onConnectionDetailsUpdate(connectionDetails, transport);
        platform_1.default.Config.nextTick(function () {
            transport.on('connected', function (connectedErr, _connectionId, connectionDetails) {
                _this.onConnectionDetailsUpdate(connectionDetails, transport);
                _this.emit('update', new connectionstatechange_1.default(connectedState, connectedState, null, connectedErr));
            });
        });
        /* If previously not connected, notify the state change (including any
         * error). */
        if (existingState.state === this.states.connected.state) {
            if (error) {
                /* if upgrading without error, leave any existing errorReason alone */
                this.errorReason = this.realtime.connection.errorReason = error;
                /* Only bother emitting an upgrade if there's an error; otherwise it's
                 * just a transport upgrade, so auth details won't have changed */
                this.emit('update', new connectionstatechange_1.default(connectedState, connectedState, null, error));
            }
        }
        else {
            this.notifyState({ state: 'connected', error: error });
            this.errorReason = this.realtime.connection.errorReason = error || null;
        }
        /* Send after the connection state update, as Channels hooks into this to
         * resend attaches on a new transport if necessary */
        this.emit('transport.active', transport);
        /* Gracefully terminate existing protocol */
        if (existingActiveProtocol) {
            if (existingActiveProtocol.messageQueue.count() > 0) {
                /* We could just requeue pending messages on the new transport, but
                 * actually this should never happen: transports should only take over
                 * from other active transports when upgrading, and upgrading waits for
                 * the old transport to be idle. So log an error. */
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', 'Previous active protocol (for transport ' +
                    existingActiveProtocol.transport.shortName +
                    ', new one is ' +
                    transport.shortName +
                    ') finishing with ' +
                    existingActiveProtocol.messageQueue.count() +
                    ' messages still pending');
            }
            if (existingActiveProtocol.transport === transport) {
                var msg = 'Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = ' +
                    transport.shortName +
                    '; stack = ' +
                    new Error().stack;
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
            }
            else {
                existingActiveProtocol.finish();
            }
        }
        /* Terminate any other pending transport(s), and
         * abort any not-yet-pending transport attempts */
        Utils.safeArrForEach(this.pendingTransports, function (pendingTransport) {
            if (pendingTransport === transport) {
                var msg = 'Assumption violated: activating a transport that is still marked as a pending transport; transport = ' +
                    transport.shortName +
                    '; stack = ' +
                    new Error().stack;
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
                Utils.arrDeleteValue(_this.pendingTransports, transport);
            }
            else {
                pendingTransport.disconnect();
            }
        });
        Utils.safeArrForEach(this.proposedTransports, function (proposedTransport) {
            if (proposedTransport === transport) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', 'Assumption violated: activating a transport that is still marked as a proposed transport; transport = ' +
                    transport.shortName +
                    '; stack = ' +
                    new Error().stack);
                Utils.arrDeleteValue(_this.proposedTransports, transport);
            }
            else {
                proposedTransport.dispose();
            }
        });
        return true;
    };
    /**
     * Called when a transport is no longer the active transport. This can occur
     * in any transport connection state.
     * @param transport
     */
    ConnectionManager.prototype.deactivateTransport = function (transport, state, error) {
        var currentProtocol = this.activeProtocol, wasActive = currentProtocol && currentProtocol.getTransport() === transport, wasPending = Utils.arrDeleteValue(this.pendingTransports, transport), wasProposed = Utils.arrDeleteValue(this.proposedTransports, transport), noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'transport = ' + transport);
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'state = ' +
            state +
            (wasActive ? '; was active' : wasPending ? '; was pending' : wasProposed ? '; was proposed' : '') +
            (noTransportsScheduledForActivation ? '' : '; another transport is scheduled for activation'));
        if (error && error.message)
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'reason =  ' + error.message);
        if (wasActive) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'Getting, clearing, and requeuing ' +
                this.activeProtocol.messageQueue.count() +
                ' pending messages');
            this.queuePendingMessages(currentProtocol.getPendingMessages());
            /* Clear any messages we requeue to allow the protocol to become idle.
             * In case of an upgrade, this will trigger an immediate activation of
             * the upgrade transport, so delay a tick so this transport can finish
             * deactivating */
            platform_1.default.Config.nextTick(function () {
                currentProtocol.clearPendingMessages();
            });
            this.activeProtocol = this.host = null;
        }
        this.emit('transport.inactive', transport);
        /* this transport state change is a state change for the connectionmanager if
         * - the transport was the active transport and there are no transports
         *   which are connected and scheduled for activation, just waiting for the
         *   active transport to finish what its doing; or
         * - the transport was the active transport and the error was fatal (so
         *   unhealable by another transport); or
         * - there is no active transport, and this is the last remaining
         *   pending transport (so we were in the connecting state)
         */
        if ((wasActive && noTransportsScheduledForActivation) ||
            (wasActive && state === 'failed') ||
            state === 'closed' ||
            (currentProtocol === null && wasPending && this.pendingTransports.length === 0)) {
            /* If we're disconnected with a 5xx we need to try fallback hosts
             * (RTN14d), but (a) due to how the upgrade sequence works, the
             * host/transport selection sequence only cares about getting to
             * `preconnect` (eg establishing a websocket) getting a `disconnected`
             * protocol message afterwards is too late; and (b) host retry only
             * applies to connectBase unless the stored preference transport doesn't
             * work. We solve this by unpersisting the transport preference and
             * setting an instance variable to force fallback hosts to be used (if
             * any) here. Bit of a kludge, but no real better alternatives without
             * rewriting the entire thing */
            if (state === 'disconnected' && error && error.statusCode > 500 && this.httpHosts.length > 1) {
                this.unpersistTransportPreference();
                this.forceFallbackHost = true;
                /* and try to connect again to try a fallback host without waiting for the usual 15s disconnectedRetryTimeout */
                this.notifyState({ state: state, error: error, retryImmediately: true });
                return;
            }
            /* TODO remove below line once realtime sends token errors as DISCONNECTEDs */
            var newConnectionState = state === 'failed' && auth_1.default.isTokenErr(error) ? 'disconnected' : state;
            this.notifyState({ state: newConnectionState, error: error });
            return;
        }
        if (wasActive && state === 'disconnected' && this.state !== this.states.synchronizing) {
            /* If we were active but there is another transport scheduled for
             * activation, go into to the connecting state until that transport
             * activates and sets us back to connected. (manually starting the
             * transition timers in case that never happens). (If we were in the
             * synchronizing state, then that's fine, the old transport just got its
             * disconnected before the new one got the sync -- ignore it and keep
             * waiting for the sync. If it fails we have a separate sync timer that
             * will expire). */
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'wasActive but another transport is connected and scheduled for activation, so going into the connecting state until it activates');
            this.startSuspendTimer();
            this.startTransitionTimer(this.states.connecting);
            this.notifyState({ state: 'connecting', error: error });
        }
    };
    /* Helper that returns true if there are no transports which are pending,
     * have been connected, and are just waiting for onceNoPending to fire before
     * being activated */
    ConnectionManager.prototype.noTransportsScheduledForActivation = function () {
        return (Utils.isEmpty(this.pendingTransports) ||
            this.pendingTransports.every(function (transport) {
                return !transport.isConnected;
            }));
    };
    ConnectionManager.prototype.setConnection = function (connectionId, connectionDetails, hasConnectionError) {
        /* if connectionKey changes but connectionId stays the same, then just a
         * transport change on the same connection. If connectionId changes, we're
         * on a new connection, with implications for msgSerial and channel state */
        /* If no previous connectionId, don't reset the msgSerial as it may have
         * been set by recover data (unless the recover failed) */
        var prevConnId = this.connectionId, connIdChanged = prevConnId && prevConnId !== connectionId, recoverFailure = !prevConnId && hasConnectionError;
        if (connIdChanged || recoverFailure) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.setConnection()', 'Resetting msgSerial');
            this.msgSerial = 0;
            // RTN19a2: In the event of a new connectionId, previous msgSerials are
            // meaningless.
            this.queuedMessages.resetSendAttempted();
        }
        if (this.connectionId !== connectionId) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.setConnection()', 'New connectionId; reattaching any attached channels');
        }
        this.realtime.connection.id = this.connectionId = connectionId;
        this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;
    };
    ConnectionManager.prototype.clearConnection = function () {
        this.realtime.connection.id = this.connectionId = undefined;
        this.realtime.connection.key = this.connectionKey = undefined;
        this.msgSerial = 0;
        this.unpersistConnection();
    };
    ConnectionManager.prototype.createRecoveryKey = function () {
        // RTN16g2.
        if (!this.connectionKey) {
            return null;
        }
        return JSON.stringify({
            connectionKey: this.connectionKey,
            msgSerial: this.msgSerial,
            channelSerials: this.realtime.channels.channelSerials(),
        });
    };
    ConnectionManager.prototype.checkConnectionStateFreshness = function () {
        if (!this.lastActivity || !this.connectionId) {
            return;
        }
        var sinceLast = Utils.now() - this.lastActivity;
        if (sinceLast > this.connectionStateTtl + this.maxIdleInterval) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.checkConnectionStateFreshness()', 'Last known activity from realtime was ' + sinceLast + 'ms ago; discarding connection state');
            this.clearConnection();
            this.states.connecting.failState = 'suspended';
        }
    };
    /**
     * Called when the connectionmanager wants to persist transport
     * state for later recovery. Only applicable in the browser context.
     */
    ConnectionManager.prototype.persistConnection = function () {
        if (haveSessionStorage()) {
            var recoveryKey = this.createRecoveryKey();
            if (recoveryKey) {
                setSessionRecoverData({
                    recoveryKey: recoveryKey,
                    disconnectedAt: Utils.now(),
                    location: global.location,
                    clientId: this.realtime.auth.clientId,
                });
            }
        }
    };
    /**
     * Called when the connectionmanager wants to persist transport
     * state for later recovery. Only applicable in the browser context.
     */
    ConnectionManager.prototype.unpersistConnection = function () {
        clearSessionRecoverData();
    };
    /*********************
     * state management
     *********************/
    ConnectionManager.prototype.getError = function () {
        return this.errorReason || this.getStateError();
    };
    ConnectionManager.prototype.getStateError = function () {
        var _a, _b;
        return (_b = (_a = connectionerrors_1.default)[this.state.state]) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    ConnectionManager.prototype.activeState = function () {
        return this.state.queueEvents || this.state.sendEvents;
    };
    ConnectionManager.prototype.enactStateChange = function (stateChange) {
        var logLevel = stateChange.current === 'failed' ? logger_1.default.LOG_ERROR : logger_1.default.LOG_MAJOR;
        logger_1.default.logAction(logLevel, 'Connection state', stateChange.current + (stateChange.reason ? '; reason: ' + stateChange.reason : ''));
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.enactStateChange', 'setting new state: ' +
            stateChange.current +
            '; reason = ' +
            (stateChange.reason && stateChange.reason.message));
        var newState = (this.state = this.states[stateChange.current]);
        if (stateChange.reason) {
            this.errorReason = stateChange.reason;
            this.realtime.connection.errorReason = stateChange.reason;
        }
        if (newState.terminal || newState.state === 'suspended') {
            /* suspended is nonterminal, but once in the suspended state, realtime
             * will have discarded our connection state, so futher connection
             * attempts should start from scratch */
            this.clearConnection();
        }
        this.emit('connectionstate', stateChange);
    };
    /****************************************
     * ConnectionManager connection lifecycle
     ****************************************/
    ConnectionManager.prototype.startTransitionTimer = function (transitionState) {
        var _this = this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'transitionState: ' + transitionState.state);
        if (this.transitionTimer) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'clearing already-running timer');
            clearTimeout(this.transitionTimer);
        }
        this.transitionTimer = setTimeout(function () {
            if (_this.transitionTimer) {
                _this.transitionTimer = null;
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager ' + transitionState.state + ' timer expired', 'requesting new state: ' + transitionState.failState);
                _this.notifyState({ state: transitionState.failState });
            }
        }, transitionState.retryDelay);
    };
    ConnectionManager.prototype.cancelTransitionTimer = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.cancelTransitionTimer()', '');
        if (this.transitionTimer) {
            clearTimeout(this.transitionTimer);
            this.transitionTimer = null;
        }
    };
    ConnectionManager.prototype.startSuspendTimer = function () {
        var _this = this;
        if (this.suspendTimer)
            return;
        this.suspendTimer = setTimeout(function () {
            if (_this.suspendTimer) {
                _this.suspendTimer = null;
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager suspend timer expired', 'requesting new state: suspended');
                _this.states.connecting.failState = 'suspended';
                _this.notifyState({ state: 'suspended' });
            }
        }, this.connectionStateTtl);
    };
    ConnectionManager.prototype.checkSuspendTimer = function (state) {
        if (state !== 'disconnected' && state !== 'suspended' && state !== 'connecting')
            this.cancelSuspendTimer();
    };
    ConnectionManager.prototype.cancelSuspendTimer = function () {
        this.states.connecting.failState = 'disconnected';
        if (this.suspendTimer) {
            clearTimeout(this.suspendTimer);
            this.suspendTimer = null;
        }
    };
    ConnectionManager.prototype.startRetryTimer = function (interval) {
        var _this = this;
        this.retryTimer = setTimeout(function () {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager retry timer expired', 'retrying');
            _this.retryTimer = null;
            _this.requestState({ state: 'connecting' });
        }, interval);
    };
    ConnectionManager.prototype.cancelRetryTimer = function () {
        if (this.retryTimer) {
            clearTimeout(this.retryTimer);
            this.retryTimer = null;
        }
    };
    ConnectionManager.prototype.notifyState = function (indicated) {
        var _this = this;
        var _a, _b;
        var state = indicated.state;
        /* We retry immediately if:
         * - something disconnects us while we're connected, or
         * - a viable (but not yet active) transport fails due to a token error (so
         *   this.errorReason will be set, and startConnect will do a forced
         *   authorize). If this.errorReason is already set (to a token error),
         *   then there has been at least one previous attempt to connect that also
         *   failed for a token error, so by RTN14b we go to DISCONNECTED and wait
         *   before trying again */
        var retryImmediately = state === 'disconnected' &&
            (this.state === this.states.connected ||
                this.state === this.states.synchronizing ||
                indicated.retryImmediately ||
                (this.state === this.states.connecting &&
                    indicated.error &&
                    auth_1.default.isTokenErr(indicated.error) &&
                    !(this.errorReason && auth_1.default.isTokenErr(this.errorReason))));
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.notifyState()', 'new state: ' + state + (retryImmediately ? '; will retry connection immediately' : ''));
        /* do nothing if we're already in the indicated state */
        if (state == this.state.state)
            return;
        /* kill timers (possibly excepting suspend timer depending on the notified
         * state), as these are superseded by this notification */
        this.cancelTransitionTimer();
        this.cancelRetryTimer();
        this.checkSuspendTimer(indicated.state);
        if (state === 'suspended' || state === 'connected') {
            this.disconnectedRetryCount = 0;
        }
        /* do nothing if we're unable to move from the current state */
        if (this.state.terminal)
            return;
        /* process new state */
        var newState = this.states[indicated.state];
        var retryDelay = newState.retryDelay;
        if (newState.state === 'disconnected') {
            this.disconnectedRetryCount++;
            retryDelay = Utils.getRetryTime(newState.retryDelay, this.disconnectedRetryCount);
        }
        var change = new connectionstatechange_1.default(this.state.state, newState.state, retryDelay, indicated.error || ((_b = (_a = connectionerrors_1.default)[newState.state]) === null || _b === void 0 ? void 0 : _b.call(_a)));
        if (retryImmediately) {
            var autoReconnect = function () {
                if (_this.state === _this.states.disconnected) {
                    _this.lastAutoReconnectAttempt = Utils.now();
                    _this.requestState({ state: 'connecting' });
                }
            };
            var sinceLast = this.lastAutoReconnectAttempt && Utils.now() - this.lastAutoReconnectAttempt + 1;
            if (sinceLast && sinceLast < 1000) {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.notifyState()', 'Last reconnect attempt was only ' +
                    sinceLast +
                    'ms ago, waiting another ' +
                    (1000 - sinceLast) +
                    'ms before trying again');
                setTimeout(autoReconnect, 1000 - sinceLast);
            }
            else {
                platform_1.default.Config.nextTick(autoReconnect);
            }
        }
        else if (state === 'disconnected' || state === 'suspended') {
            this.startRetryTimer(retryDelay);
        }
        /* If going into disconnect/suspended (and not retrying immediately), or a
         * terminal state, ensure there are no orphaned transports hanging around. */
        if ((state === 'disconnected' && !retryImmediately) || state === 'suspended' || newState.terminal) {
            /* Wait till the next tick so the connection state change is enacted,
             * so aborting transports doesn't trigger redundant state changes */
            platform_1.default.Config.nextTick(function () {
                _this.disconnectAllTransports();
            });
        }
        if (state == 'connected' && !this.activeProtocol) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.notifyState()', 'Broken invariant: attempted to go into connected state, but there is no active protocol');
        }
        /* implement the change and notify */
        this.enactStateChange(change);
        if (this.state.sendEvents) {
            this.sendQueuedMessages();
        }
        else if (!this.state.queueEvents) {
            this.realtime.channels.propogateConnectionInterruption(state, change.reason);
            this.failQueuedMessages(change.reason); // RTN7c
        }
    };
    ConnectionManager.prototype.requestState = function (request) {
        var _this = this;
        var _a, _b;
        var state = request.state;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.requestState()', 'requested state: ' + state + '; current state: ' + this.state.state);
        if (state == this.state.state)
            return; /* silently do nothing */
        /* kill running timers, as this request supersedes them */
        this.cancelTransitionTimer();
        this.cancelRetryTimer();
        /* for suspend timer check rather than cancel -- eg requesting a connecting
         * state should not reset the suspend timer */
        this.checkSuspendTimer(state);
        if (state == 'connecting' && this.state.state == 'connected')
            return;
        if (state == 'closing' && this.state.state == 'closed')
            return;
        var newState = this.states[state], change = new connectionstatechange_1.default(this.state.state, newState.state, null, request.error || ((_b = (_a = connectionerrors_1.default)[newState.state]) === null || _b === void 0 ? void 0 : _b.call(_a)));
        this.enactStateChange(change);
        if (state == 'connecting') {
            platform_1.default.Config.nextTick(function () {
                _this.startConnect();
            });
        }
        if (state == 'closing') {
            this.closeImpl();
        }
    };
    ConnectionManager.prototype.startConnect = function () {
        var _this = this;
        if (this.state !== this.states.connecting) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.startConnect()', 'Must be in connecting state to connect, but was ' + this.state.state);
            return;
        }
        var auth = this.realtime.auth;
        /* The point of the connectCounter mechanism is to ensure that the
         * connection procedure can be cancelled. We want disconnectAllTransports
         * to be able to stop any in-progress connection, even before it gets to
         * the stage of having a pending (or even a proposed) transport that it can
         * dispose() of. So we check that it's still current after any async stage,
         * up until the stage that is synchronous with instantiating a transport */
        var connectCount = ++this.connectCounter;
        var connect = function () {
            _this.checkConnectionStateFreshness();
            _this.getTransportParams(function (transportParams) {
                if (transportParams.mode === 'recover' && transportParams.options.recover) {
                    var recoveryContext = decodeRecoveryKey(transportParams.options.recover);
                    if (recoveryContext) {
                        _this.realtime.channels.recoverChannels(recoveryContext.channelSerials);
                    }
                }
                if (connectCount !== _this.connectCounter) {
                    return;
                }
                _this.connectImpl(transportParams, connectCount);
            });
        };
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.startConnect()', 'starting connection');
        this.startSuspendTimer();
        this.startTransitionTimer(this.states.connecting);
        if (auth.method === 'basic') {
            connect();
        }
        else {
            var authCb = function (err) {
                if (connectCount !== _this.connectCounter) {
                    return;
                }
                if (err) {
                    _this.actOnErrorFromAuthorize(err);
                }
                else {
                    connect();
                }
            };
            if (this.errorReason && auth_1.default.isTokenErr(this.errorReason)) {
                /* Force a refetch of a new token */
                auth._forceNewToken(null, null, authCb);
            }
            else {
                auth._ensureValidAuthCredentials(false, authCb);
            }
        }
    };
    /**
     * There are three stages in connecting:
     * - preference: if there is a cached transport preference, we try to connect
     *   on that. If that fails or times out we abort the attempt, remove the
     *   preference and fall back to base. If it succeeds, we try upgrading it if
     *   needed (will only be in the case where the preference is xhrs and the
     *   browser supports ws).
     * - base: we try to connect with the best transport that we think will
     *   never fail for this browser (usually this is xhr_polling; for very old
     *   browsers will be jsonp, for node will be comet). If it doesn't work, we
     *   try fallback hosts.
     * - upgrade: given a connected transport, we see if there are any better
     *   ones, and if so, try to upgrade to them.
     *
     * connectImpl works out what stage you're at (which is purely a function of
     * the current connection state and whether there are any stored preferences),
     * and dispatches accordingly. After a transport has been set pending,
     * tryATransport calls connectImpl to see if there's another stage to be done.
     * */
    ConnectionManager.prototype.connectImpl = function (transportParams, connectCount) {
        var state = this.state.state;
        if (state !== this.states.connecting.state && state !== this.states.connected.state) {
            /* Only keep trying as long as in the 'connecting' state (or 'connected'
             * for upgrading). Any operation can put us into 'disconnected' to cancel
             * connection attempts and wait before retrying, or 'failed' to fail. */
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectImpl()', 'Must be in connecting state to connect (or connected to upgrade), but was ' + state);
        }
        else if (this.pendingTransports.length) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectImpl()', 'Transports ' + this.pendingTransports[0].toString() + ' currently pending; taking no action');
        }
        else if (state == this.states.connected.state) {
            this.upgradeIfNeeded(transportParams);
        }
        else if (this.transports.length > 1 && this.getTransportPreference()) {
            this.connectPreference(transportParams, connectCount);
        }
        else {
            this.connectBase(transportParams, connectCount);
        }
    };
    ConnectionManager.prototype.connectPreference = function (transportParams, connectCount) {
        var _this = this;
        var preference = this.getTransportPreference();
        var preferenceTimeoutExpired = false;
        if (!Utils.arrIn(this.transports, preference)) {
            this.unpersistTransportPreference();
            this.connectImpl(transportParams, connectCount);
        }
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectPreference()', 'Trying to connect with stored transport preference ' + preference);
        var preferenceTimeout = setTimeout(function () {
            preferenceTimeoutExpired = true;
            if (!(_this.state.state === _this.states.connected.state)) {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectPreference()', 'Shortcircuit connection attempt with ' + preference + ' failed; clearing preference and trying from scratch');
                /* Abort all connection attempts. (This also disconnects the active
                 * protocol, but none exists if we're not in the connected state) */
                _this.disconnectAllTransports();
                /* Be quite agressive about clearing the stored preference if ever it doesn't work */
                _this.unpersistTransportPreference();
            }
            _this.connectImpl(transportParams, connectCount);
        }, this.options.timeouts.preferenceConnectTimeout);
        /* For connectPreference, just use the main host. If host fallback is needed, do it in connectBase.
         * The wstransport it will substitute the httphost for an appropriate wshost */
        transportParams.host = this.httpHosts[0];
        this.tryATransport(transportParams, preference, function (fatal, transport) {
            clearTimeout(preferenceTimeout);
            if (preferenceTimeoutExpired && transport) {
                /* Viable, but too late - connectImpl() will already be trying
                 * connectBase, and we weren't in upgrade mode. Just remove the
                 * onconnected listener and get rid of it */
                transport.off();
                transport.disconnect();
                Utils.arrDeleteValue(_this.pendingTransports, transport);
            }
            else if (!transport && !fatal) {
                /* Preference failed in a transport-specific way. Try more */
                _this.unpersistTransportPreference();
                _this.connectImpl(transportParams, connectCount);
            }
            /* If suceeded, or failed fatally, nothing to do */
        });
    };
    /**
     * Try to establish a transport on the base transport (the best transport
     * such that if it doesn't work, nothing will work) as determined through
     * static feature detection, checking for network connectivity and trying
     * fallback hosts if applicable.
     * @param transportParams
     */
    ConnectionManager.prototype.connectBase = function (transportParams, connectCount) {
        var _this = this;
        var giveUp = function (err) {
            _this.notifyState({ state: _this.states.connecting.failState, error: err });
        };
        var candidateHosts = this.httpHosts.slice();
        var hostAttemptCb = function (fatal, transport) {
            if (connectCount !== _this.connectCounter) {
                return;
            }
            if (!transport && !fatal) {
                tryFallbackHosts();
            }
        };
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectBase()', 'Trying to connect with base transport ' + this.baseTransport);
        /* first try to establish a connection with the priority host with http transport */
        var host = candidateHosts.shift();
        if (!host) {
            giveUp(new errorinfo_1.default('Unable to connect (no available host)', 80003, 404));
            return;
        }
        transportParams.host = host;
        /* this is what we'll be doing if the attempt for the main host fails */
        var tryFallbackHosts = function () {
            /* if there aren't any fallback hosts, fail */
            if (!candidateHosts.length) {
                giveUp(new errorinfo_1.default('Unable to connect (and no more fallback hosts to try)', 80003, 404));
                return;
            }
            /* before trying any fallback (or any remaining fallback) we decide if
             * there is a problem with the ably host, or there is a general connectivity
             * problem */
            if (!_this.realtime.http.checkConnectivity) {
                giveUp(new errorinfo_1.PartialErrorInfo('Internal error: Http.checkConnectivity not set', null, 500));
                return;
            }
            _this.realtime.http.checkConnectivity(function (err, connectivity) {
                if (connectCount !== _this.connectCounter) {
                    return;
                }
                /* we know err won't happen but handle it here anyway */
                if (err) {
                    giveUp(err);
                    return;
                }
                if (!connectivity) {
                    /* the internet isn't reachable, so don't try the fallback hosts */
                    giveUp(new errorinfo_1.default('Unable to connect (network unreachable)', 80003, 404));
                    return;
                }
                /* the network is there, so there's a problem with the main host, or
                 * its dns. Try the fallback hosts. We could try them simultaneously but
                 * that would potentially cause a huge spike in load on the load balancer */
                transportParams.host = Utils.arrPopRandomElement(candidateHosts);
                _this.tryATransport(transportParams, _this.baseTransport, hostAttemptCb);
            });
        };
        if (this.forceFallbackHost && candidateHosts.length) {
            this.forceFallbackHost = false;
            tryFallbackHosts();
            return;
        }
        this.tryATransport(transportParams, this.baseTransport, hostAttemptCb);
    };
    ConnectionManager.prototype.getUpgradePossibilities = function () {
        /* returns the subset of upgradeTransports to the right of the current
         * transport in upgradeTransports (if it's in there - if not, currentSerial
         * will be -1, so return upgradeTransports.slice(0) == upgradeTransports */
        var current = this.activeProtocol.getTransport().shortName;
        var currentSerial = Utils.arrIndexOf(this.upgradeTransports, current);
        return this.upgradeTransports.slice(currentSerial + 1);
    };
    ConnectionManager.prototype.upgradeIfNeeded = function (transportParams) {
        var _this = this;
        var upgradePossibilities = this.getUpgradePossibilities();
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.upgradeIfNeeded()', 'upgrade possibilities: ' + platform_1.default.Config.inspect(upgradePossibilities));
        if (!upgradePossibilities.length) {
            return;
        }
        Utils.arrForEach(upgradePossibilities, function (upgradeTransport) {
            /* Note: the transport may mutate the params, so give each transport a fresh one */
            var upgradeTransportParams = _this.createTransportParams(transportParams.host, 'upgrade');
            _this.tryATransport(upgradeTransportParams, upgradeTransport, noop);
        });
    };
    ConnectionManager.prototype.closeImpl = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.closeImpl()', 'closing connection');
        this.cancelSuspendTimer();
        this.startTransitionTimer(this.states.closing);
        Utils.safeArrForEach(this.pendingTransports, function (transport) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing pending transport: ' + transport);
            if (transport)
                transport.close();
        });
        Utils.safeArrForEach(this.proposedTransports, function (transport) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.closeImpl()', 'Disposing of proposed transport: ' + transport);
            if (transport)
                transport.dispose();
        });
        if (this.activeProtocol) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing active transport: ' + this.activeProtocol.getTransport());
            this.activeProtocol.getTransport().close();
        }
        /* If there was an active transport, this will probably be
         * preempted by the notifyState call in deactivateTransport */
        this.notifyState({ state: 'closed' });
    };
    ConnectionManager.prototype.onAuthUpdated = function (tokenDetails, callback) {
        var _this = this;
        var _a;
        switch (this.state.state) {
            case 'connected': {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.onAuthUpdated()', 'Sending AUTH message on active transport');
                /* If there are any proposed/pending transports (eg an upgrade that
                 * isn't yet scheduled for activation) that hasn't yet started syncing,
                 * just to get rid of them & restart the upgrade with the new token, to
                 * avoid a race condition. (If it has started syncing, the AUTH will be
                 * queued until the upgrade is complete, so everything's fine) */
                if ((this.pendingTransports.length || this.proposedTransports.length) &&
                    this.state !== this.states.synchronizing) {
                    this.disconnectAllTransports(/* exceptActive: */ true);
                    var transportParams_1 = this.activeProtocol.getTransport().params;
                    platform_1.default.Config.nextTick(function () {
                        if (_this.state.state === 'connected') {
                            _this.upgradeIfNeeded(transportParams_1);
                        }
                    });
                }
                /* Do any transport-specific new-token action */
                var activeTransport = (_a = this.activeProtocol) === null || _a === void 0 ? void 0 : _a.getTransport();
                if (activeTransport && activeTransport.onAuthUpdated) {
                    activeTransport.onAuthUpdated(tokenDetails);
                }
                var authMsg = protocolmessage_1.default.fromValues({
                    action: actions.AUTH,
                    auth: {
                        accessToken: tokenDetails.token,
                    },
                });
                this.send(authMsg);
                /* The answer will come back as either a connectiondetails event
                 * (realtime sends a CONNECTED to acknowledge the reauth) or a
                 * statechange to failed */
                var successListener_1 = function () {
                    _this.off(failureListener_1);
                    callback(null, tokenDetails);
                };
                var failureListener_1 = function (stateChange) {
                    if (stateChange.current === 'failed') {
                        _this.off(successListener_1);
                        _this.off(failureListener_1);
                        callback(stateChange.reason || _this.getStateError());
                    }
                };
                this.once('connectiondetails', successListener_1);
                this.on('connectionstate', failureListener_1);
                break;
            }
            case 'connecting':
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.onAuthUpdated()', 'Aborting current connection attempts in order to start again with the new auth details');
                this.disconnectAllTransports();
            /* fallthrough to add statechange listener */
            default: {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.onAuthUpdated()', 'Connection state is ' + this.state.state + '; waiting until either connected or failed');
                var listener_1 = function (stateChange) {
                    switch (stateChange.current) {
                        case 'connected':
                            _this.off(listener_1);
                            callback(null, tokenDetails);
                            break;
                        case 'failed':
                        case 'closed':
                        case 'suspended':
                            _this.off(listener_1);
                            callback(stateChange.reason || _this.getStateError());
                            break;
                        default:
                            /* ignore till we get either connected or failed */
                            break;
                    }
                };
                this.on('connectionstate', listener_1);
                if (this.state.state === 'connecting') {
                    /* can happen if in the connecting state but no transport was pending
                     * yet, so disconnectAllTransports did not trigger a disconnected state */
                    this.startConnect();
                }
                else {
                    this.requestState({ state: 'connecting' });
                }
            }
        }
    };
    ConnectionManager.prototype.disconnectAllTransports = function (exceptActive) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting all transports' + (exceptActive ? ' except the active transport' : ''));
        /* This will prevent any connection procedure in an async part of one of its early stages from continuing */
        this.connectCounter++;
        Utils.safeArrForEach(this.pendingTransports, function (transport) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting pending transport: ' + transport);
            if (transport)
                transport.disconnect();
        });
        this.pendingTransports = [];
        Utils.safeArrForEach(this.proposedTransports, function (transport) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disposing of proposed transport: ' + transport);
            if (transport)
                transport.dispose();
        });
        this.proposedTransports = [];
        if (this.activeProtocol && !exceptActive) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting active transport: ' + this.activeProtocol.getTransport());
            this.activeProtocol.getTransport().disconnect();
        }
        /* No need to notify state disconnected; disconnecting the active transport
         * will have that effect */
    };
    /******************
     * event queueing
     ******************/
    ConnectionManager.prototype.send = function (msg, queueEvent, callback) {
        callback = callback || noop;
        var state = this.state;
        if (state.sendEvents) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.send()', 'sending event');
            this.sendImpl(new protocol_1.PendingMessage(msg, callback));
            return;
        }
        var shouldQueue = (queueEvent && state.queueEvents) || state.forceQueueEvents;
        if (!shouldQueue) {
            var err = 'rejecting event, queueEvent was ' + queueEvent + ', state was ' + state.state;
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.send()', err);
            callback(this.errorReason || new errorinfo_1.default(err, 90000, 400));
            return;
        }
        if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.send()', 'queueing msg; ' + protocolmessage_1.default.stringify(msg));
        }
        this.queue(msg, callback);
    };
    ConnectionManager.prototype.sendImpl = function (pendingMessage) {
        var msg = pendingMessage.message;
        /* If have already attempted to send this, resend with the same msgSerial,
         * so Ably can dedup if the previous send succeeded */
        if (pendingMessage.ackRequired && !pendingMessage.sendAttempted) {
            msg.msgSerial = this.msgSerial++;
        }
        try {
            this.activeProtocol.send(pendingMessage);
        }
        catch (e) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.sendImpl()', 'Unexpected exception in transport.send(): ' + e.stack);
        }
    };
    ConnectionManager.prototype.queue = function (msg, callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.queue()', 'queueing event');
        var lastQueued = this.queuedMessages.last();
        var maxSize = this.options.maxMessageSize;
        /* If have already attempted to send a message, don't merge more messages
         * into it, as if the previous send actually succeeded and realtime ignores
         * the dup, they'll be lost */
        if (lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {
            if (!lastQueued.merged) {
                lastQueued.callback = multicaster_1.default.create([lastQueued.callback]);
                lastQueued.merged = true;
            }
            lastQueued.callback.push(callback);
        }
        else {
            this.queuedMessages.push(new protocol_1.PendingMessage(msg, callback));
        }
    };
    ConnectionManager.prototype.sendQueuedMessages = function () {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.sendQueuedMessages()', 'sending ' + this.queuedMessages.count() + ' queued messages');
        var pendingMessage;
        while ((pendingMessage = this.queuedMessages.shift()))
            this.sendImpl(pendingMessage);
    };
    ConnectionManager.prototype.queuePendingMessages = function (pendingMessages) {
        if (pendingMessages && pendingMessages.length) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.queuePendingMessages()', 'queueing ' + pendingMessages.length + ' pending messages');
            this.queuedMessages.prepend(pendingMessages);
        }
    };
    ConnectionManager.prototype.failQueuedMessages = function (err) {
        var numQueued = this.queuedMessages.count();
        if (numQueued > 0) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.failQueuedMessages()', 'failing ' + numQueued + ' queued messages, err = ' + Utils.inspectError(err));
            this.queuedMessages.completeAllMessages(err);
        }
    };
    ConnectionManager.prototype.onChannelMessage = function (message, transport) {
        var onActiveTransport = this.activeProtocol && transport === this.activeProtocol.getTransport(), onUpgradeTransport = Utils.arrIn(this.pendingTransports, transport) && this.state == this.states.synchronizing;
        /* As the lib now has a period where the upgrade transport is synced but
         * before it's become active (while waiting for the old one to become
         * idle), message can validly arrive on it even though it isn't active */
        if (onActiveTransport || onUpgradeTransport) {
            this.realtime.channels.onChannelMessage(message);
        }
        else {
            // Message came in on a defunct transport. Allow only acks, nacks, & errors for outstanding
            // messages,  no new messages (as sync has been sent on new transport so new messages will
            // be resent there, or connection has been closed so don't want new messages)
            if (Utils.arrIndexOf([actions.ACK, actions.NACK, actions.ERROR], message.action) > -1) {
                this.realtime.channels.onChannelMessage(message);
            }
            else {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.onChannelMessage()', 'received message ' + JSON.stringify(message) + 'on defunct transport; discarding');
            }
        }
    };
    ConnectionManager.prototype.ping = function (transport, callback) {
        var _this = this;
        /* if transport is specified, try that */
        if (transport) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.ping()', 'transport = ' + transport);
            var onTimeout = function () {
                transport.off('heartbeat', onHeartbeat_1);
                callback(new errorinfo_1.default('Timeout waiting for heartbeat response', 50000, 500));
            };
            var pingStart_1 = Utils.now(), id_1 = Utils.cheapRandStr();
            var onHeartbeat_1 = function (responseId) {
                if (responseId === id_1) {
                    transport.off('heartbeat', onHeartbeat_1);
                    clearTimeout(timer_1);
                    var responseTime = Utils.now() - pingStart_1;
                    callback(null, responseTime);
                }
            };
            var timer_1 = setTimeout(onTimeout, this.options.timeouts.realtimeRequestTimeout);
            transport.on('heartbeat', onHeartbeat_1);
            transport.ping(id_1);
            return;
        }
        /* if we're not connected, don't attempt */
        if (this.state.state !== 'connected') {
            callback(new errorinfo_1.default('Unable to ping service; not connected', 40000, 400));
            return;
        }
        /* no transport was specified, so use the current (connected) one
         * but ensure that we retry if the transport is superseded before we complete */
        var completed = false;
        var onPingComplete = function (err, responseTime) {
            _this.off('transport.active', onTransportActive);
            if (!completed) {
                completed = true;
                callback(err, responseTime);
            }
        };
        var onTransportActive = function () {
            if (!completed) {
                /* ensure that no callback happens for the currently outstanding operation */
                completed = true;
                /* repeat but picking up the new transport */
                platform_1.default.Config.nextTick(function () {
                    _this.ping(null, callback);
                });
            }
        };
        this.on('transport.active', onTransportActive);
        this.ping(this.activeProtocol.getTransport(), onPingComplete);
    };
    ConnectionManager.prototype.abort = function (error) {
        this.activeProtocol.getTransport().fail(error);
    };
    ConnectionManager.prototype.registerProposedTransport = function (transport) {
        this.proposedTransports.push(transport);
    };
    ConnectionManager.prototype.getTransportPreference = function () {
        var _a, _b;
        return this.transportPreference || (haveWebStorage() && ((_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.get) === null || _b === void 0 ? void 0 : _b.call(_a, transportPreferenceName)));
    };
    ConnectionManager.prototype.persistTransportPreference = function (transport) {
        var _a, _b;
        if (Utils.arrIn(defaults_1.default.upgradeTransports, transport.shortName)) {
            this.transportPreference = transport.shortName;
            if (haveWebStorage()) {
                (_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.set) === null || _b === void 0 ? void 0 : _b.call(_a, transportPreferenceName, transport.shortName);
            }
        }
    };
    ConnectionManager.prototype.unpersistTransportPreference = function () {
        var _a, _b;
        this.transportPreference = null;
        if (haveWebStorage()) {
            (_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.remove) === null || _b === void 0 ? void 0 : _b.call(_a, transportPreferenceName);
        }
    };
    /* This method is only used during connection attempts, so implements RSA4c1, RSA4c2,
     * and RSA4d. It is generally not invoked for serverside-triggered reauths or manual
     * reauths, so RSA4c3 does not apply, except (per per RSA4d1) in the case that the auth
     * server returns 403. */
    ConnectionManager.prototype.actOnErrorFromAuthorize = function (err) {
        if (err.code === 40171) {
            /* No way to reauth */
            this.notifyState({ state: 'failed', error: err });
        }
        else if (err.code === 40102) {
            this.notifyState({ state: 'failed', error: err });
        }
        else if (err.statusCode === HttpStatusCodes_1.default.Forbidden) {
            var msg = 'Client configured authentication provider returned 403; failing the connection';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.actOnErrorFromAuthorize()', msg);
            this.notifyState({ state: 'failed', error: new errorinfo_1.default(msg, 80019, 403, err) });
        }
        else {
            var msg = 'Client configured authentication provider request failed';
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.actOnErrorFromAuthorize', msg);
            this.notifyState({ state: this.state.failState, error: new errorinfo_1.default(msg, 80019, 401, err) });
        }
    };
    ConnectionManager.prototype.onConnectionDetailsUpdate = function (connectionDetails, transport) {
        if (!connectionDetails) {
            return;
        }
        this.connectionDetails = connectionDetails;
        if (connectionDetails.maxMessageSize) {
            this.options.maxMessageSize = connectionDetails.maxMessageSize;
        }
        var clientId = connectionDetails.clientId;
        if (clientId) {
            var err = this.realtime.auth._uncheckedSetClientId(clientId);
            if (err) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.onConnectionDetailsUpdate()', err.message);
                /* Errors setting the clientId are fatal to the connection */
                transport.fail(err);
                return;
            }
        }
        var connectionStateTtl = connectionDetails.connectionStateTtl;
        if (connectionStateTtl) {
            this.connectionStateTtl = connectionStateTtl;
        }
        this.maxIdleInterval = connectionDetails.maxIdleInterval;
        this.emit('connectiondetails', connectionDetails);
    };
    /*********************
     * transport management
     *********************/
    ConnectionManager.supportedTransports = {};
    return ConnectionManager;
}(eventemitter_1.default));
exports.default = ConnectionManager;

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_301120__(13)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __nested_webpack_require_391408__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_391408__(0);
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_391408__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_391408__(2));
var MessageQueue = /** @class */ (function (_super) {
    tslib_1.__extends(MessageQueue, _super);
    function MessageQueue() {
        var _this = _super.call(this) || this;
        _this.messages = [];
        return _this;
    }
    MessageQueue.prototype.count = function () {
        return this.messages.length;
    };
    MessageQueue.prototype.push = function (message) {
        this.messages.push(message);
    };
    MessageQueue.prototype.shift = function () {
        return this.messages.shift();
    };
    MessageQueue.prototype.last = function () {
        return this.messages[this.messages.length - 1];
    };
    MessageQueue.prototype.copyAll = function () {
        return this.messages.slice();
    };
    MessageQueue.prototype.append = function (messages) {
        this.messages.push.apply(this.messages, messages);
    };
    MessageQueue.prototype.prepend = function (messages) {
        this.messages.unshift.apply(this.messages, messages);
    };
    MessageQueue.prototype.completeMessages = function (serial, count, err) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'MessageQueue.completeMessages()', 'serial = ' + serial + '; count = ' + count);
        err = err || null;
        var messages = this.messages;
        if (messages.length === 0) {
            throw new Error('MessageQueue.completeMessages(): completeMessages called on any empty MessageQueue');
        }
        var first = messages[0];
        if (first) {
            var startSerial = first.message.msgSerial;
            var endSerial = serial + count; /* the serial of the first message that is *not* the subject of this call */
            if (endSerial > startSerial) {
                var completeMessages = messages.splice(0, endSerial - startSerial);
                for (var _i = 0, completeMessages_1 = completeMessages; _i < completeMessages_1.length; _i++) {
                    var message = completeMessages_1[_i];
                    message.callback(err);
                }
            }
            if (messages.length == 0)
                this.emit('idle');
        }
    };
    MessageQueue.prototype.completeAllMessages = function (err) {
        this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);
    };
    MessageQueue.prototype.resetSendAttempted = function () {
        for (var _i = 0, _a = this.messages; _i < _a.length; _i++) {
            var msg = _a[_i];
            msg.sendAttempted = false;
        }
    };
    MessageQueue.prototype.clear = function () {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'MessageQueue.clear()', 'clearing ' + this.messages.length + ' messages');
        this.messages = [];
        this.emit('idle');
    };
    return MessageQueue;
}(eventemitter_1.default));
exports.default = MessageQueue;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ConnectionStateChange = /** @class */ (function () {
    function ConnectionStateChange(previous, current, retryIn, reason) {
        this.previous = previous;
        this.current = current;
        if (retryIn)
            this.retryIn = retryIn;
        if (reason)
            this.reason = reason;
    }
    return ConnectionStateChange;
}());
exports.default = ConnectionStateChange;


/***/ }),
/* 38 */
/***/ (function(module, exports, __nested_webpack_require_395113__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_395113__(0);
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(10));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(7));
var Utils = tslib_1.__importStar(__nested_webpack_require_395113__(1));
var channel_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(33));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(2));
var realtimepresence_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(54));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(9));
var channelstatechange_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(39));
var errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_395113__(4));
var presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(15));
var connectionerrors_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(20));
var actions = protocolmessage_1.default.Action;
var noop = function () { };
function validateChannelOptions(options) {
    if (options && 'params' in options && !Utils.isObject(options.params)) {
        return new errorinfo_1.default('options.params must be an object', 40000, 400);
    }
    if (options && 'modes' in options) {
        if (!Utils.isArray(options.modes)) {
            return new errorinfo_1.default('options.modes must be an array', 40000, 400);
        }
        for (var i = 0; i < options.modes.length; i++) {
            var currentMode = options.modes[i];
            if (!currentMode ||
                typeof currentMode !== 'string' ||
                !Utils.arrIn(protocolmessage_1.default.channelModes, String.prototype.toUpperCase.call(currentMode))) {
                return new errorinfo_1.default('Invalid channel mode: ' + currentMode, 40000, 400);
            }
        }
    }
}
var RealtimeChannel = /** @class */ (function (_super) {
    tslib_1.__extends(RealtimeChannel, _super);
    function RealtimeChannel(realtime, name, options) {
        var _this = _super.call(this, realtime, name, options) || this;
        _this.retryCount = 0;
        _this.history = function (params, callback) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.history()', 'channel = ' + this.name);
            /* params and callback are optional; see if params contains the callback */
            if (callback === undefined) {
                if (typeof params == 'function') {
                    callback = params;
                    params = null;
                }
                else {
                    if (this.rest.options.promises) {
                        return Utils.promisify(this, 'history', arguments);
                    }
                    callback = noop;
                }
            }
            if (params && params.untilAttach) {
                if (this.state !== 'attached') {
                    callback(new errorinfo_1.default('option untilAttach requires the channel to be attached', 40000, 400));
                    return;
                }
                if (!this.properties.attachSerial) {
                    callback(new errorinfo_1.default('untilAttach was specified and channel is attached, but attachSerial is not defined', 40000, 400));
                    return;
                }
                delete params.untilAttach;
                params.from_serial = this.properties.attachSerial;
            }
            channel_1.default.prototype._history.call(this, params, callback);
        };
        _this.whenState = (function (state, listener) {
            return eventemitter_1.default.prototype.whenState.call(_this, state, _this.state, listener);
        });
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel()', 'started; name = ' + name);
        _this.realtime = realtime;
        _this.presence = new realtimepresence_1.default(_this);
        _this.connectionManager = realtime.connection.connectionManager;
        _this.state = 'initialized';
        _this.subscriptions = new eventemitter_1.default();
        _this.syncChannelSerial = undefined;
        _this.properties = {
            attachSerial: undefined,
            channelSerial: undefined,
        };
        _this.setOptions(options);
        _this.errorReason = null;
        _this._requestedFlags = null;
        _this._mode = null;
        _this._attachResume = false;
        _this._decodingContext = {
            channelOptions: _this.channelOptions,
            plugins: realtime.options.plugins || {},
            baseEncodedPreviousPayload: undefined,
        };
        _this._lastPayload = {
            messageId: null,
            protocolMessageChannelSerial: null,
            decodeFailureRecoveryInProgress: null,
        };
        /* Only differences between this and the public event emitter is that this emits an
         * update event for all ATTACHEDs, whether resumed or not */
        _this._allChannelChanges = new eventemitter_1.default();
        return _this;
    }
    RealtimeChannel.prototype.invalidStateError = function () {
        return new errorinfo_1.default('Channel operation failed as channel state is ' + this.state, 90001, 400, this.errorReason || undefined);
    };
    RealtimeChannel.processListenerArgs = function (args) {
        /* [event], listener, [callback] */
        args = Array.prototype.slice.call(args);
        if (typeof args[0] === 'function') {
            args.unshift(null);
        }
        if (args[args.length - 1] == undefined) {
            args.pop();
        }
        return args;
    };
    RealtimeChannel.prototype.setOptions = function (options, callback) {
        if (!callback) {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'setOptions', arguments);
            }
        }
        var _callback = callback ||
            function (err) {
                if (err) {
                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.setOptions()', 'Set options failed: ' + err.toString());
                }
            };
        var err = validateChannelOptions(options);
        if (err) {
            _callback(err);
            return;
        }
        channel_1.default.prototype.setOptions.call(this, options);
        if (this._decodingContext)
            this._decodingContext.channelOptions = this.channelOptions;
        if (this._shouldReattachToSetOptions(options)) {
            /* This does not just do _attach(true, null, callback) because that would put us
             * into the 'attaching' state until we receive the new attached, which is
             * conceptually incorrect: we are still attached, we just have a pending request to
             * change some channel params. Per RTL17 going into the attaching state would mean
             * rejecting messages until we have confirmation that the options have changed,
             * which would unnecessarily lose message continuity. */
            this.attachImpl();
            // Ignore 'attaching' -- could be just due to to a resume & reattach, should not
            // call back setOptions until we're definitely attached with the new options (or
            // else in a terminal state)
            this._allChannelChanges.once(['attached', 'update', 'detached', 'failed'], function (stateChange) {
                switch (this.event) {
                    case 'update':
                    case 'attached':
                        _callback === null || _callback === void 0 ? void 0 : _callback(null);
                        return;
                    default:
                        _callback === null || _callback === void 0 ? void 0 : _callback(stateChange.reason);
                        return;
                }
            });
        }
        else {
            _callback();
        }
    };
    RealtimeChannel.prototype._shouldReattachToSetOptions = function (options) {
        return (this.state === 'attached' || this.state === 'attaching') && ((options === null || options === void 0 ? void 0 : options.params) || (options === null || options === void 0 ? void 0 : options.modes));
    };
    RealtimeChannel.prototype.publish = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var messages = args[0];
        var argCount = args.length;
        var callback = args[argCount - 1];
        if (typeof callback !== 'function') {
            if (this.realtime.options.promises) {
                return Utils.promisify(this, 'publish', arguments);
            }
            callback = noop;
            ++argCount;
        }
        if (!this.connectionManager.activeState()) {
            callback(this.connectionManager.getError());
            return;
        }
        if (argCount == 2) {
            if (Utils.isObject(messages))
                messages = [message_1.default.fromValues(messages)];
            else if (Utils.isArray(messages))
                messages = message_1.default.fromValuesArray(messages);
            else
                throw new errorinfo_1.default('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);
        }
        else {
            messages = [message_1.default.fromValues({ name: args[0], data: args[1] })];
        }
        var maxMessageSize = this.realtime.options.maxMessageSize;
        message_1.default.encodeArray(messages, this.channelOptions, function (err) {
            if (err) {
                callback(err);
                return;
            }
            /* RSL1i */
            var size = message_1.default.getMessagesSize(messages);
            if (size > maxMessageSize) {
                callback(new errorinfo_1.default('Maximum size of messages that can be published at once exceeded ( was ' +
                    size +
                    ' bytes; limit is ' +
                    maxMessageSize +
                    ' bytes)', 40009, 400));
                return;
            }
            _this.__publish(messages, callback);
        });
    };
    // Double underscore used to prevent type conflict with underlying Channel._publish method
    RealtimeChannel.prototype.__publish = function (messages, callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.publish()', 'message count = ' + messages.length);
        var state = this.state;
        switch (state) {
            case 'failed':
            case 'suspended':
                callback(errorinfo_1.default.fromValues(this.invalidStateError()));
                break;
            default: {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.publish()', 'sending message; channel state is ' + state);
                var msg = new protocolmessage_1.default();
                msg.action = actions.MESSAGE;
                msg.channel = this.name;
                msg.messages = messages;
                this.sendMessage(msg, callback);
                break;
            }
        }
    };
    RealtimeChannel.prototype.onEvent = function (messages) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.onEvent()', 'received message');
        var subscriptions = this.subscriptions;
        for (var i = 0; i < messages.length; i++) {
            var message = messages[i];
            subscriptions.emit(message.name, message);
        }
    };
    RealtimeChannel.prototype.attach = function (flags, callback) {
        var _flags;
        if (typeof flags === 'function') {
            callback = flags;
            _flags = null;
        }
        else {
            _flags = flags;
        }
        if (!callback) {
            if (this.realtime.options.promises) {
                return Utils.promisify(this, 'attach', arguments);
            }
            callback = function (err) {
                if (err) {
                    logger_1.default.logAction(logger_1.default.LOG_MAJOR, 'RealtimeChannel.attach()', 'Channel attach failed: ' + err.toString());
                }
            };
        }
        if (_flags) {
            logger_1.default.deprecated('channel.attach() with flags', 'channel.setOptions() with channelOptions.params');
            /* If flags requested, always do a re-attach. TODO only do this if
             * current mode differs from requested mode */
            this._requestedFlags = _flags;
        }
        else if (this.state === 'attached') {
            callback(null, null);
            return;
        }
        this._attach(false, null, callback);
    };
    RealtimeChannel.prototype._attach = function (forceReattach, attachReason, callback) {
        if (!callback) {
            callback = function (err) {
                if (err) {
                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel._attach()', 'Channel attach failed: ' + err.toString());
                }
            };
        }
        var connectionManager = this.connectionManager;
        if (!connectionManager.activeState()) {
            callback(connectionManager.getError());
            return;
        }
        if (this.state !== 'attaching' || forceReattach) {
            this.requestState('attaching', attachReason);
        }
        this.once(function (stateChange) {
            switch (this.event) {
                case 'attached':
                    callback === null || callback === void 0 ? void 0 : callback(null, stateChange);
                    break;
                case 'detached':
                case 'suspended':
                case 'failed':
                    callback === null || callback === void 0 ? void 0 : callback(stateChange.reason ||
                        connectionManager.getError() ||
                        new errorinfo_1.default('Unable to attach; reason unknown; state = ' + this.event, 90000, 500));
                    break;
                case 'detaching':
                    callback === null || callback === void 0 ? void 0 : callback(new errorinfo_1.default('Attach request superseded by a subsequent detach request', 90000, 409));
                    break;
            }
        });
    };
    RealtimeChannel.prototype.attachImpl = function () {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.attachImpl()', 'sending ATTACH message');
        var attachMsg = protocolmessage_1.default.fromValues({
            action: actions.ATTACH,
            channel: this.name,
            params: this.channelOptions.params,
            // RTL4c1: Includes the channel serial to resume from a previous message
            // or attachment.
            channelSerial: this.properties.channelSerial,
        });
        if (this._requestedFlags) {
            attachMsg.encodeModesToFlags(this._requestedFlags);
        }
        else if (this.channelOptions.modes) {
            attachMsg.encodeModesToFlags(Utils.allToUpperCase(this.channelOptions.modes));
        }
        if (this._attachResume) {
            attachMsg.setFlag('ATTACH_RESUME');
        }
        if (this._lastPayload.decodeFailureRecoveryInProgress) {
            attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;
        }
        this.sendMessage(attachMsg, noop);
    };
    RealtimeChannel.prototype.detach = function (callback) {
        if (!callback) {
            if (this.realtime.options.promises) {
                return Utils.promisify(this, 'detach', arguments);
            }
            callback = noop;
        }
        var connectionManager = this.connectionManager;
        if (!connectionManager.activeState()) {
            callback(connectionManager.getError());
            return;
        }
        switch (this.state) {
            case 'suspended':
                this.notifyState('detached');
                callback();
                break;
            case 'detached':
                callback();
                break;
            case 'failed':
                callback(new errorinfo_1.default('Unable to detach; channel state = failed', 90001, 400));
                break;
            default:
                this.requestState('detaching');
            // eslint-disable-next-line no-fallthrough
            case 'detaching':
                this.once(function (stateChange) {
                    switch (this.event) {
                        case 'detached':
                            callback();
                            break;
                        case 'attached':
                        case 'suspended':
                        case 'failed':
                            callback(stateChange.reason ||
                                connectionManager.getError() ||
                                new errorinfo_1.default('Unable to detach; reason unknown; state = ' + this.event, 90000, 500));
                            break;
                        case 'attaching':
                            callback(new errorinfo_1.default('Detach request superseded by a subsequent attach request', 90000, 409));
                            break;
                    }
                });
        }
    };
    RealtimeChannel.prototype.detachImpl = function (callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.detach()', 'sending DETACH message');
        var msg = protocolmessage_1.default.fromValues({ action: actions.DETACH, channel: this.name });
        this.sendMessage(msg, callback || noop);
    };
    RealtimeChannel.prototype.subscribe = function () {
        var args = []; /* [event], listener, [callback] */
        for (var _i = 0 /* [event], listener, [callback] */; _i < arguments.length /* [event], listener, [callback] */; _i++ /* [event], listener, [callback] */) {
            args[_i] = arguments[_i]; /* [event], listener, [callback] */
        }
        var _a = RealtimeChannel.processListenerArgs(args), event = _a[0], listener = _a[1], callback = _a[2];
        if (!callback && this.realtime.options.promises) {
            return Utils.promisify(this, 'subscribe', [event, listener]);
        }
        if (this.state === 'failed') {
            callback === null || callback === void 0 ? void 0 : callback(errorinfo_1.default.fromValues(this.invalidStateError()));
            return;
        }
        // Filtered
        if (event && typeof event === 'object' && !Array.isArray(event)) {
            this._subscribeFilter(event, listener);
        }
        else {
            this.subscriptions.on(event, listener);
        }
        return this.attach(callback || noop);
    };
    RealtimeChannel.prototype._subscribeFilter = function (filter, listener) {
        var filteredListener = function (m) {
            var _a, _b, _c, _d, _e, _f;
            var mapping = {
                name: m.name,
                refTimeserial: (_b = (_a = m.extras) === null || _a === void 0 ? void 0 : _a.ref) === null || _b === void 0 ? void 0 : _b.timeserial,
                refType: (_d = (_c = m.extras) === null || _c === void 0 ? void 0 : _c.ref) === null || _d === void 0 ? void 0 : _d.type,
                isRef: !!((_f = (_e = m.extras) === null || _e === void 0 ? void 0 : _e.ref) === null || _f === void 0 ? void 0 : _f.timeserial),
                clientId: m.clientId,
            };
            // Check if any values are defined in the filter and if they match the value in the message object
            if (Object.entries(filter).find(function (_a) {
                var key = _a[0], value = _a[1];
                return value !== undefined ? mapping[key] !== value : false;
            })) {
                return;
            }
            listener(m);
        };
        this._addFilteredSubscription(filter, listener, filteredListener);
        this.subscriptions.on(filteredListener);
    };
    // Adds a new filtered subscription
    RealtimeChannel.prototype._addFilteredSubscription = function (filter, realListener, filteredListener) {
        var _a;
        if (!this.filteredSubscriptions) {
            this.filteredSubscriptions = new Map();
        }
        if (this.filteredSubscriptions.has(realListener)) {
            var realListenerMap = this.filteredSubscriptions.get(realListener);
            // Add the filtered listener to the map, or append to the array if this filter has already been used
            realListenerMap.set(filter, ((_a = realListenerMap === null || realListenerMap === void 0 ? void 0 : realListenerMap.get(filter)) === null || _a === void 0 ? void 0 : _a.concat(filteredListener)) || [filteredListener]);
        }
        else {
            this.filteredSubscriptions.set(realListener, new Map([[filter, [filteredListener]]]));
        }
    };
    RealtimeChannel.prototype._getAndDeleteFilteredSubscriptions = function (filter, realListener) {
        var _this = this;
        // No filtered subscriptions map means there has been no filtered subscriptions yet, so return nothing
        if (!this.filteredSubscriptions) {
            return [];
        }
        // Only a filter is passed in with no specific listener
        if (!realListener && filter) {
            // Return each listener which is attached to the specified filter object
            return Array.from(this.filteredSubscriptions.entries())
                .map(function (_a) {
                var _b;
                var key = _a[0], filterMaps = _a[1];
                // Get (then delete) the maps matching this filter
                var listenerMaps = filterMaps.get(filter);
                filterMaps.delete(filter);
                // Clear the parent if nothing is left
                if (filterMaps.size === 0) {
                    (_b = _this.filteredSubscriptions) === null || _b === void 0 ? void 0 : _b.delete(key);
                }
                return listenerMaps;
            })
                .reduce(function (prev, cur) {
                var _a;
                return (cur ? (_a = prev).concat.apply(_a, cur) : prev);
            }, []);
        }
        // No subscriptions for this listener
        if (!realListener || !this.filteredSubscriptions.has(realListener)) {
            return [];
        }
        var realListenerMap = this.filteredSubscriptions.get(realListener);
        // If no filter is specified return all listeners using that function
        if (!filter) {
            // array.flat is not available unless we support es2019 or higher
            var listeners_1 = Array.from(realListenerMap.values()).reduce(function (prev, cur) { return prev.concat.apply(prev, cur); }, []);
            // remove the listener from the map
            this.filteredSubscriptions.delete(realListener);
            return listeners_1;
        }
        var listeners = realListenerMap.get(filter);
        realListenerMap.delete(filter);
        return listeners || [];
    };
    RealtimeChannel.prototype.unsubscribe = function () {
        var _this = this;
        var _a;
        var args = []; /* [event], listener */
        for (var _i = 0 /* [event], listener */; _i < arguments.length /* [event], listener */; _i++ /* [event], listener */) {
            args[_i] = arguments[_i]; /* [event], listener */
        }
        var _b = RealtimeChannel.processListenerArgs(args), event = _b[0], listener = _b[1];
        // If we either have a filtered listener, a filter or both we need to do additional processing to find the original function(s)
        if ((typeof event === 'object' && !listener) || ((_a = this.filteredSubscriptions) === null || _a === void 0 ? void 0 : _a.has(listener))) {
            this._getAndDeleteFilteredSubscriptions(event, listener).forEach(function (l) { return _this.subscriptions.off(l); });
            return;
        }
        this.subscriptions.off(event, listener);
    };
    RealtimeChannel.prototype.sync = function () {
        /* check preconditions */
        switch (this.state) {
            case 'initialized':
            case 'detaching':
            case 'detached':
                throw new errorinfo_1.PartialErrorInfo('Unable to sync to channel; not attached', 40000);
            default:
        }
        var connectionManager = this.connectionManager;
        if (!connectionManager.activeState()) {
            throw connectionManager.getError();
        }
        /* send sync request */
        var syncMessage = protocolmessage_1.default.fromValues({ action: actions.SYNC, channel: this.name });
        if (this.syncChannelSerial) {
            syncMessage.channelSerial = this.syncChannelSerial;
        }
        connectionManager.send(syncMessage);
    };
    RealtimeChannel.prototype.sendMessage = function (msg, callback) {
        this.connectionManager.send(msg, this.realtime.options.queueMessages, callback);
    };
    RealtimeChannel.prototype.sendPresence = function (presence, callback) {
        var msg = protocolmessage_1.default.fromValues({
            action: actions.PRESENCE,
            channel: this.name,
            presence: Utils.isArray(presence)
                ? presencemessage_1.default.fromValuesArray(presence)
                : [presencemessage_1.default.fromValues(presence)],
        });
        this.sendMessage(msg, callback);
    };
    RealtimeChannel.prototype.onMessage = function (message) {
        if (message.action === actions.ATTACHED ||
            message.action === actions.MESSAGE ||
            message.action === actions.PRESENCE) {
            // RTL15b
            this.setChannelSerial(message.channelSerial);
        }
        var syncChannelSerial, isSync = false;
        switch (message.action) {
            case actions.ATTACHED: {
                this.properties.attachSerial = message.channelSerial;
                this._mode = message.getMode();
                this.params = message.params || {};
                var modesFromFlags = message.decodeModesFromFlags();
                this.modes = (modesFromFlags && Utils.allToLowerCase(modesFromFlags)) || undefined;
                var resumed = message.hasFlag('RESUMED');
                var hasPresence = message.hasFlag('HAS_PRESENCE');
                var hasBacklog = message.hasFlag('HAS_BACKLOG');
                if (this.state === 'attached') {
                    if (!resumed) {
                        /* On a loss of continuity, the presence set needs to be re-synced */
                        this.presence.onAttached(hasPresence);
                    }
                    var change = new channelstatechange_1.default(this.state, this.state, resumed, hasBacklog, message.error);
                    this._allChannelChanges.emit('update', change);
                    if (!resumed || this.channelOptions.updateOnAttached) {
                        this.emit('update', change);
                    }
                }
                else if (this.state === 'detaching') {
                    /* RTL5i: re-send DETACH and remain in the 'detaching' state */
                    this.checkPendingState();
                }
                else {
                    this.notifyState('attached', message.error, resumed, hasPresence, hasBacklog);
                }
                break;
            }
            case actions.DETACHED: {
                var detachErr = message.error
                    ? errorinfo_1.default.fromValues(message.error)
                    : new errorinfo_1.default('Channel detached', 90001, 404);
                if (this.state === 'detaching') {
                    this.notifyState('detached', detachErr);
                }
                else if (this.state === 'attaching') {
                    /* Only retry immediately if we were previously attached. If we were
                     * attaching, go into suspended, fail messages, and wait a few seconds
                     * before retrying */
                    this.notifyState('suspended', detachErr);
                }
                else {
                    this.requestState('attaching', detachErr);
                }
                break;
            }
            case actions.SYNC:
                /* syncs can have channelSerials, but might not if the sync is one page long */
                isSync = true;
                syncChannelSerial = this.syncChannelSerial = message.channelSerial;
                /* syncs can happen on channels with no presence data as part of connection
                 * resuming, in which case protocol message has no presence property */
                if (!message.presence)
                    break;
            // eslint-disable-next-line no-fallthrough
            case actions.PRESENCE: {
                var presence = message.presence;
                var id = message.id, connectionId = message.connectionId, timestamp = message.timestamp;
                var options = this.channelOptions;
                var presenceMsg = void 0;
                for (var i = 0; i < presence.length; i++) {
                    try {
                        presenceMsg = presence[i];
                        presencemessage_1.default.decode(presenceMsg, options);
                        if (!presenceMsg.connectionId)
                            presenceMsg.connectionId = connectionId;
                        if (!presenceMsg.timestamp)
                            presenceMsg.timestamp = timestamp;
                        if (!presenceMsg.id)
                            presenceMsg.id = id + ':' + i;
                    }
                    catch (e) {
                        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());
                    }
                }
                this.presence.setPresence(presence, isSync, syncChannelSerial);
                break;
            }
            case actions.MESSAGE: {
                //RTL17
                if (this.state !== 'attached') {
                    logger_1.default.logAction(logger_1.default.LOG_MAJOR, 'RealtimeChannel.onMessage()', 'Message "' +
                        message.id +
                        '" skipped as this channel "' +
                        this.name +
                        '" state is not "attached" (state is "' +
                        this.state +
                        '").');
                    return;
                }
                var messages = message.messages, firstMessage = messages[0], lastMessage = messages[messages.length - 1], id = message.id, connectionId = message.connectionId, timestamp = message.timestamp;
                if (firstMessage.extras &&
                    firstMessage.extras.delta &&
                    firstMessage.extras.delta.from !== this._lastPayload.messageId) {
                    var msg = 'Delta message decode failure - previous message not available for message "' +
                        message.id +
                        '" on this channel "' +
                        this.name +
                        '".';
                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.onMessage()', msg);
                    this._startDecodeFailureRecovery(new errorinfo_1.default(msg, 40018, 400));
                    break;
                }
                for (var i = 0; i < messages.length; i++) {
                    var msg = messages[i];
                    try {
                        message_1.default.decode(msg, this._decodingContext);
                    }
                    catch (e) {
                        /* decrypt failed .. the most likely cause is that we have the wrong key */
                        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());
                        switch (e.code) {
                            case 40018:
                                /* decode failure */
                                this._startDecodeFailureRecovery(e);
                                return;
                            case 40019:
                            /* No vcdiff plugin passed in - no point recovering, give up */
                            // eslint-disable-next-line no-fallthrough
                            case 40021:
                                /* Browser does not support deltas, similarly no point recovering */
                                this.notifyState('failed', e);
                                return;
                        }
                    }
                    if (!msg.connectionId)
                        msg.connectionId = connectionId;
                    if (!msg.timestamp)
                        msg.timestamp = timestamp;
                    if (!msg.id)
                        msg.id = id + ':' + i;
                }
                this._lastPayload.messageId = lastMessage.id;
                this._lastPayload.protocolMessageChannelSerial = message.channelSerial;
                this.onEvent(messages);
                break;
            }
            case actions.ERROR: {
                /* there was a channel-specific error */
                var err = message.error;
                if (err && err.code == 80016) {
                    /* attach/detach operation attempted on superseded transport handle */
                    this.checkPendingState();
                }
                else {
                    this.notifyState('failed', errorinfo_1.default.fromValues(err));
                }
                break;
            }
            default:
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.onMessage()', 'Fatal protocol error: unrecognised action (' + message.action + ')');
                this.connectionManager.abort(connectionerrors_1.default.unknownChannelErr());
        }
    };
    RealtimeChannel.prototype._startDecodeFailureRecovery = function (reason) {
        var _this = this;
        if (!this._lastPayload.decodeFailureRecoveryInProgress) {
            logger_1.default.logAction(logger_1.default.LOG_MAJOR, 'RealtimeChannel.onMessage()', 'Starting decode failure recovery process.');
            this._lastPayload.decodeFailureRecoveryInProgress = true;
            this._attach(true, reason, function () {
                _this._lastPayload.decodeFailureRecoveryInProgress = false;
            });
        }
    };
    RealtimeChannel.prototype.onAttached = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.onAttached', 'activating channel; name = ' + this.name);
    };
    RealtimeChannel.prototype.notifyState = function (state, reason, resumed, hasPresence, hasBacklog) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.notifyState', 'name = ' + this.name + ', current state = ' + this.state + ', notifying state ' + state);
        this.clearStateTimer();
        // RTP5a1
        if (Utils.arrIn(['detached', 'suspended', 'failed'], state)) {
            this.properties.channelSerial = null;
        }
        if (state === this.state) {
            return;
        }
        this.presence.actOnChannelState(state, hasPresence, reason);
        if (state === 'suspended' && this.connectionManager.state.sendEvents) {
            this.startRetryTimer();
        }
        else {
            this.cancelRetryTimer();
        }
        if (reason) {
            this.errorReason = reason;
        }
        var change = new channelstatechange_1.default(this.state, state, resumed, hasBacklog, reason);
        var logLevel = state === 'failed' ? logger_1.default.LOG_ERROR : logger_1.default.LOG_MAJOR;
        logger_1.default.logAction(logLevel, 'Channel state for channel "' + this.name + '"', state + (reason ? '; reason: ' + reason : ''));
        if (state !== 'attaching' && state !== 'suspended') {
            this.retryCount = 0;
        }
        /* Note: we don't set inProgress for pending states until the request is actually in progress */
        if (state === 'attached') {
            this.onAttached();
        }
        if (state === 'attached') {
            this._attachResume = true;
        }
        else if (state === 'detaching' || state === 'failed') {
            this._attachResume = false;
        }
        this.state = state;
        this._allChannelChanges.emit(state, change);
        this.emit(state, change);
    };
    RealtimeChannel.prototype.requestState = function (state, reason) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.requestState', 'name = ' + this.name + ', state = ' + state);
        this.notifyState(state, reason);
        /* send the event and await response */
        this.checkPendingState();
    };
    RealtimeChannel.prototype.checkPendingState = function () {
        /* if can't send events, do nothing */
        var cmState = this.connectionManager.state;
        /* Allow attach messages to queue up when synchronizing, since this will be
         * the state we'll be in when upgrade transport.active triggers a checkpendingstate */
        if (!(cmState.sendEvents || cmState.forceQueueEvents)) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.checkPendingState', 'sendEvents is false; state is ' + this.connectionManager.state.state);
            return;
        }
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.checkPendingState', 'name = ' + this.name + ', state = ' + this.state);
        /* Only start the state timer running when actually sending the event */
        switch (this.state) {
            case 'attaching':
                this.startStateTimerIfNotRunning();
                this.attachImpl();
                break;
            case 'detaching':
                this.startStateTimerIfNotRunning();
                this.detachImpl();
                break;
            case 'attached':
                /* resume any sync operation that was in progress */
                this.sync();
                break;
            default:
                break;
        }
    };
    RealtimeChannel.prototype.timeoutPendingState = function () {
        switch (this.state) {
            case 'attaching': {
                var err = new errorinfo_1.default('Channel attach timed out', 90007, 408);
                this.notifyState('suspended', err);
                break;
            }
            case 'detaching': {
                var err = new errorinfo_1.default('Channel detach timed out', 90007, 408);
                this.notifyState('attached', err);
                break;
            }
            default:
                this.checkPendingState();
                break;
        }
    };
    RealtimeChannel.prototype.startStateTimerIfNotRunning = function () {
        var _this = this;
        if (!this.stateTimer) {
            this.stateTimer = setTimeout(function () {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.startStateTimerIfNotRunning', 'timer expired');
                _this.stateTimer = null;
                _this.timeoutPendingState();
            }, this.realtime.options.timeouts.realtimeRequestTimeout);
        }
    };
    RealtimeChannel.prototype.clearStateTimer = function () {
        var stateTimer = this.stateTimer;
        if (stateTimer) {
            clearTimeout(stateTimer);
            this.stateTimer = null;
        }
    };
    RealtimeChannel.prototype.startRetryTimer = function () {
        var _this = this;
        if (this.retryTimer)
            return;
        this.retryCount++;
        var retryDelay = Utils.getRetryTime(this.realtime.options.timeouts.channelRetryTimeout, this.retryCount);
        this.retryTimer = setTimeout(function () {
            /* If connection is not connected, just leave in suspended, a reattach
             * will be triggered once it connects again */
            if (_this.state === 'suspended' && _this.connectionManager.state.sendEvents) {
                _this.retryTimer = null;
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel retry timer expired', 'attempting a new attach');
                _this.requestState('attaching');
            }
        }, retryDelay);
    };
    RealtimeChannel.prototype.cancelRetryTimer = function () {
        if (this.retryTimer) {
            clearTimeout(this.retryTimer);
            this.retryTimer = null;
        }
    };
    /* @returns null (if can safely be released) | ErrorInfo (if cannot) */
    RealtimeChannel.prototype.getReleaseErr = function () {
        var s = this.state;
        if (s === 'initialized' || s === 'detached' || s === 'failed') {
            return null;
        }
        return new errorinfo_1.default('Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was ' +
            s, 90001, 400);
    };
    RealtimeChannel.prototype.setChannelSerial = function (channelSerial) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.setChannelSerial()', 'Updating channel serial; serial = ' + channelSerial + '; previous = ' + this.properties.channelSerial);
        // RTP17h: Only update the channel serial if its present (it won't always
        // be set).
        if (channelSerial) {
            this.properties.channelSerial = channelSerial;
        }
    };
    return RealtimeChannel;
}(channel_1.default));
exports.default = RealtimeChannel;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ChannelStateChange = /** @class */ (function () {
    function ChannelStateChange(previous, current, resumed, hasBacklog, reason) {
        this.previous = previous;
        this.current = current;
        if (current === 'attached') {
            this.resumed = resumed;
            this.hasBacklog = hasBacklog;
        }
        if (reason)
            this.reason = reason;
    }
    return ChannelStateChange;
}());
exports.default = ChannelStateChange;


/***/ }),
/* 40 */
/***/ (function(module, exports, __nested_webpack_require_437421__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_437421__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function inspect(buffer) {
    if (buffer === undefined)
        return 'undefined';
    var view;
    var type;
    if (buffer instanceof ArrayBuffer) {
        type = 'ArrayBuffer';
        view = new DataView(buffer);
    }
    else if (buffer instanceof DataView) {
        type = 'DataView';
        view = buffer;
    }
    if (!view)
        return JSON.stringify(buffer);
    var bytes = [];
    for (var i = 0; i < buffer.byteLength; i++) {
        if (i > 20) {
            bytes.push('...');
            break;
        }
        var byte_ = view.getUint8(i).toString(16);
        if (byte_.length === 1)
            byte_ = '0' + byte_;
        bytes.push(byte_);
    }
    return '<' + type + ' ' + bytes.join(' ') + '>';
}
// Encode string as utf8 into dataview at offset
function utf8Write(view, offset, string) {
    for (var i = 0, l = string.length; i < l; i++) {
        var codePoint = string.charCodeAt(i);
        // One byte of UTF-8
        if (codePoint < 0x80) {
            view.setUint8(offset++, ((codePoint >>> 0) & 0x7f) | 0x00);
            continue;
        }
        // Two bytes of UTF-8
        if (codePoint < 0x800) {
            view.setUint8(offset++, ((codePoint >>> 6) & 0x1f) | 0xc0);
            view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);
            continue;
        }
        // Three bytes of UTF-8.
        if (codePoint < 0x10000) {
            view.setUint8(offset++, ((codePoint >>> 12) & 0x0f) | 0xe0);
            view.setUint8(offset++, ((codePoint >>> 6) & 0x3f) | 0x80);
            view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);
            continue;
        }
        // Four bytes of UTF-8
        if (codePoint < 0x110000) {
            view.setUint8(offset++, ((codePoint >>> 18) & 0x07) | 0xf0);
            view.setUint8(offset++, ((codePoint >>> 12) & 0x3f) | 0x80);
            view.setUint8(offset++, ((codePoint >>> 6) & 0x3f) | 0x80);
            view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);
            continue;
        }
        throw new Error('bad codepoint ' + codePoint);
    }
}
function utf8Read(view, offset, length) {
    var string = '';
    for (var i = offset, end = offset + length; i < end; i++) {
        var byte_ = view.getUint8(i);
        // One byte character
        if ((byte_ & 0x80) === 0x00) {
            string += String.fromCharCode(byte_);
            continue;
        }
        // Two byte character
        if ((byte_ & 0xe0) === 0xc0) {
            string += String.fromCharCode(((byte_ & 0x0f) << 6) | (view.getUint8(++i) & 0x3f));
            continue;
        }
        // Three byte character
        if ((byte_ & 0xf0) === 0xe0) {
            string += String.fromCharCode(((byte_ & 0x0f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0));
            continue;
        }
        // Four byte character
        if ((byte_ & 0xf8) === 0xf0) {
            string += String.fromCharCode(((byte_ & 0x07) << 18) |
                ((view.getUint8(++i) & 0x3f) << 12) |
                ((view.getUint8(++i) & 0x3f) << 6) |
                ((view.getUint8(++i) & 0x3f) << 0));
            continue;
        }
        throw new Error('Invalid byte ' + byte_.toString(16));
    }
    return string;
}
function utf8ByteCount(string) {
    var count = 0;
    for (var i = 0, l = string.length; i < l; i++) {
        var codePoint = string.charCodeAt(i);
        if (codePoint < 0x80) {
            count += 1;
            continue;
        }
        if (codePoint < 0x800) {
            count += 2;
            continue;
        }
        if (codePoint < 0x10000) {
            count += 3;
            continue;
        }
        if (codePoint < 0x110000) {
            count += 4;
            continue;
        }
        throw new Error('bad codepoint ' + codePoint);
    }
    return count;
}
function encode(value, sparse) {
    var size = sizeof(value, sparse);
    if (size === 0)
        return undefined;
    var buffer = new ArrayBuffer(size);
    var view = new DataView(buffer);
    _encode(value, view, 0, sparse);
    return buffer;
}
var SH_L_32 = (1 << 16) * (1 << 16), SH_R_32 = 1 / SH_L_32;
function getInt64(view, offset) {
    offset = offset || 0;
    return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);
}
function getUint64(view, offset) {
    offset = offset || 0;
    return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);
}
function setInt64(view, offset, val) {
    if (val < 0x8000000000000000) {
        view.setInt32(offset, Math.floor(val * SH_R_32));
        view.setInt32(offset + 4, val & -1);
    }
    else {
        view.setUint32(offset, 0x7fffffff);
        view.setUint32(offset + 4, 0x7fffffff);
    }
}
function setUint64(view, offset, val) {
    if (val < 0x10000000000000000) {
        view.setUint32(offset, Math.floor(val * SH_R_32));
        view.setInt32(offset + 4, val & -1);
    }
    else {
        view.setUint32(offset, 0xffffffff);
        view.setUint32(offset + 4, 0xffffffff);
    }
}
// https://gist.github.com/frsyuki/5432559 - v5 spec
//
// I've used one extension point from `fixext 1` to store `undefined`. On the wire this
// should translate to exactly 0xd40000
//
// +--------+--------+--------+
// |  0xd4  |  0x00  |  0x00  |
// +--------+--------+--------+
//    ^ fixext |        ^ value part unused (fixed to be 0)
//             ^ indicates undefined value
//
var Decoder = /** @class */ (function () {
    function Decoder(view, offset) {
        var _this = this;
        this.map = function (length) {
            var value = {};
            for (var i = 0; i < length; i++) {
                var key = _this.parse();
                value[key] = _this.parse();
            }
            return value;
        };
        this.bin = function (length) {
            var value = new ArrayBuffer(length);
            new Uint8Array(value).set(new Uint8Array(_this.view.buffer, _this.offset, length), 0);
            _this.offset += length;
            return value;
        };
        this.buf = this.bin;
        this.str = function (length) {
            var value = utf8Read(_this.view, _this.offset, length);
            _this.offset += length;
            return value;
        };
        this.array = function (length) {
            var value = new Array(length);
            for (var i = 0; i < length; i++) {
                value[i] = _this.parse();
            }
            return value;
        };
        this.ext = function (length) {
            _this.offset += length;
            return {
                type: _this.view.getInt8(_this.offset),
                data: _this.buf(length),
            };
        };
        this.parse = function () {
            var type = _this.view.getUint8(_this.offset);
            var value, length;
            // Positive FixInt - 0xxxxxxx
            if ((type & 0x80) === 0x00) {
                _this.offset++;
                return type;
            }
            // FixMap - 1000xxxx
            if ((type & 0xf0) === 0x80) {
                length = type & 0x0f;
                _this.offset++;
                return _this.map(length);
            }
            // FixArray - 1001xxxx
            if ((type & 0xf0) === 0x90) {
                length = type & 0x0f;
                _this.offset++;
                return _this.array(length);
            }
            // FixStr - 101xxxxx
            if ((type & 0xe0) === 0xa0) {
                length = type & 0x1f;
                _this.offset++;
                return _this.str(length);
            }
            // Negative FixInt - 111xxxxx
            if ((type & 0xe0) === 0xe0) {
                value = _this.view.getInt8(_this.offset);
                _this.offset++;
                return value;
            }
            switch (type) {
                // nil
                case 0xc0:
                    _this.offset++;
                    return null;
                // 0xc1 never used - use for undefined (NON-STANDARD)
                case 0xc1:
                    _this.offset++;
                    return undefined;
                // false
                case 0xc2:
                    _this.offset++;
                    return false;
                // true
                case 0xc3:
                    _this.offset++;
                    return true;
                // bin 8
                case 0xc4:
                    length = _this.view.getUint8(_this.offset + 1);
                    _this.offset += 2;
                    return _this.bin(length);
                // bin 16
                case 0xc5:
                    length = _this.view.getUint16(_this.offset + 1);
                    _this.offset += 3;
                    return _this.bin(length);
                // bin 32
                case 0xc6:
                    length = _this.view.getUint32(_this.offset + 1);
                    _this.offset += 5;
                    return _this.bin(length);
                // ext 8
                case 0xc7:
                    length = _this.view.getUint8(_this.offset + 1);
                    _this.offset += 2;
                    return _this.ext(length);
                // ext 16
                case 0xc8:
                    length = _this.view.getUint16(_this.offset + 1);
                    _this.offset += 3;
                    return _this.ext(length);
                // ext 32
                case 0xc9:
                    length = _this.view.getUint32(_this.offset + 1);
                    _this.offset += 5;
                    return _this.ext(length);
                // float 32
                case 0xca:
                    value = _this.view.getFloat32(_this.offset + 1);
                    _this.offset += 5;
                    return value;
                // float 64
                case 0xcb:
                    value = _this.view.getFloat64(_this.offset + 1);
                    _this.offset += 9;
                    return value;
                // uint8
                case 0xcc:
                    value = _this.view.getUint8(_this.offset + 1);
                    _this.offset += 2;
                    return value;
                // uint 16
                case 0xcd:
                    value = _this.view.getUint16(_this.offset + 1);
                    _this.offset += 3;
                    return value;
                // uint 32
                case 0xce:
                    value = _this.view.getUint32(_this.offset + 1);
                    _this.offset += 5;
                    return value;
                // uint 64
                case 0xcf:
                    value = getUint64(_this.view, _this.offset + 1);
                    _this.offset += 9;
                    return value;
                // int 8
                case 0xd0:
                    value = _this.view.getInt8(_this.offset + 1);
                    _this.offset += 2;
                    return value;
                // int 16
                case 0xd1:
                    value = _this.view.getInt16(_this.offset + 1);
                    _this.offset += 3;
                    return value;
                // int 32
                case 0xd2:
                    value = _this.view.getInt32(_this.offset + 1);
                    _this.offset += 5;
                    return value;
                // int 64
                case 0xd3:
                    value = getInt64(_this.view, _this.offset + 1);
                    _this.offset += 9;
                    return value;
                // fixext 1
                case 0xd4:
                    length = 1;
                    _this.offset++;
                    return _this.ext(length);
                // fixext 2
                case 0xd5:
                    length = 2;
                    _this.offset++;
                    return _this.ext(length);
                // fixext 4
                case 0xd6:
                    length = 4;
                    _this.offset++;
                    return _this.ext(length);
                // fixext 8
                case 0xd7:
                    length = 8;
                    _this.offset++;
                    return _this.ext(length);
                // fixext 16
                case 0xd8:
                    length = 16;
                    _this.offset++;
                    return _this.ext(length);
                // str8
                case 0xd9:
                    length = _this.view.getUint8(_this.offset + 1);
                    _this.offset += 2;
                    return _this.str(length);
                // str 16
                case 0xda:
                    length = _this.view.getUint16(_this.offset + 1);
                    _this.offset += 3;
                    return _this.str(length);
                // str 32
                case 0xdb:
                    length = _this.view.getUint32(_this.offset + 1);
                    _this.offset += 5;
                    return _this.str(length);
                // array 16
                case 0xdc:
                    length = _this.view.getUint16(_this.offset + 1);
                    _this.offset += 3;
                    return _this.array(length);
                // array 32
                case 0xdd:
                    length = _this.view.getUint32(_this.offset + 1);
                    _this.offset += 5;
                    return _this.array(length);
                // map 16
                case 0xde:
                    length = _this.view.getUint16(_this.offset + 1);
                    _this.offset += 3;
                    return _this.map(length);
                // map 32
                case 0xdf:
                    length = _this.view.getUint32(_this.offset + 1);
                    _this.offset += 5;
                    return _this.map(length);
            }
            throw new Error('Unknown type 0x' + type.toString(16));
        };
        this.offset = offset || 0;
        this.view = view;
    }
    return Decoder;
}());
function decode(buffer) {
    var view = new DataView(buffer);
    var decoder = new Decoder(view);
    var value = decoder.parse();
    if (decoder.offset !== buffer.byteLength)
        throw new Error(buffer.byteLength - decoder.offset + ' trailing bytes');
    return value;
}
function encodeableKeys(value, sparse) {
    return Object.keys(value).filter(function (e) {
        var val = value[e], type = typeof val;
        return (!sparse || (val !== undefined && val !== null)) && ('function' !== type || !!val.toJSON);
    });
}
function _encode(value, view, offset, sparse) {
    var type = typeof value;
    // Strings Bytes
    // There are four string types: fixstr/str8/str16/str32
    if (typeof value === 'string') {
        var length_1 = utf8ByteCount(value);
        // fixstr
        if (length_1 < 0x20) {
            view.setUint8(offset, length_1 | 0xa0);
            utf8Write(view, offset + 1, value);
            return 1 + length_1;
        }
        // str8
        if (length_1 < 0x100) {
            view.setUint8(offset, 0xd9);
            view.setUint8(offset + 1, length_1);
            utf8Write(view, offset + 2, value);
            return 2 + length_1;
        }
        // str16
        if (length_1 < 0x10000) {
            view.setUint8(offset, 0xda);
            view.setUint16(offset + 1, length_1);
            utf8Write(view, offset + 3, value);
            return 3 + length_1;
        }
        // str32
        if (length_1 < 0x100000000) {
            view.setUint8(offset, 0xdb);
            view.setUint32(offset + 1, length_1);
            utf8Write(view, offset + 5, value);
            return 5 + length_1;
        }
    }
    if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {
        // extract the arraybuffer and fallthrough
        value = value.buffer;
    }
    // There are three bin types: bin8/bin16/bin32
    if (value instanceof ArrayBuffer) {
        var length_2 = value.byteLength;
        // bin8
        if (length_2 < 0x100) {
            view.setUint8(offset, 0xc4);
            view.setUint8(offset + 1, length_2);
            new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 2);
            return 2 + length_2;
        }
        // bin16
        if (length_2 < 0x10000) {
            view.setUint8(offset, 0xc5);
            view.setUint16(offset + 1, length_2);
            new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 3);
            return 3 + length_2;
        }
        // bin 32
        if (length_2 < 0x100000000) {
            view.setUint8(offset, 0xc6);
            view.setUint32(offset + 1, length_2);
            new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 5);
            return 5 + length_2;
        }
    }
    if (typeof value === 'number') {
        // Floating Point
        // NOTE: We're always using float64
        if (Math.floor(value) !== value) {
            view.setUint8(offset, 0xcb);
            view.setFloat64(offset + 1, value);
            return 9;
        }
        // Integers
        if (value >= 0) {
            // positive fixnum
            if (value < 0x80) {
                view.setUint8(offset, value);
                return 1;
            }
            // uint 8
            if (value < 0x100) {
                view.setUint8(offset, 0xcc);
                view.setUint8(offset + 1, value);
                return 2;
            }
            // uint 16
            if (value < 0x10000) {
                view.setUint8(offset, 0xcd);
                view.setUint16(offset + 1, value);
                return 3;
            }
            // uint 32
            if (value < 0x100000000) {
                view.setUint8(offset, 0xce);
                view.setUint32(offset + 1, value);
                return 5;
            }
            // uint 64
            if (value < 0x10000000000000000) {
                view.setUint8(offset, 0xcf);
                setUint64(view, offset + 1, value);
                return 9;
            }
            throw new Error('Number too big 0x' + value.toString(16));
        }
        // negative fixnum
        if (value >= -0x20) {
            view.setInt8(offset, value);
            return 1;
        }
        // int 8
        if (value >= -0x80) {
            view.setUint8(offset, 0xd0);
            view.setInt8(offset + 1, value);
            return 2;
        }
        // int 16
        if (value >= -0x8000) {
            view.setUint8(offset, 0xd1);
            view.setInt16(offset + 1, value);
            return 3;
        }
        // int 32
        if (value >= -0x80000000) {
            view.setUint8(offset, 0xd2);
            view.setInt32(offset + 1, value);
            return 5;
        }
        // int 64
        if (value >= -0x8000000000000000) {
            view.setUint8(offset, 0xd3);
            setInt64(view, offset + 1, value);
            return 9;
        }
        throw new Error('Number too small -0x' + (-value).toString(16).substr(1));
    }
    // undefined - use d4 (NON-STANDARD)
    if (type === 'undefined') {
        if (sparse)
            return 0;
        view.setUint8(offset, 0xd4);
        view.setUint8(offset + 1, 0x00);
        view.setUint8(offset + 2, 0x00);
        return 3;
    }
    // null
    if (value === null) {
        if (sparse)
            return 0;
        view.setUint8(offset, 0xc0);
        return 1;
    }
    // Boolean
    if (type === 'boolean') {
        view.setUint8(offset, value ? 0xc3 : 0xc2);
        return 1;
    }
    if ('function' === typeof value.toJSON)
        return _encode(value.toJSON(), view, offset, sparse);
    // Container Types
    if (type === 'object') {
        var length_3, size = 0;
        var keys = void 0;
        var isArray = Array.isArray(value);
        if (isArray) {
            length_3 = value.length;
        }
        else {
            keys = encodeableKeys(value, sparse);
            length_3 = keys.length;
        }
        if (length_3 < 0x10) {
            view.setUint8(offset, length_3 | (isArray ? 0x90 : 0x80));
            size = 1;
        }
        else if (length_3 < 0x10000) {
            view.setUint8(offset, isArray ? 0xdc : 0xde);
            view.setUint16(offset + 1, length_3);
            size = 3;
        }
        else if (length_3 < 0x100000000) {
            view.setUint8(offset, isArray ? 0xdd : 0xdf);
            view.setUint32(offset + 1, length_3);
            size = 5;
        }
        if (isArray) {
            for (var i = 0; i < length_3; i++) {
                size += _encode(value[i], view, offset + size, sparse);
            }
        }
        else if (keys) {
            for (var i = 0; i < length_3; i++) {
                var key = keys[i];
                size += _encode(key, view, offset + size);
                size += _encode(value[key], view, offset + size, sparse);
            }
        }
        return size;
    }
    if (type === 'function')
        return 0;
    throw new Error('Unknown type ' + type);
}
function sizeof(value, sparse) {
    var type = typeof value;
    // fixstr or str8 or str16 or str32
    if (type === 'string') {
        var length_4 = utf8ByteCount(value);
        if (length_4 < 0x20) {
            return 1 + length_4;
        }
        if (length_4 < 0x100) {
            return 2 + length_4;
        }
        if (length_4 < 0x10000) {
            return 3 + length_4;
        }
        if (length_4 < 0x100000000) {
            return 5 + length_4;
        }
    }
    if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {
        // extract the arraybuffer and fallthrough
        value = value.buffer;
    }
    // bin8 or bin16 or bin32
    if (value instanceof ArrayBuffer) {
        var length_5 = value.byteLength;
        if (length_5 < 0x100) {
            return 2 + length_5;
        }
        if (length_5 < 0x10000) {
            return 3 + length_5;
        }
        if (length_5 < 0x100000000) {
            return 5 + length_5;
        }
    }
    if (typeof value === 'number') {
        // Floating Point (32 bits)
        // double
        if (Math.floor(value) !== value)
            return 9;
        // Integers
        if (value >= 0) {
            // positive fixint
            if (value < 0x80)
                return 1;
            // uint 8
            if (value < 0x100)
                return 2;
            // uint 16
            if (value < 0x10000)
                return 3;
            // uint 32
            if (value < 0x100000000)
                return 5;
            // uint 64
            if (value < 0x10000000000000000)
                return 9;
            // Too big
            throw new Error('Number too big 0x' + value.toString(16));
        }
        // negative fixint
        if (value >= -0x20)
            return 1;
        // int 8
        if (value >= -0x80)
            return 2;
        // int 16
        if (value >= -0x8000)
            return 3;
        // int 32
        if (value >= -0x80000000)
            return 5;
        // int 64
        if (value >= -0x8000000000000000)
            return 9;
        // Too small
        throw new Error('Number too small -0x' + value.toString(16).substr(1));
    }
    // Boolean
    if (type === 'boolean')
        return 1;
    // undefined, null
    if (value === null)
        return sparse ? 0 : 1;
    if (value === undefined)
        return sparse ? 0 : 3;
    if ('function' === typeof value.toJSON)
        return sizeof(value.toJSON(), sparse);
    // Container Types
    if (type === 'object') {
        var length_6, size = 0;
        if (Array.isArray(value)) {
            length_6 = value.length;
            for (var i = 0; i < length_6; i++) {
                size += sizeof(value[i], sparse);
            }
        }
        else {
            var keys = encodeableKeys(value, sparse);
            length_6 = keys.length;
            for (var i = 0; i < length_6; i++) {
                var key = keys[i];
                size += sizeof(key) + sizeof(value[key], sparse);
            }
        }
        if (length_6 < 0x10) {
            return 1 + size;
        }
        if (length_6 < 0x10000) {
            return 3 + size;
        }
        if (length_6 < 0x100000000) {
            return 5 + size;
        }
        throw new Error('Array or object too long 0x' + length_6.toString(16));
    }
    if (type === 'function')
        return 0;
    throw new Error('Unknown type ' + type);
}
exports.default = {
    encode: encode,
    decode: decode,
    inspect: inspect,
    utf8Write: utf8Write,
    utf8Read: utf8Read,
    utf8ByteCount: utf8ByteCount,
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __nested_webpack_require_466211__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_466211__(0);
// Common
var rest_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(30));
var realtime_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(50));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(3));
// Platform Specific
var bufferutils_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(55));
// @ts-ignore
var crypto_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(57));
var http_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(62));
var config_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(64));
// @ts-ignore
var transport_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(68));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(2));
var defaults_1 = __nested_webpack_require_466211__(8);
var webstorage_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(65));
var defaults_2 = tslib_1.__importDefault(__nested_webpack_require_466211__(66));
var msgpack_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(41));
var Crypto = (0, crypto_1.default)(config_1.default, bufferutils_1.default);
platform_1.default.Crypto = Crypto;
platform_1.default.BufferUtils = bufferutils_1.default;
platform_1.default.Http = http_1.default;
platform_1.default.Config = config_1.default;
platform_1.default.Transports = transport_1.default;
platform_1.default.WebStorage = webstorage_1.default;
rest_1.default.Crypto = Crypto;
realtime_1.default.Crypto = Crypto;
logger_1.default.initLogHandlers();
platform_1.default.Defaults = (0, defaults_1.getDefaults)(defaults_2.default);
if (platform_1.default.Config.agent) {
    // @ts-ignore
    platform_1.default.Defaults.agent += ' ' + platform_1.default.Config.agent;
}
/* If using IE8, don't attempt to upgrade from xhr_polling to xhr_streaming -
 * while it can do streaming, the low max http-connections-per-host limit means
 * that the polling transport is crippled during the upgrade process. So just
 * leave it at the base transport */
if (platform_1.default.Config.noUpgrade) {
    platform_1.default.Defaults.upgradeTransports = [];
}
exports.default = {
    Rest: rest_1.default,
    Realtime: realtime_1.default,
    msgpack: msgpack_1.default,
};


/***/ }),
/* 43 */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"ably\",\"description\":\"Realtime client library for Ably, the realtime messaging service\",\"version\":\"1.2.43\",\"license\":\"Apache-2.0\",\"bugs\":{\"url\":\"https://github.com/ably/ably-js/issues\",\"email\":\"support@ably.com\"},\"main\":\"./build/ably-node.js\",\"typings\":\"./ably.d.ts\",\"react-native\":{\"./build/ably-node.js\":\"./build/ably-reactnative.js\"},\"browser\":{\"./build/ably-node.js\":\"./build/ably-commonjs.js\"},\"files\":[\"build/**\",\"ably.d.ts\",\"callbacks.d.ts\",\"callbacks.js\",\"promises.d.ts\",\"promises.js\",\"resources/**\"],\"dependencies\":{\"@ably/msgpack-js\":\"^0.4.0\",\"got\":\"^11.8.5\",\"ws\":\"^5.1\"},\"devDependencies\":{\"@ably/vcdiff-decoder\":\"1.0.4\",\"@types/crypto-js\":\"^4.0.1\",\"@types/node\":\"^15.0.0\",\"@types/request\":\"^2.48.7\",\"@types/ws\":\"^8.2.0\",\"@typescript-eslint/eslint-plugin\":\"^5.14.0\",\"@typescript-eslint/parser\":\"^5.14.0\",\"async\":\"ably-forks/async#requirejs\",\"aws-sdk\":\"^2.1413.0\",\"chai\":\"^4.2.0\",\"copy-webpack-plugin\":\"^6.4.1\",\"cors\":\"^2.8.5\",\"crypto-js\":\"ably-forks/crypto-js#crypto-lite\",\"eslint\":\"^7.13.0\",\"eslint-plugin-jsdoc\":\"^40.0.0\",\"eslint-plugin-security\":\"^1.4.0\",\"express\":\"^4.17.1\",\"glob\":\"~4.4\",\"google-closure-compiler\":\"^20180610.0.1\",\"grunt\":\"^1.6.1\",\"grunt-bump\":\"^0.3.1\",\"grunt-cli\":\"~1.2.0\",\"grunt-closure-tools\":\"^1.0.0\",\"grunt-contrib-concat\":\"~0.5\",\"grunt-shell\":\"~1.1\",\"grunt-webpack\":\"^4.0.2\",\"hexy\":\"~0.2\",\"kexec\":\"ably-forks/node-kexec#update-for-node-12\",\"minimist\":\"^1.2.5\",\"mocha\":\"^8.1.3\",\"null-loader\":\"^4.0.1\",\"playwright\":\"^1.10.0\",\"prettier\":\"^2.5.1\",\"requirejs\":\"~2.1\",\"shelljs\":\"~0.8\",\"source-map-explorer\":\"^2.5.2\",\"ts-loader\":\"^8.2.0\",\"tsconfig-paths-webpack-plugin\":\"^4.0.1\",\"tslib\":\"^2.3.1\",\"typedoc\":\"^0.23.8\",\"typescript\":\"^4.6.4\",\"webpack\":\"^4.44.2\",\"webpack-cli\":\"^4.2.0\"},\"engines\":{\"node\":\">=5.10.x\"},\"repository\":\"ably/ably-js\",\"jspm\":{\"registry\":\"npm\",\"directories\":{\"lib\":\"build\"},\"main\":\"ably\"},\"scripts\":{\"grunt\":\"grunt\",\"test\":\"grunt test\",\"test:node\":\"grunt test:node\",\"test:node:skip-build\":\"grunt mocha\",\"test:webserver\":\"grunt test:webserver\",\"test:playwright\":\"node test/support/runPlaywrightTests.js\",\"concat\":\"grunt concat\",\"build\":\"grunt build:all\",\"build:node\":\"grunt build:node\",\"build:browser\":\"grunt build:browser\",\"requirejs\":\"grunt requirejs\",\"lint\":\"eslint .\",\"lint:fix\":\"eslint --fix .\",\"check-closure-compiler\":\"grunt check-closure-compiler\",\"prepare\":\"npm run build\",\"format\":\"prettier --write --ignore-path .gitignore --ignore-path .prettierignore src test ably.d.ts webpack.config.js Gruntfile.js scripts/cdn_deploy.js docs/chrome-mv3.md\",\"format:check\":\"prettier --check --ignore-path .gitignore --ignore-path .prettierignore src test ably.d.ts webpack.config.js Gruntfile.js scripts/cdn_deploy.js\",\"sourcemap\":\"source-map-explorer build/ably.min.js\",\"sourcemap:noencryption\":\"source-map-explorer build/ably.noencryption.min.js\",\"docs\":\"typedoc --entryPoints ably.d.ts --out docs/generated/default --readme docs/landing-pages/default.md && typedoc --entryPoints promises.d.ts --out docs/generated/promises --name \\\"ably (Promise-based)\\\" --readme docs/landing-pages/promises.md && cp docs/landing-pages/choose-library.html docs/generated/index.html\"}}");

/***/ }),
/* 44 */
/***/ (function(module, exports) {



/***/ }),
/* 45 */
/***/ (function(module, exports, __nested_webpack_require_472099__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_472099__(6), __nested_webpack_require_472099__(32), __nested_webpack_require_472099__(24));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.HmacSHA256;

}));

/***/ }),
/* 46 */
/***/ (function(module, exports, __nested_webpack_require_472422__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_472422__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_472422__(1));
var devicedetails_1 = tslib_1.__importDefault(__nested_webpack_require_472422__(47));
var resource_1 = tslib_1.__importDefault(__nested_webpack_require_472422__(14));
var paginatedresource_1 = tslib_1.__importDefault(__nested_webpack_require_472422__(19));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_472422__(4));
var pushchannelsubscription_1 = tslib_1.__importDefault(__nested_webpack_require_472422__(48));
var noop = function () { };
var Push = /** @class */ (function () {
    function Push(rest) {
        this.rest = rest;
        this.admin = new Admin(rest);
    }
    return Push;
}());
var Admin = /** @class */ (function () {
    function Admin(rest) {
        this.rest = rest;
        this.deviceRegistrations = new DeviceRegistrations(rest);
        this.channelSubscriptions = new ChannelSubscriptions(rest);
    }
    Admin.prototype.publish = function (recipient, payload, callback) {
        var rest = this.rest;
        var format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(rest.options, format), params = {};
        var body = Utils.mixin({ recipient: recipient }, payload);
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'publish', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        var requestBody = Utils.encodeBody(body, format);
        resource_1.default.post(rest, '/push/publish', requestBody, headers, params, null, function (err) { return callback(err); });
    };
    return Admin;
}());
var DeviceRegistrations = /** @class */ (function () {
    function DeviceRegistrations(rest) {
        this.rest = rest;
    }
    DeviceRegistrations.prototype.save = function (device, callback) {
        var rest = this.rest;
        var body = devicedetails_1.default.fromValues(device);
        var format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(rest.options, format), params = {};
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'save', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        var requestBody = Utils.encodeBody(body, format);
        resource_1.default.put(rest, '/push/deviceRegistrations/' + encodeURIComponent(device.id), requestBody, headers, params, null, function (err, body, headers, unpacked) {
            callback(err, !err
                ? devicedetails_1.default.fromResponseBody(body, unpacked ? undefined : format)
                : undefined);
        });
    };
    DeviceRegistrations.prototype.get = function (deviceIdOrDetails, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultGetHeaders(rest.options, format), deviceId = deviceIdOrDetails.id || deviceIdOrDetails;
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'get', arguments);
            }
            callback = noop;
        }
        if (typeof deviceId !== 'string' || !deviceId.length) {
            callback(new errorinfo_1.default('First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails', 40000, 400));
            return;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        resource_1.default.get(rest, '/push/deviceRegistrations/' + encodeURIComponent(deviceId), headers, {}, null, function (err, body, headers, unpacked) {
            callback(err, !err
                ? devicedetails_1.default.fromResponseBody(body, unpacked ? undefined : format)
                : undefined);
        });
    };
    DeviceRegistrations.prototype.list = function (params, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'list', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        new paginatedresource_1.default(rest, '/push/deviceRegistrations', headers, envelope, function (body, headers, unpacked) {
            return devicedetails_1.default.fromResponseBody(body, unpacked ? undefined : format);
        }).get(params, callback);
    };
    DeviceRegistrations.prototype.remove = function (deviceIdOrDetails, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultGetHeaders(rest.options, format), params = {}, deviceId = deviceIdOrDetails.id || deviceIdOrDetails;
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'remove', arguments);
            }
            callback = noop;
        }
        if (typeof deviceId !== 'string' || !deviceId.length) {
            callback(new errorinfo_1.default('First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails', 40000, 400));
            return;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        resource_1.default['delete'](rest, '/push/deviceRegistrations/' + encodeURIComponent(deviceId), headers, params, null, function (err) { return callback(err); });
    };
    DeviceRegistrations.prototype.removeWhere = function (params, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultGetHeaders(rest.options, format);
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'removeWhere', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        resource_1.default['delete'](rest, '/push/deviceRegistrations', headers, params, null, function (err) { return callback(err); });
    };
    return DeviceRegistrations;
}());
var ChannelSubscriptions = /** @class */ (function () {
    function ChannelSubscriptions(rest) {
        /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */
        this.remove = ChannelSubscriptions.prototype.removeWhere;
        this.rest = rest;
    }
    ChannelSubscriptions.prototype.save = function (subscription, callback) {
        var rest = this.rest;
        var body = pushchannelsubscription_1.default.fromValues(subscription);
        var format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(rest.options, format), params = {};
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'save', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        var requestBody = Utils.encodeBody(body, format);
        resource_1.default.post(rest, '/push/channelSubscriptions', requestBody, headers, params, null, function (err, body, headers, unpacked) {
            callback(err, !err && pushchannelsubscription_1.default.fromResponseBody(body, unpacked ? undefined : format));
        });
    };
    ChannelSubscriptions.prototype.list = function (params, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'list', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        new paginatedresource_1.default(rest, '/push/channelSubscriptions', headers, envelope, function (body, headers, unpacked) {
            return pushchannelsubscription_1.default.fromResponseBody(body, unpacked ? undefined : format);
        }).get(params, callback);
    };
    ChannelSubscriptions.prototype.removeWhere = function (params, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultGetHeaders(rest.options, format);
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'removeWhere', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        resource_1.default['delete'](rest, '/push/channelSubscriptions', headers, params, null, function (err) { return callback(err); });
    };
    ChannelSubscriptions.prototype.listChannels = function (params, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'listChannels', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        new paginatedresource_1.default(rest, '/push/channels', headers, envelope, function (body, headers, unpacked) {
            var parsedBody = (!unpacked && format ? Utils.decodeBody(body, format) : body);
            for (var i = 0; i < parsedBody.length; i++) {
                parsedBody[i] = String(parsedBody[i]);
            }
            return parsedBody;
        }).get(params, callback);
    };
    return ChannelSubscriptions;
}());
exports.default = Push;


/***/ }),
/* 47 */
/***/ (function(module, exports, __nested_webpack_require_484001__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_484001__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_484001__(1));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_484001__(4));
var DeviceFormFactor;
(function (DeviceFormFactor) {
    DeviceFormFactor["Phone"] = "phone";
    DeviceFormFactor["Tablet"] = "tablet";
    DeviceFormFactor["Desktop"] = "desktop";
    DeviceFormFactor["TV"] = "tv";
    DeviceFormFactor["Watch"] = "watch";
    DeviceFormFactor["Car"] = "car";
    DeviceFormFactor["Embedded"] = "embedded";
    DeviceFormFactor["Other"] = "other";
})(DeviceFormFactor || (DeviceFormFactor = {}));
var DevicePlatform;
(function (DevicePlatform) {
    DevicePlatform["Android"] = "android";
    DevicePlatform["IOS"] = "ios";
    DevicePlatform["Browser"] = "browser";
})(DevicePlatform || (DevicePlatform = {}));
var DeviceDetails = /** @class */ (function () {
    function DeviceDetails() {
    }
    DeviceDetails.prototype.toJSON = function () {
        var _a, _b, _c;
        return {
            id: this.id,
            deviceSecret: this.deviceSecret,
            platform: this.platform,
            formFactor: this.formFactor,
            clientId: this.clientId,
            metadata: this.metadata,
            deviceIdentityToken: this.deviceIdentityToken,
            push: {
                recipient: (_a = this.push) === null || _a === void 0 ? void 0 : _a.recipient,
                state: (_b = this.push) === null || _b === void 0 ? void 0 : _b.state,
                error: (_c = this.push) === null || _c === void 0 ? void 0 : _c.error,
            },
        };
    };
    DeviceDetails.prototype.toString = function () {
        var _a, _b, _c, _d;
        var result = '[DeviceDetails';
        if (this.id)
            result += '; id=' + this.id;
        if (this.platform)
            result += '; platform=' + this.platform;
        if (this.formFactor)
            result += '; formFactor=' + this.formFactor;
        if (this.clientId)
            result += '; clientId=' + this.clientId;
        if (this.metadata)
            result += '; metadata=' + this.metadata;
        if (this.deviceIdentityToken)
            result += '; deviceIdentityToken=' + JSON.stringify(this.deviceIdentityToken);
        if ((_a = this.push) === null || _a === void 0 ? void 0 : _a.recipient)
            result += '; push.recipient=' + JSON.stringify(this.push.recipient);
        if ((_b = this.push) === null || _b === void 0 ? void 0 : _b.state)
            result += '; push.state=' + this.push.state;
        if ((_c = this.push) === null || _c === void 0 ? void 0 : _c.error)
            result += '; push.error=' + JSON.stringify(this.push.error);
        if ((_d = this.push) === null || _d === void 0 ? void 0 : _d.metadata)
            result += '; push.metadata=' + this.push.metadata;
        result += ']';
        return result;
    };
    DeviceDetails.fromResponseBody = function (body, format) {
        if (format) {
            body = Utils.decodeBody(body, format);
        }
        if (Utils.isArray(body)) {
            return DeviceDetails.fromValuesArray(body);
        }
        else {
            return DeviceDetails.fromValues(body);
        }
    };
    DeviceDetails.fromValues = function (values) {
        values.error = values.error && errorinfo_1.default.fromValues(values.error);
        return Object.assign(new DeviceDetails(), values);
    };
    DeviceDetails.fromValuesArray = function (values) {
        var count = values.length, result = new Array(count);
        for (var i = 0; i < count; i++)
            result[i] = DeviceDetails.fromValues(values[i]);
        return result;
    };
    DeviceDetails.toRequestBody = Utils.encodeBody;
    return DeviceDetails;
}());
exports.default = DeviceDetails;


/***/ }),
/* 48 */
/***/ (function(module, exports, __nested_webpack_require_487921__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_487921__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_487921__(1));
var PushChannelSubscription = /** @class */ (function () {
    function PushChannelSubscription() {
    }
    /**
     * Overload toJSON() to intercept JSON.stringify()
     * @return {*}
     */
    PushChannelSubscription.prototype.toJSON = function () {
        return {
            channel: this.channel,
            deviceId: this.deviceId,
            clientId: this.clientId,
        };
    };
    PushChannelSubscription.prototype.toString = function () {
        var result = '[PushChannelSubscription';
        if (this.channel)
            result += '; channel=' + this.channel;
        if (this.deviceId)
            result += '; deviceId=' + this.deviceId;
        if (this.clientId)
            result += '; clientId=' + this.clientId;
        result += ']';
        return result;
    };
    PushChannelSubscription.fromResponseBody = function (body, format) {
        if (format) {
            body = Utils.decodeBody(body, format);
        }
        if (Utils.isArray(body)) {
            return PushChannelSubscription.fromValuesArray(body);
        }
        else {
            return PushChannelSubscription.fromValues(body);
        }
    };
    PushChannelSubscription.fromValues = function (values) {
        return Object.assign(new PushChannelSubscription(), values);
    };
    PushChannelSubscription.fromValuesArray = function (values) {
        var count = values.length, result = new Array(count);
        for (var i = 0; i < count; i++)
            result[i] = PushChannelSubscription.fromValues(values[i]);
        return result;
    };
    PushChannelSubscription.toRequestBody = Utils.encodeBody;
    return PushChannelSubscription;
}());
exports.default = PushChannelSubscription;


/***/ }),
/* 49 */
/***/ (function(module, exports, __nested_webpack_require_489889__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_489889__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_489889__(1));
var MessageCount = /** @class */ (function () {
    function MessageCount(values) {
        this.count = (values && values.count) || 0;
        this.data = (values && values.data) || 0;
        this.uncompressedData = (values && values.uncompressedData) || 0;
        this.failed = (values && values.failed) || 0;
        this.refused = (values && values.refused) || 0;
    }
    return MessageCount;
}());
var MessageCategory = /** @class */ (function (_super) {
    tslib_1.__extends(MessageCategory, _super);
    function MessageCategory(values) {
        var _this = _super.call(this, values) || this;
        if (values && values.category) {
            _this.category = {};
            Utils.forInOwnNonNullProperties(values.category, function (prop) {
                _this.category[prop] = new MessageCount(values.category[prop]);
            });
        }
        return _this;
    }
    return MessageCategory;
}(MessageCount));
var ResourceCount = /** @class */ (function () {
    function ResourceCount(values) {
        this.peak = (values && values.peak) || 0;
        this.min = (values && values.min) || 0;
        this.mean = (values && values.mean) || 0;
        this.opened = (values && values.opened) || 0;
        this.refused = (values && values.refused) || 0;
    }
    return ResourceCount;
}());
var RequestCount = /** @class */ (function () {
    function RequestCount(values) {
        this.succeeded = (values && values.succeeded) || 0;
        this.failed = (values && values.failed) || 0;
        this.refused = (values && values.refused) || 0;
    }
    return RequestCount;
}());
var ConnectionTypes = /** @class */ (function () {
    function ConnectionTypes(values) {
        this.plain = new ResourceCount(values && values.plain);
        this.tls = new ResourceCount(values && values.tls);
        this.all = new ResourceCount(values && values.all);
    }
    return ConnectionTypes;
}());
var MessageTypes = /** @class */ (function () {
    function MessageTypes(values) {
        this.messages = new MessageCategory(values && values.messages);
        this.presence = new MessageCategory(values && values.presence);
        this.all = new MessageCategory(values && values.all);
    }
    return MessageTypes;
}());
var MessageTraffic = /** @class */ (function () {
    function MessageTraffic(values) {
        this.realtime = new MessageTypes(values && values.realtime);
        this.rest = new MessageTypes(values && values.rest);
        this.webhook = new MessageTypes(values && values.webhook);
        this.sharedQueue = new MessageTypes(values && values.sharedQueue);
        this.externalQueue = new MessageTypes(values && values.externalQueue);
        this.httpEvent = new MessageTypes(values && values.httpEvent);
        this.push = new MessageTypes(values && values.push);
        this.all = new MessageTypes(values && values.all);
    }
    return MessageTraffic;
}());
var MessageDirections = /** @class */ (function () {
    function MessageDirections(values) {
        this.all = new MessageTypes(values && values.all);
        this.inbound = new MessageTraffic(values && values.inbound);
        this.outbound = new MessageTraffic(values && values.outbound);
    }
    return MessageDirections;
}());
var XchgMessages = /** @class */ (function () {
    function XchgMessages(values) {
        this.all = new MessageTypes(values && values.all);
        this.producerPaid = new MessageDirections(values && values.producerPaid);
        this.consumerPaid = new MessageDirections(values && values.consumerPaid);
    }
    return XchgMessages;
}());
var PushStats = /** @class */ (function () {
    function PushStats(values) {
        this.messages = (values && values.messages) || 0;
        var notifications = values && values.notifications;
        this.notifications = {
            invalid: (notifications && notifications.invalid) || 0,
            attempted: (notifications && notifications.attempted) || 0,
            successful: (notifications && notifications.successful) || 0,
            failed: (notifications && notifications.failed) || 0,
        };
        this.directPublishes = (values && values.directPublishes) || 0;
    }
    return PushStats;
}());
var ProcessedCount = /** @class */ (function () {
    function ProcessedCount(values) {
        this.succeeded = (values && values.succeeded) || 0;
        this.skipped = (values && values.skipped) || 0;
        this.failed = (values && values.failed) || 0;
    }
    return ProcessedCount;
}());
var ProcessedMessages = /** @class */ (function () {
    function ProcessedMessages(values) {
        var _this = this;
        this.delta = undefined;
        if (values && values.delta) {
            this.delta = {};
            Utils.forInOwnNonNullProperties(values.delta, function (prop) {
                _this.delta[prop] = new ProcessedCount(values.delta[prop]);
            });
        }
    }
    return ProcessedMessages;
}());
var Stats = /** @class */ (function (_super) {
    tslib_1.__extends(Stats, _super);
    function Stats(values) {
        var _this = _super.call(this, values) || this;
        _this.persisted = new MessageTypes(values && values.persisted);
        _this.connections = new ConnectionTypes(values && values.connections);
        _this.channels = new ResourceCount(values && values.channels);
        _this.apiRequests = new RequestCount(values && values.apiRequests);
        _this.tokenRequests = new RequestCount(values && values.tokenRequests);
        _this.xchgProducer = new XchgMessages(values && values.xchgProducer);
        _this.xchgConsumer = new XchgMessages(values && values.xchgConsumer);
        _this.push = new PushStats(values && values.pushStats);
        _this.processed = new ProcessedMessages(values && values.processed);
        _this.inProgress = (values && values.inProgress) || undefined;
        _this.unit = (values && values.unit) || undefined;
        _this.intervalId = (values && values.intervalId) || undefined;
        return _this;
    }
    Stats.fromValues = function (values) {
        return new Stats(values);
    };
    return Stats;
}(MessageDirections));
exports.default = Stats;


/***/ }),
/* 50 */
/***/ (function(module, exports, __nested_webpack_require_496325__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_496325__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_496325__(1));
var rest_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(30));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(2));
var connection_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(51));
var realtimechannel_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(38));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(8));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(4));
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(10));
var connectionmanager_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(35));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(3));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(9));
var Realtime = /** @class */ (function (_super) {
    tslib_1.__extends(Realtime, _super);
    function Realtime(options) {
        var _this = _super.call(this, options) || this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Realtime()', '');
        _this.connection = new connection_1.default(_this, _this.options);
        _this.channels = new Channels(_this);
        if (options.autoConnect !== false)
            _this.connect();
        return _this;
    }
    Realtime.prototype.connect = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Realtime.connect()', '');
        this.connection.connect();
    };
    Realtime.prototype.close = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Realtime.close()', '');
        this.connection.close();
    };
    Realtime.Promise = function (options) {
        options = defaults_1.default.objectifyOptions(options);
        options.promises = true;
        return new Realtime(options);
    };
    Realtime.Callbacks = Realtime;
    Realtime.Utils = Utils;
    Realtime.ConnectionManager = connectionmanager_1.default;
    Realtime.Platform = platform_1.default;
    Realtime.ProtocolMessage = protocolmessage_1.default;
    Realtime.Message = message_1.default;
    return Realtime;
}(rest_1.default));
var Channels = /** @class */ (function (_super) {
    tslib_1.__extends(Channels, _super);
    function Channels(realtime) {
        var _this = _super.call(this) || this;
        _this.realtime = realtime;
        _this.all = Object.create(null);
        realtime.connection.connectionManager.on('transport.active', function () {
            _this.onTransportActive();
        });
        return _this;
    }
    Channels.prototype.channelSerials = function () {
        var serials = {};
        for (var _i = 0, _a = Utils.keysArray(this.all, true); _i < _a.length; _i++) {
            var name_1 = _a[_i];
            var channel = this.all[name_1];
            if (channel.properties.channelSerial) {
                serials[name_1] = channel.properties.channelSerial;
            }
        }
        return serials;
    };
    // recoverChannels gets the given channels and sets their channel serials.
    Channels.prototype.recoverChannels = function (channelSerials) {
        for (var _i = 0, _a = Utils.keysArray(channelSerials, true); _i < _a.length; _i++) {
            var name_2 = _a[_i];
            var channel = this.get(name_2);
            channel.properties.channelSerial = channelSerials[name_2];
        }
    };
    Channels.prototype.onChannelMessage = function (msg) {
        var channelName = msg.channel;
        if (channelName === undefined) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Channels.onChannelMessage()', 'received event unspecified channel, action = ' + msg.action);
            return;
        }
        var channel = this.all[channelName];
        if (!channel) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Channels.onChannelMessage()', 'received event for non-existent channel: ' + channelName);
            return;
        }
        channel.onMessage(msg);
    };
    /* called when a transport becomes connected; reattempt attach/detach
     * for channels that are attaching or detaching. */
    Channels.prototype.onTransportActive = function () {
        for (var channelName in this.all) {
            var channel = this.all[channelName];
            if (channel.state === 'attaching' || channel.state === 'detaching') {
                channel.checkPendingState();
            }
            else if (channel.state === 'suspended') {
                channel._attach(false, null);
            }
            else if (channel.state === 'attached') {
                // Note explicity request the state, channel.attach() would do nothing
                // as its already attached.
                channel.requestState('attaching');
            }
        }
    };
    /* Connection interruptions (ie when the connection will no longer queue
     * events) imply connection state changes for any channel which is either
     * attached, pending, or will attempt to become attached in the future */
    Channels.prototype.propogateConnectionInterruption = function (connectionState, reason) {
        var connectionStateToChannelState = {
            closing: 'detached',
            closed: 'detached',
            failed: 'failed',
            suspended: 'suspended',
        };
        var fromChannelStates = ['attaching', 'attached', 'detaching', 'suspended'];
        var toChannelState = connectionStateToChannelState[connectionState];
        for (var channelId in this.all) {
            var channel = this.all[channelId];
            if (Utils.arrIn(fromChannelStates, channel.state)) {
                channel.notifyState(toChannelState, reason);
            }
        }
    };
    Channels.prototype.get = function (name, channelOptions) {
        name = String(name);
        var channel = this.all[name];
        if (!channel) {
            channel = this.all[name] = new realtimechannel_1.default(this.realtime, name, channelOptions);
        }
        else if (channelOptions) {
            if (channel._shouldReattachToSetOptions(channelOptions)) {
                throw new errorinfo_1.default('Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.', 40000, 400);
            }
            channel.setOptions(channelOptions);
        }
        return channel;
    };
    Channels.prototype.getDerived = function (name, deriveOptions, channelOptions) {
        if (deriveOptions.filter) {
            var filter = Utils.toBase64(deriveOptions.filter);
            var match = Utils.matchDerivedChannel(name);
            name = "[filter=".concat(filter).concat(match.qualifierParam, "]").concat(match.channelName);
        }
        return this.get(name, channelOptions);
    };
    /* Included to support certain niche use-cases; most users should ignore this.
     * Please do not use this unless you know what you're doing */
    Channels.prototype.release = function (name) {
        name = String(name);
        var channel = this.all[name];
        if (!channel) {
            return;
        }
        var releaseErr = channel.getReleaseErr();
        if (releaseErr) {
            throw releaseErr;
        }
        delete this.all[name];
    };
    return Channels;
}(eventemitter_1.default));
exports.default = Realtime;


/***/ }),
/* 51 */
/***/ (function(module, exports, __nested_webpack_require_503898__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_503898__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_503898__(1));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_503898__(7));
var connectionmanager_1 = tslib_1.__importDefault(__nested_webpack_require_503898__(35));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_503898__(2));
var connectionstatechange_1 = tslib_1.__importDefault(__nested_webpack_require_503898__(37));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_503898__(3));
function noop() { }
var Connection = /** @class */ (function (_super) {
    tslib_1.__extends(Connection, _super);
    function Connection(ably, options) {
        var _this = _super.call(this) || this;
        _this.whenState = (function (state, listener) {
            return eventemitter_1.default.prototype.whenState.call(_this, state, _this.state, listener, new connectionstatechange_1.default(undefined, state));
        });
        _this.ably = ably;
        _this.connectionManager = new connectionmanager_1.default(ably, options);
        _this.state = _this.connectionManager.state.state;
        _this.key = undefined;
        _this.id = undefined;
        _this.errorReason = null;
        _this.connectionManager.on('connectionstate', function (stateChange) {
            var state = (_this.state = stateChange.current);
            platform_1.default.Config.nextTick(function () {
                _this.emit(state, stateChange);
            });
        });
        _this.connectionManager.on('update', function (stateChange) {
            platform_1.default.Config.nextTick(function () {
                _this.emit('update', stateChange);
            });
        });
        return _this;
    }
    Connection.prototype.connect = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Connection.connect()', '');
        this.connectionManager.requestState({ state: 'connecting' });
    };
    Connection.prototype.ping = function (callback) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Connection.ping()', '');
        if (!callback) {
            if (this.ably.options.promises) {
                return Utils.promisify(this, 'ping', arguments);
            }
            callback = noop;
        }
        this.connectionManager.ping(null, callback);
    };
    Connection.prototype.close = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Connection.close()', 'connectionKey = ' + this.key);
        this.connectionManager.requestState({ state: 'closing' });
    };
    Object.defineProperty(Connection.prototype, "recoveryKey", {
        get: function () {
            return this.createRecoveryKey();
        },
        enumerable: false,
        configurable: true
    });
    Connection.prototype.createRecoveryKey = function () {
        return this.connectionManager.createRecoveryKey();
    };
    return Connection;
}(eventemitter_1.default));
exports.default = Connection;


/***/ }),
/* 52 */
/***/ (function(module, exports, __nested_webpack_require_506979__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PendingMessage = void 0;
var tslib_1 = __nested_webpack_require_506979__(0);
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_506979__(10));
var Utils = tslib_1.__importStar(__nested_webpack_require_506979__(1));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_506979__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_506979__(2));
var messagequeue_1 = tslib_1.__importDefault(__nested_webpack_require_506979__(36));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_506979__(4));
var actions = protocolmessage_1.default.Action;
var PendingMessage = /** @class */ (function () {
    function PendingMessage(message, callback) {
        this.message = message;
        this.callback = callback;
        this.merged = false;
        var action = message.action;
        this.sendAttempted = false;
        this.ackRequired = action == actions.MESSAGE || action == actions.PRESENCE;
    }
    return PendingMessage;
}());
exports.PendingMessage = PendingMessage;
var Protocol = /** @class */ (function (_super) {
    tslib_1.__extends(Protocol, _super);
    function Protocol(transport) {
        var _this = _super.call(this) || this;
        _this.transport = transport;
        _this.messageQueue = new messagequeue_1.default();
        transport.on('ack', function (serial, count) {
            _this.onAck(serial, count);
        });
        transport.on('nack', function (serial, count, err) {
            _this.onNack(serial, count, err);
        });
        return _this;
    }
    Protocol.prototype.onAck = function (serial, count) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Protocol.onAck()', 'serial = ' + serial + '; count = ' + count);
        this.messageQueue.completeMessages(serial, count);
    };
    Protocol.prototype.onNack = function (serial, count, err) {
        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Protocol.onNack()', 'serial = ' + serial + '; count = ' + count + '; err = ' + Utils.inspectError(err));
        if (!err) {
            err = new errorinfo_1.default('Unable to send message; channel not responding', 50001, 500);
        }
        this.messageQueue.completeMessages(serial, count, err);
    };
    Protocol.prototype.onceIdle = function (listener) {
        var messageQueue = this.messageQueue;
        if (messageQueue.count() === 0) {
            listener();
            return;
        }
        messageQueue.once('idle', listener);
    };
    Protocol.prototype.send = function (pendingMessage) {
        if (pendingMessage.ackRequired) {
            this.messageQueue.push(pendingMessage);
        }
        if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Protocol.send()', 'sending msg; ' + protocolmessage_1.default.stringify(pendingMessage.message));
        }
        pendingMessage.sendAttempted = true;
        this.transport.send(pendingMessage.message);
    };
    Protocol.prototype.getTransport = function () {
        return this.transport;
    };
    Protocol.prototype.getPendingMessages = function () {
        return this.messageQueue.copyAll();
    };
    Protocol.prototype.clearPendingMessages = function () {
        return this.messageQueue.clear();
    };
    Protocol.prototype.finish = function () {
        var transport = this.transport;
        this.onceIdle(function () {
            transport.disconnect();
        });
    };
    return Protocol;
}(eventemitter_1.default));
exports.default = Protocol;


/***/ }),
/* 53 */
/***/ (function(module, exports, __nested_webpack_require_510629__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_510629__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_510629__(3));
var Utils = tslib_1.__importStar(__nested_webpack_require_510629__(1));
var transport_1 = tslib_1.__importDefault(__nested_webpack_require_510629__(26));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_510629__(8));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_510629__(2));
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_510629__(10));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_510629__(4));
var shortName = 'web_socket';
function isNodeWebSocket(ws) {
    return !!ws.on;
}
var WebSocketTransport = /** @class */ (function (_super) {
    tslib_1.__extends(WebSocketTransport, _super);
    function WebSocketTransport(connectionManager, auth, params) {
        var _this = _super.call(this, connectionManager, auth, params) || this;
        _this.shortName = shortName;
        /* If is a browser, can't detect pings, so request protocol heartbeats */
        params.heartbeats = platform_1.default.Config.useProtocolHeartbeats;
        _this.wsHost = defaults_1.default.getHost(params.options, params.host, true);
        return _this;
    }
    WebSocketTransport.isAvailable = function () {
        return !!platform_1.default.Config.WebSocket;
    };
    WebSocketTransport.prototype.createWebSocket = function (uri, connectParams) {
        this.uri = uri + Utils.toQueryString(connectParams);
        return new platform_1.default.Config.WebSocket(this.uri);
    };
    WebSocketTransport.prototype.toString = function () {
        return 'WebSocketTransport; uri=' + this.uri;
    };
    WebSocketTransport.prototype.connect = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.connect()', 'starting');
        transport_1.default.prototype.connect.call(this);
        var self = this, params = this.params, options = params.options;
        var wsScheme = options.tls ? 'wss://' : 'ws://';
        var wsUri = wsScheme + this.wsHost + ':' + defaults_1.default.getPort(options) + '/';
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.connect()', 'uri: ' + wsUri);
        this.auth.getAuthParams(function (err, authParams) {
            if (self.isDisposed) {
                return;
            }
            var paramStr = '';
            for (var param in authParams)
                paramStr += ' ' + param + ': ' + authParams[param] + ';';
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.connect()', 'authParams:' + paramStr + ' err: ' + err);
            if (err) {
                self.disconnect(err);
                return;
            }
            var connectParams = params.getConnectParams(authParams);
            try {
                var wsConnection = (self.wsConnection = self.createWebSocket(wsUri, connectParams));
                wsConnection.binaryType = platform_1.default.Config.binaryType;
                wsConnection.onopen = function () {
                    self.onWsOpen();
                };
                wsConnection.onclose = function (ev) {
                    self.onWsClose(ev);
                };
                wsConnection.onmessage = function (ev) {
                    self.onWsData(ev.data);
                };
                wsConnection.onerror = function (ev) {
                    self.onWsError(ev);
                };
                if (isNodeWebSocket(wsConnection)) {
                    /* node; browsers currently don't have a general eventemitter and can't detect
                     * pings. Also, no need to reply with a pong explicitly, ws lib handles that */
                    wsConnection.on('ping', function () {
                        self.onActivity();
                    });
                }
            }
            catch (e) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'WebSocketTransport.connect()', 'Unexpected exception creating websocket: err = ' + (e.stack || e.message));
                self.disconnect(e);
            }
        });
    };
    WebSocketTransport.prototype.send = function (message) {
        var wsConnection = this.wsConnection;
        if (!wsConnection) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'WebSocketTransport.send()', 'No socket connection');
            return;
        }
        try {
            wsConnection.send(protocolmessage_1.default.serialize(message, this.params.format));
        }
        catch (e) {
            var msg = 'Exception from ws connection when trying to send: ' + Utils.inspectError(e);
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'WebSocketTransport.send()', msg);
            /* Don't try to request a disconnect, that'll just involve sending data
             * down the websocket again. Just finish the transport. */
            this.finish('disconnected', new errorinfo_1.default(msg, 50000, 500));
        }
    };
    WebSocketTransport.prototype.onWsData = function (data) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'WebSocketTransport.onWsData()', 'data received; length = ' + data.length + '; type = ' + typeof data);
        try {
            this.onProtocolMessage(protocolmessage_1.default.deserialize(data, this.format));
        }
        catch (e) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'WebSocketTransport.onWsData()', 'Unexpected exception handing channel message: ' + e.stack);
        }
    };
    WebSocketTransport.prototype.onWsOpen = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.onWsOpen()', 'opened WebSocket');
        this.emit('preconnect');
    };
    WebSocketTransport.prototype.onWsClose = function (ev) {
        var wasClean, code;
        if (typeof ev == 'object') {
            /* W3C spec-compatible */
            code = ev.code;
            // ev.wasClean is undefined in reactnative
            wasClean = ev.wasClean || code === 1000;
        } /*if(typeof(ev) == 'number')*/
        else {
            /* ws in node */
            code = ev;
            wasClean = code == 1000;
        }
        delete this.wsConnection;
        if (wasClean) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.onWsClose()', 'Cleanly closed WebSocket');
            var err = new errorinfo_1.default('Websocket closed', 80003, 400);
            this.finish('disconnected', err);
        }
        else {
            var msg = 'Unclean disconnection of WebSocket ; code = ' + code, err = new errorinfo_1.default(msg, 80003, 400);
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.onWsClose()', msg);
            this.finish('disconnected', err);
        }
        this.emit('disposed');
    };
    WebSocketTransport.prototype.onWsError = function (err) {
        var _this = this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.onError()', 'Error from WebSocket: ' + err.message);
        /* Wait a tick before aborting: if the websocket was connected, this event
         * will be immediately followed by an onclose event with a close code. Allow
         * that to close it (so we see the close code) rather than anticipating it */
        platform_1.default.Config.nextTick(function () {
            _this.disconnect(Error(err.message));
        });
    };
    WebSocketTransport.prototype.dispose = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.dispose()', '');
        this.isDisposed = true;
        var wsConnection = this.wsConnection;
        if (wsConnection) {
            /* Ignore any messages that come through after dispose() is called but before
             * websocket is actually closed. (mostly would be harmless, but if it's a
             * CONNECTED, it'll re-tick isConnected and cause all sorts of havoc) */
            wsConnection.onmessage = function () { };
            delete this.wsConnection;
            /* defer until the next event loop cycle before closing the socket,
             * giving some implementations the opportunity to send any outstanding close message */
            platform_1.default.Config.nextTick(function () {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'WebSocketTransport.dispose()', 'closing websocket');
                if (!wsConnection) {
                    throw new Error('WebSocketTransport.dispose(): wsConnection is not defined');
                }
                wsConnection.close();
            });
        }
    };
    return WebSocketTransport;
}(transport_1.default));
function initialiseTransport(connectionManager) {
    if (WebSocketTransport.isAvailable())
        connectionManager.supportedTransports[shortName] = WebSocketTransport;
    return WebSocketTransport;
}
exports.default = initialiseTransport;


/***/ }),
/* 54 */
/***/ (function(module, exports, __nested_webpack_require_519747__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_519747__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_519747__(1));
var presence_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(34));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(2));
var presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(15));
var errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_519747__(4));
var realtimechannel_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(38));
var multicaster_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(23));
var channelstatechange_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(39));
var noop = function () { };
function getClientId(realtimePresence) {
    return realtimePresence.channel.realtime.auth.clientId;
}
function isAnonymousOrWildcard(realtimePresence) {
    var realtime = realtimePresence.channel.realtime;
    /* If not currently connected, we can't assume that we're an anonymous
     * client, as realtime may inform us of our clientId in the CONNECTED
     * message. So assume we're not anonymous and leave it to realtime to
     * return an error if we are */
    var clientId = realtime.auth.clientId;
    return (!clientId || clientId === '*') && realtime.connection.state === 'connected';
}
/* Callback is called only in the event of an error */
function waitAttached(channel, callback, action) {
    switch (channel.state) {
        case 'attached':
        case 'suspended':
            action();
            break;
        case 'initialized':
        case 'detached':
        case 'detaching':
        case 'attaching':
            channel.attach(function (err) {
                if (err)
                    callback(err);
                else
                    action();
            });
            break;
        default:
            callback(errorinfo_1.default.fromValues(channel.invalidStateError()));
    }
}
function newerThan(item, existing) {
    /* RTP2b1: if either is synthesised, compare by timestamp */
    if (item.isSynthesized() || existing.isSynthesized()) {
        // RTP2b1a: if equal, prefer the newly-arrived one
        return item.timestamp >= existing.timestamp;
    }
    /* RTP2b2 */
    var itemOrderings = item.parseId(), existingOrderings = existing.parseId();
    if (itemOrderings.msgSerial === existingOrderings.msgSerial) {
        return itemOrderings.index > existingOrderings.index;
    }
    else {
        return itemOrderings.msgSerial > existingOrderings.msgSerial;
    }
}
var RealtimePresence = /** @class */ (function (_super) {
    tslib_1.__extends(RealtimePresence, _super);
    function RealtimePresence(channel) {
        var _this = _super.call(this, channel) || this;
        _this.channel = channel;
        _this.syncComplete = false;
        _this.members = new PresenceMap(_this, function (item) { return item.clientId + ':' + item.connectionId; });
        // RTP17h: Store own members by clientId only.
        _this._myMembers = new PresenceMap(_this, function (item) { return item.clientId; });
        _this.subscriptions = new eventemitter_1.default();
        _this.pendingPresence = [];
        return _this;
    }
    RealtimePresence.prototype.enter = function (data, callback) {
        if (isAnonymousOrWildcard(this)) {
            throw new errorinfo_1.default('clientId must be specified to enter a presence channel', 40012, 400);
        }
        return this._enterOrUpdateClient(undefined, undefined, data, 'enter', callback);
    };
    RealtimePresence.prototype.update = function (data, callback) {
        if (isAnonymousOrWildcard(this)) {
            throw new errorinfo_1.default('clientId must be specified to update presence data', 40012, 400);
        }
        return this._enterOrUpdateClient(undefined, undefined, data, 'update', callback);
    };
    RealtimePresence.prototype.enterClient = function (clientId, data, callback) {
        return this._enterOrUpdateClient(undefined, clientId, data, 'enter', callback);
    };
    RealtimePresence.prototype.updateClient = function (clientId, data, callback) {
        return this._enterOrUpdateClient(undefined, clientId, data, 'update', callback);
    };
    RealtimePresence.prototype._enterOrUpdateClient = function (id, clientId, data, action, callback) {
        var _this = this;
        if (!callback) {
            if (typeof data === 'function') {
                callback = data;
                data = null;
            }
            else {
                if (this.channel.realtime.options.promises) {
                    return Utils.promisify(this, '_enterOrUpdateClient', [id, clientId, data, action]);
                }
                callback = noop;
            }
        }
        var channel = this.channel;
        if (!channel.connectionManager.activeState()) {
            callback(channel.connectionManager.getError());
            return;
        }
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.' + action + 'Client()', 'channel = ' + channel.name + ', id = ' + id + ', client = ' + (clientId || '(implicit) ' + getClientId(this)));
        var presence = presencemessage_1.default.fromData(data);
        presence.action = action;
        if (id) {
            presence.id = id;
        }
        if (clientId) {
            presence.clientId = clientId;
        }
        presencemessage_1.default.encode(presence, channel.channelOptions, function (err) {
            if (err) {
                callback(err);
                return;
            }
            switch (channel.state) {
                case 'attached':
                    channel.sendPresence(presence, callback);
                    break;
                case 'initialized':
                case 'detached':
                    channel.attach();
                // eslint-disable-next-line no-fallthrough
                case 'attaching':
                    _this.pendingPresence.push({
                        presence: presence,
                        callback: callback,
                    });
                    break;
                default:
                    err = new errorinfo_1.PartialErrorInfo('Unable to ' + action + ' presence channel while in ' + channel.state + ' state', 90001);
                    err.code = 90001;
                    callback(err);
            }
        });
    };
    RealtimePresence.prototype.leave = function (data, callback) {
        if (isAnonymousOrWildcard(this)) {
            throw new errorinfo_1.default('clientId must have been specified to enter or leave a presence channel', 40012, 400);
        }
        return this.leaveClient(undefined, data, callback);
    };
    RealtimePresence.prototype.leaveClient = function (clientId, data, callback) {
        if (!callback) {
            if (typeof data === 'function') {
                callback = data;
                data = null;
            }
            else {
                if (this.channel.realtime.options.promises) {
                    return Utils.promisify(this, 'leaveClient', [clientId, data]);
                }
                callback = noop;
            }
        }
        var channel = this.channel;
        if (!channel.connectionManager.activeState()) {
            callback === null || callback === void 0 ? void 0 : callback(channel.connectionManager.getError());
            return;
        }
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.leaveClient()', 'leaving; channel = ' + this.channel.name + ', client = ' + clientId);
        var presence = presencemessage_1.default.fromValues({
            action: 'leave',
            data: data,
        });
        if (clientId) {
            presence.clientId = clientId;
        }
        switch (channel.state) {
            case 'attached':
                channel.sendPresence(presence, callback);
                break;
            case 'attaching':
                this.pendingPresence.push({
                    presence: presence,
                    callback: callback,
                });
                break;
            case 'initialized':
            case 'failed': {
                /* we're not attached; therefore we let any entered status
                 * timeout by itself instead of attaching just in order to leave */
                var err = new errorinfo_1.PartialErrorInfo('Unable to leave presence channel (incompatible state)', 90001);
                callback === null || callback === void 0 ? void 0 : callback(err);
                break;
            }
            default:
                callback === null || callback === void 0 ? void 0 : callback(channel.invalidStateError());
        }
    };
    // Return type is any to avoid conflict with base Presence class
    RealtimePresence.prototype.get = function (params, callback) {
        var _this = this;
        var args = Array.prototype.slice.call(arguments);
        if (args.length == 1 && typeof args[0] == 'function')
            args.unshift(null);
        params = args[0];
        callback = args[1];
        var waitForSync = !params || ('waitForSync' in params ? params.waitForSync : true);
        if (!callback) {
            if (this.channel.realtime.options.promises) {
                return Utils.promisify(this, 'get', args);
            }
            callback = noop;
        }
        function returnMembers(members) {
            callback(null, params ? members.list(params) : members.values());
        }
        /* Special-case the suspended state: can still get (stale) presence set if waitForSync is false */
        if (this.channel.state === 'suspended') {
            if (waitForSync) {
                callback(errorinfo_1.default.fromValues({
                    statusCode: 400,
                    code: 91005,
                    message: 'Presence state is out of sync due to channel being in the SUSPENDED state',
                }));
            }
            else {
                returnMembers(this.members);
            }
            return;
        }
        waitAttached(this.channel, callback, function () {
            var members = _this.members;
            if (waitForSync) {
                members.waitSync(function () {
                    returnMembers(members);
                });
            }
            else {
                returnMembers(members);
            }
        });
    };
    RealtimePresence.prototype.history = function (params, callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.history()', 'channel = ' + this.name);
        /* params and callback are optional; see if params contains the callback */
        if (callback === undefined) {
            if (typeof params == 'function') {
                callback = params;
                params = null;
            }
            else {
                if (this.channel.realtime.options.promises) {
                    return Utils.promisify(this, 'history', arguments);
                }
                callback = noop;
            }
        }
        if (params && params.untilAttach) {
            if (this.channel.state === 'attached') {
                delete params.untilAttach;
                params.from_serial = this.channel.properties.attachSerial;
            }
            else {
                callback(new errorinfo_1.default('option untilAttach requires the channel to be attached, was: ' + this.channel.state, 40000, 400));
            }
        }
        presence_1.default.prototype._history.call(this, params, callback);
    };
    RealtimePresence.prototype.setPresence = function (presenceSet, isSync, syncChannelSerial) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.setPresence()', 'received presence for ' + presenceSet.length + ' participants; syncChannelSerial = ' + syncChannelSerial);
        var syncCursor, match;
        var members = this.members, myMembers = this._myMembers, broadcastMessages = [], connId = this.channel.connectionManager.connectionId;
        if (isSync) {
            this.members.startSync();
            if (syncChannelSerial && (match = syncChannelSerial.match(/^[\w-]+:(.*)$/))) {
                syncCursor = match[1];
            }
        }
        for (var i = 0; i < presenceSet.length; i++) {
            var presence = presencemessage_1.default.fromValues(presenceSet[i]);
            switch (presence.action) {
                case 'leave':
                    if (members.remove(presence)) {
                        broadcastMessages.push(presence);
                    }
                    if (presence.connectionId === connId && !presence.isSynthesized()) {
                        myMembers.remove(presence);
                    }
                    break;
                case 'enter':
                case 'present':
                case 'update':
                    if (members.put(presence)) {
                        broadcastMessages.push(presence);
                    }
                    if (presence.connectionId === connId) {
                        myMembers.put(presence);
                    }
                    break;
            }
        }
        /* if this is the last (or only) message in a sequence of sync updates, end the sync */
        if (isSync && !syncCursor) {
            members.endSync();
            this.channel.syncChannelSerial = null;
        }
        /* broadcast to listeners */
        for (var i = 0; i < broadcastMessages.length; i++) {
            var presence = broadcastMessages[i];
            this.subscriptions.emit(presence.action, presence);
        }
    };
    RealtimePresence.prototype.onAttached = function (hasPresence) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimePresence.onAttached()', 'channel = ' + this.channel.name + ', hasPresence = ' + hasPresence);
        if (hasPresence) {
            this.members.startSync();
        }
        else {
            this._synthesizeLeaves(this.members.values());
            this.members.clear();
        }
        // RTP17f: Re-enter own members when moving into the attached state.
        this._ensureMyMembersPresent();
        /* NB this must be after the _ensureMyMembersPresent call, which may add items to pendingPresence */
        var pendingPresence = this.pendingPresence, pendingPresCount = pendingPresence.length;
        if (pendingPresCount) {
            this.pendingPresence = [];
            var presenceArray = [];
            var multicaster = multicaster_1.default.create();
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.onAttached', 'sending ' + pendingPresCount + ' queued presence messages');
            for (var i = 0; i < pendingPresCount; i++) {
                var event_1 = pendingPresence[i];
                presenceArray.push(event_1.presence);
                multicaster.push(event_1.callback);
            }
            this.channel.sendPresence(presenceArray, multicaster);
        }
    };
    RealtimePresence.prototype.actOnChannelState = function (state, hasPresence, err) {
        switch (state) {
            case 'attached':
                this.onAttached(hasPresence);
                break;
            case 'detached':
            case 'failed':
                this._clearMyMembers();
                this.members.clear();
            /* falls through */
            case 'suspended':
                this.failPendingPresence(err);
                break;
        }
    };
    RealtimePresence.prototype.failPendingPresence = function (err) {
        if (this.pendingPresence.length) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.failPendingPresence', 'channel; name = ' + this.channel.name + ', err = ' + Utils.inspectError(err));
            for (var i = 0; i < this.pendingPresence.length; i++)
                try {
                    this.pendingPresence[i].callback(err);
                    // eslint-disable-next-line no-empty
                }
                catch (e) { }
            this.pendingPresence = [];
        }
    };
    RealtimePresence.prototype._clearMyMembers = function () {
        this._myMembers.clear();
    };
    RealtimePresence.prototype._ensureMyMembersPresent = function () {
        var _this = this;
        var myMembers = this._myMembers, reenterCb = function (err) {
            if (err) {
                var msg = 'Presence auto-re-enter failed: ' + err.toString();
                var wrappedErr = new errorinfo_1.default(msg, 91004, 400);
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimePresence._ensureMyMembersPresent()', msg);
                var change = new channelstatechange_1.default(_this.channel.state, _this.channel.state, true, false, wrappedErr);
                _this.channel.emit('update', change);
            }
        };
        for (var memberKey in myMembers.map) {
            var entry = myMembers.map[memberKey];
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence._ensureMyMembersPresent()', 'Auto-reentering clientId "' + entry.clientId + '" into the presence set');
            // RTP17g: Send ENTER containing the member id, clientId and data
            // attributes.
            this._enterOrUpdateClient(entry.id, entry.clientId, entry.data, 'enter', reenterCb);
        }
    };
    RealtimePresence.prototype._synthesizeLeaves = function (items) {
        var subscriptions = this.subscriptions;
        Utils.arrForEach(items, function (item) {
            var presence = presencemessage_1.default.fromValues({
                action: 'leave',
                connectionId: item.connectionId,
                clientId: item.clientId,
                data: item.data,
                encoding: item.encoding,
                timestamp: Utils.now(),
            });
            subscriptions.emit('leave', presence);
        });
    };
    /* Deprecated */
    RealtimePresence.prototype.on = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        logger_1.default.deprecated('presence.on', 'presence.subscribe');
        this.subscribe.apply(this, args);
    };
    /* Deprecated */
    RealtimePresence.prototype.off = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        logger_1.default.deprecated('presence.off', 'presence.unsubscribe');
        this.unsubscribe.apply(this, args);
    };
    RealtimePresence.prototype.subscribe = function () {
        var _args = []; /* [event], listener, [callback] */
        for (var _i = 0 /* [event], listener, [callback] */; _i < arguments.length /* [event], listener, [callback] */; _i++ /* [event], listener, [callback] */) {
            _args[_i] = arguments[_i]; /* [event], listener, [callback] */
        }
        var args = realtimechannel_1.default.processListenerArgs(_args);
        var event = args[0];
        var listener = args[1];
        var callback = args[2];
        var channel = this.channel;
        if (!callback) {
            if (this.channel.realtime.options.promises) {
                return Utils.promisify(this, 'subscribe', [event, listener]);
            }
            callback = noop;
        }
        if (channel.state === 'failed') {
            callback(errorinfo_1.default.fromValues(channel.invalidStateError()));
            return;
        }
        this.subscriptions.on(event, listener);
        channel.attach(callback);
    };
    RealtimePresence.prototype.unsubscribe = function () {
        var _args = []; /* [event], listener */
        for (var _i = 0 /* [event], listener */; _i < arguments.length /* [event], listener */; _i++ /* [event], listener */) {
            _args[_i] = arguments[_i]; /* [event], listener */
        }
        var args = realtimechannel_1.default.processListenerArgs(_args);
        var event = args[0];
        var listener = args[1];
        this.subscriptions.off(event, listener);
    };
    return RealtimePresence;
}(presence_1.default));
var PresenceMap = /** @class */ (function (_super) {
    tslib_1.__extends(PresenceMap, _super);
    function PresenceMap(presence, memberKey) {
        var _this = _super.call(this) || this;
        _this.presence = presence;
        _this.map = Object.create(null);
        _this.syncInProgress = false;
        _this.residualMembers = null;
        _this.memberKey = memberKey;
        return _this;
    }
    PresenceMap.prototype.get = function (key) {
        return this.map[key];
    };
    PresenceMap.prototype.getClient = function (clientId) {
        var map = this.map, result = [];
        for (var key in map) {
            var item = map[key];
            if (item.clientId == clientId && item.action != 'absent')
                result.push(item);
        }
        return result;
    };
    PresenceMap.prototype.list = function (params) {
        var map = this.map, clientId = params && params.clientId, connectionId = params && params.connectionId, result = [];
        for (var key in map) {
            var item = map[key];
            if (item.action === 'absent')
                continue;
            if (clientId && clientId != item.clientId)
                continue;
            if (connectionId && connectionId != item.connectionId)
                continue;
            result.push(item);
        }
        return result;
    };
    PresenceMap.prototype.put = function (item) {
        if (item.action === 'enter' || item.action === 'update') {
            item = presencemessage_1.default.fromValues(item);
            item.action = 'present';
        }
        var map = this.map, key = this.memberKey(item);
        /* we've seen this member, so do not remove it at the end of sync */
        if (this.residualMembers)
            delete this.residualMembers[key];
        /* compare the timestamp of the new item with any existing member (or ABSENT witness) */
        var existingItem = map[key];
        if (existingItem && !newerThan(item, existingItem)) {
            return false;
        }
        map[key] = item;
        return true;
    };
    PresenceMap.prototype.values = function () {
        var map = this.map, result = [];
        for (var key in map) {
            var item = map[key];
            if (item.action != 'absent')
                result.push(item);
        }
        return result;
    };
    PresenceMap.prototype.remove = function (item) {
        var map = this.map, key = this.memberKey(item);
        var existingItem = map[key];
        if (existingItem && !newerThan(item, existingItem)) {
            return false;
        }
        /* RTP2f */
        if (this.syncInProgress) {
            item = presencemessage_1.default.fromValues(item);
            item.action = 'absent';
            map[key] = item;
        }
        else {
            delete map[key];
        }
        return true;
    };
    PresenceMap.prototype.startSync = function () {
        var map = this.map, syncInProgress = this.syncInProgress;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'PresenceMap.startSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
        /* we might be called multiple times while a sync is in progress */
        if (!this.syncInProgress) {
            this.residualMembers = Utils.copy(map);
            this.setInProgress(true);
        }
    };
    PresenceMap.prototype.endSync = function () {
        var map = this.map, syncInProgress = this.syncInProgress;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'PresenceMap.endSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
        if (syncInProgress) {
            /* we can now strip out the ABSENT members, as we have
             * received all of the out-of-order sync messages */
            for (var memberKey in map) {
                var entry = map[memberKey];
                if (entry.action === 'absent') {
                    delete map[memberKey];
                }
            }
            /* any members that were present at the start of the sync,
             * and have not been seen in sync, can be removed, and leave events emitted */
            this.presence._synthesizeLeaves(Utils.valuesArray(this.residualMembers));
            for (var memberKey in this.residualMembers) {
                delete map[memberKey];
            }
            this.residualMembers = null;
            /* finish, notifying any waiters */
            this.setInProgress(false);
        }
        this.emit('sync');
    };
    PresenceMap.prototype.waitSync = function (callback) {
        var syncInProgress = this.syncInProgress;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'PresenceMap.waitSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
        if (!syncInProgress) {
            callback();
            return;
        }
        this.once('sync', callback);
    };
    PresenceMap.prototype.clear = function () {
        this.map = {};
        this.setInProgress(false);
        this.residualMembers = null;
    };
    PresenceMap.prototype.setInProgress = function (inProgress) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'PresenceMap.setInProgress()', 'inProgress = ' + inProgress);
        this.syncInProgress = inProgress;
        this.presence.syncComplete = !inProgress;
    };
    return PresenceMap;
}(eventemitter_1.default));
exports.default = RealtimePresence;


/***/ }),
/* 55 */
/***/ (function(module, exports, __nested_webpack_require_545633__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_545633__(0);
var enc_hex_1 = __nested_webpack_require_545633__(56);
var enc_utf8_1 = __nested_webpack_require_545633__(31);
var enc_base64_1 = __nested_webpack_require_545633__(11);
var lib_typedarrays_1 = tslib_1.__importDefault(__nested_webpack_require_545633__(5));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_545633__(3));
var BufferUtils = /** @class */ (function () {
    function BufferUtils() {
        this.base64CharSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        this.hexCharSet = '0123456789abcdef';
    }
    BufferUtils.prototype.isWordArray = function (ob) {
        return ob !== null && ob !== undefined && ob.sigBytes !== undefined;
    };
    BufferUtils.prototype.isArrayBuffer = function (ob) {
        return ob !== null && ob !== undefined && ob.constructor === ArrayBuffer;
    };
    BufferUtils.prototype.isTypedArray = function (ob) {
        return !!ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(ob);
    };
    // // https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js
    BufferUtils.prototype.uint8ViewToBase64 = function (bytes) {
        var base64 = '';
        var encodings = this.base64CharSet;
        var byteLength = bytes.byteLength;
        var byteRemainder = byteLength % 3;
        var mainLength = byteLength - byteRemainder;
        var a, b, c, d;
        var chunk;
        // Main loop deals with bytes in chunks of 3
        for (var i = 0; i < mainLength; i = i + 3) {
            // Combine the three bytes into a single integer
            chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
            // Use bitmasks to extract 6-bit segments from the triplet
            a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
            b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12
            c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6
            d = chunk & 63; // 63       = 2^6 - 1
            // Convert the raw binary segments to the appropriate ASCII encoding
            base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
        }
        // Deal with the remaining bytes and padding
        if (byteRemainder == 1) {
            chunk = bytes[mainLength];
            a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2
            // Set the 4 least significant bits to zero
            b = (chunk & 3) << 4; // 3   = 2^2 - 1
            base64 += encodings[a] + encodings[b] + '==';
        }
        else if (byteRemainder == 2) {
            chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];
            a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
            b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4
            // Set the 2 least significant bits to zero
            c = (chunk & 15) << 2; // 15    = 2^4 - 1
            base64 += encodings[a] + encodings[b] + encodings[c] + '=';
        }
        return base64;
    };
    BufferUtils.prototype.base64ToArrayBuffer = function (base64) {
        var binary_string = atob === null || atob === void 0 ? void 0 : atob(base64); // this will always be defined in browser so it's safe to cast
        var len = binary_string.length;
        var bytes = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
            var ascii = binary_string.charCodeAt(i);
            bytes[i] = ascii;
        }
        return bytes.buffer;
    };
    BufferUtils.prototype.isBuffer = function (buffer) {
        return this.isArrayBuffer(buffer) || this.isWordArray(buffer) || this.isTypedArray(buffer);
    };
    /* In browsers, returns a Uint8Array */
    BufferUtils.prototype.toBuffer = function (buffer) {
        if (!ArrayBuffer) {
            throw new Error("Can't convert to Buffer: browser does not support the necessary types");
        }
        if (this.isArrayBuffer(buffer)) {
            return new Uint8Array(buffer);
        }
        if (this.isTypedArray(buffer)) {
            return new Uint8Array(buffer.buffer);
        }
        if (this.isWordArray(buffer)) {
            /* Backported from unreleased CryptoJS
             * https://code.google.com/p/crypto-js/source/browse/branches/3.x/src/lib-typedarrays.js?r=661 */
            var arrayBuffer = new ArrayBuffer(buffer.sigBytes);
            var uint8View = new Uint8Array(arrayBuffer);
            for (var i = 0; i < buffer.sigBytes; i++) {
                uint8View[i] = (buffer.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
            }
            return uint8View;
        }
        throw new Error('BufferUtils.toBuffer expected an arraybuffer, typed array, or CryptoJS wordarray');
    };
    BufferUtils.prototype.toArrayBuffer = function (buffer) {
        if (this.isArrayBuffer(buffer)) {
            return buffer;
        }
        return this.toBuffer(buffer).buffer;
    };
    BufferUtils.prototype.toWordArray = function (buffer) {
        if (this.isTypedArray(buffer)) {
            buffer = buffer.buffer;
        }
        return this.isWordArray(buffer) ? buffer : lib_typedarrays_1.default.create(buffer);
    };
    BufferUtils.prototype.base64Encode = function (buffer) {
        if (this.isWordArray(buffer)) {
            return (0, enc_base64_1.stringify)(buffer);
        }
        return this.uint8ViewToBase64(this.toBuffer(buffer));
    };
    BufferUtils.prototype.base64Decode = function (str) {
        if (ArrayBuffer && platform_1.default.Config.atob) {
            return this.base64ToArrayBuffer(str);
        }
        return (0, enc_base64_1.parse)(str);
    };
    BufferUtils.prototype.hexEncode = function (buffer) {
        return (0, enc_hex_1.stringify)(this.toWordArray(buffer));
    };
    BufferUtils.prototype.hexDecode = function (string) {
        var wordArray = (0, enc_hex_1.parse)(string);
        return ArrayBuffer ? this.toArrayBuffer(wordArray) : wordArray;
    };
    BufferUtils.prototype.utf8Encode = function (string) {
        if (platform_1.default.Config.TextEncoder) {
            return new platform_1.default.Config.TextEncoder().encode(string).buffer;
        }
        return (0, enc_utf8_1.parse)(string);
    };
    /* For utf8 decoding we apply slightly stricter input validation than to
     * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from
     * can take (in particular allowing strings, which are just interpreted as
     * binary); here we ensure that the input is actually a buffer since trying
     * to utf8-decode a string to another string is almost certainly a mistake */
    BufferUtils.prototype.utf8Decode = function (buffer) {
        if (!this.isBuffer(buffer)) {
            throw new Error('Expected input of utf8decode to be an arraybuffer, typed array, or CryptoJS wordarray');
        }
        if (TextDecoder && !this.isWordArray(buffer)) {
            return new TextDecoder().decode(buffer);
        }
        buffer = this.toWordArray(buffer);
        return (0, enc_utf8_1.stringify)(buffer);
    };
    BufferUtils.prototype.bufferCompare = function (buffer1, buffer2) {
        if (!buffer1)
            return -1;
        if (!buffer2)
            return 1;
        var wordArray1 = this.toWordArray(buffer1);
        var wordArray2 = this.toWordArray(buffer2);
        wordArray1.clamp();
        wordArray2.clamp();
        var cmp = wordArray1.sigBytes - wordArray2.sigBytes;
        if (cmp != 0)
            return cmp;
        var words1 = wordArray1.words;
        var words2 = wordArray2.words;
        for (var i = 0; i < words1.length; i++) {
            cmp = words1[i] - words2[i];
            if (cmp != 0)
                return cmp;
        }
        return 0;
    };
    BufferUtils.prototype.byteLength = function (buffer) {
        if (this.isArrayBuffer(buffer) || this.isTypedArray(buffer)) {
            return buffer.byteLength;
        }
        else if (this.isWordArray(buffer)) {
            return buffer.sigBytes;
        }
        return -1;
    };
    /* Returns ArrayBuffer on browser and Buffer on Node.js */
    BufferUtils.prototype.typedArrayToBuffer = function (typedArray) {
        return typedArray.buffer;
    };
    return BufferUtils;
}());
exports.default = new BufferUtils();


/***/ }),
/* 56 */
/***/ (function(module, exports, __nested_webpack_require_554008__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_554008__(6));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Hex;

}));

/***/ }),
/* 57 */
/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_554290__) {

"use strict";
__nested_webpack_require_554290__.r(__nested_webpack_exports__);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_554290__(5);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_554290__.n(crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_554290__(11);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_554290__.n(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crypto_js_build__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_554290__(22);
/* harmony import */ var crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_554290__.n(crypto_js_build__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_554290__(2);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_554290__.n(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_554290__(4);
/* harmony import */ var common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__nested_webpack_require_554290__.n(common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_4__);






var CryptoFactory = function (config, bufferUtils) {
  var DEFAULT_ALGORITHM = 'aes';
  var DEFAULT_KEYLENGTH = 256; // bits
  var DEFAULT_MODE = 'cbc';
  var DEFAULT_BLOCKLENGTH = 16; // bytes
  var DEFAULT_BLOCKLENGTH_WORDS = 4; // 32-bit words
  var UINT32_SUP = 0x100000000;
  var INT32_SUP = 0x80000000;

  /**
   * Internal: generate an array of secure random words corresponding to the given length of bytes
   * @param bytes
   * @param callback
   */
  var generateRandom;
  if (config.getRandomWordArray) {
    generateRandom = config.getRandomWordArray;
  } else if (typeof Uint32Array !== 'undefined' && config.getRandomValues) {
    var blockRandomArray = new Uint32Array(DEFAULT_BLOCKLENGTH_WORDS);
    generateRandom = function (bytes, callback) {
      var words = bytes / 4,
        nativeArray = words == DEFAULT_BLOCKLENGTH_WORDS ? blockRandomArray : new Uint32Array(words);
      config.getRandomValues(nativeArray, function (err) {
        if (typeof callback !== 'undefined') {
          callback(err, bufferUtils.toWordArray(nativeArray));
        }
      });
    };
  } else {
    generateRandom = function (bytes, callback) {
      _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.logAction(
        _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.LOG_MAJOR,
        'Ably.Crypto.generateRandom()',
        'Warning: the browser you are using does not support secure cryptographically secure randomness generation; falling back to insecure Math.random()'
      );
      var words = bytes / 4,
        array = new Array(words);
      for (var i = 0; i < words; i++) {
        /* cryptojs wordarrays use signed ints. When WordArray.create is fed a
         * Uint32Array unsigned are converted to signed automatically, but when
         * fed a normal array they aren't, so need to do so ourselves by
         * subtracting INT32_SUP */
        array[i] = Math.floor(Math.random() * UINT32_SUP) - INT32_SUP;
      }

      callback(null, crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(array));
    };
  }

  /**
   * Internal: calculate the padded length of a given plaintext
   * using PKCS5.
   * @param plaintextLength
   * @return
   */
  function getPaddedLength(plaintextLength) {
    return (plaintextLength + DEFAULT_BLOCKLENGTH) & -DEFAULT_BLOCKLENGTH;
  }

  /**
   * Internal: checks that the cipherParams are a valid combination. Currently
   * just checks that the calculated keyLength is a valid one for aes-cbc
   */
  function validateCipherParams(params) {
    if (params.algorithm === 'aes' && params.mode === 'cbc') {
      if (params.keyLength === 128 || params.keyLength === 256) {
        return;
      }
      throw new Error(
        'Unsupported key length ' +
          params.keyLength +
          ' for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)'
      );
    }
  }

  function normaliseBase64(string) {
    /* url-safe base64 strings use _ and - instread of / and + */
    return string.replace('_', '/').replace('-', '+');
  }

  /**
   * Internal: obtain the pkcs5 padding string for a given padded length;
   */
  var pkcs5Padding = [
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x10101010, 0x10101010, 0x10101010, 0x10101010], 16),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x01000000], 1),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x02020000], 2),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x03030300], 3),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x04040404], 4),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x05050505, 0x05000000], 5),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x06060606, 0x06060000], 6),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x07070707, 0x07070700], 7),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x08080808, 0x08080808], 8),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x09090909, 0x09090909, 0x09000000], 9),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0a0a0a0a, 0x0a0a0a0a, 0x0a0a0000], 10),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0b0b0b0b, 0x0b0b0b0b, 0x0b0b0b00], 11),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0c0c0c0c, 0x0c0c0c0c, 0x0c0c0c0c], 12),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0d0d0d0d, 0x0d0d0d0d, 0x0d0d0d0d, 0x0d000000], 13),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0e0e0e0e, 0x0e0e0e0e, 0x0e0e0e0e, 0x0e0e0000], 14),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f], 15),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x10101010, 0x10101010, 0x10101010, 0x10101010], 16),
  ];

  /**
   * Utility classes and interfaces for message payload encryption.
   *
   * This class supports AES/CBC/PKCS5 with a default keylength of 128 bits
   * but supporting other keylengths. Other algorithms and chaining modes are
   * not supported directly, but supportable by extending/implementing the base
   * classes and interfaces here.
   *-
   * Secure random data for creation of Initialization Vectors (IVs) and keys
   * is obtained from window.crypto.getRandomValues if available, or from
   * Math.random() if not. Clients who do not want to depend on Math.random()
   * should polyfill window.crypto.getRandomValues with a library that seeds
   * a PRNG with real entropy.
   *
   * Each message payload is encrypted with an IV in CBC mode, and the IV is
   * concatenated with the resulting raw ciphertext to construct the "ciphertext"
   * data passed to the recipient.
   */
  function Crypto() {}

  /**
   * A class encapsulating the client-specifiable parameters for
   * the cipher.
   *
   * algorithm is the name of the algorithm in the default system provider,
   * or the lower-cased version of it; eg "aes" or "AES".
   *
   * Clients are recommended to not call this directly, but instead to use the
   * Crypto.getDefaultParams helper, which will fill in any fields not supplied
   * with default values and validation the result.
   */
  function CipherParams() {
    this.algorithm = null;
    this.keyLength = null;
    this.mode = null;
    this.key = null;
  }
  Crypto.CipherParams = CipherParams;

  /**
   * Obtain a complete CipherParams instance from the provided params, filling
   * in any not provided with default values, calculating a keyLength from
   * the supplied key, and validating the result.
   * @param params an object containing at a minimum a `key` key with value the
   * key, as either a binary (ArrayBuffer, Array, WordArray) or a
   * base64-encoded string. May optionally also contain: algorithm (defaults to
   * AES), mode (defaults to 'cbc')
   */
  Crypto.getDefaultParams = function (params) {
    var key;
    /* Backward compatibility */
    if (typeof params === 'function' || typeof params === 'string') {
      _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.deprecated('Crypto.getDefaultParams(key, callback)', 'Crypto.getDefaultParams({key: key})');
      if (typeof params === 'function') {
        Crypto.generateRandomKey(function (key) {
          params(null, Crypto.getDefaultParams({ key: key }));
        });
      } else if (typeof arguments[1] === 'function') {
        arguments[1](null, Crypto.getDefaultParams({ key: params }));
      } else {
        throw new Error('Invalid arguments for Crypto.getDefaultParams');
      }
      return;
    }

    if (!params.key) {
      throw new Error('Crypto.getDefaultParams: a key is required');
    }

    if (typeof params.key === 'string') {
      key = Object(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__["parse"])(normaliseBase64(params.key));
    } else {
      key = bufferUtils.toWordArray(params.key); // Expect key to be an Array, ArrayBuffer, or WordArray at this point
    }

    var cipherParams = new CipherParams();
    cipherParams.key = key;
    cipherParams.algorithm = params.algorithm || DEFAULT_ALGORITHM;
    cipherParams.keyLength = key.words.length * (4 * 8);
    cipherParams.mode = params.mode || DEFAULT_MODE;

    if (params.keyLength && params.keyLength !== cipherParams.keyLength) {
      throw new Error(
        'Crypto.getDefaultParams: a keyLength of ' +
          params.keyLength +
          ' was specified, but the key actually has length ' +
          cipherParams.keyLength
      );
    }

    validateCipherParams(cipherParams);
    return cipherParams;
  };

  /**
   * Generate a random encryption key from the supplied keylength (or the
   * default keyLength if none supplied) as a CryptoJS WordArray
   * @param keyLength (optional) the required keyLength in bits
   * @param callback (optional) (err, key)
   */
  Crypto.generateRandomKey = function (keyLength, callback) {
    if (arguments.length == 1 && typeof keyLength == 'function') {
      callback = keyLength;
      keyLength = undefined;
    }

    generateRandom((keyLength || DEFAULT_KEYLENGTH) / 8, function (err, buf) {
      if (callback !== undefined) {
        callback(err ? common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_4___default.a.fromValues(err) : null, buf);
      }
    });
  };

  /**
   * Internal; get a ChannelCipher instance based on the given cipherParams
   * @param params either a CipherParams instance or some subset of its
   * fields that includes a key
   */
  Crypto.getCipher = function (params) {
    var cipherParams = params instanceof CipherParams ? params : Crypto.getDefaultParams(params);

    return { cipherParams: cipherParams, cipher: new CBCCipher(cipherParams, DEFAULT_BLOCKLENGTH_WORDS, params.iv) };
  };

  function CBCCipher(params, blockLengthWords, iv) {
    this.algorithm = params.algorithm + '-' + String(params.keyLength) + '-' + params.mode;
    this.cjsAlgorithm = params.algorithm.toUpperCase().replace(/-\d+$/, '');
    this.key = bufferUtils.toWordArray(params.key);
    if (iv) {
      this.iv = bufferUtils.toWordArray(iv).clone();
    }
    this.blockLengthWords = blockLengthWords;
  }

  CBCCipher.prototype.encrypt = function (plaintext, callback) {
    _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.LOG_MICRO, 'CBCCipher.encrypt()', '');
    plaintext = bufferUtils.toWordArray(plaintext);
    var plaintextLength = plaintext.sigBytes,
      paddedLength = getPaddedLength(plaintextLength),
      self = this;

    var then = function () {
      self.getIv(function (err, iv) {
        if (err) {
          callback(err);
          return;
        }
        var cipherOut = self.encryptCipher.process(plaintext.concat(pkcs5Padding[paddedLength - plaintextLength]));
        var ciphertext = iv.concat(cipherOut);
        callback(null, ciphertext);
      });
    };

    if (!this.encryptCipher) {
      if (this.iv) {
        this.encryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[this.cjsAlgorithm].createEncryptor(this.key, { iv: this.iv });
        then();
      } else {
        generateRandom(DEFAULT_BLOCKLENGTH, function (err, iv) {
          if (err) {
            callback(err);
            return;
          }
          self.encryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[self.cjsAlgorithm].createEncryptor(self.key, { iv: iv });
          self.iv = iv;
          then();
        });
      }
    } else {
      then();
    }
  };

  CBCCipher.prototype.decrypt = function (ciphertext) {
    _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.LOG_MICRO, 'CBCCipher.decrypt()', '');
    ciphertext = bufferUtils.toWordArray(ciphertext);
    var blockLengthWords = this.blockLengthWords,
      ciphertextWords = ciphertext.words,
      iv = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(ciphertextWords.slice(0, blockLengthWords)),
      ciphertextBody = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(ciphertextWords.slice(blockLengthWords));

    var decryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[this.cjsAlgorithm].createDecryptor(this.key, { iv: iv });
    var plaintext = decryptCipher.process(ciphertextBody);
    var epilogue = decryptCipher.finalize();
    decryptCipher.reset();
    if (epilogue && epilogue.sigBytes) plaintext.concat(epilogue);
    return plaintext;
  };

  CBCCipher.prototype.getIv = function (callback) {
    if (this.iv) {
      var iv = this.iv;
      this.iv = null;
      callback(null, iv);
      return;
    }

    /* Since the iv for a new block is the ciphertext of the last, this
     * sets a new iv (= aes(randomBlock XOR lastCipherText)) as well as
     * returning it */
    var self = this;
    generateRandom(DEFAULT_BLOCKLENGTH, function (err, randomBlock) {
      if (err) {
        callback(err);
        return;
      }
      callback(null, self.encryptCipher.process(randomBlock));
    });
  };

  return Crypto;
};

/* harmony default export */ __nested_webpack_exports__["default"] = (CryptoFactory);


/***/ }),
/* 58 */
/***/ (function(module, exports, __nested_webpack_require_569507__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_569507__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	return CryptoJS.enc.Utf16;

}));

/***/ }),
/* 59 */
/***/ (function(module, exports, __nested_webpack_require_573504__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_573504__(6), __nested_webpack_require_573504__(28));
	}
	else {}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	return CryptoJS.format.Hex;

}));

/***/ }),
/* 60 */
/***/ (function(module, exports, __nested_webpack_require_575212__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_575212__(6), __nested_webpack_require_575212__(11), __nested_webpack_require_575212__(61), __nested_webpack_require_575212__(27), __nested_webpack_require_575212__(28));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            var t;

	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));

/***/ }),
/* 61 */
/***/ (function(module, exports, __nested_webpack_require_583721__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_583721__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),
/* 62 */
/***/ (function(module, exports, __nested_webpack_require_593050__) {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_593050__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(3));
var Utils = tslib_1.__importStar(__nested_webpack_require_593050__(1));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(8));
var errorinfo_1 = __nested_webpack_require_593050__(4);
var HttpMethods_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(18));
var xhrrequest_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(16));
var XHRStates_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(21));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(2));
var jsonptransport_1 = __nested_webpack_require_593050__(29);
var fetchrequest_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(63));
var HttpStatusCodes_1 = __nested_webpack_require_593050__(25);
function shouldFallback(errorInfo) {
    var statusCode = errorInfo.statusCode;
    /* 400 + no code = a generic xhr onerror. Browser doesn't give us enough
     * detail to know whether it's fallback-fixable, but it may be (eg if a
     * network issue), so try just in case */
    return ((statusCode === 408 && !errorInfo.code) ||
        (statusCode === 400 && !errorInfo.code) ||
        (statusCode >= 500 && statusCode <= 504));
}
function getHosts(client) {
    /* If we're a connected realtime client, try the endpoint we're connected
     * to first -- but still have fallbacks, being connected is not an absolute
     * guarantee that a datacenter has free capacity to service REST requests. */
    var connection = client.connection, connectionHost = connection && connection.connectionManager.host;
    if (connectionHost) {
        return [connectionHost].concat(defaults_1.default.getFallbackHosts(client.options));
    }
    return defaults_1.default.getHosts(client.options);
}
var Http = (_a = /** @class */ (function () {
        function class_1(options) {
            this.checksInProgress = null;
            this.checkConnectivity = undefined;
            this.supportsAuthHeaders = false;
            this.supportsLinkHeaders = false;
            this._getHosts = getHosts;
            this.options = options || {};
            var connectivityCheckUrl = this.options.connectivityCheckUrl || defaults_1.default.connectivityCheckUrl;
            var connectivityCheckParams = this.options.connectivityCheckParams;
            var connectivityUrlIsDefault = !this.options.connectivityCheckUrl;
            if (platform_1.default.Config.xhrSupported) {
                this.supportsAuthHeaders = true;
                this.Request = function (method, rest, uri, headers, params, body, callback) {
                    var req = xhrrequest_1.default.createRequest(uri, headers, params, body, XHRStates_1.default.REQ_SEND, rest && rest.options.timeouts, method);
                    req.once('complete', callback);
                    req.exec();
                    return req;
                };
                if (this.options.disableConnectivityCheck) {
                    this.checkConnectivity = function (callback) {
                        callback(null, true);
                    };
                }
                else {
                    this.checkConnectivity = function (callback) {
                        logger_1.default.logAction(logger_1.default.LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Sending; ' + connectivityCheckUrl);
                        this.doUri(HttpMethods_1.default.Get, null, connectivityCheckUrl, null, null, connectivityCheckParams, function (err, responseText, headers, unpacked, statusCode) {
                            var result = false;
                            if (!connectivityUrlIsDefault) {
                                result = !err && (0, HttpStatusCodes_1.isSuccessCode)(statusCode);
                            }
                            else {
                                result = !err && (responseText === null || responseText === void 0 ? void 0 : responseText.replace(/\n/, '')) == 'yes';
                            }
                            logger_1.default.logAction(logger_1.default.LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Result: ' + result);
                            callback(null, result);
                        });
                    };
                }
            }
            else if (platform_1.default.Config.jsonpSupported) {
                this.Request = function (method, rest, uri, headers, params, body, callback) {
                    var req = (0, jsonptransport_1.createRequest)(uri, headers, params, body, XHRStates_1.default.REQ_SEND, rest && rest.options.timeouts, method);
                    req.once('complete', callback);
                    platform_1.default.Config.nextTick(function () {
                        req.exec();
                    });
                    return req;
                };
                if (this.options.disableConnectivityCheck) {
                    this.checkConnectivity = function (callback) {
                        callback(null, true);
                    };
                }
                else {
                    this.checkConnectivity = function (callback) {
                        var _this = this;
                        var upUrl = defaults_1.default.jsonpInternetUpUrl;
                        if (this.checksInProgress) {
                            this.checksInProgress.push(callback);
                            return;
                        }
                        this.checksInProgress = [callback];
                        logger_1.default.logAction(logger_1.default.LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Sending; ' + upUrl);
                        var req = new jsonptransport_1.Request('isTheInternetUp', upUrl, null, null, null, XHRStates_1.default.REQ_SEND, defaults_1.default.TIMEOUTS);
                        req.once('complete', function (err, response) {
                            var result = !err && response;
                            logger_1.default.logAction(logger_1.default.LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Result: ' + result);
                            for (var i = 0; i < _this.checksInProgress.length; i++)
                                _this.checksInProgress[i](null, result);
                            _this.checksInProgress = null;
                        });
                        platform_1.default.Config.nextTick(function () {
                            req.exec();
                        });
                    };
                }
            }
            else if (platform_1.default.Config.fetchSupported) {
                this.supportsAuthHeaders = true;
                this.Request = fetchrequest_1.default;
                this.checkConnectivity = function (callback) {
                    logger_1.default.logAction(logger_1.default.LOG_MICRO, '(Fetch)Http.checkConnectivity()', 'Sending; ' + connectivityCheckUrl);
                    this.doUri(HttpMethods_1.default.Get, null, connectivityCheckUrl, null, null, null, function (err, responseText) {
                        var result = !err && (responseText === null || responseText === void 0 ? void 0 : responseText.replace(/\n/, '')) == 'yes';
                        logger_1.default.logAction(logger_1.default.LOG_MICRO, '(Fetch)Http.checkConnectivity()', 'Result: ' + result);
                        callback(null, result);
                    });
                };
            }
            else {
                this.Request = function (method, rest, uri, headers, params, body, callback) {
                    callback(new errorinfo_1.PartialErrorInfo('no supported HTTP transports available', null, 400), null);
                };
            }
        }
        /* Unlike for doUri, the 'rest' param here is mandatory, as it's used to generate the hosts */
        class_1.prototype.do = function (method, rest, path, headers, body, params, callback) {
            var _this = this;
            var uriFromHost = typeof path == 'function'
                ? path
                : function (host) {
                    return rest.baseUri(host) + path;
                };
            var currentFallback = rest._currentFallback;
            if (currentFallback) {
                if (currentFallback.validUntil > Utils.now()) {
                    /* Use stored fallback */
                    if (!this.Request) {
                        callback === null || callback === void 0 ? void 0 : callback(new errorinfo_1.PartialErrorInfo('Request invoked before assigned to', null, 500));
                        return;
                    }
                    this.Request(method, rest, uriFromHost(currentFallback.host), headers, params, body, function (err) {
                        var args = [];
                        for (var _i = 1; _i < arguments.length; _i++) {
                            args[_i - 1] = arguments[_i];
                        }
                        // This typecast is safe because ErrnoExceptions are only thrown in NodeJS
                        if (err && shouldFallback(err)) {
                            /* unstore the fallback and start from the top with the default sequence */
                            rest._currentFallback = null;
                            _this.do(method, rest, path, headers, body, params, callback);
                            return;
                        }
                        callback === null || callback === void 0 ? void 0 : callback.apply(void 0, tslib_1.__spreadArray([err], args, false));
                    });
                    return;
                }
                else {
                    /* Fallback expired; remove it and fallthrough to normal sequence */
                    rest._currentFallback = null;
                }
            }
            var hosts = getHosts(rest);
            /* if there is only one host do it */
            if (hosts.length === 1) {
                this.doUri(method, rest, uriFromHost(hosts[0]), headers, body, params, callback);
                return;
            }
            /* hosts is an array with preferred host plus at least one fallback */
            var tryAHost = function (candidateHosts, persistOnSuccess) {
                var host = candidateHosts.shift();
                _this.doUri(method, rest, uriFromHost(host), headers, body, params, function (err) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    // This typecast is safe because ErrnoExceptions are only thrown in NodeJS
                    if (err && shouldFallback(err) && candidateHosts.length) {
                        tryAHost(candidateHosts, true);
                        return;
                    }
                    if (persistOnSuccess) {
                        /* RSC15f */
                        rest._currentFallback = {
                            host: host,
                            validUntil: Utils.now() + rest.options.timeouts.fallbackRetryTimeout,
                        };
                    }
                    callback === null || callback === void 0 ? void 0 : callback.apply(void 0, tslib_1.__spreadArray([err], args, false));
                });
            };
            tryAHost(hosts);
        };
        class_1.prototype.doUri = function (method, rest, uri, headers, body, params, callback) {
            if (!this.Request) {
                callback(new errorinfo_1.PartialErrorInfo('Request invoked before assigned to', null, 500));
                return;
            }
            this.Request(method, rest, uri, headers, params, body, callback);
        };
        return class_1;
    }()),
    _a.methods = [HttpMethods_1.default.Get, HttpMethods_1.default.Delete, HttpMethods_1.default.Post, HttpMethods_1.default.Put, HttpMethods_1.default.Patch],
    _a.methodsWithoutBody = [HttpMethods_1.default.Get, HttpMethods_1.default.Delete],
    _a.methodsWithBody = [HttpMethods_1.default.Post, HttpMethods_1.default.Put, HttpMethods_1.default.Patch],
    _a);
exports.default = Http;


/***/ }),
/* 63 */
/***/ (function(module, exports, __nested_webpack_require_605278__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_605278__(0);
var errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_605278__(4));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_605278__(3));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_605278__(8));
var Utils = tslib_1.__importStar(__nested_webpack_require_605278__(1));
var utils_1 = __nested_webpack_require_605278__(1);
function isAblyError(responseBody, headers) {
    return !!headers.get('x-ably-errorcode');
}
function getAblyError(responseBody, headers) {
    if (isAblyError(responseBody, headers)) {
        return responseBody.error && errorinfo_1.default.fromValues(responseBody.error);
    }
}
function fetchRequest(method, rest, uri, headers, params, body, callback) {
    var fetchHeaders = new Headers(headers || {});
    var _method = method ? method.toUpperCase() : Utils.isEmptyArg(body) ? 'GET' : 'POST';
    var controller = new AbortController();
    var timeout = setTimeout(function () {
        controller.abort();
        callback(new errorinfo_1.PartialErrorInfo('Request timed out', null, 408));
    }, rest ? rest.options.timeouts.httpRequestTimeout : defaults_1.default.TIMEOUTS.httpRequestTimeout);
    var requestInit = {
        method: _method,
        headers: fetchHeaders,
        body: body,
    };
    if (!platform_1.default.Config.isWebworker) {
        requestInit.credentials = fetchHeaders.has('authorization') ? 'include' : 'same-origin';
    }
    (0, utils_1.getGlobalObject)()
        .fetch(uri + '?' + new URLSearchParams(params || {}), requestInit)
        .then(function (res) {
        clearTimeout(timeout);
        var contentType = res.headers.get('Content-Type');
        var prom;
        if (contentType && contentType.indexOf('application/x-msgpack') > -1) {
            prom = res.arrayBuffer();
        }
        else if (contentType && contentType.indexOf('application/json') > -1) {
            prom = res.json();
        }
        else {
            prom = res.text();
        }
        prom.then(function (body) {
            var unpacked = !!contentType && contentType.indexOf('application/x-msgpack') === -1;
            if (!res.ok) {
                var err = getAblyError(body, res.headers) ||
                    new errorinfo_1.PartialErrorInfo('Error response received from server: ' + res.status + ' body was: ' + platform_1.default.Config.inspect(body), null, res.status);
                callback(err, body, res.headers, unpacked, res.status);
            }
            else {
                callback(null, body, res.headers, unpacked, res.status);
            }
        });
    })
        .catch(function (err) {
        clearTimeout(timeout);
        callback(err);
    });
}
exports.default = fetchRequest;


/***/ }),
/* 64 */
/***/ (function(module, exports, __nested_webpack_require_608129__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_608129__(0);
var msgpack_1 = tslib_1.__importDefault(__nested_webpack_require_608129__(41));
var Utils = tslib_1.__importStar(__nested_webpack_require_608129__(1));
// Workaround for salesforce lightning locker compat
var globalObject = Utils.getGlobalObject();
if (typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') {
    console.log("Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm");
}
function allowComet() {
    /* xhr requests from local files are unreliable in some browsers, such as Chrome 65 and higher -- see eg
     * https://stackoverflow.com/questions/49256429/chrome-65-unable-to-make-post-requests-from-local-files-to-flask
     * So if websockets are supported, then just forget about comet transports and use that */
    var loc = globalObject.location;
    return !globalObject.WebSocket || !loc || !loc.origin || loc.origin.indexOf('http') > -1;
}
var userAgent = globalObject.navigator && globalObject.navigator.userAgent.toString();
var currentUrl = globalObject.location && globalObject.location.href;
var Config = {
    agent: 'browser',
    logTimestamps: true,
    userAgent: userAgent,
    currentUrl: currentUrl,
    noUpgrade: userAgent && !!userAgent.match(/MSIE\s8\.0/),
    binaryType: 'arraybuffer',
    WebSocket: globalObject.WebSocket,
    fetchSupported: !!globalObject.fetch,
    xhrSupported: globalObject.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest(),
    jsonpSupported: typeof document !== 'undefined',
    allowComet: allowComet(),
    streamingSupported: true,
    useProtocolHeartbeats: true,
    createHmac: null,
    msgpack: msgpack_1.default,
    supportsBinary: !!globalObject.TextDecoder,
    preferBinary: false,
    ArrayBuffer: globalObject.ArrayBuffer,
    atob: globalObject.atob,
    nextTick: typeof globalObject.setImmediate !== 'undefined'
        ? globalObject.setImmediate.bind(globalObject)
        : function (f) {
            setTimeout(f, 0);
        },
    addEventListener: globalObject.addEventListener,
    inspect: JSON.stringify,
    stringByteSize: function (str) {
        /* str.length will be an underestimate for non-ascii strings. But if we're
         * in a browser too old to support TextDecoder, not much we can do. Better
         * to underestimate, so if we do go over-size, the server will reject the
         * message */
        return (globalObject.TextDecoder && new globalObject.TextEncoder().encode(str).length) || str.length;
    },
    TextEncoder: globalObject.TextEncoder,
    TextDecoder: globalObject.TextDecoder,
    Promise: globalObject.Promise,
    getRandomValues: (function (crypto) {
        if (crypto === undefined) {
            return undefined;
        }
        return function (arr, callback) {
            crypto.getRandomValues(arr);
            if (callback) {
                callback(null);
            }
        };
    })(globalObject.crypto || msCrypto),
};
exports.default = Config;


/***/ }),
/* 65 */
/***/ (function(module, exports, __nested_webpack_require_611284__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_611284__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_611284__(1));
var test = 'ablyjs-storage-test';
var Webstorage = /** @class */ (function () {
    function Webstorage() {
        /* Even just accessing the session/localStorage object can throw a
         * security exception in some circumstances with some browsers. In
         * others, calling setItem will throw. So have to check in this
         * somewhat roundabout way. (If unsupported or no global object,
         * will throw on accessing a property of undefined) */
        try {
            global.sessionStorage.setItem(test, test);
            global.sessionStorage.removeItem(test);
            this.sessionSupported = true;
        }
        catch (e) {
            this.sessionSupported = false;
        }
        try {
            global.localStorage.setItem(test, test);
            global.localStorage.removeItem(test);
            this.localSupported = true;
        }
        catch (e) {
            this.localSupported = false;
        }
    }
    Webstorage.prototype.get = function (name) {
        return this._get(name, false);
    };
    Webstorage.prototype.getSession = function (name) {
        return this._get(name, true);
    };
    Webstorage.prototype.remove = function (name) {
        return this._remove(name, false);
    };
    Webstorage.prototype.removeSession = function (name) {
        return this._remove(name, true);
    };
    Webstorage.prototype.set = function (name, value, ttl) {
        return this._set(name, value, ttl, false);
    };
    Webstorage.prototype.setSession = function (name, value, ttl) {
        return this._set(name, value, ttl, true);
    };
    Webstorage.prototype._set = function (name, value, ttl, session) {
        var wrappedValue = { value: value };
        if (ttl) {
            wrappedValue.expires = Utils.now() + ttl;
        }
        return this.storageInterface(session).setItem(name, JSON.stringify(wrappedValue));
    };
    Webstorage.prototype._get = function (name, session) {
        if (session && !this.sessionSupported)
            throw new Error('Session Storage not supported');
        if (!session && !this.localSupported)
            throw new Error('Local Storage not supported');
        var rawItem = this.storageInterface(session).getItem(name);
        if (!rawItem)
            return null;
        var wrappedValue = JSON.parse(rawItem);
        if (wrappedValue.expires && wrappedValue.expires < Utils.now()) {
            this.storageInterface(session).removeItem(name);
            return null;
        }
        return wrappedValue.value;
    };
    Webstorage.prototype._remove = function (name, session) {
        return this.storageInterface(session).removeItem(name);
    };
    Webstorage.prototype.storageInterface = function (session) {
        return session ? global.sessionStorage : global.localStorage;
    };
    return Webstorage;
}());
exports.default = new Webstorage();

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_611284__(13)))

/***/ }),
/* 66 */
/***/ (function(module, exports, __nested_webpack_require_614538__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_614538__(0);
var TransportNames_1 = tslib_1.__importDefault(__nested_webpack_require_614538__(67));
var Defaults = {
    connectivityCheckUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up.txt',
    jsonpInternetUpUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up-0-9.js',
    /* Order matters here: the base transport is the leftmost one in the
     * intersection of baseTransportOrder and the transports clientOption that's
     * supported.  This is not quite the same as the preference order -- e.g.
     * xhr_polling is preferred to jsonp, but for browsers that support it we want
     * the base transport to be xhr_polling, not jsonp */
    defaultTransports: [
        TransportNames_1.default.XhrPolling,
        TransportNames_1.default.XhrStreaming,
        TransportNames_1.default.JsonP,
        TransportNames_1.default.WebSocket,
    ],
    baseTransportOrder: [
        TransportNames_1.default.XhrPolling,
        TransportNames_1.default.XhrStreaming,
        TransportNames_1.default.JsonP,
        TransportNames_1.default.WebSocket,
    ],
    transportPreferenceOrder: [
        TransportNames_1.default.JsonP,
        TransportNames_1.default.XhrPolling,
        TransportNames_1.default.XhrStreaming,
        TransportNames_1.default.WebSocket,
    ],
    upgradeTransports: [TransportNames_1.default.XhrStreaming, TransportNames_1.default.WebSocket],
};
exports.default = Defaults;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var TransportNames;
(function (TransportNames) {
    TransportNames["WebSocket"] = "web_socket";
    TransportNames["Comet"] = "comet";
    TransportNames["XhrStreaming"] = "xhr_streaming";
    TransportNames["XhrPolling"] = "xhr_polling";
    TransportNames["JsonP"] = "jsonp";
})(TransportNames || (TransportNames = {}));
exports.default = TransportNames;


/***/ }),
/* 68 */
/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_616665__) {

"use strict";
// ESM COMPAT FLAG
__nested_webpack_require_616665__.r(__nested_webpack_exports__);

// EXTERNAL MODULE: ./src/platform/web/lib/transport/jsonptransport.ts
var jsonptransport = __nested_webpack_require_616665__(29);
var jsonptransport_default = /*#__PURE__*/__nested_webpack_require_616665__.n(jsonptransport);

// EXTERNAL MODULE: ./src/common/lib/util/utils.ts
var utils = __nested_webpack_require_616665__(1);

// EXTERNAL MODULE: ./src/common/platform.ts
var platform = __nested_webpack_require_616665__(3);
var platform_default = /*#__PURE__*/__nested_webpack_require_616665__.n(platform);

// EXTERNAL MODULE: ./src/common/lib/transport/comettransport.ts
var comettransport = __nested_webpack_require_616665__(12);
var comettransport_default = /*#__PURE__*/__nested_webpack_require_616665__.n(comettransport);

// EXTERNAL MODULE: ./src/platform/web/lib/transport/xhrrequest.ts
var xhrrequest = __nested_webpack_require_616665__(16);
var xhrrequest_default = /*#__PURE__*/__nested_webpack_require_616665__.n(xhrrequest);

// CONCATENATED MODULE: ./src/platform/web/lib/transport/xhrpollingtransport.js





var xhrpollingtransport_XHRPollingTransport = function (connectionManager) {
  var shortName = 'xhr_polling';

  function XHRPollingTransport(connectionManager, auth, params) {
    params.stream = false;
    comettransport_default.a.call(this, connectionManager, auth, params);
    this.shortName = shortName;
  }
  utils["inherits"](XHRPollingTransport, comettransport_default.a);

  XHRPollingTransport.isAvailable = function () {
    return platform_default.a.Config.xhrSupported && platform_default.a.Config.allowComet;
  };

  XHRPollingTransport.prototype.toString = function () {
    return 'XHRPollingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
  };

  XHRPollingTransport.prototype.createRequest = function (uri, headers, params, body, requestMode) {
    return xhrrequest_default.a.createRequest(uri, headers, params, body, requestMode, this.timeouts);
  };

  if (typeof connectionManager !== 'undefined' && XHRPollingTransport.isAvailable()) {
    connectionManager.supportedTransports[shortName] = XHRPollingTransport;
  }

  return XHRPollingTransport;
};

/* harmony default export */ var xhrpollingtransport = (xhrpollingtransport_XHRPollingTransport);

// CONCATENATED MODULE: ./src/platform/web/lib/transport/xhrstreamingtransport.js





var xhrstreamingtransport_XHRStreamingTransport = function (connectionManager) {
  var shortName = 'xhr_streaming';

  /* public constructor */
  function XHRStreamingTransport(connectionManager, auth, params) {
    comettransport_default.a.call(this, connectionManager, auth, params);
    this.shortName = shortName;
  }
  utils["inherits"](XHRStreamingTransport, comettransport_default.a);

  XHRStreamingTransport.isAvailable = function () {
    return platform_default.a.Config.xhrSupported && platform_default.a.Config.streamingSupported && platform_default.a.Config.allowComet;
  };

  XHRStreamingTransport.prototype.toString = function () {
    return 'XHRStreamingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
  };

  XHRStreamingTransport.prototype.createRequest = function (uri, headers, params, body, requestMode) {
    return xhrrequest_default.a.createRequest(uri, headers, params, body, requestMode, this.timeouts);
  };

  if (typeof connectionManager !== 'undefined' && XHRStreamingTransport.isAvailable()) {
    connectionManager.supportedTransports[shortName] = XHRStreamingTransport;
  }

  return XHRStreamingTransport;
};

/* harmony default export */ var xhrstreamingtransport = (xhrstreamingtransport_XHRStreamingTransport);

// CONCATENATED MODULE: ./src/platform/web/lib/transport/index.js




/* harmony default export */ var transport = __nested_webpack_exports__["default"] = ([jsonptransport_default.a, xhrpollingtransport, xhrstreamingtransport]);


/***/ })
/******/ ])["default"];
});

/***/ }),

/***/ "./node_modules/ably/promises.js":
/*!***************************************!*\
  !*** ./node_modules/ably/promises.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

function promisifyOptions(options) {
  if (typeof options == 'string') {
    options = options.indexOf(':') == -1 ? { token: options } : { key: options };
  }
  options.promises = true;
  return options;
}

/* Please note that the file imported below is only generated after running
 * the build task. */
// eslint-disable-next-line @typescript-eslint/no-var-requires
var Ably = __webpack_require__(/*! ./build/ably-node */ "./node_modules/ably/build/ably-commonjs.js");

var RestPromise = function (options) {
  return new Ably.Rest(promisifyOptions(options));
};
Object.assign(RestPromise, Ably.Rest);

var RealtimePromise = function (options) {
  return new Ably.Realtime(promisifyOptions(options));
};
Object.assign(RealtimePromise, Ably.Realtime);

module.exports = {
  Rest: RestPromise,
  Realtime: RealtimePromise,
};


/***/ }),

/***/ "./src/controller.js":
/*!***************************!*\
  !*** ./src/controller.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Controller: () => (/* binding */ Controller)
/* harmony export */ });
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./server */ "./src/server.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view */ "./src/view.js");
/* harmony import */ var _untils_random__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./untils/random */ "./src/untils/random.js");




class Controller {
  style = localStorage.getItem("style") ?? "light";
  step = (0,_untils_random__WEBPACK_IMPORTED_MODULE_2__.getRandomInt)(1) === 0 ? "x" : "o";

  cellsData = [];

  async init() {
    await _server__WEBPACK_IMPORTED_MODULE_0__.server.init();

    this.resetGame();
    console.log(this.cellsData);

    _server__WEBPACK_IMPORTED_MODULE_0__.server.onServerMessage = (message) => this.onServerMessage(message);

    _view__WEBPACK_IMPORTED_MODULE_1__.view.setStyle(this.style);

    _view__WEBPACK_IMPORTED_MODULE_1__.view.setTurn(this.step);

    _view__WEBPACK_IMPORTED_MODULE_1__.view.buttonTopic.onclick = () => this.toggleStyle();

    _view__WEBPACK_IMPORTED_MODULE_1__.view.onCellPress = (cell) => this.onCellPress(cell);
  }

  toggleStyle() {
    this.style = this.style === "light" ? "dark" : "light";
    _view__WEBPACK_IMPORTED_MODULE_1__.view.setStyle(this.style);
    localStorage.setItem("style", this.style);
  }

  resetGame() {
    this.cellsData = new Array(9).fill("empty");
    _view__WEBPACK_IMPORTED_MODULE_1__.view.clearCells();
    _view__WEBPACK_IMPORTED_MODULE_1__.view.setTurn(this.step);
  }

  onServerMessage(message) {
    const data = JSON.parse(message.data);

    this.step = data.step;
    this.cell = _view__WEBPACK_IMPORTED_MODULE_1__.view.cells[data.cell];
    this.cellsData[data.cell] = this.step;

    _view__WEBPACK_IMPORTED_MODULE_1__.view.updateCell(_view__WEBPACK_IMPORTED_MODULE_1__.view.cells[data.cell], this.step);
    _view__WEBPACK_IMPORTED_MODULE_1__.view.setTurn(this.step);

    this.switchStep();
    _view__WEBPACK_IMPORTED_MODULE_1__.view.setTurn(this.step);

    this.checkDraw();
    this.checkWin();
  }

  switchStep() {
    this.step = this.step === "x" ? "o" : "x";
    console.log("switchStep", this.step);
  }

  onCellPress(cell) {
    console.log("onCellPress", this.step);

    if (this.cellsData[_view__WEBPACK_IMPORTED_MODULE_1__.view.cells.indexOf(cell)] !== "empty") {
      return;
    }

    _server__WEBPACK_IMPORTED_MODULE_0__.server.makeMove({
      cell: _view__WEBPACK_IMPORTED_MODULE_1__.view.cells.indexOf(cell),
      step: this.step,
    });
  }

  checkWin() {
    const winner = this.getWinner();

    if (!winner) {
      return;
    }

    _view__WEBPACK_IMPORTED_MODULE_1__.view.setWin();
    _view__WEBPACK_IMPORTED_MODULE_1__.view.setComment(this.step);
    _view__WEBPACK_IMPORTED_MODULE_1__.view.setWinText(winner);
    this.cellsData.fill("full");
    setTimeout(() => this.resetGame(), 5000);
    console.log(`winner: ${winner}`);
  }

  getWinner() {
    if (this.checkWinningPositions("x")) {
      return "x";
    }

    if (this.checkWinningPositions("o")) {
      return "o";
    }

    return null;
  }

  checkWinningPositions(winningMark) {
    let winningPositions = [
      [0, 1, 2],
      [3, 4, 5],
      [6, 7, 8],
      [0, 3, 6],
      [1, 4, 7],
      [2, 5, 8],
      [0, 4, 8],
      [2, 4, 6],
    ];

    for (let i = 0; i < winningPositions.length; i++) {
      const [pos1, pos2, pos3] = winningPositions[i];

      if (
        this.cellsData[pos1] === winningMark &&
        this.cellsData[pos2] === winningMark &&
        this.cellsData[pos3] === winningMark
      ) {
        return true;
      }
    }

    return false;
  }

  checkDraw() {
    for (let i = 0; i < this.cellsData.length; i++) {
      if (this.cellsData[i] !== "x" && this.cellsData[i] !== "o") {
        return false;
      }
    }
    console.log("DRAW");

    _view__WEBPACK_IMPORTED_MODULE_1__.view.setDraw();
    _view__WEBPACK_IMPORTED_MODULE_1__.view.setComment(this.step);

    setTimeout(() => this.resetGame(), 5000);
  }
}


/***/ }),

/***/ "./src/server.js":
/*!***********************!*\
  !*** ./src/server.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   server: () => (/* binding */ server)
/* harmony export */ });
/* harmony import */ var ably_promises__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ably/promises */ "./node_modules/ably/promises.js");
/* harmony import */ var ably_promises__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ably_promises__WEBPACK_IMPORTED_MODULE_0__);


const API_KEY = "Z9oq-w.SeC0sA:RWchQVoe5OW6HCx_ogk-pRt_g2qoBkzE3huhxdsSI_A";

const messages = {
  move: "move",
  message: "message",
};

class Server {
  async init() {
    this.server = await this.connect();
    await this.createChannel("game");
  }

  async connect() {
    // For the full code sample see here: https://github.com/ably/quickstart-js
    const server = new (ably_promises__WEBPACK_IMPORTED_MODULE_0___default().Realtime).Promise(API_KEY);

    await server.connection.once("connected");
    console.log("Connected to Ably!");

    window.addEventListener("beforeunload", () => ably_promises__WEBPACK_IMPORTED_MODULE_0___default().close());

    return server;
  }

  async createChannel(channelName) {
    this.channel = this.server.channels.get(channelName);

    await this.channel.subscribe(messages.move, (message) =>
      this.onServerMessage(message)
    );
  }

  async makeMove(data) {
    await this.channel.publish(messages.move, JSON.stringify(data));
  }
}

const server = new Server();


/***/ }),

/***/ "./src/untils/random.js":
/*!******************************!*\
  !*** ./src/untils/random.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getRandomInt: () => (/* binding */ getRandomInt)
/* harmony export */ });
function getRandomInt(max) {
    return Math.floor(Math.random() * max);
}

/***/ }),

/***/ "./src/view.js":
/*!*********************!*\
  !*** ./src/view.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   View: () => (/* binding */ View),
/* harmony export */   view: () => (/* binding */ view)
/* harmony export */ });
class View {
  cells = [];

  constructor() {
    this.parent = document.getElementById("parent");

    const ticTacToeDiv = this.createDiv("tictactoeDiv");
    this.parent.appendChild(ticTacToeDiv);
    ticTacToeDiv.classList.add("displayNone");

    this.buttonTopic = this.createButton("buttonTopic");
    ticTacToeDiv.appendChild(this.buttonTopic);

    const playerDiv = this.createDiv("playerDiv");
    ticTacToeDiv.appendChild(playerDiv);

    this.turnPointer = this.createDiv("player");
    playerDiv.appendChild(this.turnPointer);

    this.comments = this.createDiv("playerP");
    playerDiv.appendChild(this.comments);

    const cellDiv = this.createDiv("cellDiv");
    ticTacToeDiv.appendChild(cellDiv);

    this.createCells(cellDiv);



    // this.buttonPlayAgain = this.createButton("button");
    // ticTacToeDiv.appendChild(this.buttonPlayAgain);
  }

  createDiv(className) {
    const div = document.createElement("div");
    div.classList.add(className);

    return div;
  }

  createCells(cellsDiv) {
    for (let cellNum = 0; cellNum < 9; cellNum++) {
      const cell = this.createButton("cell full");

      cell.onclick = () => this.onCellPress(cell);

      cellsDiv.appendChild(cell);

      this.cells.push(cell);
    }
  }

  createButton(className) {
    const button = document.createElement("button");
    button.className = className;

    return button;
  }

  setTurn(turn) {
    if (turn === "x") {
      this.turnPointer.innerHTML = "X Turn";
    } else if (turn === "o") {
      this.turnPointer.innerHTML = "O Turn";
    }
  }

  setComment(turn) {
    if (turn === "x") {
      this.comments.innerHTML = "Next turn X";
    } else if (turn === "o") {
      this.comments.innerHTML = "Next turn O";
    }
  }

  setWinText(winSymbol) {
    if (winSymbol === "x") {
      this.turnPointer.innerHTML = "X Won!";
    } else if (winSymbol === "o") {
      this.turnPointer.innerHTML = "O Won!";
    }
  }

  setStyle(style) {
    if (style === "dark") {
      this.parent.classList.add("dark");
    } else if (style === "light") {
      this.parent.classList.remove("dark");
    }
  }

  updateCell(cell, step) {
    if (step === "x") {
      cell.classList.add("x", "empty", "stepX");
      cell.classList.remove("full");
    } else if (step === "o") {
      cell.classList.add("o", "empty", "stepO");
      cell.classList.remove("cellWait", "full");
    }
  }

  setWin() {
    this.parent.classList.add("win");
  }

  setDraw() {
    this.turnPointer.innerHTML = "Draw!";
    this.parent.classList.add("draw");
  }

  clearCells() {
    for (const cell of this.cells) {
      cell.classList.add("full");
      cell.classList.remove("o", "x", "stepX", "stepO", "empty");
    }

    this.parent.classList.remove("win", "draw");
    this.comments.innerHTML = "";

    console.log("clear");
  }
}

const view = new View();


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./controller */ "./src/controller.js");


new _controller__WEBPACK_IMPORTED_MODULE_0__.Controller().init();

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELG1CQUFtQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFh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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLDRCQUE0QixZQUFZLGlDQUFtQjs7QUFFM0QsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7O0FBRUEsK0NBQStDLGFBQWE7QUFDNUQsY0FBYyxpQ0FBbUI7QUFDakMsdUNBQXVDLGlDQUFtQjtBQUMxRCxpQ0FBaUMsaUNBQW1CO0FBQ3BELDRDQUE0QyxpQ0FBbUI7QUFDL0QsMENBQTBDLGlDQUFtQjtBQUM3RCw0Q0FBNEMsaUNBQW1CO0FBQy9ELG1CQUFtQixpQ0FBbUI7QUFDdEMsNENBQTRDLGlDQUFtQjtBQUMvRCxnREFBZ0QsaUNBQW1CO0FBQ25FLHlDQUF5QyxpQ0FBbUI7QUFDNUQseUNBQXlDLGlDQUFtQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SCxhQUFhO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCLDZGQUE2RjtBQUNuSCxzQkFBc0IsNkZBQTZGO0FBQ25I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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSTtBQUNwSTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrTEFBa0w7QUFDbEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlMQUFpTDtBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNEQUFzRDtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJKQUEySjtBQUMzSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MscUJBQXFCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0xBQXNMO0FBQ3RMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkJBQTZCO0FBQzVEO0FBQ0E7QUFDQSwrQkFBK0IsNkJBQTZCO0FBQzVEO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQSwrQkFBK0IsdUVBQXVFO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1GQUFtRjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLDRCQUE0QixZQUFZLGlDQUFtQjs7QUFFM0QsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7O0FBRUEsK0NBQStDLGFBQWE7QUFDNUQsY0FBYyxpQ0FBbUI7QUFDakMsNkNBQTZDLGlDQUFtQjtBQUNoRSx1Q0FBdUMsaUNBQW1CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEg7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0Esd0VBQXdFLGdDQUFnQztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSwrQ0FBK0MsYUFBYTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7O0FBRUEsK0NBQStDLGFBQWE7QUFDNUQsY0FBYyxpQ0FBbUI7QUFDakMsZ0RBQWdELGlDQUFtQjtBQUNuRSw2Q0FBNkMsaUNBQW1CO0FBQ2hFLGlDQUFpQyxpQ0FBbUI7QUFDcEQsd0NBQXdDLGlDQUFtQjtBQUMzRCx1Q0FBdUMsaUNBQW1CO0FBQzFELGlEQUFpRCxpQ0FBbUI7QUFDcEUsd0NBQXdDLGlDQUFtQjtBQUMzRCxtREFBbUQsaUNBQW1CO0FBQ3RFLHVDQUF1QyxpQ0FBbUI7QUFDMUQsZ0RBQWdELGlDQUFtQjtBQUNuRSxpREFBaUQsaUNBQW1CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw4QkFBOEI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNIQUFzSDtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGdCQUFnQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGdCQUFnQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDRDQUE0QztBQUNyRztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsNkRBQTZELDJEQUEyRDtBQUN4SCxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLHNDQUFzQztBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLGlEQUFpRCwrQ0FBK0M7QUFDaEcsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLG9DQUFvQztBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwwQ0FBMEM7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esa0hBQWtIO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSEFBbUg7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SDtBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QSxVQUFVOztBQUVWO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Es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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrREFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwwREFBVTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087Ozs7Ozs7Ozs7Ozs7Ozs7QUN4Q0E7QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDRk87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7Ozs7OztVQzNIUDtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsaUNBQWlDLFdBQVc7V0FDNUM7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7Ozs7Ozs7OztBQ04wQztBQUMxQztBQUNBLElBQUksbURBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aWN0dGFjLXRvZS8uL25vZGVfbW9kdWxlcy9hYmx5L2J1aWxkL2FibHktY29tbW9uanMuanMiLCJ3ZWJwYWNrOi8vdGljdHRhYy10b2UvLi9ub2RlX21vZHVsZXMvYWJseS9wcm9taXNlcy5qcyIsIndlYnBhY2s6Ly90aWN0dGFjLXRvZS8uL3NyYy9jb250cm9sbGVyLmpzIiwid2VicGFjazovL3RpY3R0YWMtdG9lLy4vc3JjL3NlcnZlci5qcyIsIndlYnBhY2s6Ly90aWN0dGFjLXRvZS8uL3NyYy91bnRpbHMvcmFuZG9tLmpzIiwid2VicGFjazovL3RpY3R0YWMtdG9lLy4vc3JjL3ZpZXcuanMiLCJ3ZWJwYWNrOi8vdGljdHRhYy10b2Uvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vdGljdHRhYy10b2Uvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vdGljdHRhYy10b2Uvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3RpY3R0YWMtdG9lL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vdGljdHRhYy10b2Uvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly90aWN0dGFjLXRvZS8uL3NyYy9tYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMTUtMjAyMiBBYmx5IFJlYWwtdGltZSBMdGQgKGFibHkuY29tKVxuICogXG4gKiBBYmx5IEphdmFTY3JpcHQgTGlicmFyeSB2MS4yLjQzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYWJseS9hYmx5LWpzXG4gKiBcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5jZSB2Mi4wXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkFibHlcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiQWJseVwiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA0Mik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXh0ZW5kc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fZXh0ZW5kczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19hc3NpZ25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2Fzc2lnbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19yZXN0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19yZXN0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2RlY29yYXRlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19kZWNvcmF0ZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19wYXJhbVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fcGFyYW07IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fbWV0YWRhdGFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX21ldGFkYXRhOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2F3YWl0ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2F3YWl0ZXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZ2VuZXJhdG9yXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19nZW5lcmF0b3I7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fY3JlYXRlQmluZGluZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fY3JlYXRlQmluZGluZzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19leHBvcnRTdGFyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19leHBvcnRTdGFyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX3ZhbHVlc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fdmFsdWVzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX3JlYWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX3JlYWQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fc3ByZWFkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19zcHJlYWQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fc3ByZWFkQXJyYXlzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19zcHJlYWRBcnJheXM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fc3ByZWFkQXJyYXlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX3NwcmVhZEFycmF5OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2F3YWl0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19hd2FpdDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19hc3luY0dlbmVyYXRvclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3I7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fYXN5bmNEZWxlZ2F0b3JcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2FzeW5jRGVsZWdhdG9yOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2FzeW5jVmFsdWVzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19hc3luY1ZhbHVlczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19tYWtlVGVtcGxhdGVPYmplY3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX21ha2VUZW1wbGF0ZU9iamVjdDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19pbXBvcnRTdGFyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19pbXBvcnRTdGFyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2ltcG9ydERlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2ltcG9ydERlZmF1bHQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fY2xhc3NQcml2YXRlRmllbGRHZXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZFNldDsgfSk7XG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSk7XHJcblxyXG5mdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFsbFRvVXBwZXJDYXNlID0gZXhwb3J0cy5hbGxUb0xvd2VyQ2FzZSA9IGV4cG9ydHMuZW5jb2RlQm9keSA9IGV4cG9ydHMuZGVjb2RlQm9keSA9IGV4cG9ydHMuRm9ybWF0ID0gZXhwb3J0cy5wcm9taXNpZnkgPSBleHBvcnRzLnRyaW0gPSBleHBvcnRzLmFyckNob29zZU4gPSBleHBvcnRzLnJhbmRvbUhleFN0cmluZyA9IGV4cG9ydHMucmFuZG9tU3RyaW5nID0gZXhwb3J0cy5jaGVhcFJhbmRTdHIgPSBleHBvcnRzLmRhdGFTaXplQnl0ZXMgPSBleHBvcnRzLmluc3BlY3RCb2R5ID0gZXhwb3J0cy5pbnNwZWN0RXJyb3IgPSBleHBvcnRzLmlzRXJyb3JJbmZvT3JQYXJ0aWFsRXJyb3JJbmZvID0gZXhwb3J0cy5ub3cgPSBleHBvcnRzLnBhcnNlUXVlcnlTdHJpbmcgPSBleHBvcnRzLnRvUXVlcnlTdHJpbmcgPSBleHBvcnRzLmFyclBvcFJhbmRvbUVsZW1lbnQgPSBleHBvcnRzLmRlZmF1bHRQb3N0SGVhZGVycyA9IGV4cG9ydHMuZGVmYXVsdEdldEhlYWRlcnMgPSBleHBvcnRzLmFsbFNhbWUgPSBleHBvcnRzLmFyckV2ZXJ5ID0gZXhwb3J0cy5hcnJGaWx0ZXIgPSBleHBvcnRzLmFyck1hcCA9IGV4cG9ydHMuc2FmZUFyckZvckVhY2ggPSBleHBvcnRzLmFyckZvckVhY2ggPSBleHBvcnRzLmZvckluT3duTm9uTnVsbFByb3BlcnRpZXMgPSBleHBvcnRzLnZhbHVlc0FycmF5ID0gZXhwb3J0cy5rZXlzQXJyYXkgPSBleHBvcnRzLmFycldpdGhvdXRWYWx1ZSA9IGV4cG9ydHMuYXJyRGVsZXRlVmFsdWUgPSBleHBvcnRzLmFyckluID0gZXhwb3J0cy5hcnJJbmRleE9mID0gZXhwb3J0cy5hcnJTdWJ0cmFjdCA9IGV4cG9ydHMuYXJySW50ZXJzZWN0T2IgPSBleHBvcnRzLmFyckludGVyc2VjdCA9IGV4cG9ydHMuaW50ZXJzZWN0ID0gZXhwb3J0cy5jb250YWluc1ZhbHVlID0gZXhwb3J0cy5pbmhlcml0cyA9IGV4cG9ydHMucHJvdG90eXBpY2FsQ2xvbmUgPSBleHBvcnRzLnNoYWxsb3dDbG9uZSA9IGV4cG9ydHMuaXNFbXB0eUFyZyA9IGV4cG9ydHMuaXNPbmx5UHJvcEluID0gZXhwb3J0cy5pc0VtcHR5ID0gZXhwb3J0cy5pc09iamVjdCA9IGV4cG9ydHMuZW5zdXJlQXJyYXkgPSBleHBvcnRzLmlzQXJyYXkgPSBleHBvcnRzLmNvcHkgPSBleHBvcnRzLm1peGluID0gdm9pZCAwO1xuZXhwb3J0cy50b0Jhc2U2NCA9IGV4cG9ydHMubWF0Y2hEZXJpdmVkQ2hhbm5lbCA9IGV4cG9ydHMuc2hhbGxvd0VxdWFscyA9IGV4cG9ydHMuZ2V0R2xvYmFsT2JqZWN0ID0gZXhwb3J0cy5nZXRSZXRyeVRpbWUgPSBleHBvcnRzLmdldEppdHRlckNvZWZmaWNpZW50ID0gZXhwb3J0cy5nZXRCYWNrb2ZmQ29lZmZpY2llbnQgPSB2b2lkIDA7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIGRlZmF1bHRzXzEgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIGVuY19iYXNlNjRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xudmFyIGVuY191dGY4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcbmZ1bmN0aW9uIHJhbmRvbVBvc24oYXJyT3JTdHIpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyT3JTdHIubGVuZ3RoKTtcbn1cbi8qXG4gKiBBZGQgYSBzZXQgb2YgcHJvcGVydGllcyB0byBhIHRhcmdldCBvYmplY3RcbiAqIHRhcmdldDogdGhlIHRhcmdldCBvYmplY3RcbiAqIHByb3BzOiAgYW4gb2JqZWN0IHdob3NlIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmVcbiAqICAgICAgICAgYWRkZWQsIGJ5IHJlZmVyZW5jZSBvbmx5XG4gKi9cbmZ1bmN0aW9uIG1peGluKHRhcmdldCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmdzW2ldO1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmV4cG9ydHMubWl4aW4gPSBtaXhpbjtcbi8qXG4gKiBBZGQgYSBzZXQgb2YgcHJvcGVydGllcyB0byBhIHRhcmdldCBvYmplY3RcbiAqIHRhcmdldDogdGhlIHRhcmdldCBvYmplY3RcbiAqIHByb3BzOiAgYW4gb2JqZWN0IHdob3NlIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmVcbiAqICAgICAgICAgYWRkZWQsIGJ5IHJlZmVyZW5jZSBvbmx5XG4gKi9cbmZ1bmN0aW9uIGNvcHkoc3JjKSB7XG4gICAgcmV0dXJuIG1peGluKHt9LCBzcmMpO1xufVxuZXhwb3J0cy5jb3B5ID0gY29weTtcbi8qXG4gKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYSBnaXZlbiBvYmplY3QgaXNcbiAqIGFuIGFycmF5LlxuICovXG5leHBvcnRzLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8XG4gICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcbi8qXG4gKiBFbnN1cmVzIHRoYXQgYW4gQXJyYXkgb2JqZWN0IGlzIGFsd2F5cyByZXR1cm5lZFxuICogcmV0dXJuaW5nIHRoZSBvcmlnaW5hbCBBcnJheSBvZiBvYmogaXMgYW4gQXJyYXlcbiAqIGVsc2Ugd3JhcHBpbmcgdGhlIG9iaiBpbiBhIHNpbmdsZSBlbGVtZW50IEFycmF5XG4gKi9cbmZ1bmN0aW9uIGVuc3VyZUFycmF5KG9iaikge1xuICAgIGlmIChpc0VtcHR5QXJnKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoKDAsIGV4cG9ydHMuaXNBcnJheSkob2JqKSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICByZXR1cm4gW29ial07XG59XG5leHBvcnRzLmVuc3VyZUFycmF5ID0gZW5zdXJlQXJyYXk7XG5mdW5jdGlvbiBpc09iamVjdChvYikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2IpID09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuLypcbiAqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgY29udGFpbnNcbiAqIGFueSBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKiBvYjogdGhlIG9iamVjdFxuICovXG5mdW5jdGlvbiBpc0VtcHR5KG9iKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc0VtcHR5ID0gaXNFbXB0eTtcbmZ1bmN0aW9uIGlzT25seVByb3BJbihvYiwgcHJvcGVydHkpIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc09ubHlQcm9wSW4gPSBpc09ubHlQcm9wSW47XG4vKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGFuIGFyZ3VtZW50IHRvIGFuIG92ZXJsb2FkZWQgZnVuY3Rpb24gaXNcbiAqIHVuZGVmaW5lZCAobWlzc2luZykgb3IgbnVsbC5cbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCB3aGVuIGNvbnN0cnVjdGluZyBmdW5jdGlvbnMgc3VjaCBhcyAoV2ViSURMIHRlcm1pbm9sb2d5KTpcbiAqICAgb2ZmKFtUcmVhdFVuZGVmaW5lZEFzPU51bGxdIERPTVN0cmluZz8gZXZlbnQpXG4gKiBhcyB5b3UgY2FuIHRoZW4gY29uZmlybSB0aGUgYXJndW1lbnQgdXNpbmc6XG4gKiAgIFV0aWxzLmlzRW1wdHlBcmcoZXZlbnQpXG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHlBcmcoYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fCBhcmcgPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuaXNFbXB0eUFyZyA9IGlzRW1wdHlBcmc7XG4vKlxuICogUGVyZm9ybSBhIHNpbXBsZSBzaGFsbG93IGNsb25lIG9mIGFuIG9iamVjdC5cbiAqIFJlc3VsdCBpcyBhbiBvYmplY3QgaXJyZXNwZWN0aXZlIG9mIHdoZXRoZXJcbiAqIHRoZSBpbnB1dCBpcyBhbiBvYmplY3Qgb3IgYXJyYXkuIEFsbFxuICogZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQuXG4gKiBvYjogdGhlIG9iamVjdFxuICovXG5mdW5jdGlvbiBzaGFsbG93Q2xvbmUob2IpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IE9iamVjdCgpO1xuICAgIGZvciAodmFyIHByb3AgaW4gb2IpXG4gICAgICAgIHJlc3VsdFtwcm9wXSA9IG9iW3Byb3BdO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnNoYWxsb3dDbG9uZSA9IHNoYWxsb3dDbG9uZTtcbi8qXG4gKiBDbG9uZSBhbiBvYmplY3QgYnkgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHdpdGggdGhlXG4gKiBnaXZlbiBvYmplY3QgYXMgaXRzIHByb3RvdHlwZS4gT3B0aW9uYWxseVxuICogYSBzZXQgb2YgYWRkaXRpb25hbCBvd24gcHJvcGVydGllcyBjYW4gYmVcbiAqIHN1cHBsaWVkIHRvIGJlIGFkZGVkIHRvIHRoZSBuZXdseSBjcmVhdGVkIGNsb25lLlxuICogb2I6ICAgICAgICAgICAgdGhlIG9iamVjdCB0byBiZSBjbG9uZWRcbiAqIG93blByb3BlcnRpZXM6IG9wdGlvbmFsIG9iamVjdCB3aXRoIGFkZGl0aW9uYWxcbiAqICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgdG8gYWRkXG4gKi9cbmZ1bmN0aW9uIHByb3RvdHlwaWNhbENsb25lKG9iLCBvd25Qcm9wZXJ0aWVzKSB7XG4gICAgdmFyIEYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEYoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEY7XG4gICAgfSgpKTtcbiAgICBGLnByb3RvdHlwZSA9IG9iO1xuICAgIHZhciByZXN1bHQgPSBuZXcgRigpO1xuICAgIGlmIChvd25Qcm9wZXJ0aWVzKVxuICAgICAgICBtaXhpbihyZXN1bHQsIG93blByb3BlcnRpZXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnByb3RvdHlwaWNhbENsb25lID0gcHJvdG90eXBpY2FsQ2xvbmU7XG4vKlxuICogRGVjbGFyZSBhIGNvbnN0cnVjdG9yIHRvIHJlcHJlc2VudCBhIHN1YmNsYXNzXG4gKiBvZiBhbm90aGVyIGNvbnN0cnVjdG9yXG4gKiBJZiBwbGF0Zm9ybSBoYXMgYSBidWlsdC1pbiB2ZXJzaW9uIHdlIHVzZSB0aGF0IGZyb20gUGxhdGZvcm0sIGVsc2Ugd2VcbiAqIGRlZmluZSBoZXJlIChzbyBjYW4gbWFrZSB1c2Ugb2Ygb3RoZXIgVXRpbHMgZm5zKVxuICogU2VlIG5vZGUuanMgdXRpbC5pbmhlcml0c1xuICovXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5oZXJpdHMpIHtcbiAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgIGN0b3IucHJvdG90eXBlID0gcHJvdG90eXBpY2FsQ2xvbmUoc3VwZXJDdG9yLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogY3RvciB9KTtcbn07XG5leHBvcnRzLmluaGVyaXRzID0gaW5oZXJpdHM7XG4vKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBoYXMgYW4gZW51bWVyYWJsZVxuICogcHJvcGVydHkgd2hvc2UgdmFsdWUgZXF1YWxzIGEgZ2l2ZW4gdmFsdWUuXG4gKiBvYjogIHRoZSBvYmplY3RcbiAqIHZhbDogdGhlIHZhbHVlIHRvIGZpbmRcbiAqL1xuZnVuY3Rpb24gY29udGFpbnNWYWx1ZShvYiwgdmFsKSB7XG4gICAgZm9yICh2YXIgaSBpbiBvYikge1xuICAgICAgICBpZiAob2JbaV0gPT0gdmFsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuY29udGFpbnNWYWx1ZSA9IGNvbnRhaW5zVmFsdWU7XG5mdW5jdGlvbiBpbnRlcnNlY3QoYXJyLCBvYikge1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5pc0FycmF5KShvYikgPyBhcnJJbnRlcnNlY3QoYXJyLCBvYikgOiBhcnJJbnRlcnNlY3RPYihhcnIsIG9iKTtcbn1cbmV4cG9ydHMuaW50ZXJzZWN0ID0gaW50ZXJzZWN0O1xuZnVuY3Rpb24gYXJySW50ZXJzZWN0KGFycjEsIGFycjIpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBtZW1iZXIgPSBhcnIxW2ldO1xuICAgICAgICBpZiAoKDAsIGV4cG9ydHMuYXJySW5kZXhPZikoYXJyMiwgbWVtYmVyKSAhPSAtMSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1lbWJlcik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmFyckludGVyc2VjdCA9IGFyckludGVyc2VjdDtcbmZ1bmN0aW9uIGFyckludGVyc2VjdE9iKGFyciwgb2IpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG1lbWJlciA9IGFycltpXTtcbiAgICAgICAgaWYgKG1lbWJlciBpbiBvYilcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1lbWJlcik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmFyckludGVyc2VjdE9iID0gYXJySW50ZXJzZWN0T2I7XG5mdW5jdGlvbiBhcnJTdWJ0cmFjdChhcnIxLCBhcnIyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IGFycjFbaV07XG4gICAgICAgIGlmICgoMCwgZXhwb3J0cy5hcnJJbmRleE9mKShhcnIyLCBlbGVtZW50KSA9PSAtMSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5hcnJTdWJ0cmFjdCA9IGFyclN1YnRyYWN0O1xuZXhwb3J0cy5hcnJJbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2ZcbiAgICA/IGZ1bmN0aW9uIChhcnIsIGVsZW0sIGZyb21JbmRleCkge1xuICAgICAgICByZXR1cm4gYXJyLmluZGV4T2YoZWxlbSwgZnJvbUluZGV4KTtcbiAgICB9XG4gICAgOiBmdW5jdGlvbiAoYXJyLCBlbGVtLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgZnJvbUluZGV4ID0gZnJvbUluZGV4IHx8IDA7XG4gICAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgZnJvbUluZGV4IDwgbGVuOyBmcm9tSW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKGFycltmcm9tSW5kZXhdID09PSBlbGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21JbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbmZ1bmN0aW9uIGFyckluKGFyciwgdmFsKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmFyckluZGV4T2YpKGFyciwgdmFsKSAhPT0gLTE7XG59XG5leHBvcnRzLmFyckluID0gYXJySW47XG5mdW5jdGlvbiBhcnJEZWxldGVWYWx1ZShhcnIsIHZhbCkge1xuICAgIHZhciBpZHggPSAoMCwgZXhwb3J0cy5hcnJJbmRleE9mKShhcnIsIHZhbCk7XG4gICAgdmFyIHJlcyA9IGlkeCAhPSAtMTtcbiAgICBpZiAocmVzKVxuICAgICAgICBhcnIuc3BsaWNlKGlkeCwgMSk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuYXJyRGVsZXRlVmFsdWUgPSBhcnJEZWxldGVWYWx1ZTtcbmZ1bmN0aW9uIGFycldpdGhvdXRWYWx1ZShhcnIsIHZhbCkge1xuICAgIHZhciBuZXdBcnIgPSBhcnIuc2xpY2UoKTtcbiAgICBhcnJEZWxldGVWYWx1ZShuZXdBcnIsIHZhbCk7XG4gICAgcmV0dXJuIG5ld0Fycjtcbn1cbmV4cG9ydHMuYXJyV2l0aG91dFZhbHVlID0gYXJyV2l0aG91dFZhbHVlO1xuLypcbiAqIENvbnN0cnVjdCBhbiBhcnJheSBvZiB0aGUga2V5cyBvZiB0aGUgZW51bWVyYWJsZVxuICogcHJvcGVydGllcyBvZiBhIGdpdmVuIG9iamVjdCwgb3B0aW9uYWxseSBsaW1pdGVkXG4gKiB0byBvbmx5IHRoZSBvd24gcHJvcGVydGllcy5cbiAqIG9iOiAgICAgIHRoZSBvYmplY3RcbiAqIG93bk9ubHk6IGJvb2xlYW4sIGdldCBvd24gcHJvcGVydGllcyBvbmx5XG4gKi9cbmZ1bmN0aW9uIGtleXNBcnJheShvYiwgb3duT25seSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iKSB7XG4gICAgICAgIGlmIChvd25Pbmx5ICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2IsIHByb3ApKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHJlc3VsdC5wdXNoKHByb3ApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5rZXlzQXJyYXkgPSBrZXlzQXJyYXk7XG4vKlxuICogQ29uc3RydWN0IGFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgb2YgdGhlIGVudW1lcmFibGVcbiAqIHByb3BlcnRpZXMgb2YgYSBnaXZlbiBvYmplY3QsIG9wdGlvbmFsbHkgbGltaXRlZFxuICogdG8gb25seSB0aGUgb3duIHByb3BlcnRpZXMuXG4gKiBvYjogICAgICB0aGUgb2JqZWN0XG4gKiBvd25Pbmx5OiBib29sZWFuLCBnZXQgb3duIHByb3BlcnRpZXMgb25seVxuICovXG5mdW5jdGlvbiB2YWx1ZXNBcnJheShvYiwgb3duT25seSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iKSB7XG4gICAgICAgIGlmIChvd25Pbmx5ICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2IsIHByb3ApKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHJlc3VsdC5wdXNoKG9iW3Byb3BdKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMudmFsdWVzQXJyYXkgPSB2YWx1ZXNBcnJheTtcbmZ1bmN0aW9uIGZvckluT3duTm9uTnVsbFByb3BlcnRpZXMob2IsIGZuKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iLCBwcm9wKSAmJiBvYltwcm9wXSkge1xuICAgICAgICAgICAgZm4ocHJvcCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmZvckluT3duTm9uTnVsbFByb3BlcnRpZXMgPSBmb3JJbk93bk5vbk51bGxQcm9wZXJ0aWVzO1xuZXhwb3J0cy5hcnJGb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2hcbiAgICA/IGZ1bmN0aW9uIChhcnIsIGZuKSB7XG4gICAgICAgIGFyci5mb3JFYWNoKGZuKTtcbiAgICB9XG4gICAgOiBmdW5jdGlvbiAoYXJyLCBmbikge1xuICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZm4oYXJyW2ldLCBpLCBhcnIpO1xuICAgICAgICB9XG4gICAgfTtcbi8qIFVzZWZ1bCB3aGVuIHRoZSBmdW5jdGlvbiBtYXkgbXV0YXRlIHRoZSBhcnJheSAqL1xuZnVuY3Rpb24gc2FmZUFyckZvckVhY2goYXJyLCBmbikge1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5hcnJGb3JFYWNoKShhcnIuc2xpY2UoKSwgZm4pO1xufVxuZXhwb3J0cy5zYWZlQXJyRm9yRWFjaCA9IHNhZmVBcnJGb3JFYWNoO1xuZXhwb3J0cy5hcnJNYXAgPSBBcnJheS5wcm90b3R5cGUubWFwXG4gICAgPyBmdW5jdGlvbiAoYXJyLCBmbikge1xuICAgICAgICByZXR1cm4gYXJyLm1hcChmbik7XG4gICAgfVxuICAgIDogZnVuY3Rpb24gKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZm4oYXJyW2ldLCBpLCBhcnIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5leHBvcnRzLmFyckZpbHRlciA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXJcbiAgICA/IGZ1bmN0aW9uIChhcnIsIGZuKSB7XG4gICAgICAgIHJldHVybiBhcnIuZmlsdGVyKGZuKTtcbiAgICB9XG4gICAgOiBmdW5jdGlvbiAoYXJyLCBmbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW10sIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmbihhcnJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5leHBvcnRzLmFyckV2ZXJ5ID0gQXJyYXkucHJvdG90eXBlLmV2ZXJ5XG4gICAgPyBmdW5jdGlvbiAoYXJyLCBmbikge1xuICAgICAgICByZXR1cm4gYXJyLmV2ZXJ5KGZuKTtcbiAgICB9XG4gICAgOiBmdW5jdGlvbiAoYXJyLCBmbikge1xuICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKCFmbihhcnJbaV0sIGksIGFycikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbmZ1bmN0aW9uIGFsbFNhbWUoYXJyLCBwcm9wKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBmaXJzdCA9IGFyclswXVtwcm9wXTtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuYXJyRXZlcnkpKGFyciwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1bcHJvcF0gPT09IGZpcnN0O1xuICAgIH0pO1xufVxuZXhwb3J0cy5hbGxTYW1lID0gYWxsU2FtZTtcbnZhciBjb250ZW50VHlwZXMgPSB7XG4gICAganNvbjogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgIGpzb25wOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsXG4gICAgeG1sOiAnYXBwbGljYXRpb24veG1sJyxcbiAgICBodG1sOiAndGV4dC9odG1sJyxcbiAgICBtc2dwYWNrOiAnYXBwbGljYXRpb24veC1tc2dwYWNrJyxcbn07XG5mdW5jdGlvbiBkZWZhdWx0R2V0SGVhZGVycyhvcHRpb25zLCBmb3JtYXQpIHtcbiAgICB2YXIgYWNjZXB0ID0gY29udGVudFR5cGVzW2Zvcm1hdCB8fCBGb3JtYXQuanNvbl07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWNjZXB0OiBhY2NlcHQsXG4gICAgICAgICdYLUFibHktVmVyc2lvbic6IGRlZmF1bHRzXzEuZGVmYXVsdC5wcm90b2NvbFZlcnNpb24udG9TdHJpbmcoKSxcbiAgICAgICAgJ0FibHktQWdlbnQnOiAoMCwgZGVmYXVsdHNfMS5nZXRBZ2VudFN0cmluZykob3B0aW9ucyksXG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdEdldEhlYWRlcnMgPSBkZWZhdWx0R2V0SGVhZGVycztcbmZ1bmN0aW9uIGRlZmF1bHRQb3N0SGVhZGVycyhvcHRpb25zLCBmb3JtYXQpIHtcbiAgICB2YXIgY29udGVudFR5cGU7XG4gICAgdmFyIGFjY2VwdCA9IChjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlc1tmb3JtYXQgfHwgRm9ybWF0Lmpzb25dKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhY2NlcHQ6IGFjY2VwdCxcbiAgICAgICAgJ2NvbnRlbnQtdHlwZSc6IGNvbnRlbnRUeXBlLFxuICAgICAgICAnWC1BYmx5LVZlcnNpb24nOiBkZWZhdWx0c18xLmRlZmF1bHQucHJvdG9jb2xWZXJzaW9uLnRvU3RyaW5nKCksXG4gICAgICAgICdBYmx5LUFnZW50JzogKDAsIGRlZmF1bHRzXzEuZ2V0QWdlbnRTdHJpbmcpKG9wdGlvbnMpLFxuICAgIH07XG59XG5leHBvcnRzLmRlZmF1bHRQb3N0SGVhZGVycyA9IGRlZmF1bHRQb3N0SGVhZGVycztcbmZ1bmN0aW9uIGFyclBvcFJhbmRvbUVsZW1lbnQoYXJyKSB7XG4gICAgcmV0dXJuIGFyci5zcGxpY2UocmFuZG9tUG9zbihhcnIpLCAxKVswXTtcbn1cbmV4cG9ydHMuYXJyUG9wUmFuZG9tRWxlbWVudCA9IGFyclBvcFJhbmRvbUVsZW1lbnQ7XG5mdW5jdGlvbiB0b1F1ZXJ5U3RyaW5nKHBhcmFtcykge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHBhcmFtcylcbiAgICAgICAgICAgIHBhcnRzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1zW2tleV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA/ICc/JyArIHBhcnRzLmpvaW4oJyYnKSA6ICcnO1xufVxuZXhwb3J0cy50b1F1ZXJ5U3RyaW5nID0gdG9RdWVyeVN0cmluZztcbmZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmcocXVlcnkpIHtcbiAgICB2YXIgbWF0Y2g7XG4gICAgdmFyIHNlYXJjaCA9IC8oW14/Jj1dKyk9PyhbXiZdKikvZztcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgd2hpbGUgKChtYXRjaCA9IHNlYXJjaC5leGVjKHF1ZXJ5KSkpXG4gICAgICAgIHJlc3VsdFtkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMV0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFsyXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucGFyc2VRdWVyeVN0cmluZyA9IHBhcnNlUXVlcnlTdHJpbmc7XG5leHBvcnRzLm5vdyA9IERhdGUubm93IHx8XG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiBJRSA4ICovXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9O1xuZnVuY3Rpb24gaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm8oZXJyKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgZXJyID09ICdvYmplY3QnICYmXG4gICAgICAgIGVyciAhPT0gbnVsbCAmJlxuICAgICAgICAoZXJyLmNvbnN0cnVjdG9yLm5hbWUgPT0gJ0Vycm9ySW5mbycgfHwgZXJyLmNvbnN0cnVjdG9yLm5hbWUgPT0gJ1BhcnRpYWxFcnJvckluZm8nKSk7XG59XG5leHBvcnRzLmlzRXJyb3JJbmZvT3JQYXJ0aWFsRXJyb3JJbmZvID0gaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm87XG5mdW5jdGlvbiBpbnNwZWN0RXJyb3IoZXJyKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgfHxcbiAgICAgICAgKChfYSA9IGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09PSAnRXJyb3JJbmZvJyB8fFxuICAgICAgICAoKF9iID0gZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubmFtZSkgPT09ICdQYXJ0aWFsRXJyb3JJbmZvJylcbiAgICAgICAgcmV0dXJuIGVyci50b1N0cmluZygpO1xuICAgIHJldHVybiBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QoZXJyKTtcbn1cbmV4cG9ydHMuaW5zcGVjdEVycm9yID0gaW5zcGVjdEVycm9yO1xuZnVuY3Rpb24gaW5zcGVjdEJvZHkoYm9keSkge1xuICAgIGlmIChwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgICAgcmV0dXJuIGJvZHkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBib2R5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChib2R5KTtcbiAgICB9XG59XG5leHBvcnRzLmluc3BlY3RCb2R5ID0gaW5zcGVjdEJvZHk7XG4vKiBEYXRhIGlzIGFzc3VtZWQgdG8gYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgYnVmZmVyLiAqL1xuZnVuY3Rpb24gZGF0YVNpemVCeXRlcyhkYXRhKSB7XG4gICAgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICByZXR1cm4gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuc3RyaW5nQnl0ZVNpemUoZGF0YSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5wdXQgb2YgVXRpbHMuZGF0YVNpemVCeXRlcyB0byBiZSBhIGJ1ZmZlciBvciBzdHJpbmcsIGJ1dCB3YXM6ICcgKyB0eXBlb2YgZGF0YSk7XG59XG5leHBvcnRzLmRhdGFTaXplQnl0ZXMgPSBkYXRhU2l6ZUJ5dGVzO1xuZnVuY3Rpb24gY2hlYXBSYW5kU3RyKCkge1xuICAgIHJldHVybiBTdHJpbmcoTWF0aC5yYW5kb20oKSkuc3Vic3RyKDIpO1xufVxuZXhwb3J0cy5jaGVhcFJhbmRTdHIgPSBjaGVhcFJhbmRTdHI7XG4vKiBUYWtlcyBwYXJhbSB0aGUgbWluaW11bSBudW1iZXIgb2YgYnl0ZXMgb2YgZW50cm9weSB0aGUgc3RyaW5nIG11c3RcbiAqIGluY2x1ZGUsIG5vdCB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcuIFN0cmluZyBsZW5ndGggcHJvZHVjZWQgaXMgbm90XG4gKiBndWFyYW50ZWVkLiAqL1xudmFyIHJhbmRvbVN0cmluZyA9IGZ1bmN0aW9uIChudW1CeXRlcykge1xuICAgIGlmIChwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmdldFJhbmRvbVZhbHVlcyAmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIHVJbnRBcnIgPSBuZXcgVWludDhBcnJheShudW1CeXRlcyk7XG4gICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuZ2V0UmFuZG9tVmFsdWVzKHVJbnRBcnIpO1xuICAgICAgICByZXR1cm4gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZSh1SW50QXJyKTtcbiAgICB9XG4gICAgLyogT2xkIGJyb3dzZXI7IGZhbGwgYmFjayB0byBNYXRoLnJhbmRvbS4gQ291bGQganVzdCB1c2UgYVxuICAgICAqIENyeXB0b0pTIHZlcnNpb24gb2YgdGhlIGFib3ZlLCBidXQgd2FudCB0aGlzIHRvIHN0aWxsIHdvcmsgaW4gbm9jcnlwdG9cbiAgICAgKiB2ZXJzaW9ucyBvZiB0aGUgbGlicmFyeSAqL1xuICAgIHZhciBjaGFyc2V0ID0gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmJhc2U2NENoYXJTZXQ7XG4gICAgLyogYmFzZTY0IGhhcyAzMyUgb3ZlcmhlYWQ7IHJvdW5kIGxlbmd0aCB1cCAqL1xuICAgIHZhciBsZW5ndGggPSBNYXRoLnJvdW5kKChudW1CeXRlcyAqIDQpIC8gMyk7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IGNoYXJzZXRbcmFuZG9tUG9zbihjaGFyc2V0KV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5yYW5kb21TdHJpbmcgPSByYW5kb21TdHJpbmc7XG52YXIgcmFuZG9tSGV4U3RyaW5nID0gZnVuY3Rpb24gKG51bUJ5dGVzKSB7XG4gICAgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuZ2V0UmFuZG9tVmFsdWVzICYmIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgdUludEFyciA9IG5ldyBVaW50OEFycmF5KG51bUJ5dGVzKTtcbiAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5nZXRSYW5kb21WYWx1ZXModUludEFycik7XG4gICAgICAgIHJldHVybiBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuaGV4RW5jb2RlKHVJbnRBcnIpO1xuICAgIH1cbiAgICB2YXIgY2hhcnNldCA9IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5oZXhDaGFyU2V0O1xuICAgIHZhciBsZW5ndGggPSBudW1CeXRlcyAqIDI7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IGNoYXJzZXRbcmFuZG9tUG9zbihjaGFyc2V0KV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5yYW5kb21IZXhTdHJpbmcgPSByYW5kb21IZXhTdHJpbmc7XG4vKiBQaWNrIG4gZWxlbWVudHMgYXQgcmFuZG9tIHdpdGhvdXQgcmVwbGFjZW1lbnQgZnJvbSBhbiBhcnJheSAqL1xuZnVuY3Rpb24gYXJyQ2hvb3NlTihhcnIsIG4pIHtcbiAgICB2YXIgbnVtSXRlbXMgPSBNYXRoLm1pbihuLCBhcnIubGVuZ3RoKSwgbXV0YWJsZUFyciA9IGFyci5zbGljZSgpLCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUl0ZW1zOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYXJyUG9wUmFuZG9tRWxlbWVudChtdXRhYmxlQXJyKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmFyckNob29zZU4gPSBhcnJDaG9vc2VOO1xuZXhwb3J0cy50cmltID0gU3RyaW5nLnByb3RvdHlwZS50cmltXG4gICAgPyBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIudHJpbSgpO1xuICAgIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuICAgIH07XG5mdW5jdGlvbiBwcm9taXNpZnkob2IsIGZuTmFtZSwgYXJncykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIG9iW2ZuTmFtZV0uYXBwbHkob2IsIHRzbGliXzEuX19zcHJlYWRBcnJheSh0c2xpYl8xLl9fc3ByZWFkQXJyYXkoW10sIGFyZ3MsIGZhbHNlKSwgW2Z1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgICAgIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgfV0sIGZhbHNlKSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnByb21pc2lmeSA9IHByb21pc2lmeTtcbnZhciBGb3JtYXQ7XG4oZnVuY3Rpb24gKEZvcm1hdCkge1xuICAgIEZvcm1hdFtcIm1zZ3BhY2tcIl0gPSBcIm1zZ3BhY2tcIjtcbiAgICBGb3JtYXRbXCJqc29uXCJdID0gXCJqc29uXCI7XG59KShGb3JtYXQgPSBleHBvcnRzLkZvcm1hdCB8fCAoZXhwb3J0cy5Gb3JtYXQgPSB7fSkpO1xuZnVuY3Rpb24gZGVjb2RlQm9keShib2R5LCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0ID09ICdtc2dwYWNrJyA/IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubXNncGFjay5kZWNvZGUoYm9keSkgOiBKU09OLnBhcnNlKFN0cmluZyhib2R5KSk7XG59XG5leHBvcnRzLmRlY29kZUJvZHkgPSBkZWNvZGVCb2R5O1xuZnVuY3Rpb24gZW5jb2RlQm9keShib2R5LCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0ID09ICdtc2dwYWNrJyA/IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubXNncGFjay5lbmNvZGUoYm9keSwgdHJ1ZSkgOiBKU09OLnN0cmluZ2lmeShib2R5KTtcbn1cbmV4cG9ydHMuZW5jb2RlQm9keSA9IGVuY29kZUJvZHk7XG5mdW5jdGlvbiBhbGxUb0xvd2VyQ2FzZShhcnIpIHtcbiAgICByZXR1cm4gYXJyLm1hcChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmFsbFRvTG93ZXJDYXNlID0gYWxsVG9Mb3dlckNhc2U7XG5mdW5jdGlvbiBhbGxUb1VwcGVyQ2FzZShhcnIpIHtcbiAgICByZXR1cm4gYXJyLm1hcChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50LnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmFsbFRvVXBwZXJDYXNlID0gYWxsVG9VcHBlckNhc2U7XG5mdW5jdGlvbiBnZXRCYWNrb2ZmQ29lZmZpY2llbnQoY291bnQpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oKGNvdW50ICsgMikgLyAzLCAyKTtcbn1cbmV4cG9ydHMuZ2V0QmFja29mZkNvZWZmaWNpZW50ID0gZ2V0QmFja29mZkNvZWZmaWNpZW50O1xuZnVuY3Rpb24gZ2V0Sml0dGVyQ29lZmZpY2llbnQoKSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnJhbmRvbSgpICogMC4yO1xufVxuZXhwb3J0cy5nZXRKaXR0ZXJDb2VmZmljaWVudCA9IGdldEppdHRlckNvZWZmaWNpZW50O1xuLyoqXG4gKlxuICogQHBhcmFtIGluaXRpYWxUaW1lb3V0IGluaXRpYWwgdGltZW91dCB2YWx1ZVxuICogQHBhcmFtIHJldHJ5QXR0ZW1wdCBpbnRlZ2VyIGluZGljYXRpbmcgcmV0cnlBdHRlbXB0XG4gKiBAcmV0dXJucyBSZXRyeVRpbWVvdXQgdmFsdWUgZm9yIGdpdmVuIHRpbWVvdXQgYW5kIHJldHJ5QXR0ZW1wdC5cbiAqIElmIHggaXMgdGhlIHZhbHVlIGdlbmVyYXRlZCB0aGVuLFxuICogVXBwZXIgYm91bmQgPSBtaW4oKHJldHJ5QXR0ZW1wdCArIDIpIC8gMywgMikgKiBpbml0aWFsVGltZW91dCxcbiAqIExvd2VyIGJvdW5kID0gMC44ICogVXBwZXIgYm91bmQsXG4gKiBMb3dlciBib3VuZCA8IHggPCBVcHBlciBib3VuZFxuICovXG5mdW5jdGlvbiBnZXRSZXRyeVRpbWUoaW5pdGlhbFRpbWVvdXQsIHJldHJ5QXR0ZW1wdCkge1xuICAgIHJldHVybiBpbml0aWFsVGltZW91dCAqIGdldEJhY2tvZmZDb2VmZmljaWVudChyZXRyeUF0dGVtcHQpICogZ2V0Sml0dGVyQ29lZmZpY2llbnQoKTtcbn1cbmV4cG9ydHMuZ2V0UmV0cnlUaW1lID0gZ2V0UmV0cnlUaW1lO1xuZnVuY3Rpb24gZ2V0R2xvYmFsT2JqZWN0KCkge1xuICAgIGlmIChnbG9iYWwpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZXhwb3J0cy5nZXRHbG9iYWxPYmplY3QgPSBnZXRHbG9iYWxPYmplY3Q7XG5mdW5jdGlvbiBzaGFsbG93RXF1YWxzKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIChPYmplY3Qua2V5cyhzb3VyY2UpLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHNvdXJjZVtrZXldID09PSB0YXJnZXRba2V5XTsgfSkgJiZcbiAgICAgICAgT2JqZWN0LmtleXModGFyZ2V0KS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiB0YXJnZXRba2V5XSA9PT0gc291cmNlW2tleV07IH0pKTtcbn1cbmV4cG9ydHMuc2hhbGxvd0VxdWFscyA9IHNoYWxsb3dFcXVhbHM7XG5mdW5jdGlvbiBtYXRjaERlcml2ZWRDaGFubmVsKG5hbWUpIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIHJlZ2V4IGNoZWNrIGlzIHRvIHJldGFpbiBleGlzdGluZyBjaGFubmVsIHBhcmFtcyBpZiBhbnkgZS5nIFs/cmV3aW5kPTFdZm9vIHRvXG4gICAgICogW2ZpbHRlcj14eXo/cmV3aW5kPTFdZm9vLiBUaGlzIGlzIHRvIGtlZXAgY2hhbm5lbCBjb21wYXRpYmlsaXR5IGFyb3VuZCB1c2Ugb2ZcbiAgICAgKiBjaGFubmVsIHBhcmFtcyB0aGF0IHdvcmsgd2l0aCBkZXJpdmVkIGNoYW5uZWxzLlxuICAgICAqXG4gICAgICogVGhpcyBlc2xpbnQgdW5zYWZlIHJlZ2V4IHdhcm5pbmcgaXMgdHJpZ2dlcmVkIGJlY2F1c2UgdGhlIFJlZ0V4cCB1c2VzIG5lc3RlZCBxdWFudGlmaWVycyxcbiAgICAgKiBidXQgaXQgZG9lcyBub3QgY3JlYXRlIGFueSBzaXR1YXRpb24gd2hlcmUgdGhlIHJlZ2V4IGVuZ2luZSBoYXMgdG9cbiAgICAgKiBleHBsb3JlIGEgbGFyZ2UgbnVtYmVyIG9mIHBvc3NpYmxlIG1hdGNoZXMgc28gaXTigJlzIHNhZmUgdG8gaWdub3JlXG4gICAgICovXG4gICAgdmFyIHJlZ2V4ID0gL14oXFxbKFteP10qKSg/OiguKikpXFxdKT8oLispJC87IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKHJlZ2V4KTtcbiAgICBpZiAoIW1hdGNoIHx8ICFtYXRjaC5sZW5ndGggfHwgbWF0Y2gubGVuZ3RoIDwgNSkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgncmVnZXggbWF0Y2ggZmFpbGVkJywgNDAwLCA0MDAxMCk7XG4gICAgfVxuICAgIC8vIEZhaWwgaWYgdGhlcmUgaXMgYWxyZWFkeSBhIGNoYW5uZWwgcXVhbGlmaWVyLCBlZyBbbWV0YV1mb28gc2hvdWxkIGZhaWwgaW5zdGVhZCBvZiBqdXN0IG92ZXJyaWRpbmcgd2l0aCBbZmlsdGVyPXh5el1mb29cbiAgICBpZiAobWF0Y2hbMl0pIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoXCJjYW5ub3QgdXNlIGEgZGVyaXZlZCBvcHRpb24gd2l0aCBhIFwiLmNvbmNhdChtYXRjaFsyXSwgXCIgY2hhbm5lbFwiKSwgNDAwLCA0MDAxMCk7XG4gICAgfVxuICAgIC8vIFJldHVybiBtYXRjaCB2YWx1ZXMgdG8gYmUgYWRkZWQgdG8gZGVyaXZlIGNoYW5uZWwgcXVhbnRpZmllci5cbiAgICByZXR1cm4ge1xuICAgICAgICBxdWFsaWZpZXJQYXJhbTogbWF0Y2hbM10gfHwgJycsXG4gICAgICAgIGNoYW5uZWxOYW1lOiBtYXRjaFs0XSxcbiAgICB9O1xufVxuZXhwb3J0cy5tYXRjaERlcml2ZWRDaGFubmVsID0gbWF0Y2hEZXJpdmVkQ2hhbm5lbDtcbmZ1bmN0aW9uIHRvQmFzZTY0KHN0cikge1xuICAgIGlmIChwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmNyZWF0ZUhtYWMpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwgJ2FzY2lpJykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGVuY19iYXNlNjRfMS5zdHJpbmdpZnkpKCgwLCBlbmNfdXRmOF8xLnBhcnNlKShzdHIpKTtcbn1cbmV4cG9ydHMudG9CYXNlNjQgPSB0b0Jhc2U2NDtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTMpKSlcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbi8vIFdvcmthcm91bmQgZm9yIHNhbGVzZm9yY2UgbGlnaHRuaW5nIGxvY2tlciBjb21wYXRpYmlsaXR5XG4vLyBUaGlzIGlzIGEgc2hvcnRoYW5kIHZlcnNpb24gb2YgVXRpbHMuZ2V0R2xvYmFsT2JqZWN0ICh3aGljaCB3ZSBjYW4ndCB1c2UgaGVyZSB3aXRob3V0IGNyZWF0aW5nIGEgY2lyY3VsYXIgaW1wb3J0KVxudmFyIGdsb2JhbE9iamVjdCA9IGdsb2JhbCB8fCAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBzZWxmKTtcbnZhciBMb2dMZXZlbHM7XG4oZnVuY3Rpb24gKExvZ0xldmVscykge1xuICAgIExvZ0xldmVsc1tMb2dMZXZlbHNbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICBMb2dMZXZlbHNbTG9nTGV2ZWxzW1wiRXJyb3JcIl0gPSAxXSA9IFwiRXJyb3JcIjtcbiAgICBMb2dMZXZlbHNbTG9nTGV2ZWxzW1wiTWFqb3JcIl0gPSAyXSA9IFwiTWFqb3JcIjtcbiAgICBMb2dMZXZlbHNbTG9nTGV2ZWxzW1wiTWlub3JcIl0gPSAzXSA9IFwiTWlub3JcIjtcbiAgICBMb2dMZXZlbHNbTG9nTGV2ZWxzW1wiTWljcm9cIl0gPSA0XSA9IFwiTWljcm9cIjtcbn0pKExvZ0xldmVscyB8fCAoTG9nTGV2ZWxzID0ge30pKTtcbmZ1bmN0aW9uIHBhZCh0aW1lU2VnbWVudCwgdGhyZWUpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQodGltZVNlZ21lbnQpLnBhZFN0YXJ0KHRocmVlID8gMyA6IDIsICcwJyk7XG59XG5mdW5jdGlvbiBnZXRIYW5kbGVyKGxvZ2dlcikge1xuICAgIHJldHVybiBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmxvZ1RpbWVzdGFtcHNcbiAgICAgICAgPyBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICB2YXIgdGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBsb2dnZXIocGFkKHRpbWUuZ2V0SG91cnMoKSkgK1xuICAgICAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICAgICAgcGFkKHRpbWUuZ2V0TWludXRlcygpKSArXG4gICAgICAgICAgICAgICAgJzonICtcbiAgICAgICAgICAgICAgICBwYWQodGltZS5nZXRTZWNvbmRzKCkpICtcbiAgICAgICAgICAgICAgICAnLicgK1xuICAgICAgICAgICAgICAgIHBhZCh0aW1lLmdldE1pbGxpc2Vjb25kcygpLCAxKSArXG4gICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgICBtc2cpO1xuICAgICAgICB9XG4gICAgICAgIDogbG9nZ2VyO1xufVxudmFyIGdldERlZmF1bHRMb2dnZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdmFyIGNvbnNvbGVMb2dnZXI7XG4gICAgdmFyIGVycm9yTG9nZ2VyO1xuICAgIC8qIENhbid0IGp1c3QgY2hlY2sgZm9yIGNvbnNvbGUgJiYgY29uc29sZS5sb2c7IGZhaWxzIGluIElFIDw9OSAqL1xuICAgIGlmICgodHlwZW9mIFdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlID09PSAndW5kZWZpbmVkJykgLyogbm9kZSAqLyB8fFxuICAgICAgICB0eXBlb2YgKChfYiA9IChfYSA9IGdsb2JhbE9iamVjdCA9PT0gbnVsbCB8fCBnbG9iYWxPYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdsb2JhbE9iamVjdC5jb25zb2xlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9nKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYXBwbHkpID09PSAnZnVuY3Rpb24nIC8qIHNlbnNpYmxlIGJyb3dzZXJzICovKSB7XG4gICAgICAgIGNvbnNvbGVMb2dnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgZXJyb3JMb2dnZXIgPSBjb25zb2xlLndhcm5cbiAgICAgICAgICAgID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGNvbnNvbGVMb2dnZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGdsb2JhbE9iamVjdCA9PT0gbnVsbCB8fCBnbG9iYWxPYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdsb2JhbE9iamVjdC5jb25zb2xlLmxvZykge1xuICAgICAgICAvKiBJRSA8PSA5IHdpdGggdGhlIGNvbnNvbGUgb3BlbiAtLSBjb25zb2xlLmxvZyBkb2VzIG5vdFxuICAgICAgICAgKiBpbmhlcml0IGZyb20gRnVuY3Rpb24sIHNvIGhhcyBubyBhcHBseSBtZXRob2QgKi9cbiAgICAgICAgY29uc29sZUxvZ2dlciA9IGVycm9yTG9nZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKiBJRSA8PSA5IHdoZW4gZGV2IHRvb2xzIGFyZSBjbG9zZWQgLSB3aW5kb3cuY29uc29sZSBub3QgZXZlbiBkZWZpbmVkICovXG4gICAgICAgIGNvbnNvbGVMb2dnZXIgPSBlcnJvckxvZ2dlciA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICB9XG4gICAgcmV0dXJuIFtjb25zb2xlTG9nZ2VyLCBlcnJvckxvZ2dlcl0ubWFwKGdldEhhbmRsZXIpO1xufTtcbnZhciBMb2dnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG9nZ2VyKCkge1xuICAgICAgICBMb2dnZXIubG9nTGV2ZWwgPSBMb2dnZXIuTE9HX0RFRkFVTFQ7XG4gICAgfVxuICAgIExvZ2dlci5pbml0TG9nSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IGdldERlZmF1bHRMb2dnZXJzKCksIGxvZ0hhbmRsZXIgPSBfYVswXSwgbG9nRXJyb3JIYW5kbGVyID0gX2FbMV07XG4gICAgICAgIHRoaXMubG9nSGFuZGxlciA9IGxvZ0hhbmRsZXI7XG4gICAgICAgIHRoaXMubG9nRXJyb3JIYW5kbGVyID0gbG9nRXJyb3JIYW5kbGVyO1xuICAgIH07XG4gICAgTG9nZ2VyLmxvZ0xldmVsID0gTG9nTGV2ZWxzLkVycm9yOyAvLyBkZWZhdWx0IGxvZ0xldmVsXG4gICAgLy8gcHVibGljIGNvbnN0YW50c1xuICAgIExvZ2dlci5MT0dfTk9ORSA9IExvZ0xldmVscy5Ob25lO1xuICAgIExvZ2dlci5MT0dfRVJST1IgPSBMb2dMZXZlbHMuRXJyb3I7XG4gICAgTG9nZ2VyLkxPR19NQUpPUiA9IExvZ0xldmVscy5NYWpvcjtcbiAgICBMb2dnZXIuTE9HX01JTk9SID0gTG9nTGV2ZWxzLk1pbm9yO1xuICAgIExvZ2dlci5MT0dfTUlDUk8gPSBMb2dMZXZlbHMuTWljcm87XG4gICAgLy8gYWxpYXNlc1xuICAgIExvZ2dlci5MT0dfREVGQVVMVCA9IExvZ0xldmVscy5FcnJvcjtcbiAgICBMb2dnZXIuTE9HX0RFQlVHID0gTG9nTGV2ZWxzLk1pY3JvO1xuICAgIC8qIHB1YmxpYyBzdGF0aWMgZnVuY3Rpb25zICovXG4gICAgTG9nZ2VyLmxvZ0FjdGlvbiA9IGZ1bmN0aW9uIChsZXZlbCwgYWN0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChMb2dnZXIuc2hvdWxkTG9nKGxldmVsKSkge1xuICAgICAgICAgICAgKGxldmVsID09PSBMb2dMZXZlbHMuRXJyb3IgPyBMb2dnZXIubG9nRXJyb3JIYW5kbGVyIDogTG9nZ2VyLmxvZ0hhbmRsZXIpKCdBYmx5OiAnICsgYWN0aW9uICsgJzogJyArIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMb2dnZXIuZGVwcmVjYXRlZCA9IGZ1bmN0aW9uIChvcmlnaW5hbCwgcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgTG9nZ2VyLmRlcHJlY2F0ZWRXaXRoTXNnKG9yaWdpbmFsLCBcIlBsZWFzZSB1c2UgJ1wiICsgcmVwbGFjZW1lbnQgKyBcIicgaW5zdGVhZC5cIik7XG4gICAgfTtcbiAgICBMb2dnZXIuZGVwcmVjYXRlZFdpdGhNc2cgPSBmdW5jdGlvbiAoZnVuY05hbWUsIG1zZykge1xuICAgICAgICBpZiAoTG9nZ2VyLnNob3VsZExvZyhMb2dMZXZlbHMuRXJyb3IpKSB7XG4gICAgICAgICAgICBMb2dnZXIubG9nRXJyb3JIYW5kbGVyKFwiQWJseTogRGVwcmVjYXRpb24gd2FybmluZyAtICdcIiArIGZ1bmNOYW1lICsgXCInIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIGEgZnV0dXJlIHZlcnNpb24uIFwiICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyogV2hlcmUgYSBsb2dnaW5nIG9wZXJhdGlvbiBpcyBleHBlbnNpdmUsIHN1Y2ggYXMgc2VyaWFsaXNhdGlvbiBvZiBkYXRhLCB1c2Ugc2hvdWxkTG9nIHdpbGwgcHJldmVudFxuICAgICAgICAgdGhlIG9iamVjdCBiZWluZyBzZXJpYWxpc2VkIGlmIHRoZSBsb2cgbGV2ZWwgd2lsbCBub3Qgb3V0cHV0IHRoZSBtZXNzYWdlICovXG4gICAgTG9nZ2VyLnNob3VsZExvZyA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICByZXR1cm4gbGV2ZWwgPD0gTG9nZ2VyLmxvZ0xldmVsO1xuICAgIH07XG4gICAgTG9nZ2VyLnNldExvZyA9IGZ1bmN0aW9uIChsZXZlbCwgaGFuZGxlcikge1xuICAgICAgICBpZiAobGV2ZWwgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIExvZ2dlci5sb2dMZXZlbCA9IGxldmVsO1xuICAgICAgICBpZiAoaGFuZGxlciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgTG9nZ2VyLmxvZ0hhbmRsZXIgPSBMb2dnZXIubG9nRXJyb3JIYW5kbGVyID0gaGFuZGxlcjtcbiAgICB9O1xuICAgIHJldHVybiBMb2dnZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTG9nZ2VyO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxMykpKVxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQbGF0Zm9ybSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQbGF0Zm9ybSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIFBsYXRmb3JtO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFBsYXRmb3JtO1xuXG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXJ0aWFsRXJyb3JJbmZvID0gdm9pZCAwO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xuZnVuY3Rpb24gdG9TdHJpbmcoZXJyKSB7XG4gICAgdmFyIHJlc3VsdCA9ICdbJyArIGVyci5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChlcnIubWVzc2FnZSlcbiAgICAgICAgcmVzdWx0ICs9ICc6ICcgKyBlcnIubWVzc2FnZTtcbiAgICBpZiAoZXJyLnN0YXR1c0NvZGUpXG4gICAgICAgIHJlc3VsdCArPSAnOyBzdGF0dXNDb2RlPScgKyBlcnIuc3RhdHVzQ29kZTtcbiAgICBpZiAoZXJyLmNvZGUpXG4gICAgICAgIHJlc3VsdCArPSAnOyBjb2RlPScgKyBlcnIuY29kZTtcbiAgICBpZiAoZXJyLmNhdXNlKVxuICAgICAgICByZXN1bHQgKz0gJzsgY2F1c2U9JyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIuY2F1c2UpO1xuICAgIGlmIChlcnIuaHJlZiAmJiAhKGVyci5tZXNzYWdlICYmIGVyci5tZXNzYWdlLmluZGV4T2YoJ2hlbHAuYWJseS5pbycpID4gLTEpKVxuICAgICAgICByZXN1bHQgKz0gJzsgc2VlICcgKyBlcnIuaHJlZiArICcgJztcbiAgICByZXN1bHQgKz0gJ10nO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG52YXIgRXJyb3JJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEVycm9ySW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFcnJvckluZm8obWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSwgY2F1c2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3Quc2V0UHJvdG90eXBlT2YgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIEVycm9ySW5mby5wcm90b3R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICBfdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICAgICAgX3RoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFcnJvckluZm8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcodGhpcyk7XG4gICAgfTtcbiAgICBFcnJvckluZm8uZnJvbVZhbHVlcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgdmFyIF9hID0gdmFsdWVzLCBtZXNzYWdlID0gX2EubWVzc2FnZSwgY29kZSA9IF9hLmNvZGUsIHN0YXR1c0NvZGUgPSBfYS5zdGF0dXNDb2RlO1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJyB8fCB0eXBlb2Ygc3RhdHVzQ29kZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3JJbmZvLmZyb21WYWx1ZXMoKTogaW52YWxpZCB2YWx1ZXM6ICcgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QodmFsdWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5hc3NpZ24obmV3IEVycm9ySW5mbyhtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlKSwgdmFsdWVzKTtcbiAgICAgICAgaWYgKHJlc3VsdC5jb2RlICYmICFyZXN1bHQuaHJlZikge1xuICAgICAgICAgICAgcmVzdWx0LmhyZWYgPSAnaHR0cHM6Ly9oZWxwLmFibHkuaW8vZXJyb3IvJyArIHJlc3VsdC5jb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gRXJyb3JJbmZvO1xufShFcnJvcikpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRXJyb3JJbmZvO1xudmFyIFBhcnRpYWxFcnJvckluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUGFydGlhbEVycm9ySW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXJ0aWFsRXJyb3JJbmZvKG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUsIGNhdXNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LnNldFByb3RvdHlwZU9mICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBQYXJ0aWFsRXJyb3JJbmZvLnByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIF90aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICBfdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFBhcnRpYWxFcnJvckluZm8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFydGlhbEVycm9ySW5mbztcbn0oRXJyb3IpKTtcbmV4cG9ydHMuUGFydGlhbEVycm9ySW5mbyA9IFBhcnRpYWxFcnJvckluZm87XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gQ2hlY2sgaWYgdHlwZWQgYXJyYXlzIGFyZSBzdXBwb3J0ZWRcblx0ICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXG5cdCAgICAvLyBSZWZlcmVuY2Ugb3JpZ2luYWwgaW5pdFxuXHQgICAgdmFyIHN1cGVySW5pdCA9IFdvcmRBcnJheS5pbml0O1xuXG5cdCAgICAvLyBBdWdtZW50IFdvcmRBcnJheS5pbml0IHRvIGhhbmRsZSB0eXBlZCBhcnJheXNcblx0ICAgIHZhciBzdWJJbml0ID0gV29yZEFycmF5LmluaXQgPSBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHQgICAgICAgIC8vIENvbnZlcnQgYnVmZmVycyB0byB1aW50OFxuXHQgICAgICAgIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIENvbnZlcnQgb3RoZXIgYXJyYXkgdmlld3MgdG8gdWludDhcblx0ICAgICAgICBpZiAoXG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgfHxcblx0ICAgICAgICAgICAgKHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQxNkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50MzJBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5XG5cdCAgICAgICAgKSB7XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0eXBlZEFycmF5LmJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5LmJ5dGVMZW5ndGgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIEhhbmRsZSBVaW50OEFycmF5XG5cdCAgICAgICAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciB0eXBlZEFycmF5Qnl0ZUxlbmd0aCA9IHR5cGVkQXJyYXkuYnl0ZUxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBFeHRyYWN0IGJ5dGVzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkQXJyYXlCeXRlTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDJdIHw9IHR5cGVkQXJyYXlbaV0gPDwgKDI0IC0gKGkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGlzIHdvcmQgYXJyYXlcblx0ICAgICAgICAgICAgc3VwZXJJbml0LmNhbGwodGhpcywgd29yZHMsIHR5cGVkQXJyYXlCeXRlTGVuZ3RoKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBFbHNlIGNhbGwgbm9ybWFsIGluaXRcblx0ICAgICAgICAgICAgc3VwZXJJbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgc3ViSW5pdC5wcm90b3R5cGUgPSBXb3JkQXJyYXk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMubGliLldvcmRBcnJheTtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgezsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuXHQvKmdsb2JhbHMgd2luZG93LCBnbG9iYWwsIHJlcXVpcmUqL1xuXG5cdC8qKlxuXHQgKiBDcnlwdG9KUyBjb3JlIGNvbXBvbmVudHMuXG5cdCAqL1xuXHR2YXIgQ3J5cHRvSlMgPSBDcnlwdG9KUyB8fCAoZnVuY3Rpb24gKE1hdGgsIHVuZGVmaW5lZCkge1xuXG5cdCAgICB2YXIgY3J5cHRvO1xuXG5cdCAgICAvLyBOYXRpdmUgY3J5cHRvIGZyb20gd2luZG93IChCcm93c2VyKVxuXHQgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jcnlwdG8pIHtcblx0ICAgICAgICBjcnlwdG8gPSB3aW5kb3cuY3J5cHRvO1xuXHQgICAgfVxuXG5cdCAgICAvLyBOYXRpdmUgKGV4cGVyaW1lbnRhbCBJRSAxMSkgY3J5cHRvIGZyb20gd2luZG93IChCcm93c2VyKVxuXHQgICAgaWYgKCFjcnlwdG8gJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm1zQ3J5cHRvKSB7XG5cdCAgICAgICAgY3J5cHRvID0gd2luZG93Lm1zQ3J5cHRvO1xuXHQgICAgfVxuXG5cdCAgICAvLyBOYXRpdmUgY3J5cHRvIGZyb20gZ2xvYmFsIChOb2RlSlMpXG5cdCAgICBpZiAoIWNyeXB0byAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuY3J5cHRvKSB7XG5cdCAgICAgICAgY3J5cHRvID0gZ2xvYmFsLmNyeXB0bztcblx0ICAgIH1cblxuXHQgICAgLy8gTmF0aXZlIGNyeXB0byBpbXBvcnQgdmlhIHJlcXVpcmUgKE5vZGVKUylcblx0ICAgIGlmICghY3J5cHRvICYmIFwiZnVuY3Rpb25cIiA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIGNyeXB0byA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgIH1cblxuXHQgICAgLypcblx0ICAgICAqIENyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwc2V1ZG9yYW5kb20gbnVtYmVyIGdlbmVyYXRvclxuXHQgICAgICpcblx0ICAgICAqIEFzIE1hdGgucmFuZG9tKCkgaXMgY3J5cHRvZ3JhcGhpY2FsbHkgbm90IHNhZmUgdG8gdXNlXG5cdCAgICAgKi9cblx0ICAgIHZhciBjcnlwdG9TZWN1cmVSYW5kb21JbnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKGNyeXB0bykge1xuXHQgICAgICAgICAgICAvLyBVc2UgZ2V0UmFuZG9tVmFsdWVzIG1ldGhvZCAoQnJvd3Nlcilcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgxKSlbMF07XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBVc2UgcmFuZG9tQnl0ZXMgbWV0aG9kIChOb2RlSlMpXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvLnJhbmRvbUJ5dGVzID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMoNCkucmVhZEludDMyTEUoKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignTmF0aXZlIGNyeXB0byBtb2R1bGUgY291bGQgbm90IGJlIHVzZWQgdG8gZ2V0IHNlY3VyZSByYW5kb20gbnVtYmVyLicpO1xuXHQgICAgfTtcblxuXHQgICAgLypcblx0ICAgICAqIExvY2FsIHBvbHlmaWxsIG9mIE9iamVjdC5jcmVhdGVcblxuXHQgICAgICovXG5cdCAgICB2YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIEYoKSB7fVxuXG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICAgICAgdmFyIHN1YnR5cGU7XG5cblx0ICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBvYmo7XG5cblx0ICAgICAgICAgICAgc3VidHlwZSA9IG5ldyBGKCk7XG5cblx0ICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBudWxsO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuXHQgICAgICAgIH07XG5cdCAgICB9KCkpXG5cblx0ICAgIC8qKlxuXHQgICAgICogQ3J5cHRvSlMgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQyA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExpYnJhcnkgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYiA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEJhc2Ugb2JqZWN0IGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2UgPSAoZnVuY3Rpb24gKCkge1xuXG5cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3ZlcnJpZGVzIFByb3BlcnRpZXMgdG8gY29weSBpbnRvIHRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJyxcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICogICAgICAgICB9XG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGV4dGVuZDogZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuXHQgICAgICAgICAgICAgICAgLy8gU3Bhd25cblx0ICAgICAgICAgICAgICAgIHZhciBzdWJ0eXBlID0gY3JlYXRlKHRoaXMpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBBdWdtZW50XG5cdCAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5taXhJbihvdmVycmlkZXMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZGVmYXVsdCBpbml0aWFsaXplclxuXHQgICAgICAgICAgICAgICAgaWYgKCFzdWJ0eXBlLmhhc093blByb3BlcnR5KCdpbml0JykgfHwgdGhpcy5pbml0ID09PSBzdWJ0eXBlLmluaXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplcidzIHByb3RvdHlwZSBpcyB0aGUgc3VidHlwZSBvYmplY3Rcblx0ICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdC5wcm90b3R5cGUgPSBzdWJ0eXBlO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2Ugc3VwZXJ0eXBlXG5cdCAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlciA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBFeHRlbmRzIHRoaXMgb2JqZWN0IGFuZCBydW5zIHRoZSBpbml0IG1ldGhvZC5cblx0ICAgICAgICAgICAgICogQXJndW1lbnRzIHRvIGNyZWF0ZSgpIHdpbGwgYmUgcGFzc2VkIHRvIGluaXQoKS5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIGluc3RhbmNlID0gTXlUeXBlLmNyZWF0ZSgpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmV4dGVuZCgpO1xuXHQgICAgICAgICAgICAgICAgaW5zdGFuY2UuaW5pdC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhZGQgc29tZSBsb2dpYyB3aGVuIHlvdXIgb2JqZWN0cyBhcmUgY3JlYXRlZC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICogICAgICAgICAgICAgLy8gLi4uXG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIGludG8gdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIFRoZSBwcm9wZXJ0aWVzIHRvIG1peCBpbi5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIE15VHlwZS5taXhJbih7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZSdcblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgbWl4SW46IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gcHJvcGVydGllcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdID0gcHJvcGVydGllc1twcm9wZXJ0eU5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSUUgd29uJ3QgY29weSB0b1N0cmluZyB1c2luZyB0aGUgbG9vcCBhYm92ZVxuXHQgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoJ3RvU3RyaW5nJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvU3RyaW5nID0gcHJvcGVydGllcy50b1N0cmluZztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gaW5zdGFuY2UuY2xvbmUoKTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0LnByb3RvdHlwZS5leHRlbmQodGhpcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtBcnJheX0gd29yZHMgVGhlIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaWdCeXRlcyBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIChPcHRpb25hbCkgQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaWdCeXRlcyAoT3B0aW9uYWwpIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhlIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSk7XG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10sIDYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uICh3b3Jkcywgc2lnQnl0ZXMpIHtcblx0ICAgICAgICAgICAgd29yZHMgPSB0aGlzLndvcmRzID0gd29yZHMgfHwgW107XG5cblx0ICAgICAgICAgICAgaWYgKHNpZ0J5dGVzICE9IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHdvcmRzLmxlbmd0aCAqIDQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhpcyB3b3JkIGFycmF5IHRvIGEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyIChPcHRpb25hbCkgVGhlIGVuY29kaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogQ3J5cHRvSlMuZW5jLkhleFxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5naWZpZWQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheSArICcnO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKCk7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLlV0ZjgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoZW5jb2Rlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gKGVuY29kZXIgfHwgSGV4KS5zdHJpbmdpZnkodGhpcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmNhdGVuYXRlcyBhIHdvcmQgYXJyYXkgdG8gdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgd29yZEFycmF5MS5jb25jYXQod29yZEFycmF5Mik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY29uY2F0OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgdGhpc1dvcmRzID0gdGhpcy53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHRoYXRXb3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHRoaXNTaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciB0aGF0U2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAgdGhpcy5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbmNhdFxuXHQgICAgICAgICAgICBpZiAodGhpc1NpZ0J5dGVzICUgNCkge1xuXHQgICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgYnl0ZSBhdCBhIHRpbWVcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdEJ5dGUgPSAodGhhdFdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSB8PSB0aGF0Qnl0ZSA8PCAoMjQgLSAoKHRoaXNTaWdCeXRlcyArIGkpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIHdvcmQgYXQgYSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gPSB0aGF0V29yZHNbaSA+Pj4gMl07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyArPSB0aGF0U2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZW1vdmVzIGluc2lnbmlmaWNhbnQgYml0cy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgd29yZEFycmF5LmNsYW1wKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xhbXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXBcblx0ICAgICAgICAgICAgd29yZHNbc2lnQnl0ZXMgPj4+IDJdICY9IDB4ZmZmZmZmZmYgPDwgKDMyIC0gKHNpZ0J5dGVzICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgd29yZHMubGVuZ3RoID0gTWF0aC5jZWlsKHNpZ0J5dGVzIC8gNCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGNsb25lLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSB3b3JkQXJyYXkuY2xvbmUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLndvcmRzID0gdGhpcy53b3Jkcy5zbGljZSgwKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSB3b3JkIGFycmF5IGZpbGxlZCB3aXRoIHJhbmRvbSBieXRlcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuQnl0ZXMgVGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2VuZXJhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSByYW5kb20gd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKDE2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByYW5kb206IGZ1bmN0aW9uIChuQnl0ZXMpIHtcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgd29yZHMucHVzaChjcnlwdG9TZWN1cmVSYW5kb21JbnQoKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBuQnl0ZXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEVuY29kZXIgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYyA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEhleCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEhleCA9IENfZW5jLkhleCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuSGV4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgaGV4Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlID4+PiA0KS50b1N0cmluZygxNikpO1xuXHQgICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSAmIDB4MGYpLnRvU3RyaW5nKDE2KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gaGV4Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4U3RyIFRoZSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoaGV4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGhleFN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaGV4U3RyTGVuZ3RoID0gaGV4U3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhleFN0ckxlbmd0aDsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAzXSB8PSBwYXJzZUludChoZXhTdHIuc3Vic3RyKGksIDIpLCAxNikgPDwgKDI0IC0gKGkgJSA4KSAqIDQpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgaGV4U3RyTGVuZ3RoIC8gMik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMYXRpbjEgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBMYXRpbjEgPSBDX2VuYy5MYXRpbjEgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbGF0aW4xU3RyaW5nID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGxhdGluMUNoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgbGF0aW4xQ2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJpdGUpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBsYXRpbjFDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBMYXRpbjEgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXRpbjFTdHIgVGhlIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5wYXJzZShsYXRpbjFTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAobGF0aW4xU3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBsYXRpbjFTdHJMZW5ndGggPSBsYXRpbjFTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0aW4xU3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDJdIHw9IChsYXRpbjFTdHIuY2hhckNvZGVBdChpKSAmIDB4ZmYpIDw8ICgyNCAtIChpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGxhdGluMVN0ckxlbmd0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVVEYtOCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB1dGY4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLlV0Zjguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShMYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSkpKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgVVRGLTggZGF0YScpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgVVRGLTggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dGY4U3RyIFRoZSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UodXRmOFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGY4U3RyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBMYXRpbjEucGFyc2UodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHV0ZjhTdHIpKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBidWZmZXJlZCBibG9jayBhbGdvcml0aG0gdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogVGhlIHByb3BlcnR5IGJsb2NrU2l6ZSBtdXN0IGJlIGltcGxlbWVudGVkIGluIGEgY29uY3JldGUgc3VidHlwZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX21pbkJ1ZmZlclNpemUgVGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBzaG91bGQgYmUga2VwdCB1bnByb2Nlc3NlZCBpbiB0aGUgYnVmZmVyLiBEZWZhdWx0OiAwXG5cdCAgICAgKi9cblx0ICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBibG9jayBhbGdvcml0aG0ncyBkYXRhIGJ1ZmZlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgV29yZEFycmF5LmluaXQoKTtcblx0ICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyA9IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgbmV3IGRhdGEgdG8gdGhpcyBibG9jayBhbGdvcml0aG0ncyBidWZmZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYXBwZW5kLiBTdHJpbmdzIGFyZSBjb252ZXJ0ZWQgdG8gYSBXb3JkQXJyYXkgdXNpbmcgVVRGLTguXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCgnZGF0YScpO1xuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfYXBwZW5kOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBXb3JkQXJyYXksIGVsc2UgYXNzdW1lIFdvcmRBcnJheSBhbHJlYWR5XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgZGF0YSA9IFV0ZjgucGFyc2UoZGF0YSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fZGF0YS5jb25jYXQoZGF0YSk7XG5cdCAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgKz0gZGF0YS5zaWdCeXRlcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUHJvY2Vzc2VzIGF2YWlsYWJsZSBkYXRhIGJsb2Nrcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgX2RvUHJvY2Vzc0Jsb2NrKG9mZnNldCksIHdoaWNoIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgYSBjb25jcmV0ZSBzdWJ0eXBlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBkb0ZsdXNoIFdoZXRoZXIgYWxsIGJsb2NrcyBhbmQgcGFydGlhbCBibG9ja3Mgc2hvdWxkIGJlIHByb2Nlc3NlZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHByb2Nlc3NlZCBkYXRhLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX3Byb2Nlc3M6IGZ1bmN0aW9uIChkb0ZsdXNoKSB7XG5cdCAgICAgICAgICAgIHZhciBwcm9jZXNzZWRXb3JkcztcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGRhdGFTaWdCeXRlcyA9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSB0aGlzLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBibG9ja3MgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CbG9ja3NSZWFkeSA9IGRhdGFTaWdCeXRlcyAvIGJsb2NrU2l6ZUJ5dGVzO1xuXHQgICAgICAgICAgICBpZiAoZG9GbHVzaCkge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgdXAgdG8gaW5jbHVkZSBwYXJ0aWFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5jZWlsKG5CbG9ja3NSZWFkeSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBSb3VuZCBkb3duIHRvIGluY2x1ZGUgb25seSBmdWxsIGJsb2Nrcyxcblx0ICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBtdXN0IHJlbWFpbiBpbiB0aGUgYnVmZmVyXG5cdCAgICAgICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLm1heCgobkJsb2Nrc1JlYWR5IHwgMCkgLSB0aGlzLl9taW5CdWZmZXJTaXplLCAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvdW50IHdvcmRzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuV29yZHNSZWFkeSA9IG5CbG9ja3NSZWFkeSAqIGJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBieXRlcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbkJ5dGVzUmVhZHkgPSBNYXRoLm1pbihuV29yZHNSZWFkeSAqIDQsIGRhdGFTaWdCeXRlcyk7XG5cblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBibG9ja3Ncblx0ICAgICAgICAgICAgaWYgKG5Xb3Jkc1JlYWR5KSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBuV29yZHNSZWFkeTsgb2Zmc2V0ICs9IGJsb2NrU2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtYWxnb3JpdGhtIGxvZ2ljXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9Qcm9jZXNzQmxvY2soZGF0YVdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcHJvY2Vzc2VkIHdvcmRzXG5cdCAgICAgICAgICAgICAgICBwcm9jZXNzZWRXb3JkcyA9IGRhdGFXb3Jkcy5zcGxpY2UoMCwgbldvcmRzUmVhZHkpO1xuXHQgICAgICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuQnl0ZXNSZWFkeTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBwcm9jZXNzZWQgd29yZHNcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdChwcm9jZXNzZWRXb3JkcywgbkJ5dGVzUmVhZHkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5fZGF0YSA9IHRoaXMuX2RhdGEuY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9taW5CdWZmZXJTaXplOiAwXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBoYXNoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGhhc2hlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMTYgKDUxMiBiaXRzKVxuXHQgICAgICovXG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyID0gQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKCksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgaGFzaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGhhc2ggY29tcHV0YXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoYXNoZXIgPSBDcnlwdG9KUy5hbGdvLlNIQTI1Ni5jcmVhdGUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGhhc2hlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSBidWZmZXJcblx0ICAgICAgICAgICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHRoaXMuX2RvUmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVXBkYXRlcyB0aGlzIGhhc2hlciB3aXRoIGEgbWVzc2FnZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtIYXNoZXJ9IFRoaXMgaGFzaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBoYXNoXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgaGFzaCBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCk7XG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEZpbmFsIG1lc3NhZ2UgdXBkYXRlXG5cdCAgICAgICAgICAgIGlmIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2RvRmluYWxpemUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiA1MTIvMzIsXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gYSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGhhc2hlci5pbml0KGNmZykuZmluYWxpemUobWVzc2FnZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gdXNlIGluIHRoaXMgSE1BQyBoZWxwZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgSG1hY1NIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIbWFjSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwga2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENfYWxnby5ITUFDLmluaXQoaGFzaGVyLCBrZXkpLmZpbmFsaXplKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFsZ29yaXRobSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ28gPSB7fTtcblxuXHQgICAgcmV0dXJuIEM7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTO1xuXG59KSk7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxMykpKVxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xuLyogQ2FsbCB0aGUgbGlzdGVuZXIsIGNhdGNoIGFueSBleGNlcHRpb25zIGFuZCBsb2csIGJ1dCBjb250aW51ZSBvcGVyYXRpb24qL1xuZnVuY3Rpb24gY2FsbExpc3RlbmVyKGV2ZW50VGhpcywgbGlzdGVuZXIsIGFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgICBsaXN0ZW5lci5hcHBseShldmVudFRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0V2ZW50RW1pdHRlci5lbWl0KCknLCAnVW5leHBlY3RlZCBsaXN0ZW5lciBleGNlcHRpb246ICcgKyBlICsgJzsgc3RhY2sgPSAnICsgKGUgJiYgZS5zdGFjaykpO1xuICAgIH1cbn1cbi8qKlxuICogUmVtb3ZlIGxpc3RlbmVycyB0aGF0IG1hdGNoIGxpc3RlbmVyXG4gKiBAcGFyYW0gdGFyZ2V0TGlzdGVuZXJzIGlzIGFuIGFycmF5IG9mIGxpc3RlbmVyIGFycmF5cyBvciBldmVudCBvYmplY3RzIHdpdGggYXJyYXlzIG9mIGxpc3RlbmVyc1xuICogQHBhcmFtIGxpc3RlbmVyIHRoZSBsaXN0ZW5lciBjYWxsYmFjayB0byByZW1vdmVcbiAqIEBwYXJhbSBldmVudEZpbHRlciAob3B0aW9uYWwpIGV2ZW50IG5hbWUgaW5zdHJ1Y3RpbmcgdGhlIGZ1bmN0aW9uIHRvIG9ubHkgcmVtb3ZlIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCBldmVudFxuICovXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0YXJnZXRMaXN0ZW5lcnMsIGxpc3RlbmVyLCBldmVudEZpbHRlcikge1xuICAgIHZhciBsaXN0ZW5lcnM7XG4gICAgdmFyIGluZGV4O1xuICAgIHZhciBldmVudE5hbWU7XG4gICAgZm9yICh2YXIgdGFyZ2V0TGlzdGVuZXJzSW5kZXggPSAwOyB0YXJnZXRMaXN0ZW5lcnNJbmRleCA8IHRhcmdldExpc3RlbmVycy5sZW5ndGg7IHRhcmdldExpc3RlbmVyc0luZGV4KyspIHtcbiAgICAgICAgbGlzdGVuZXJzID0gdGFyZ2V0TGlzdGVuZXJzW3RhcmdldExpc3RlbmVyc0luZGV4XTtcbiAgICAgICAgaWYgKGV2ZW50RmlsdGVyKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNbZXZlbnRGaWx0ZXJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChVdGlscy5pc0FycmF5KGxpc3RlbmVycykpIHtcbiAgICAgICAgICAgIHdoaWxlICgoaW5kZXggPSBVdGlscy5hcnJJbmRleE9mKGxpc3RlbmVycywgbGlzdGVuZXIpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIElmIGV2ZW50cyBvYmplY3QgaGFzIGFuIGV2ZW50IG5hbWUga2V5IHdpdGggbm8gbGlzdGVuZXJzIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBrZXkgdG8gc3RvcCB0aGUgbGlzdCBncm93aW5nIGluZGVmaW5pdGVseSAqL1xuICAgICAgICAgICAgaWYgKGV2ZW50RmlsdGVyICYmIGxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0TGlzdGVuZXJzW3RhcmdldExpc3RlbmVyc0luZGV4XVtldmVudEZpbHRlcl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVXRpbHMuaXNPYmplY3QobGlzdGVuZXJzKSkge1xuICAgICAgICAgICAgLyogZXZlbnRzICovXG4gICAgICAgICAgICBmb3IgKGV2ZW50TmFtZSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxpc3RlbmVycywgZXZlbnROYW1lKSAmJiBVdGlscy5pc0FycmF5KGxpc3RlbmVyc1tldmVudE5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcihbbGlzdGVuZXJzXSwgbGlzdGVuZXIsIGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxudmFyIEV2ZW50RW1pdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gICAgICAgIHRoaXMuYW55ID0gW107XG4gICAgICAgIHRoaXMuZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5hbnlPbmNlID0gW107XG4gICAgICAgIHRoaXMuZXZlbnRzT25jZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBhcmdzWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMuYW55LnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudExpc3RlbmVyLm9uKCk6IEludmFsaWQgYXJndW1lbnRzOiAnICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHZhciBldmVudF8xID0gYXJnc1swXSwgbGlzdGVuZXJfMSA9IGFyZ3NbMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyXzEgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50TGlzdGVuZXIub24oKTogSW52YWxpZCBhcmd1bWVudHM6ICcgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFV0aWxzLmlzRW1wdHlBcmcoZXZlbnRfMSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFueS5wdXNoKGxpc3RlbmVyXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoVXRpbHMuaXNBcnJheShldmVudF8xKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50XzEuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXJfMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50XzEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnRMaXN0ZW5lci5vbigpOiBJbnZhbGlkIGFyZ3VtZW50czogJyArIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c1tldmVudF8xXSB8fCAodGhpcy5ldmVudHNbZXZlbnRfMV0gPSBbXSk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXJfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDAgfHwgKFV0aWxzLmlzRW1wdHlBcmcoYXJnc1swXSkgJiYgVXRpbHMuaXNFbXB0eUFyZyhhcmdzWzFdKSkpIHtcbiAgICAgICAgICAgIHRoaXMuYW55ID0gW107XG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB0aGlzLmFueU9uY2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzT25jZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0QXJnID0gYXJnc1swXSwgc2Vjb25kQXJnID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgdmFyIGV2ZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxIHx8ICFzZWNvbmRBcmcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlyc3RBcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvKiB3ZSB0YWtlIHRoaXMgdG8gYmUgdGhlIGxpc3RlbmVyIGFuZCB0cmVhdCB0aGUgZXZlbnQgYXMgXCJhbnlcIiAuLiAqL1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gZmlyc3RBcmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IGZpcnN0QXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogLi4uIG9yIHdlIHRha2UgZXZlbnQgdG8gYmUgdGhlIGFjdHVhbCBldmVudCBuYW1lIGFuZCBsaXN0ZW5lciB0byBiZSBhbGwgKi9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2Vjb25kQXJnICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudEVtaXR0ZXIub2ZmKCk6IGludmFsaWQgYXJndW1lbnRzOicgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2EgPSBbZmlyc3RBcmcsIHNlY29uZEFyZ10sIGV2ZW50ID0gX2FbMF0sIGxpc3RlbmVyID0gX2FbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyICYmIFV0aWxzLmlzRW1wdHlBcmcoZXZlbnQpKSB7XG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcihbdGhpcy5hbnksIHRoaXMuZXZlbnRzLCB0aGlzLmFueU9uY2UsIHRoaXMuZXZlbnRzT25jZV0sIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVXRpbHMuaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9mZihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIFwibm9ybWFsXCIgY2FzZSB3aGVyZSBldmVudCBpcyBhbiBhY3R1YWwgZXZlbnQgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBldmVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnRFbWl0dGVyLm9mZigpOiBpbnZhbGlkIGFyZ3VtZW50czonICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKFt0aGlzLmV2ZW50cywgdGhpcy5ldmVudHNPbmNlXSwgbGlzdGVuZXIsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c1tldmVudF07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ldmVudHNPbmNlW2V2ZW50XTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhcnJheSBvZiBsaXN0ZW5lcnMgZm9yIGEgZ2l2ZW4gZXZlbnQ7IGV4Y2x1ZGVzIG9uY2UgZXZlbnRzXG4gICAgICogQHBhcmFtIGV2ZW50IChvcHRpb25hbCkgdGhlIG5hbWUgb2YgdGhlIGV2ZW50LCBvciBub25lIGZvciAnYW55J1xuICAgICAqIEByZXR1cm4gYXJyYXkgb2YgZXZlbnRzLCBvciBudWxsIGlmIG5vbmVcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c1tldmVudF0gfHwgW107XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudHNPbmNlW2V2ZW50XSlcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuZXZlbnRzT25jZVtldmVudF0pO1xuICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGggPyBsaXN0ZW5lcnMgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFueS5sZW5ndGggPyB0aGlzLmFueSA6IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbWl0IGFuIGV2ZW50XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIGFyZ3MgdGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBsaXN0ZW5lclxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdOyAvKiAsIGFyZ3MuLi4gKi9cbiAgICAgICAgZm9yICh2YXIgX2kgPSAxIC8qICwgYXJncy4uLiAqLzsgX2kgPCBhcmd1bWVudHMubGVuZ3RoIC8qICwgYXJncy4uLiAqLzsgX2krKyAvKiAsIGFyZ3MuLi4gKi8pIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07IC8qICwgYXJncy4uLiAqL1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudFRoaXMgPSB7IGV2ZW50OiBldmVudCB9O1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gW107XG4gICAgICAgIGlmICh0aGlzLmFueU9uY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuYW55T25jZSk7XG4gICAgICAgICAgICB0aGlzLmFueU9uY2UgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbnkubGVuZ3RoKSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuYW55KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRzT25jZUxpc3RlbmVycyA9IHRoaXMuZXZlbnRzT25jZVtldmVudF07XG4gICAgICAgIGlmIChldmVudHNPbmNlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIGV2ZW50c09uY2VMaXN0ZW5lcnMpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnRzT25jZVtldmVudF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50c0xpc3RlbmVycyA9IHRoaXMuZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgaWYgKGV2ZW50c0xpc3RlbmVycykge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCBldmVudHNMaXN0ZW5lcnMpO1xuICAgICAgICB9XG4gICAgICAgIFV0aWxzLmFyckZvckVhY2gobGlzdGVuZXJzLCBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNhbGxMaXN0ZW5lcihldmVudFRoaXMsIGxpc3RlbmVyLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ0NvdW50ID0gYXJncy5sZW5ndGg7XG4gICAgICAgIGlmICgoYXJnQ291bnQgPT09IDAgfHwgKGFyZ0NvdW50ID09PSAxICYmIHR5cGVvZiBhcmdzWzBdICE9PSAnZnVuY3Rpb24nKSkgJiYgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5Qcm9taXNlKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRfMiA9IGFyZ3NbMF07XG4gICAgICAgICAgICByZXR1cm4gbmV3IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uY2UoZXZlbnRfMiwgcmVzb2x2ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3RBcmcgPSBhcmdzWzBdLCBzZWNvbmRBcmcgPSBhcmdzWzFdO1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGZpcnN0QXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmFueU9uY2UucHVzaChmaXJzdEFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVXRpbHMuaXNFbXB0eUFyZyhmaXJzdEFyZykpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2Vjb25kQXJnICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudEVtaXR0ZXIub25jZSgpOiBJbnZhbGlkIGFyZ3VtZW50czonICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYW55T25jZS5wdXNoKHNlY29uZEFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVXRpbHMuaXNBcnJheShmaXJzdEFyZykpIHtcbiAgICAgICAgICAgIHZhciBzZWxmXzEgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyV3JhcHBlcl8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbm5lckFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIFV0aWxzLmFyckZvckVhY2goZmlyc3RBcmcsIGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZl8xLm9mZihldmVudE5hbWUsIGxpc3RlbmVyV3JhcHBlcl8xKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50RW1pdHRlci5vbmNlKCk6IEludmFsaWQgYXJndW1lbnRzOicgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWNvbmRBcmcuYXBwbHkodGhpcywgaW5uZXJBcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBVdGlscy5hcnJGb3JFYWNoKGZpcnN0QXJnLCBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgc2VsZl8xLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXJXcmFwcGVyXzEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpcnN0QXJnICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6JyArIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5ldmVudHNPbmNlW2ZpcnN0QXJnXSB8fCAodGhpcy5ldmVudHNPbmNlW2ZpcnN0QXJnXSA9IFtdKTtcbiAgICAgICAgICAgIGlmIChzZWNvbmRBcmcpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50RW1pdHRlci5vbmNlKCk6IEludmFsaWQgYXJndW1lbnRzOicgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChzZWNvbmRBcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcml2YXRlIEFQSVxuICAgICAqXG4gICAgICogTGlzdGVuIGZvciBhIHNpbmdsZSBvY2N1cnJlbmNlIG9mIGEgc3RhdGUgZXZlbnQgYW5kIGZpcmUgaW1tZWRpYXRlbHkgaWYgY3VycmVudFN0YXRlIG1hdGNoZXMgdGFyZ2V0U3RhdGVcbiAgICAgKiBAcGFyYW0gdGFyZ2V0U3RhdGUgdGhlIG5hbWUgb2YgdGhlIHN0YXRlIGV2ZW50IHRvIGxpc3RlbiB0b1xuICAgICAqIEBwYXJhbSBjdXJyZW50U3RhdGUgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhpcyBvYmplY3RcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgdGhlIGxpc3RlbmVyIHRvIGJlIGNhbGxlZFxuICAgICAqIEBwYXJhbSBsaXN0ZW5lckFyZ3NcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLndoZW5TdGF0ZSA9IGZ1bmN0aW9uICh0YXJnZXRTdGF0ZSwgY3VycmVudFN0YXRlLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbGlzdGVuZXJBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMzsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBsaXN0ZW5lckFyZ3NbX2kgLSAzXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50VGhpcyA9IHsgZXZlbnQ6IHRhcmdldFN0YXRlIH07XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0U3RhdGUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjdXJyZW50U3RhdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyAnd2hlblN0YXRlIHJlcXVpcmVzIGEgdmFsaWQgZXZlbnQgU3RyaW5nIGFyZ3VtZW50JztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nICYmIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLndoZW5TdGF0ZS5hcHBseShfdGhpcywgW3RhcmdldFN0YXRlLCBjdXJyZW50U3RhdGUsIHJlc29sdmVdLmNvbmNhdChsaXN0ZW5lckFyZ3MpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXRTdGF0ZSA9PT0gY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgICBjYWxsTGlzdGVuZXIoZXZlbnRUaGlzLCBsaXN0ZW5lciwgbGlzdGVuZXJBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25jZSh0YXJnZXRTdGF0ZSwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50RW1pdHRlcjtcblxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RGVmYXVsdHMgPSBleHBvcnRzLm5vcm1hbGlzZU9wdGlvbnMgPSBleHBvcnRzLm9iamVjdGlmeU9wdGlvbnMgPSBleHBvcnRzLmdldEFnZW50U3RyaW5nID0gZXhwb3J0cy5nZXRIb3N0cyA9IGV4cG9ydHMuZ2V0RmFsbGJhY2tIb3N0cyA9IGV4cG9ydHMuZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzID0gZXhwb3J0cy5nZXRIdHRwU2NoZW1lID0gZXhwb3J0cy5nZXRQb3J0ID0gZXhwb3J0cy5nZXRIb3N0ID0gdm9pZCAwO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBwYWNrYWdlX2pzb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xudmFyIGFnZW50ID0gJ2FibHktanMvJyArIHBhY2thZ2VfanNvbl8xLnZlcnNpb247XG52YXIgRGVmYXVsdHMgPSB7XG4gICAgRU5WSVJPTk1FTlQ6ICcnLFxuICAgIFJFU1RfSE9TVDogJ3Jlc3QuYWJseS5pbycsXG4gICAgUkVBTFRJTUVfSE9TVDogJ3JlYWx0aW1lLmFibHkuaW8nLFxuICAgIEZBTExCQUNLX0hPU1RTOiBbXG4gICAgICAgICdBLmFibHktcmVhbHRpbWUuY29tJyxcbiAgICAgICAgJ0IuYWJseS1yZWFsdGltZS5jb20nLFxuICAgICAgICAnQy5hYmx5LXJlYWx0aW1lLmNvbScsXG4gICAgICAgICdELmFibHktcmVhbHRpbWUuY29tJyxcbiAgICAgICAgJ0UuYWJseS1yZWFsdGltZS5jb20nLFxuICAgIF0sXG4gICAgUE9SVDogODAsXG4gICAgVExTX1BPUlQ6IDQ0MyxcbiAgICBUSU1FT1VUUzoge1xuICAgICAgICAvKiBEb2N1bWVudGVkIGFzIG9wdGlvbnMgcGFyYW1zOiAqL1xuICAgICAgICBkaXNjb25uZWN0ZWRSZXRyeVRpbWVvdXQ6IDE1MDAwLFxuICAgICAgICBzdXNwZW5kZWRSZXRyeVRpbWVvdXQ6IDMwMDAwLFxuICAgICAgICAvKiBVbmRvY3VtZW50ZWQsIGJ1dCBwYXJ0IG9mIHRoZSBhcGkgYW5kIGNhbiBiZSB1c2VkIGJ5IGN1c3RvbWVyczogKi9cbiAgICAgICAgaHR0cFJlcXVlc3RUaW1lb3V0OiAxNTAwMCxcbiAgICAgICAgY2hhbm5lbFJldHJ5VGltZW91dDogMTUwMDAsXG4gICAgICAgIGZhbGxiYWNrUmV0cnlUaW1lb3V0OiA2MDAwMDAsXG4gICAgICAgIC8qIEZvciBpbnRlcm5hbCAvIHRlc3QgdXNlIG9ubHk6ICovXG4gICAgICAgIGNvbm5lY3Rpb25TdGF0ZVR0bDogMTIwMDAwLFxuICAgICAgICByZWFsdGltZVJlcXVlc3RUaW1lb3V0OiAxMDAwMCxcbiAgICAgICAgcmVjdlRpbWVvdXQ6IDkwMDAwLFxuICAgICAgICBwcmVmZXJlbmNlQ29ubmVjdFRpbWVvdXQ6IDYwMDAsXG4gICAgICAgIHBhcmFsbGVsVXBncmFkZURlbGF5OiA2MDAwLFxuICAgIH0sXG4gICAgaHR0cE1heFJldHJ5Q291bnQ6IDMsXG4gICAgbWF4TWVzc2FnZVNpemU6IDY1NTM2LFxuICAgIHZlcnNpb246IHBhY2thZ2VfanNvbl8xLnZlcnNpb24sXG4gICAgcHJvdG9jb2xWZXJzaW9uOiAyLFxuICAgIGFnZW50OiBhZ2VudCxcbiAgICBnZXRIb3N0OiBnZXRIb3N0LFxuICAgIGdldFBvcnQ6IGdldFBvcnQsXG4gICAgZ2V0SHR0cFNjaGVtZTogZ2V0SHR0cFNjaGVtZSxcbiAgICBlbnZpcm9ubWVudEZhbGxiYWNrSG9zdHM6IGVudmlyb25tZW50RmFsbGJhY2tIb3N0cyxcbiAgICBnZXRGYWxsYmFja0hvc3RzOiBnZXRGYWxsYmFja0hvc3RzLFxuICAgIGdldEhvc3RzOiBnZXRIb3N0cyxcbiAgICBjaGVja0hvc3Q6IGNoZWNrSG9zdCxcbiAgICBvYmplY3RpZnlPcHRpb25zOiBvYmplY3RpZnlPcHRpb25zLFxuICAgIG5vcm1hbGlzZU9wdGlvbnM6IG5vcm1hbGlzZU9wdGlvbnMsXG59O1xuZnVuY3Rpb24gZ2V0SG9zdChvcHRpb25zLCBob3N0LCB3cykge1xuICAgIGlmICh3cylcbiAgICAgICAgaG9zdCA9IChob3N0ID09IG9wdGlvbnMucmVzdEhvc3QgJiYgb3B0aW9ucy5yZWFsdGltZUhvc3QpIHx8IGhvc3QgfHwgb3B0aW9ucy5yZWFsdGltZUhvc3Q7XG4gICAgZWxzZVxuICAgICAgICBob3N0ID0gaG9zdCB8fCBvcHRpb25zLnJlc3RIb3N0O1xuICAgIHJldHVybiBob3N0O1xufVxuZXhwb3J0cy5nZXRIb3N0ID0gZ2V0SG9zdDtcbmZ1bmN0aW9uIGdldFBvcnQob3B0aW9ucywgdGxzKSB7XG4gICAgcmV0dXJuIHRscyB8fCBvcHRpb25zLnRscyA/IG9wdGlvbnMudGxzUG9ydCA6IG9wdGlvbnMucG9ydDtcbn1cbmV4cG9ydHMuZ2V0UG9ydCA9IGdldFBvcnQ7XG5mdW5jdGlvbiBnZXRIdHRwU2NoZW1lKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy50bHMgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nO1xufVxuZXhwb3J0cy5nZXRIdHRwU2NoZW1lID0gZ2V0SHR0cFNjaGVtZTtcbi8vIGNvbnN0cnVjdCBlbnZpcm9ubWVudCBmYWxsYmFjayBob3N0cyBhcyBwZXIgUlNDMTVpXG5mdW5jdGlvbiBlbnZpcm9ubWVudEZhbGxiYWNrSG9zdHMoZW52aXJvbm1lbnQpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBlbnZpcm9ubWVudCArICctYS1mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbScsXG4gICAgICAgIGVudmlyb25tZW50ICsgJy1iLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tJyxcbiAgICAgICAgZW52aXJvbm1lbnQgKyAnLWMtZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb20nLFxuICAgICAgICBlbnZpcm9ubWVudCArICctZC1mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbScsXG4gICAgICAgIGVudmlyb25tZW50ICsgJy1lLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tJyxcbiAgICBdO1xufVxuZXhwb3J0cy5lbnZpcm9ubWVudEZhbGxiYWNrSG9zdHMgPSBlbnZpcm9ubWVudEZhbGxiYWNrSG9zdHM7XG5mdW5jdGlvbiBnZXRGYWxsYmFja0hvc3RzKG9wdGlvbnMpIHtcbiAgICB2YXIgZmFsbGJhY2tIb3N0cyA9IG9wdGlvbnMuZmFsbGJhY2tIb3N0cywgaHR0cE1heFJldHJ5Q291bnQgPSB0eXBlb2Ygb3B0aW9ucy5odHRwTWF4UmV0cnlDb3VudCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmh0dHBNYXhSZXRyeUNvdW50IDogRGVmYXVsdHMuaHR0cE1heFJldHJ5Q291bnQ7XG4gICAgcmV0dXJuIGZhbGxiYWNrSG9zdHMgPyBVdGlscy5hcnJDaG9vc2VOKGZhbGxiYWNrSG9zdHMsIGh0dHBNYXhSZXRyeUNvdW50KSA6IFtdO1xufVxuZXhwb3J0cy5nZXRGYWxsYmFja0hvc3RzID0gZ2V0RmFsbGJhY2tIb3N0cztcbmZ1bmN0aW9uIGdldEhvc3RzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gW29wdGlvbnMucmVzdEhvc3RdLmNvbmNhdChnZXRGYWxsYmFja0hvc3RzKG9wdGlvbnMpKTtcbn1cbmV4cG9ydHMuZ2V0SG9zdHMgPSBnZXRIb3N0cztcbmZ1bmN0aW9uIGNoZWNrSG9zdChob3N0KSB7XG4gICAgaWYgKHR5cGVvZiBob3N0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnaG9zdCBtdXN0IGJlIGEgc3RyaW5nOyB3YXMgYSAnICsgdHlwZW9mIGhvc3QsIDQwMDAwLCA0MDApO1xuICAgIH1cbiAgICBpZiAoIWhvc3QubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdob3N0IG11c3Qgbm90IGJlIHplcm8tbGVuZ3RoJywgNDAwMDAsIDQwMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UmVhbHRpbWVIb3N0KG9wdGlvbnMsIHByb2R1Y3Rpb24sIGVudmlyb25tZW50KSB7XG4gICAgaWYgKG9wdGlvbnMucmVhbHRpbWVIb3N0KVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5yZWFsdGltZUhvc3Q7XG4gICAgLyogcHJlZmVyIHNldHRpbmcgcmVhbHRpbWVIb3N0IHRvIHJlc3RIb3N0IGFzIGEgY3VzdG9tIHJlc3RIb3N0IHR5cGljYWxseSBpbmRpY2F0ZXNcbiAgICAgKiBhIGRldmVsb3BtZW50IGVudmlyb25tZW50IGlzIGJlaW5nIHVzZWQgdGhhdCBjYW4ndCBiZSBpbmZlcnJlZCBieSB0aGUgbGlicmFyeSAqL1xuICAgIGlmIChvcHRpb25zLnJlc3RIb3N0KSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9ucycsICdyZXN0SG9zdCBpcyBzZXQgdG8gXCInICtcbiAgICAgICAgICAgIG9wdGlvbnMucmVzdEhvc3QgK1xuICAgICAgICAgICAgJ1wiIGJ1dCByZWFsdGltZUhvc3QgaXMgbm90IHNldCwgc28gc2V0dGluZyByZWFsdGltZUhvc3QgdG8gXCInICtcbiAgICAgICAgICAgIG9wdGlvbnMucmVzdEhvc3QgK1xuICAgICAgICAgICAgJ1wiIHRvby4gSWYgdGhpcyBpcyBub3Qgd2hhdCB5b3Ugd2FudCwgcGxlYXNlIHNldCByZWFsdGltZUhvc3QgZXhwbGljaXRseS4nKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVzdEhvc3Q7XG4gICAgfVxuICAgIHJldHVybiBwcm9kdWN0aW9uID8gRGVmYXVsdHMuUkVBTFRJTUVfSE9TVCA6IGVudmlyb25tZW50ICsgJy0nICsgRGVmYXVsdHMuUkVBTFRJTUVfSE9TVDtcbn1cbmZ1bmN0aW9uIGdldFRpbWVvdXRzKG9wdGlvbnMpIHtcbiAgICAvKiBBbGxvdyB2YWx1ZXMgcGFzc2VkIGluIG9wdGlvbnMgdG8gb3ZlcnJpZGUgZGVmYXVsdCB0aW1lb3V0cyAqL1xuICAgIHZhciB0aW1lb3V0cyA9IHt9O1xuICAgIGZvciAodmFyIHByb3AgaW4gRGVmYXVsdHMuVElNRU9VVFMpIHtcbiAgICAgICAgdGltZW91dHNbcHJvcF0gPSBvcHRpb25zW3Byb3BdIHx8IERlZmF1bHRzLlRJTUVPVVRTW3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gdGltZW91dHM7XG59XG5mdW5jdGlvbiBnZXRBZ2VudFN0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIGFnZW50U3RyID0gRGVmYXVsdHMuYWdlbnQ7XG4gICAgaWYgKG9wdGlvbnMuYWdlbnRzKSB7XG4gICAgICAgIGZvciAodmFyIGFnZW50IGluIG9wdGlvbnMuYWdlbnRzKSB7XG4gICAgICAgICAgICBhZ2VudFN0ciArPSAnICcgKyBhZ2VudCArICcvJyArIG9wdGlvbnMuYWdlbnRzW2FnZW50XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWdlbnRTdHI7XG59XG5leHBvcnRzLmdldEFnZW50U3RyaW5nID0gZ2V0QWdlbnRTdHJpbmc7XG5mdW5jdGlvbiBvYmplY3RpZnlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuaW5kZXhPZignOicpID09IC0xID8geyB0b2tlbjogb3B0aW9ucyB9IDogeyBrZXk6IG9wdGlvbnMgfTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5leHBvcnRzLm9iamVjdGlmeU9wdGlvbnMgPSBvYmplY3RpZnlPcHRpb25zO1xuZnVuY3Rpb24gbm9ybWFsaXNlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgLyogRGVwcmVjYXRlZCBvcHRpb25zICovXG4gICAgaWYgKG9wdGlvbnMuaG9zdCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlcHJlY2F0ZWQoJ2hvc3QnLCAncmVzdEhvc3QnKTtcbiAgICAgICAgb3B0aW9ucy5yZXN0SG9zdCA9IG9wdGlvbnMuaG9zdDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMud3NIb3N0KSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZGVwcmVjYXRlZCgnd3NIb3N0JywgJ3JlYWx0aW1lSG9zdCcpO1xuICAgICAgICBvcHRpb25zLnJlYWx0aW1lSG9zdCA9IG9wdGlvbnMud3NIb3N0O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5xdWV1ZUV2ZW50cykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlcHJlY2F0ZWQoJ3F1ZXVlRXZlbnRzJywgJ3F1ZXVlTWVzc2FnZXMnKTtcbiAgICAgICAgb3B0aW9ucy5xdWV1ZU1lc3NhZ2VzID0gb3B0aW9ucy5xdWV1ZUV2ZW50cztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZmFsbGJhY2tIb3N0c1VzZURlZmF1bHQpIHtcbiAgICAgICAgLyogZmFsbGJhY2tIb3N0c1VzZURlZmF1bHQgYW5kIGZhbGxiYWNrSG9zdHMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSBhcyBwZXIgVE8zazcgKi9cbiAgICAgICAgaWYgKG9wdGlvbnMuZmFsbGJhY2tIb3N0cykge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdmYWxsYmFja0hvc3RzIGFuZCBmYWxsYmFja0hvc3RzVXNlRGVmYXVsdCBjYW5ub3QgYm90aCBiZSBzZXQnO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zJywgbXNnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgNDAwMDAsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogZGVmYXVsdCBmYWxsYmFja3MgY2FuJ3QgYmUgdXNlZCB3aXRoIGN1c3RvbSBwb3J0cyAqL1xuICAgICAgICBpZiAob3B0aW9ucy5wb3J0IHx8IG9wdGlvbnMudGxzUG9ydCkge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdmYWxsYmFja0hvc3RzVXNlRGVmYXVsdCBjYW5ub3QgYmUgc2V0IHdoZW4gcG9ydCBvciB0bHNQb3J0IGFyZSBzZXQnO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zJywgbXNnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgNDAwMDAsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogZW1pdCBhbiBhcHByb3ByaWF0ZSBkZXByZWNhdGlvbiB3YXJuaW5nICovXG4gICAgICAgIGlmIChvcHRpb25zLmVudmlyb25tZW50KSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlcHJlY2F0ZWRXaXRoTXNnKCdmYWxsYmFja0hvc3RzVXNlRGVmYXVsdCcsICdUaGVyZSBpcyBubyBsb25nZXIgYSBuZWVkIHRvIHNldCB0aGlzIHdoZW4gdGhlIGVudmlyb25tZW50IG9wdGlvbiBpcyBhbHNvIHNldCBzaW5jZSB0aGUgbGlicmFyeSB3aWxsIG5vdyBnZW5lcmF0ZSB0aGUgY29ycmVjdCBmYWxsYmFjayBob3N0cyB1c2luZyB0aGUgZW52aXJvbm1lbnQgb3B0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZXByZWNhdGVkKCdmYWxsYmFja0hvc3RzVXNlRGVmYXVsdCcsICdmYWxsYmFja0hvc3RzOiBBYmx5LkRlZmF1bHRzLkZBTExCQUNLX0hPU1RTJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogdXNlIHRoZSBkZWZhdWx0IGZhbGxiYWNrIGhvc3RzIGFzIHJlcXVlc3RlZCAqL1xuICAgICAgICBvcHRpb25zLmZhbGxiYWNrSG9zdHMgPSBEZWZhdWx0cy5GQUxMQkFDS19IT1NUUztcbiAgICB9XG4gICAgLyogb3B0aW9ucy5yZWNvdmVyIGFzIGEgYm9vbGVhbiBpcyBkZXByZWNhdGVkLCBhbmQgdGhlcmVmb3JlIGlzIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgdHlwaW5nICovXG4gICAgaWYgKG9wdGlvbnMucmVjb3ZlciA9PT0gdHJ1ZSkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlcHJlY2F0ZWQoJ3tyZWNvdmVyOiB0cnVlfScsICd7cmVjb3ZlcjogZnVuY3Rpb24obGFzdENvbm5lY3Rpb25EZXRhaWxzLCBjYikgeyBjYih0cnVlKTsgfX0nKTtcbiAgICAgICAgb3B0aW9ucy5yZWNvdmVyID0gZnVuY3Rpb24gKGxhc3RDb25uZWN0aW9uRGV0YWlscywgY2IpIHtcbiAgICAgICAgICAgIGNiKHRydWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVjb3ZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zLmNsb3NlT25VbmxvYWQgPT09IHRydWUpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zJywgJ2Nsb3NlT25VbmxvYWQgd2FzIHRydWUgYW5kIGEgc2Vzc2lvbiByZWNvdmVyeSBmdW5jdGlvbiB3YXMgc2V0IC0gdGhlc2UgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSwgc28gdW5zZXR0aW5nIHRoZSBsYXR0ZXInKTtcbiAgICAgICAgb3B0aW9ucy5yZWNvdmVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoISgnY2xvc2VPblVubG9hZCcgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgLyogSGF2ZSBjbG9zZU9uVW5sb2FkIGRlZmF1bHQgdG8gdHJ1ZSB1bmxlc3Mgd2UgaGF2ZSBhbnkgaW5kaWNhdGlvbiB0aGF0XG4gICAgICAgICAqIHRoZSB1c2VyIG1heSB3YW50IHRvIHJlY292ZXIgdGhlIGNvbm5lY3Rpb24gKi9cbiAgICAgICAgb3B0aW9ucy5jbG9zZU9uVW5sb2FkID0gIW9wdGlvbnMucmVjb3ZlcjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudHJhbnNwb3J0cyAmJiBVdGlscy5hcnJJbihvcHRpb25zLnRyYW5zcG9ydHMsICd4aHInKSkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlcHJlY2F0ZWQoJ3RyYW5zcG9ydHM6IFtcInhoclwiXScsICd0cmFuc3BvcnRzOiBbXCJ4aHJfc3RyZWFtaW5nXCJdJyk7XG4gICAgICAgIFV0aWxzLmFyckRlbGV0ZVZhbHVlKG9wdGlvbnMudHJhbnNwb3J0cywgJ3hocicpO1xuICAgICAgICBvcHRpb25zLnRyYW5zcG9ydHMucHVzaCgneGhyX3N0cmVhbWluZycpO1xuICAgIH1cbiAgICBpZiAoISgncXVldWVNZXNzYWdlcycgaW4gb3B0aW9ucykpXG4gICAgICAgIG9wdGlvbnMucXVldWVNZXNzYWdlcyA9IHRydWU7XG4gICAgLyogaW5mZXIgaG9zdHMgYW5kIGZhbGxiYWNrcyBiYXNlZCBvbiB0aGUgY29uZmlndXJlZCBlbnZpcm9ubWVudCAqL1xuICAgIHZhciBlbnZpcm9ubWVudCA9IChvcHRpb25zLmVudmlyb25tZW50ICYmIFN0cmluZyhvcHRpb25zLmVudmlyb25tZW50KS50b0xvd2VyQ2FzZSgpKSB8fCBEZWZhdWx0cy5FTlZJUk9OTUVOVDtcbiAgICB2YXIgcHJvZHVjdGlvbiA9ICFlbnZpcm9ubWVudCB8fCBlbnZpcm9ubWVudCA9PT0gJ3Byb2R1Y3Rpb24nO1xuICAgIGlmICghb3B0aW9ucy5mYWxsYmFja0hvc3RzICYmICFvcHRpb25zLnJlc3RIb3N0ICYmICFvcHRpb25zLnJlYWx0aW1lSG9zdCAmJiAhb3B0aW9ucy5wb3J0ICYmICFvcHRpb25zLnRsc1BvcnQpIHtcbiAgICAgICAgb3B0aW9ucy5mYWxsYmFja0hvc3RzID0gcHJvZHVjdGlvbiA/IERlZmF1bHRzLkZBTExCQUNLX0hPU1RTIDogZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzKGVudmlyb25tZW50KTtcbiAgICB9XG4gICAgdmFyIHJlc3RIb3N0ID0gb3B0aW9ucy5yZXN0SG9zdCB8fCAocHJvZHVjdGlvbiA/IERlZmF1bHRzLlJFU1RfSE9TVCA6IGVudmlyb25tZW50ICsgJy0nICsgRGVmYXVsdHMuUkVTVF9IT1NUKTtcbiAgICB2YXIgcmVhbHRpbWVIb3N0ID0gZ2V0UmVhbHRpbWVIb3N0KG9wdGlvbnMsIHByb2R1Y3Rpb24sIGVudmlyb25tZW50KTtcbiAgICBVdGlscy5hcnJGb3JFYWNoKChvcHRpb25zLmZhbGxiYWNrSG9zdHMgfHwgW10pLmNvbmNhdChyZXN0SG9zdCwgcmVhbHRpbWVIb3N0KSwgY2hlY2tIb3N0KTtcbiAgICBvcHRpb25zLnBvcnQgPSBvcHRpb25zLnBvcnQgfHwgRGVmYXVsdHMuUE9SVDtcbiAgICBvcHRpb25zLnRsc1BvcnQgPSBvcHRpb25zLnRsc1BvcnQgfHwgRGVmYXVsdHMuVExTX1BPUlQ7XG4gICAgaWYgKCEoJ3RscycgaW4gb3B0aW9ucykpXG4gICAgICAgIG9wdGlvbnMudGxzID0gdHJ1ZTtcbiAgICB2YXIgdGltZW91dHMgPSBnZXRUaW1lb3V0cyhvcHRpb25zKTtcbiAgICBpZiAoJ3VzZUJpbmFyeVByb3RvY29sJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLnN1cHBvcnRzQmluYXJ5ICYmIG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2w7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID0gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5wcmVmZXJCaW5hcnk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNsaWVudElkKSB7XG4gICAgICAgIHZhciBoZWFkZXJzID0gKG9wdGlvbnMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fSk7XG4gICAgICAgIGhlYWRlcnNbJ1gtQWJseS1DbGllbnRJZCddID0gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMudXRmOEVuY29kZShvcHRpb25zLmNsaWVudElkKSk7XG4gICAgfVxuICAgIGlmICghKCdpZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMuaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucHJvbWlzZXMgJiYgIXBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuUHJvbWlzZSkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0RlZmF1bHRzLm5vcm1hbGlzZU9wdGlvbnMnLCAne3Byb21pc2VzOiB0cnVlfSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gUHJvbWlzZSBjb25zdHJ1Y3RvciBmb3VuZDsgZGlzYWJsaW5nIHByb21pc2VzJyk7XG4gICAgICAgIG9wdGlvbnMucHJvbWlzZXMgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zID0gbnVsbDtcbiAgICB2YXIgY29ubmVjdGl2aXR5Q2hlY2tVcmwgPSBvcHRpb25zLmNvbm5lY3Rpdml0eUNoZWNrVXJsO1xuICAgIGlmIChvcHRpb25zLmNvbm5lY3Rpdml0eUNoZWNrVXJsKSB7XG4gICAgICAgIHZhciBfYSA9IG9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmwuc3BsaXQoJz8nKSwgdXJpID0gX2FbMF0sIHFzID0gX2FbMV07XG4gICAgICAgIGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zID0gcXMgPyBVdGlscy5wYXJzZVF1ZXJ5U3RyaW5nKHFzKSA6IHt9O1xuICAgICAgICBpZiAodXJpLmluZGV4T2YoJzovLycpID09PSAtMSkge1xuICAgICAgICAgICAgdXJpID0gJ2h0dHBzOi8vJyArIHVyaTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0aXZpdHlDaGVja1VybCA9IHVyaTtcbiAgICB9XG4gICAgcmV0dXJuIHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgdXNlQmluYXJ5UHJvdG9jb2w6ICd1c2VCaW5hcnlQcm90b2NvbCcgaW4gb3B0aW9uc1xuICAgICAgICAgICAgPyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLnN1cHBvcnRzQmluYXJ5ICYmIG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2xcbiAgICAgICAgICAgIDogcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5wcmVmZXJCaW5hcnksIHJlYWx0aW1lSG9zdDogcmVhbHRpbWVIb3N0LCByZXN0SG9zdDogcmVzdEhvc3QsIG1heE1lc3NhZ2VTaXplOiBvcHRpb25zLm1heE1lc3NhZ2VTaXplIHx8IERlZmF1bHRzLm1heE1lc3NhZ2VTaXplLCB0aW1lb3V0czogdGltZW91dHMsIGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zOiBjb25uZWN0aXZpdHlDaGVja1BhcmFtcywgY29ubmVjdGl2aXR5Q2hlY2tVcmw6IGNvbm5lY3Rpdml0eUNoZWNrVXJsIH0pO1xufVxuZXhwb3J0cy5ub3JtYWxpc2VPcHRpb25zID0gbm9ybWFsaXNlT3B0aW9ucztcbmV4cG9ydHMuZGVmYXVsdCA9IERlZmF1bHRzO1xuZnVuY3Rpb24gZ2V0RGVmYXVsdHMocGxhdGZvcm1EZWZhdWx0cykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKERlZmF1bHRzLCBwbGF0Zm9ybURlZmF1bHRzKTtcbn1cbmV4cG9ydHMuZ2V0RGVmYXVsdHMgPSBnZXREZWZhdWx0cztcblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG5mdW5jdGlvbiBub3JtYWxpc2VDb250ZXh0KGNvbnRleHQpIHtcbiAgICBpZiAoIWNvbnRleHQgfHwgIWNvbnRleHQuY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5uZWxPcHRpb25zOiBjb250ZXh0LFxuICAgICAgICAgICAgcGx1Z2luczoge30sXG4gICAgICAgICAgICBiYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNpcGhlck9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY2lwaGVyKSB7XG4gICAgICAgIGlmICghcGxhdGZvcm1fMS5kZWZhdWx0LkNyeXB0bylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiBub3QgZW5hYmxlZDsgdXNlIGFibHkuZW5jcnlwdGlvbi5qcyBpbnN0ZWFkJyk7XG4gICAgICAgIHZhciBjaXBoZXIgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQ3J5cHRvLmdldENpcGhlcihvcHRpb25zLmNpcGhlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaXBoZXI6IGNpcGhlci5jaXBoZXJQYXJhbXMsXG4gICAgICAgICAgICBjaGFubmVsQ2lwaGVyOiBjaXBoZXIuY2lwaGVyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlU2l6ZShtc2cpIHtcbiAgICB2YXIgc2l6ZSA9IDA7XG4gICAgaWYgKG1zZy5uYW1lKSB7XG4gICAgICAgIHNpemUgKz0gbXNnLm5hbWUubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobXNnLmNsaWVudElkKSB7XG4gICAgICAgIHNpemUgKz0gbXNnLmNsaWVudElkLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKG1zZy5leHRyYXMpIHtcbiAgICAgICAgc2l6ZSArPSBKU09OLnN0cmluZ2lmeShtc2cuZXh0cmFzKS5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChtc2cuZGF0YSkge1xuICAgICAgICBzaXplICs9IFV0aWxzLmRhdGFTaXplQnl0ZXMobXNnLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn1cbnZhciBNZXNzYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2UoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJsb2FkIHRvSlNPTigpIHRvIGludGVyY2VwdCBKU09OLnN0cmluZ2lmeSgpXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBNZXNzYWdlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIGVuY29kZSBkYXRhIHRvIGJhc2U2NCBpZiBwcmVzZW50IGFuZCB3ZSdyZSByZXR1cm5pbmcgcmVhbCBKU09OO1xuICAgICAgICAgKiBhbHRob3VnaCBtc2dwYWNrIGNhbGxzIHRvSlNPTigpLCB3ZSBrbm93IGl0IGlzIGEgc3RyaW5naWZ5KClcbiAgICAgICAgICogY2FsbCBpZiBpdCBoYXMgYSBub24tZW1wdHkgYXJndW1lbnRzIGxpc3QgKi9cbiAgICAgICAgdmFyIGVuY29kaW5nID0gdGhpcy5lbmNvZGluZztcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGlmIChkYXRhICYmIHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLyogc3RyaW5naWZ5IGNhbGwgKi9cbiAgICAgICAgICAgICAgICBlbmNvZGluZyA9IGVuY29kaW5nID8gZW5jb2RpbmcgKyAnL2Jhc2U2NCcgOiAnYmFzZTY0JztcbiAgICAgICAgICAgICAgICBkYXRhID0gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIENhbGxlZCBieSBtc2dwYWNrLiB0b0J1ZmZlciByZXR1cm5zIGEgZGF0YXR5cGUgdW5kZXJzdGFuZGFibGUgYnlcbiAgICAgICAgICAgICAgICAgKiB0aGF0IHBsYXRmb3JtJ3MgbXNncGFjayBpbXBsZW1lbnRhdGlvbiAoQnVmZmVyIGluIG5vZGUsIFVpbnQ4QXJyYXlcbiAgICAgICAgICAgICAgICAgKiBpbiBicm93c2VycykgKi9cbiAgICAgICAgICAgICAgICBkYXRhID0gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLnRvQnVmZmVyKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuICAgICAgICAgICAgY29ubmVjdGlvbklkOiB0aGlzLmNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25LZXk6IHRoaXMuY29ubmVjdGlvbktleSxcbiAgICAgICAgICAgIGV4dHJhczogdGhpcy5leHRyYXMsXG4gICAgICAgICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWVzc2FnZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnW01lc3NhZ2UnO1xuICAgICAgICBpZiAodGhpcy5uYW1lKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IG5hbWU9JyArIHRoaXMubmFtZTtcbiAgICAgICAgaWYgKHRoaXMuaWQpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgaWQ9JyArIHRoaXMuaWQ7XG4gICAgICAgIGlmICh0aGlzLnRpbWVzdGFtcClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyB0aW1lc3RhbXA9JyArIHRoaXMudGltZXN0YW1wO1xuICAgICAgICBpZiAodGhpcy5jbGllbnRJZClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBjbGllbnRJZD0nICsgdGhpcy5jbGllbnRJZDtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbklkKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGNvbm5lY3Rpb25JZD0nICsgdGhpcy5jb25uZWN0aW9uSWQ7XG4gICAgICAgIGlmICh0aGlzLmVuY29kaW5nKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGVuY29kaW5nPScgKyB0aGlzLmVuY29kaW5nO1xuICAgICAgICBpZiAodGhpcy5leHRyYXMpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgZXh0cmFzID0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5leHRyYXMpO1xuICAgICAgICBpZiAodGhpcy5kYXRhKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGF0YSA9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJzsgZGF0YT0nICsgdGhpcy5kYXRhO1xuICAgICAgICAgICAgZWxzZSBpZiAocGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmlzQnVmZmVyKHRoaXMuZGF0YSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGRhdGEgKGJ1ZmZlcik9JyArIHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUodGhpcy5kYXRhKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJzsgZGF0YSAoanNvbik9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXh0cmFzKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGV4dHJhcz0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5leHRyYXMpO1xuICAgICAgICByZXN1bHQgKz0gJ10nO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWVzc2FnZS5lbmNyeXB0ID0gZnVuY3Rpb24gKG1zZywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtc2cuZGF0YSwgZW5jb2RpbmcgPSBtc2cuZW5jb2RpbmcsIGNpcGhlciA9IG9wdGlvbnMuY2hhbm5lbENpcGhlcjtcbiAgICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyA/IGVuY29kaW5nICsgJy8nIDogJyc7XG4gICAgICAgIGlmICghcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgICBkYXRhID0gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUoU3RyaW5nKGRhdGEpKTtcbiAgICAgICAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgKyAndXRmLTgvJztcbiAgICAgICAgfVxuICAgICAgICBjaXBoZXIuZW5jcnlwdChkYXRhLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtc2cuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICBtc2cuZW5jb2RpbmcgPSBlbmNvZGluZyArICdjaXBoZXIrJyArIGNpcGhlci5hbGdvcml0aG07XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtc2cpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1lc3NhZ2UuZW5jb2RlID0gZnVuY3Rpb24gKG1zZywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtc2cuZGF0YTtcbiAgICAgICAgdmFyIG5hdGl2ZURhdGFUeXBlID0gdHlwZW9mIGRhdGEgPT0gJ3N0cmluZycgfHwgcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIW5hdGl2ZURhdGFUeXBlKSB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3QoZGF0YSkgfHwgVXRpbHMuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIG1zZy5kYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgICAgICAgICAgbXNnLmVuY29kaW5nID0gbXNnLmVuY29kaW5nID8gbXNnLmVuY29kaW5nICsgJy9qc29uJyA6ICdqc29uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdEYXRhIHR5cGUgaXMgdW5zdXBwb3J0ZWQnLCA0MDAxMywgNDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuY2lwaGVyKSB7XG4gICAgICAgICAgICBNZXNzYWdlLmVuY3J5cHQobXNnLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtc2cpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXNzYWdlLmVuY29kZUFycmF5ID0gZnVuY3Rpb24gKG1lc3NhZ2VzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcHJvY2Vzc2VkID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgTWVzc2FnZS5lbmNvZGUobWVzc2FnZXNbaV0sIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkKys7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NlZCA9PSBtZXNzYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWVzc2FnZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXNzYWdlLmRlY29kZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBpbnB1dENvbnRleHQpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBub3JtYWxpc2VDb250ZXh0KGlucHV0Q29udGV4dCk7XG4gICAgICAgIHZhciBsYXN0UGF5bG9hZCA9IG1lc3NhZ2UuZGF0YTtcbiAgICAgICAgdmFyIGVuY29kaW5nID0gbWVzc2FnZS5lbmNvZGluZztcbiAgICAgICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICAgICAgICB2YXIgeGZvcm1zID0gZW5jb2Rpbmcuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgIHZhciBsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCA9IHZvaWQgMCwgZW5jb2RpbmdzVG9Qcm9jZXNzID0geGZvcm1zLmxlbmd0aCwgZGF0YSA9IG1lc3NhZ2UuZGF0YTtcbiAgICAgICAgICAgIHZhciB4Zm9ybSA9ICcnO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4ID0gZW5jb2RpbmdzVG9Qcm9jZXNzKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNlY3VyaXR5L2RldGVjdC11bnNhZmUtcmVnZXhcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0geGZvcm1zWy0tZW5jb2RpbmdzVG9Qcm9jZXNzXS5tYXRjaCgvKFstXFx3XSspKFxcKyhbXFx3LV0rKSk/Lyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgeGZvcm0gPSBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh4Zm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmJhc2U2NERlY29kZShTdHJpbmcoZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCA9PSB4Zm9ybXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RQYXlsb2FkID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy51dGY4RGVjb2RlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjaXBoZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmNoYW5uZWxPcHRpb25zICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5jaGFubmVsT3B0aW9ucy5jaXBoZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5jaGFubmVsT3B0aW9ucy5jaGFubmVsQ2lwaGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Zm9ybUFsZ29yaXRobSA9IG1hdGNoWzNdLCBjaXBoZXIgPSBjb250ZXh0LmNoYW5uZWxPcHRpb25zLmNoYW5uZWxDaXBoZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGRvbid0IGF0dGVtcHQgdG8gZGVjcnlwdCB1bmxlc3MgdGhlIGNpcGhlciBwYXJhbXMgYXJlIGNvbXBhdGlibGUgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhmb3JtQWxnb3JpdGhtICE9IGNpcGhlci5hbGdvcml0aG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGRlY3J5cHQgbWVzc2FnZSB3aXRoIGdpdmVuIGNpcGhlcjsgaW5jb21wYXRpYmxlIGNpcGhlciBwYXJhbXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gY2lwaGVyLmRlY3J5cHQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZGVjcnlwdCBtZXNzYWdlOyBub3QgYW4gZW5jcnlwdGVkIGNoYW5uZWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd2Y2RpZmYnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5wbHVnaW5zIHx8ICFjb250ZXh0LnBsdWdpbnMudmNkaWZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdNaXNzaW5nIFZjZGlmZiBkZWNvZGVyIChodHRwczovL2dpdGh1Yi5jb20vYWJseS1mb3Jrcy92Y2RpZmYtZGVjb2RlciknLCA0MDAxOSwgNDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnRGVsdGEgZGVjb2Rpbmcgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIgKG5lZWQgQXJyYXlCdWZmZXIgJiBVaW50OEFycmF5KScsIDQwMDIwLCA0MDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFCYXNlID0gY29udGV4dC5iYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWx0YUJhc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YUJhc2UgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMudXRmOEVuY29kZShkZWx0YUJhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHZjZGlmZiBleHBlY3RzIFVpbnQ4QXJyYXlzLCBjYW4ndCBjb3B5IHdpdGggQXJyYXlCdWZmZXJzLiAoYWxzbywgaWYgd2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogZG9uJ3QgaGF2ZSBhIFRleHREZWNvZGVyLCBkZWx0YUJhc2UgbWlnaHQgYmUgYSBXb3JkQXJyYXkgaGVyZSwgc28gbmVlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0byBwcm9jZXNzIGl0IGludG8gYSBidWZmZXIgYW55d2F5KSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YUJhc2UgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMudG9CdWZmZXIoZGVsdGFCYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy50b0J1ZmZlcihkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy50eXBlZEFycmF5VG9CdWZmZXIoY29udGV4dC5wbHVnaW5zLnZjZGlmZi5kZWNvZGUoZGF0YSwgZGVsdGFCYXNlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RQYXlsb2FkID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1ZjZGlmZiBkZWx0YSBkZWNvZGUgZmFpbGVkIHdpdGggJyArIGUsIDQwMDE4LCA0MDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBlO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdFcnJvciBwcm9jZXNzaW5nIHRoZSAnICsgeGZvcm0gKyAnIGVuY29kaW5nLCBkZWNvZGVyIHJldHVybmVkIOKAmCcgKyBlcnIubWVzc2FnZSArICfigJknLCBlcnIuY29kZSB8fCA0MDAxMywgNDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW5jb2RpbmcgPVxuICAgICAgICAgICAgICAgICAgICBsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCA8PSAwID8gbnVsbCA6IHhmb3Jtcy5zbGljZSgwLCBsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCkuam9pbignLycpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5iYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZCA9IGxhc3RQYXlsb2FkO1xuICAgIH07XG4gICAgTWVzc2FnZS5mcm9tUmVzcG9uc2VCb2R5ID0gZnVuY3Rpb24gKGJvZHksIG9wdGlvbnMsIGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBib2R5ID0gVXRpbHMuZGVjb2RlQm9keShib2R5LCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1zZyA9IChib2R5W2ldID0gTWVzc2FnZS5mcm9tVmFsdWVzKGJvZHlbaV0pKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgTWVzc2FnZS5kZWNvZGUobXNnLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdNZXNzYWdlLmZyb21SZXNwb25zZUJvZHkoKScsIGUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfTtcbiAgICBNZXNzYWdlLmZyb21WYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBNZXNzYWdlKCksIHZhbHVlcyk7XG4gICAgfTtcbiAgICBNZXNzYWdlLmZyb21WYWx1ZXNBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gdmFsdWVzLmxlbmd0aCwgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKVxuICAgICAgICAgICAgcmVzdWx0W2ldID0gTWVzc2FnZS5mcm9tVmFsdWVzKHZhbHVlc1tpXSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNZXNzYWdlLmZyb21FbmNvZGVkID0gZnVuY3Rpb24gKGVuY29kZWQsIGlucHV0T3B0aW9ucykge1xuICAgICAgICB2YXIgbXNnID0gTWVzc2FnZS5mcm9tVmFsdWVzKGVuY29kZWQpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IG5vcm1hbGl6ZUNpcGhlck9wdGlvbnMoaW5wdXRPcHRpb25zICE9PSBudWxsICYmIGlucHV0T3B0aW9ucyAhPT0gdm9pZCAwID8gaW5wdXRPcHRpb25zIDogbnVsbCk7XG4gICAgICAgIC8qIGlmIGRlY29kaW5nIGZhaWxzIGF0IGFueSBwb2ludCwgY2F0Y2ggYW5kIHJldHVybiB0aGUgbWVzc2FnZSBkZWNvZGVkIHRvXG4gICAgICAgICAqIHRoZSBmdWxsZXN0IGV4dGVudCBwb3NzaWJsZSAqL1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgTWVzc2FnZS5kZWNvZGUobXNnLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdNZXNzYWdlLmZyb21FbmNvZGVkKCknLCBlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfTtcbiAgICBNZXNzYWdlLmZyb21FbmNvZGVkQXJyYXkgPSBmdW5jdGlvbiAoZW5jb2RlZEFycmF5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVkQXJyYXkubWFwKGZ1bmN0aW9uIChlbmNvZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gTWVzc2FnZS5mcm9tRW5jb2RlZChlbmNvZGVkLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgb24gZW5jb2RlKClkIChhbmQgZW5jcnlwdCgpZCkgTWVzc2FnZXMgKGFzIGl0XG4gICAgICogYXNzdW1lcyB0aGUgZGF0YSBpcyBhIHN0cmluZyBvciBidWZmZXIpICovXG4gICAgTWVzc2FnZS5nZXRNZXNzYWdlc1NpemUgPSBmdW5jdGlvbiAobWVzc2FnZXMpIHtcbiAgICAgICAgdmFyIG1zZywgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtc2cgPSBtZXNzYWdlc1tpXTtcbiAgICAgICAgICAgIHRvdGFsICs9IG1zZy5zaXplIHx8IChtc2cuc2l6ZSA9IGdldE1lc3NhZ2VTaXplKG1zZykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9O1xuICAgIE1lc3NhZ2Uuc2VyaWFsaXplID0gVXRpbHMuZW5jb2RlQm9keTtcbiAgICByZXR1cm4gTWVzc2FnZTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBNZXNzYWdlO1xuXG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg5KSk7XG52YXIgcHJlc2VuY2VtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KSk7XG52YXIgYWN0aW9ucyA9IHtcbiAgICBIRUFSVEJFQVQ6IDAsXG4gICAgQUNLOiAxLFxuICAgIE5BQ0s6IDIsXG4gICAgQ09OTkVDVDogMyxcbiAgICBDT05ORUNURUQ6IDQsXG4gICAgRElTQ09OTkVDVDogNSxcbiAgICBESVNDT05ORUNURUQ6IDYsXG4gICAgQ0xPU0U6IDcsXG4gICAgQ0xPU0VEOiA4LFxuICAgIEVSUk9SOiA5LFxuICAgIEFUVEFDSDogMTAsXG4gICAgQVRUQUNIRUQ6IDExLFxuICAgIERFVEFDSDogMTIsXG4gICAgREVUQUNIRUQ6IDEzLFxuICAgIFBSRVNFTkNFOiAxNCxcbiAgICBNRVNTQUdFOiAxNSxcbiAgICBTWU5DOiAxNixcbiAgICBBVVRIOiAxNyxcbiAgICBBQ1RJVkFURTogMTgsXG59O1xudmFyIEFjdGlvbk5hbWUgPSBbXTtcbk9iamVjdC5rZXlzKGFjdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBBY3Rpb25OYW1lW2FjdGlvbnNbbmFtZV1dID0gbmFtZTtcbn0pO1xudmFyIGZsYWdzID0ge1xuICAgIC8qIENoYW5uZWwgYXR0YWNoIHN0YXRlIGZsYWdzICovXG4gICAgSEFTX1BSRVNFTkNFOiAxIDw8IDAsXG4gICAgSEFTX0JBQ0tMT0c6IDEgPDwgMSxcbiAgICBSRVNVTUVEOiAxIDw8IDIsXG4gICAgVFJBTlNJRU5UOiAxIDw8IDQsXG4gICAgQVRUQUNIX1JFU1VNRTogMSA8PCA1LFxuICAgIC8qIENoYW5uZWwgbW9kZSBmbGFncyAqL1xuICAgIFBSRVNFTkNFOiAxIDw8IDE2LFxuICAgIFBVQkxJU0g6IDEgPDwgMTcsXG4gICAgU1VCU0NSSUJFOiAxIDw8IDE4LFxuICAgIFBSRVNFTkNFX1NVQlNDUklCRTogMSA8PCAxOSxcbn07XG52YXIgZmxhZ05hbWVzID0gT2JqZWN0LmtleXMoZmxhZ3MpO1xuZmxhZ3MuTU9ERV9BTEwgPSBmbGFncy5QUkVTRU5DRSB8IGZsYWdzLlBVQkxJU0ggfCBmbGFncy5TVUJTQ1JJQkUgfCBmbGFncy5QUkVTRU5DRV9TVUJTQ1JJQkU7XG5mdW5jdGlvbiB0b1N0cmluZ0FycmF5KGFycmF5KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGlmIChhcnJheSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ1sgJyArIHJlc3VsdC5qb2luKCcsICcpICsgJyBdJztcbn1cbnZhciBzaW1wbGVBdHRyaWJ1dGVzID0gJ2lkIGNoYW5uZWwgY2hhbm5lbFNlcmlhbCBjb25uZWN0aW9uSWQgY291bnQgbXNnU2VyaWFsIHRpbWVzdGFtcCcuc3BsaXQoJyAnKTtcbnZhciBQcm90b2NvbE1lc3NhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvdG9jb2xNZXNzYWdlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmhhc0ZsYWcgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgICAgICAgcmV0dXJuIChfdGhpcy5mbGFncyAmIGZsYWdzW2ZsYWddKSA+IDA7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByb3RvY29sTWVzc2FnZS5wcm90b3R5cGUuc2V0RmxhZyA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyA9IHRoaXMuZmxhZ3MgfCBmbGFnc1tmbGFnXSk7XG4gICAgfTtcbiAgICBQcm90b2NvbE1lc3NhZ2UucHJvdG90eXBlLmdldE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzICYmIHRoaXMuZmxhZ3MgJiBmbGFncy5NT0RFX0FMTDtcbiAgICB9O1xuICAgIFByb3RvY29sTWVzc2FnZS5wcm90b3R5cGUuZW5jb2RlTW9kZXNUb0ZsYWdzID0gZnVuY3Rpb24gKG1vZGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG1vZGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZGUpIHsgcmV0dXJuIF90aGlzLnNldEZsYWcobW9kZSk7IH0pO1xuICAgIH07XG4gICAgUHJvdG9jb2xNZXNzYWdlLnByb3RvdHlwZS5kZWNvZGVNb2Rlc0Zyb21GbGFncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG1vZGVzID0gW107XG4gICAgICAgIFByb3RvY29sTWVzc2FnZS5jaGFubmVsTW9kZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kZSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmhhc0ZsYWcobW9kZSkpIHtcbiAgICAgICAgICAgICAgICBtb2Rlcy5wdXNoKG1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1vZGVzLmxlbmd0aCA+IDAgPyBtb2RlcyA6IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIFByb3RvY29sTWVzc2FnZS5mcm9tVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgUHJvdG9jb2xNZXNzYWdlKCksIHZhbHVlcyk7XG4gICAgfTtcbiAgICBQcm90b2NvbE1lc3NhZ2UuQWN0aW9uID0gYWN0aW9ucztcbiAgICBQcm90b2NvbE1lc3NhZ2UuY2hhbm5lbE1vZGVzID0gWydQUkVTRU5DRScsICdQVUJMSVNIJywgJ1NVQlNDUklCRScsICdQUkVTRU5DRV9TVUJTQ1JJQkUnXTtcbiAgICBQcm90b2NvbE1lc3NhZ2UuQWN0aW9uTmFtZSA9IEFjdGlvbk5hbWU7XG4gICAgUHJvdG9jb2xNZXNzYWdlLnNlcmlhbGl6ZSA9IFV0aWxzLmVuY29kZUJvZHk7XG4gICAgUHJvdG9jb2xNZXNzYWdlLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKHNlcmlhbGl6ZWQsIGZvcm1hdCkge1xuICAgICAgICB2YXIgZGVzZXJpYWxpemVkID0gVXRpbHMuZGVjb2RlQm9keShzZXJpYWxpemVkLCBmb3JtYXQpO1xuICAgICAgICByZXR1cm4gUHJvdG9jb2xNZXNzYWdlLmZyb21EZXNlcmlhbGl6ZWQoZGVzZXJpYWxpemVkKTtcbiAgICB9O1xuICAgIFByb3RvY29sTWVzc2FnZS5mcm9tRGVzZXJpYWxpemVkID0gZnVuY3Rpb24gKGRlc2VyaWFsaXplZCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBkZXNlcmlhbGl6ZWQuZXJyb3I7XG4gICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgIGRlc2VyaWFsaXplZC5lcnJvciA9IGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyhlcnJvcik7XG4gICAgICAgIHZhciBtZXNzYWdlcyA9IGRlc2VyaWFsaXplZC5tZXNzYWdlcztcbiAgICAgICAgaWYgKG1lc3NhZ2VzKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBtZXNzYWdlc1tpXSA9IG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMobWVzc2FnZXNbaV0pO1xuICAgICAgICB2YXIgcHJlc2VuY2UgPSBkZXNlcmlhbGl6ZWQucHJlc2VuY2U7XG4gICAgICAgIGlmIChwcmVzZW5jZSlcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlc2VuY2UubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgcHJlc2VuY2VbaV0gPSBwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMocHJlc2VuY2VbaV0sIHRydWUpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgUHJvdG9jb2xNZXNzYWdlKCksIGRlc2VyaWFsaXplZCk7XG4gICAgfTtcbiAgICBQcm90b2NvbE1lc3NhZ2Uuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJ1tQcm90b2NvbE1lc3NhZ2UnO1xuICAgICAgICBpZiAobXNnLmFjdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGFjdGlvbj0nICsgUHJvdG9jb2xNZXNzYWdlLkFjdGlvbk5hbWVbbXNnLmFjdGlvbl0gfHwgZmFsc2U7XG4gICAgICAgIHZhciBhdHRyaWJ1dGU7XG4gICAgICAgIGZvciAodmFyIGF0dHJpYkluZGV4ID0gMDsgYXR0cmliSW5kZXggPCBzaW1wbGVBdHRyaWJ1dGVzLmxlbmd0aDsgYXR0cmliSW5kZXgrKykge1xuICAgICAgICAgICAgYXR0cmlidXRlID0gc2ltcGxlQXR0cmlidXRlc1thdHRyaWJJbmRleF07XG4gICAgICAgICAgICBpZiAobXNnW2F0dHJpYnV0ZV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJzsgJyArIGF0dHJpYnV0ZSArICc9JyArIG1zZ1thdHRyaWJ1dGVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtc2cubWVzc2FnZXMpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgbWVzc2FnZXM9JyArIHRvU3RyaW5nQXJyYXkobWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlc0FycmF5KG1zZy5tZXNzYWdlcykpO1xuICAgICAgICBpZiAobXNnLnByZXNlbmNlKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IHByZXNlbmNlPScgKyB0b1N0cmluZ0FycmF5KHByZXNlbmNlbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlc0FycmF5KG1zZy5wcmVzZW5jZSkpO1xuICAgICAgICBpZiAobXNnLmVycm9yKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGVycm9yPScgKyBlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMobXNnLmVycm9yKS50b1N0cmluZygpO1xuICAgICAgICBpZiAobXNnLmF1dGggJiYgbXNnLmF1dGguYWNjZXNzVG9rZW4pXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgdG9rZW49JyArIG1zZy5hdXRoLmFjY2Vzc1Rva2VuO1xuICAgICAgICBpZiAobXNnLmZsYWdzKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGZsYWdzPScgKyBmbGFnTmFtZXMuZmlsdGVyKG1zZy5oYXNGbGFnKS5qb2luKCcsJyk7XG4gICAgICAgIGlmIChtc2cucGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgc3RyaW5naWZpZWRQYXJhbXNfMSA9ICcnO1xuICAgICAgICAgICAgVXRpbHMuZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllcyhtc2cucGFyYW1zLCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIGlmIChzdHJpbmdpZmllZFBhcmFtc18xLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZpZWRQYXJhbXNfMSArPSAnOyAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllZFBhcmFtc18xICs9IHByb3AgKyAnPScgKyBtc2cucGFyYW1zW3Byb3BdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc3RyaW5naWZpZWRQYXJhbXNfMS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICc7IHBhcmFtcz1bJyArIHN0cmluZ2lmaWVkUGFyYW1zXzEgKyAnXSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICddJztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBQcm90b2NvbE1lc3NhZ2U7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUHJvdG9jb2xNZXNzYWdlO1xuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDYpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCYXNlNjQgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgYmFzZTY0U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgbWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBiYXNlNjRDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMSA9ICh3b3Jkc1tpID4+PiAyXSAgICAgICA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAgICAgICAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTIgPSAod29yZHNbKGkgKyAxKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDEpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUzID0gKHdvcmRzWyhpICsgMikgPj4+IDJdID4+PiAoMjQgLSAoKGkgKyAyKSAlIDQpICogOCkpICYgMHhmZjtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHRyaXBsZXQgPSAoYnl0ZTEgPDwgMTYpIHwgKGJ5dGUyIDw8IDgpIHwgYnl0ZTM7XG5cblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyAoaiA8IDQpICYmIChpICsgaiAqIDAuNzUgPCBzaWdCeXRlcyk7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2gobWFwLmNoYXJBdCgodHJpcGxldCA+Pj4gKDYgKiAoMyAtIGopKSkgJiAweDNmKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcblx0ICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoYmFzZTY0Q2hhcnMubGVuZ3RoICUgNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2gocGFkZGluZ0NoYXIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGJhc2U2NENoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIEJhc2U2NCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFN0ciBUaGUgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnBhcnNlKGJhc2U2NFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChiYXNlNjRTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBiYXNlNjRTdHJMZW5ndGggPSBiYXNlNjRTdHIubGVuZ3RoO1xuXHQgICAgICAgICAgICB2YXIgbWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89Jztcblx0ICAgICAgICAgICAgdmFyIHJldmVyc2VNYXAgPSB0aGlzLl9yZXZlcnNlTWFwO1xuXG5cdCAgICAgICAgICAgIGlmICghcmV2ZXJzZU1hcCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXAgPSB0aGlzLl9yZXZlcnNlTWFwID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXAubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcFttYXAuY2hhckNvZGVBdChqKV0gPSBqO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIElnbm9yZSBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuXHQgICAgICAgICAgICBpZiAocGFkZGluZ0NoYXIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nSW5kZXggPSBiYXNlNjRTdHIuaW5kZXhPZihwYWRkaW5nQ2hhcik7XG5cdCAgICAgICAgICAgICAgICBpZiAocGFkZGluZ0luZGV4ICE9PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhc2U2NFN0ckxlbmd0aCA9IHBhZGRpbmdJbmRleDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgcmV0dXJuIHBhcnNlTG9vcChiYXNlNjRTdHIsIGJhc2U2NFN0ckxlbmd0aCwgcmV2ZXJzZU1hcCk7XG5cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBwYXJzZUxvb3AoYmFzZTY0U3RyLCBiYXNlNjRTdHJMZW5ndGgsIHJldmVyc2VNYXApIHtcblx0ICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgIHZhciBuQnl0ZXMgPSAwO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2U2NFN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBpZiAoaSAlIDQpIHtcblx0ICAgICAgICAgICAgICB2YXIgYml0czEgPSByZXZlcnNlTWFwW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkgLSAxKV0gPDwgKChpICUgNCkgKiAyKTtcblx0ICAgICAgICAgICAgICB2YXIgYml0czIgPSByZXZlcnNlTWFwW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkpXSA+Pj4gKDYgLSAoaSAlIDQpICogMik7XG5cdCAgICAgICAgICAgICAgdmFyIGJpdHNDb21iaW5lZCA9IGJpdHMxIHwgYml0czI7XG5cdCAgICAgICAgICAgICAgd29yZHNbbkJ5dGVzID4+PiAyXSB8PSBiaXRzQ29tYmluZWQgPDwgKDI0IC0gKG5CeXRlcyAlIDQpICogOCk7XG5cdCAgICAgICAgICAgICAgbkJ5dGVzKys7XG5cdCAgICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIG5CeXRlcyk7XG5cdCAgICB9XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLkJhc2U2NDtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBwcm90b2NvbG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTApKTtcbnZhciB0cmFuc3BvcnRfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjYpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIGRlZmF1bHRzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKTtcbnZhciBjb25uZWN0aW9uZXJyb3JzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKSk7XG52YXIgYXV0aF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNykpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgWEhSU3RhdGVzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xuLyogVE9ETzogY2FuIHJlbW92ZSBvbmNlIHJlYWx0aW1lIHNlbmRzIHByb3RvY29sIG1lc3NhZ2UgcmVzcG9uc2VzIGZvciBjb21ldCBlcnJvcnMgKi9cbmZ1bmN0aW9uIHNob3VsZEJlRXJyb3JBY3Rpb24oZXJyKSB7XG4gICAgdmFyIFVOUkVTT0xWQUJMRV9FUlJPUl9DT0RFUyA9IFs4MDAxNSwgODAwMTcsIDgwMDMwXTtcbiAgICBpZiAoZXJyLmNvZGUpIHtcbiAgICAgICAgaWYgKGF1dGhfMS5kZWZhdWx0LmlzVG9rZW5FcnIoZXJyKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKFV0aWxzLmFyckluKFVOUkVTT0xWQUJMRV9FUlJPUl9DT0RFUywgZXJyLmNvZGUpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBlcnIuY29kZSA+PSA0MDAwMCAmJiBlcnIuY29kZSA8IDUwMDAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLyogTGlrZWx5IGEgbmV0d29yayBvciB0cmFuc3BvcnQgZXJyb3Igb2Ygc29tZSBraW5kLiBDZXJ0YWlubHkgbm90IGZhdGFsIHRvIHRoZSBjb25uZWN0aW9uICovXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyKSB7XG4gICAgLyogZXJyIHdpbGwgYmUgZWl0aGVyIGEgbGVnYWN5IChub24tcHJvdG9jb2xtZXNzYWdlKSBjb21ldCBlcnJvciByZXNwb25zZVxuICAgICAqICh3aGljaCB3aWxsIGhhdmUgYW4gZXJyLmNvZGUpLCBvciBhIHhoci9uZXR3b3JrIGVycm9yICh3aGljaCB3b24ndCkuICovXG4gICAgaWYgKHNob3VsZEJlRXJyb3JBY3Rpb24oZXJyKSkge1xuICAgICAgICByZXR1cm4gW3Byb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyh7IGFjdGlvbjogcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5BY3Rpb24uRVJST1IsIGVycm9yOiBlcnIgfSldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoeyBhY3Rpb246IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuQWN0aW9uLkRJU0NPTk5FQ1RFRCwgZXJyb3I6IGVyciB9KV07XG4gICAgfVxufVxuLypcbiAqIEEgYmFzZSBjb21ldCB0cmFuc3BvcnQgY2xhc3NcbiAqL1xudmFyIENvbWV0VHJhbnNwb3J0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKENvbWV0VHJhbnNwb3J0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbWV0VHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcywgLyogYmluYXJ5IG5vdCBzdXBwb3J0ZWQgZm9yIGNvbWV0IHNvIGZvcmNlIEpTT04gcHJvdG9jb2wgKi8gdHJ1ZSkgfHwgdGhpcztcbiAgICAgICAgLyogRm9yIGNvbWV0LCB3ZSBjb3VsZCBkbyB0aGUgYXV0aCB1cGRhdGUgYnkgYWJvcnRpbmcgdGhlIGN1cnJlbnQgcmVjdiBhbmRcbiAgICAgICAgICogc3RhcnRpbmcgYSBuZXcgb25lIHdpdGggdGhlIG5ldyB0b2tlbiwgdGhhdCdkIGJlIHN1ZmZpY2llbnQgZm9yIHJlYWx0aW1lLlxuICAgICAgICAgKiBQcm9ibGVtIGlzIEpTT05QIC0geW91IGNhbid0IGNhbmNlbCB0cnVseSBhYm9ydCBhIHJlY3Ygb25jZSBzdGFydGVkLiBTb1xuICAgICAgICAgKiB3ZSBuZWVkIHRvIHNlbmQgYW4gQVVUSCBmb3IganNvbnAuIEluIHdoaWNoIGNhc2UgaXQncyBzaW1wbGVyIHRvIGtlZXAgYWxsXG4gICAgICAgICAqIGNvbWV0IHRyYW5zcG9ydHMgdGhlIHNhbWUgYW5kIGRvIGl0IGZvciBhbGwgb2YgdGhlbS4gU28gd2Ugc2VuZCB0aGUgQVVUSFxuICAgICAgICAgKiBpbnN0ZWFkLCBhbmQgZG9uJ3QgbmVlZCB0byBhYm9ydCB0aGUgcmVjdiAqL1xuICAgICAgICBfdGhpcy5vbkF1dGhVcGRhdGVkID0gZnVuY3Rpb24gKHRva2VuRGV0YWlscykge1xuICAgICAgICAgICAgX3RoaXMuYXV0aFBhcmFtcyA9IHsgYWNjZXNzX3Rva2VuOiB0b2tlbkRldGFpbHMudG9rZW4gfTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc3RyZWFtID0gJ3N0cmVhbScgaW4gcGFyYW1zID8gcGFyYW1zLnN0cmVhbSA6IHRydWU7XG4gICAgICAgIF90aGlzLnNlbmRSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgX3RoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuICAgICAgICBfdGhpcy5wZW5kaW5nQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICBfdGhpcy5wZW5kaW5nSXRlbXMgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdzdGFydGluZycpO1xuICAgICAgICB0cmFuc3BvcnRfMS5kZWZhdWx0LnByb3RvdHlwZS5jb25uZWN0LmNhbGwodGhpcyk7XG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucztcbiAgICAgICAgdmFyIGhvc3QgPSBkZWZhdWx0c18xLmRlZmF1bHQuZ2V0SG9zdChvcHRpb25zLCBwYXJhbXMuaG9zdCk7XG4gICAgICAgIHZhciBwb3J0ID0gZGVmYXVsdHNfMS5kZWZhdWx0LmdldFBvcnQob3B0aW9ucyk7XG4gICAgICAgIHZhciBjb21ldFNjaGVtZSA9IG9wdGlvbnMudGxzID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJztcbiAgICAgICAgdGhpcy5iYXNlVXJpID0gY29tZXRTY2hlbWUgKyBob3N0ICsgJzonICsgcG9ydCArICcvY29tZXQvJztcbiAgICAgICAgdmFyIGNvbm5lY3RVcmkgPSB0aGlzLmJhc2VVcmkgKyAnY29ubmVjdCc7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29tZXRUcmFuc3BvcnQuY29ubmVjdCgpJywgJ3VyaTogJyArIGNvbm5lY3RVcmkpO1xuICAgICAgICB0aGlzLmF1dGguZ2V0QXV0aFBhcmFtcyhmdW5jdGlvbiAoZXJyLCBhdXRoUGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGlzY29ubmVjdChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuYXV0aFBhcmFtcyA9IGF1dGhQYXJhbXM7XG4gICAgICAgICAgICB2YXIgY29ubmVjdFBhcmFtcyA9IF90aGlzLnBhcmFtcy5nZXRDb25uZWN0UGFyYW1zKGF1dGhQYXJhbXMpO1xuICAgICAgICAgICAgaWYgKCdzdHJlYW0nIGluIGNvbm5lY3RQYXJhbXMpXG4gICAgICAgICAgICAgICAgX3RoaXMuc3RyZWFtID0gY29ubmVjdFBhcmFtcy5zdHJlYW07XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdjb25uZWN0UGFyYW1zOicgKyBVdGlscy50b1F1ZXJ5U3RyaW5nKGNvbm5lY3RQYXJhbXMpKTtcbiAgICAgICAgICAgIC8qIHRoaXMgd2lsbCBiZSB0aGUgJ3JlY3ZSZXF1ZXN0JyBzbyB0aGlzIGNvbm5lY3Rpb24gY2FuIHN0cmVhbSBtZXNzYWdlcyAqL1xuICAgICAgICAgICAgdmFyIHByZWNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGNvbm5lY3RSZXF1ZXN0ID0gKF90aGlzLnJlY3ZSZXF1ZXN0ID0gX3RoaXMuY3JlYXRlUmVxdWVzdChjb25uZWN0VXJpLCBudWxsLCBjb25uZWN0UGFyYW1zLCBudWxsLCBfdGhpcy5zdHJlYW0gPyBYSFJTdGF0ZXNfMS5kZWZhdWx0LlJFUV9SRUNWX1NUUkVBTSA6IFhIUlN0YXRlc18xLmRlZmF1bHQuUkVRX1JFQ1YpKTtcbiAgICAgICAgICAgIGNvbm5lY3RSZXF1ZXN0Lm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnJlY3ZSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIHRoZSB0cmFuc3BvcnQgd2FzIGRpc3Bvc2VkIGJlZm9yZSB3ZSBjb25uZWN0ZWQgKi9cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXByZWNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdwcmVjb25uZWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLm9uRGF0YShkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29ubmVjdFJlcXVlc3Qub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMucmVjdlJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogdGhlIHRyYW5zcG9ydCB3YXMgZGlzcG9zZWQgYmVmb3JlIHdlIGNvbm5lY3RlZCAqL1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSBlcnIgfHwgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1JlcXVlc3QgY2FuY2VsbGVkJywgODAwMDMsIDQwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnJlY3ZSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvKiBDb25uZWN0IHJlcXVlc3QgbWF5IGNvbXBsZXRlIHdpdGhvdXQgYSBlbWl0dGluZyAnZGF0YScgZXZlbnQgc2luY2UgdGhhdCBpcyBub3RcbiAgICAgICAgICAgICAgICAgKiBlbWl0dGVkIGZvciBlLmcuIGEgbm9uLXN0cmVhbWVkIGVycm9yIHJlc3BvbnNlLiBTdGlsbCBpbXBsaWVzIHByZWNvbm5lY3QuICovXG4gICAgICAgICAgICAgICAgaWYgKCFwcmVjb25uZWN0ZWQgJiYgIWVycikge1xuICAgICAgICAgICAgICAgICAgICBwcmVjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdwcmVjb25uZWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLm9uQWN0aXZpdHkoKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogQSBwcm90b2NvbCBlcnJvciByZWNlaXZlZCBmcm9tIHJlYWx0aW1lLiBUT0RPOiBvbmNlIHJlYWx0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBjb25zaXN0ZW5kbHkgc2VuZHMgZXJyb3JzIHdyYXBwZWQgaW4gcHJvdG9jb2wgbWVzc2FnZXMsIHNob3VsZCBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogYWJsZSB0byByZW1vdmUgdGhpcyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25EYXRhKHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIEEgbmV0d29yay94aHIgZXJyb3IuIERvbid0IGJvdGhlciB3cmFwcGluZyBpbiBhIHByb3RvY29sIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBqdXN0IGRpc2Nvbm5lY3QgdGhlIHRyYW5zcG9ydCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzY29ubmVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlY3YoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29ubmVjdFJlcXVlc3QuZXhlYygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5yZXF1ZXN0Q2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29tZXRUcmFuc3BvcnQucmVxdWVzdENsb3NlKCknKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdENsb3NlT3JEaXNjb25uZWN0KHRydWUpO1xuICAgIH07XG4gICAgQ29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnJlcXVlc3REaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LnJlcXVlc3REaXNjb25uZWN0KCknKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdENsb3NlT3JEaXNjb25uZWN0KGZhbHNlKTtcbiAgICB9O1xuICAgIENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5fcmVxdWVzdENsb3NlT3JEaXNjb25uZWN0ID0gZnVuY3Rpb24gKGNsb3NpbmcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNsb3NlT3JEaXNjb25uZWN0VXJpID0gY2xvc2luZyA/IHRoaXMuY2xvc2VVcmkgOiB0aGlzLmRpc2Nvbm5lY3RVcmk7XG4gICAgICAgIGlmIChjbG9zZU9yRGlzY29ubmVjdFVyaSkge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLmNyZWF0ZVJlcXVlc3QoY2xvc2VPckRpc2Nvbm5lY3RVcmksIG51bGwsIHRoaXMuYXV0aFBhcmFtcywgbnVsbCwgWEhSU3RhdGVzXzEuZGVmYXVsdC5SRVFfU0VORCk7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQ29tZXRUcmFuc3BvcnQucmVxdWVzdCcgKyAoY2xvc2luZyA/ICdDbG9zZSgpJyA6ICdEaXNjb25uZWN0KCknKSwgJ3JlcXVlc3QgcmV0dXJuZWQgZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmluaXNoKCdkaXNjb25uZWN0ZWQnLCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdC5leGVjKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LmRpc3Bvc2UoKScsICcnKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWN2UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29tZXRUcmFuc3BvcnQuZGlzcG9zZSgpJywgJ2Fib3J0aW5nIHJlY3YgcmVxdWVzdCcpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVjdlJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY3ZSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIEluIGFsbW9zdCBhbGwgY2FzZXMgdGhlIHRyYW5zcG9ydCB3aWxsIGJlIGZpbmlzaGVkIGJlZm9yZSBpdCdzXG4gICAgICAgICAgICAgKiBkaXNwb3NlZC4gRmluaXNoIGhlcmUganVzdCB0byBtYWtlIHN1cmUuICovXG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgY29ubmVjdGlvbmVycm9yc18xLmRlZmF1bHQuZGlzY29ubmVjdGVkKCkpO1xuICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnZGlzcG9zZWQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUub25Db25uZWN0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvKiBpZiB0aGlzIHRyYW5zcG9ydCBoYXMgYmVlbiBkaXNwb3NlZCB3aGlsc3QgYXdhaXRpbmcgY29ubmVjdGlvbiwgZG8gbm90aGluZyAqL1xuICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyogdGhlIGNvbm5lY3Rpb25LZXkgaW4gYSBjb21ldCBjb25uZWN0ZWQgcmVzcG9uc2UgaXMgcmVhbGx5XG4gICAgICAgICAqIDxpbnN0SWQ+LTxjb25uZWN0aW9uS2V5PiAqL1xuICAgICAgICB2YXIgY29ubmVjdGlvblN0ciA9IChfYSA9IG1lc3NhZ2UuY29ubmVjdGlvbkRldGFpbHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25uZWN0aW9uS2V5O1xuICAgICAgICB0cmFuc3BvcnRfMS5kZWZhdWx0LnByb3RvdHlwZS5vbkNvbm5lY3QuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgdmFyIGJhc2VDb25uZWN0aW9uVXJpID0gdGhpcy5iYXNlVXJpICsgY29ubmVjdGlvblN0cjtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb21ldFRyYW5zcG9ydC5vbkNvbm5lY3QoKScsICdiYXNlVXJpID0gJyArIGJhc2VDb25uZWN0aW9uVXJpKTtcbiAgICAgICAgdGhpcy5zZW5kVXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyAnL3NlbmQnO1xuICAgICAgICB0aGlzLnJlY3ZVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArICcvcmVjdic7XG4gICAgICAgIHRoaXMuY2xvc2VVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArICcvY2xvc2UnO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArICcvZGlzY29ubmVjdCc7XG4gICAgfTtcbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbmRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAvKiB0aGVyZSBpcyBhIHBlbmRpbmcgc2VuZCwgc28gcXVldWUgdGhpcyBtZXNzYWdlICovXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdJdGVtcyA9IHRoaXMucGVuZGluZ0l0ZW1zIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nSXRlbXMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBzZW5kIHRoaXMsIHBsdXMgYW55IHBlbmRpbmcsIG5vdyAqL1xuICAgICAgICB2YXIgcGVuZGluZ0l0ZW1zID0gdGhpcy5wZW5kaW5nSXRlbXMgfHwgW107XG4gICAgICAgIHBlbmRpbmdJdGVtcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnBlbmRpbmdJdGVtcyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VuZEl0ZW1zKHBlbmRpbmdJdGVtcyk7XG4gICAgfTtcbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZEFueVBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwZW5kaW5nSXRlbXMgPSB0aGlzLnBlbmRpbmdJdGVtcztcbiAgICAgICAgaWYgKCFwZW5kaW5nSXRlbXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdJdGVtcyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VuZEl0ZW1zKHBlbmRpbmdJdGVtcyk7XG4gICAgfTtcbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZEl0ZW1zID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZW5kUmVxdWVzdCA9ICh0aGlzLnNlbmRSZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KHRoaXMuc2VuZFVyaSwgbnVsbCwgdGhpcy5hdXRoUGFyYW1zLCB0aGlzLmVuY29kZVJlcXVlc3QoaXRlbXMpLCBYSFJTdGF0ZXNfMS5kZWZhdWx0LlJFUV9TRU5EKSk7XG4gICAgICAgIHNlbmRSZXF1ZXN0Lm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDb21ldFRyYW5zcG9ydC5zZW5kSXRlbXMoKScsICdvbiBjb21wbGV0ZTogZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgICAgIF90aGlzLnNlbmRSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIC8qIHRoZSByZXN1bHQgb2YgdGhlIHJlcXVlc3QsIGV2ZW4gaWYgYSBuYWNrLCBpcyB1c3VhbGx5IGEgcHJvdG9jb2wgcmVzcG9uc2VcbiAgICAgICAgICAgICAqIGNvbnRhaW5lZCBpbiB0aGUgZGF0YS4gQW4gZXJyIGlzIGFub21vbG91cywgYW5kIGluZGljYXRlcyBzb21lIGlzc3VlIHdpdGggdGhlXG4gICAgICAgICAgICAgKiBuZXR3b3JrLHRyYW5zcG9ydCwgb3IgY29ubmVjdGlvbiAqL1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAvKiBBIHByb3RvY29sIGVycm9yIHJlY2VpdmVkIGZyb20gcmVhbHRpbWUuIFRPRE86IG9uY2UgcmVhbHRpbWVcbiAgICAgICAgICAgICAgICAgICAgICogY29uc2lzdGVuZGx5IHNlbmRzIGVycm9ycyB3cmFwcGVkIGluIHByb3RvY29sIG1lc3NhZ2VzLCBzaG91bGQgYmVcbiAgICAgICAgICAgICAgICAgICAgICogYWJsZSB0byByZW1vdmUgdGhpcyAqL1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkRhdGEocHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLyogQSBuZXR3b3JrL3hociBlcnJvci4gRG9uJ3QgYm90aGVyIHdyYXBwaW5nIGluIGEgcHJvdG9jb2wgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICoganVzdCBkaXNjb25uZWN0IHRoZSB0cmFuc3BvcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzY29ubmVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uRGF0YShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5wZW5kaW5nSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogSWYgdGhlcmUncyBhIG5ldyBzZW5kIHJlcXVlc3QgYnkgbm93LCBhbnkgcGVuZGluZyBpdGVtcyB3aWxsIGhhdmVcbiAgICAgICAgICAgICAgICAgICAgICogYmVlbiBwaWNrZWQgdXAgYnkgdGhhdDsgYW55IG5ldyBvbmVzIGFkZGVkIHNpbmNlIHRoZW4gd2lsbCBiZVxuICAgICAgICAgICAgICAgICAgICAgKiBwaWNrZWQgdXAgYWZ0ZXIgdGhhdCBvbmUgY29tcGxldGVzICovXG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuc2VuZFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNlbmRBbnlQZW5kaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNlbmRSZXF1ZXN0LmV4ZWMoKTtcbiAgICB9O1xuICAgIENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5yZWN2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiBkbyBub3RoaW5nIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSByZXF1ZXN0LCB3aGljaCBtaWdodCBiZSBzdHJlYW1pbmcgKi9cbiAgICAgICAgaWYgKHRoaXMucmVjdlJlcXVlc3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8qIElmIHdlJ3JlIG5vIGxvbmdlciBjb25uZWN0ZWQsIGRvIG5vdGhpbmcgKi9cbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgcmVjdlJlcXVlc3QgPSAodGhpcy5yZWN2UmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdCh0aGlzLnJlY3ZVcmksIG51bGwsIHRoaXMuYXV0aFBhcmFtcywgbnVsbCwgdGhpcy5zdHJlYW0gPyBYSFJTdGF0ZXNfMS5kZWZhdWx0LlJFUV9SRUNWX1NUUkVBTSA6IFhIUlN0YXRlc18xLmRlZmF1bHQuUkVRX1JFQ1ZfUE9MTCkpO1xuICAgICAgICByZWN2UmVxdWVzdC5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBfdGhpcy5vbkRhdGEoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZWN2UmVxdWVzdC5vbignY29tcGxldGUnLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBfdGhpcy5yZWN2UmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICAvKiBBIHJlcXVlc3QgY29tcGxldGluZyBtdXN0IGJlIGNvbnNpZGVyZWQgYWN0aXZpdHksIGFzIHJlYWx0aW1lIHNlbmRzXG4gICAgICAgICAgICAgKiBoZWFydGJlYXRzIGV2ZXJ5IDE1cyBzaW5jZSBhIHJlcXVlc3QgYmVnYW4sIG5vdCBldmVyeSAxNXMgYWJzb2x1dGVseSAqL1xuICAgICAgICAgICAgX3RoaXMub25BY3Rpdml0eSgpO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAvKiBBIHByb3RvY29sIGVycm9yIHJlY2VpdmVkIGZyb20gcmVhbHRpbWUuIFRPRE86IG9uY2UgcmVhbHRpbWVcbiAgICAgICAgICAgICAgICAgICAgICogY29uc2lzdGVudGx5IHNlbmRzIGVycm9ycyB3cmFwcGVkIGluIHByb3RvY29sIG1lc3NhZ2VzLCBzaG91bGQgYmVcbiAgICAgICAgICAgICAgICAgICAgICogYWJsZSB0byByZW1vdmUgdGhpcyAqL1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkRhdGEocHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLyogQSBuZXR3b3JrL3hociBlcnJvci4gRG9uJ3QgYm90aGVyIHdyYXBwaW5nIGluIGEgcHJvdG9jb2wgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICoganVzdCBkaXNjb25uZWN0IHRoZSB0cmFuc3BvcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzY29ubmVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWN2KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlY3ZSZXF1ZXN0LmV4ZWMoKTtcbiAgICB9O1xuICAgIENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAocmVzcG9uc2VEYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLmRlY29kZVJlc3BvbnNlKHJlc3BvbnNlRGF0YSk7XG4gICAgICAgICAgICBpZiAoaXRlbXMgJiYgaXRlbXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Qcm90b2NvbE1lc3NhZ2UocHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5mcm9tRGVzZXJpYWxpemVkKGl0ZW1zW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQ29tZXRUcmFuc3BvcnQub25EYXRhKCknLCAnVW5leHBlY3RlZCBleGNlcHRpb24gaGFuZGluZyBjaGFubmVsIGV2ZW50OiAnICsgZS5zdGFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5lbmNvZGVSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3RJdGVtcykge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVxdWVzdEl0ZW1zKTtcbiAgICB9O1xuICAgIENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5kZWNvZGVSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZURhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZURhdGEgPT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXNwb25zZURhdGEpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VEYXRhO1xuICAgIH07XG4gICAgcmV0dXJuIENvbWV0VHJhbnNwb3J0O1xufSh0cmFuc3BvcnRfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDb21ldFRyYW5zcG9ydDtcblxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBhdXRoXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSk7XG52YXIgSHR0cE1ldGhvZHNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTgpKTtcbnZhciBlcnJvcmluZm9fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5mdW5jdGlvbiB3aXRoQXV0aERldGFpbHMocmVzdCwgaGVhZGVycywgcGFyYW1zLCBlcnJDYWxsYmFjaywgb3BDYWxsYmFjaykge1xuICAgIGlmIChyZXN0Lmh0dHAuc3VwcG9ydHNBdXRoSGVhZGVycykge1xuICAgICAgICByZXN0LmF1dGguZ2V0QXV0aEhlYWRlcnMoZnVuY3Rpb24gKGVyciwgYXV0aEhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgZXJyQ2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvcENhbGxiYWNrKFV0aWxzLm1peGluKGF1dGhIZWFkZXJzLCBoZWFkZXJzKSwgcGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN0LmF1dGguZ2V0QXV0aFBhcmFtcyhmdW5jdGlvbiAoZXJyLCBhdXRoUGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgIGVyckNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb3BDYWxsYmFjayhoZWFkZXJzLCBVdGlscy5taXhpbihhdXRoUGFyYW1zLCBwYXJhbXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdW5lbnZlbG9wZShjYWxsYmFjaywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIsIGJvZHksIG91dGVySGVhZGVycywgdW5wYWNrZWQsIG91dGVyU3RhdHVzQ29kZSkge1xuICAgICAgICBpZiAoZXJyICYmICFib2R5KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdW5wYWNrZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IFV0aWxzLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKFV0aWxzLmlzRXJyb3JJbmZvT3JQYXJ0aWFsRXJyb3JJbmZvKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oVXRpbHMuaW5zcGVjdEVycm9yKGUpLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCd1bmVudmVsb3BlKCk6IFJlc3BvbnNlIGJvZHkgaXMgbWlzc2luZycsIG51bGwpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSBib2R5LCB3cmFwcGVkU3RhdHVzQ29kZSA9IF9hLnN0YXR1c0NvZGUsIHJlc3BvbnNlID0gX2EucmVzcG9uc2UsIHdyYXBwZWRIZWFkZXJzID0gX2EuaGVhZGVycztcbiAgICAgICAgaWYgKHdyYXBwZWRTdGF0dXNDb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8qIEVudmVsb3BlIGFscmVhZHkgdW53cmFwcGVkIGJ5IHRoZSB0cmFuc3BvcnQgKi9cbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgYm9keSwgb3V0ZXJIZWFkZXJzLCB0cnVlLCBvdXRlclN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwcGVkU3RhdHVzQ29kZSA8IDIwMCB8fCB3cmFwcGVkU3RhdHVzQ29kZSA+PSAzMDApIHtcbiAgICAgICAgICAgIC8qIGhhbmRsZSB3cmFwcGVkIGVycm9ycyAqL1xuICAgICAgICAgICAgdmFyIHdyYXBwZWRFcnIgPSAocmVzcG9uc2UgJiYgcmVzcG9uc2UuZXJyb3IpIHx8IGVycjtcbiAgICAgICAgICAgIGlmICghd3JhcHBlZEVycikge1xuICAgICAgICAgICAgICAgIHdyYXBwZWRFcnIgPSBuZXcgRXJyb3IoJ0Vycm9yIGluIHVuZW52ZWxvcGluZyAnICsgYm9keSk7XG4gICAgICAgICAgICAgICAgd3JhcHBlZEVyci5zdGF0dXNDb2RlID0gd3JhcHBlZFN0YXR1c0NvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayh3cmFwcGVkRXJyLCByZXNwb25zZSwgd3JhcHBlZEhlYWRlcnMsIHRydWUsIHdyYXBwZWRTdGF0dXNDb2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlLCB3cmFwcGVkSGVhZGVycywgdHJ1ZSwgd3JhcHBlZFN0YXR1c0NvZGUpO1xuICAgIH07XG59XG5mdW5jdGlvbiBwYXJhbVN0cmluZyhwYXJhbXMpIHtcbiAgICB2YXIgcGFyYW1QYWlycyA9IFtdO1xuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgZm9yICh2YXIgbmVlZGxlIGluIHBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1QYWlycy5wdXNoKG5lZWRsZSArICc9JyArIHBhcmFtc1tuZWVkbGVdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyYW1QYWlycy5qb2luKCcmJyk7XG59XG5mdW5jdGlvbiB1cmxGcm9tUGF0aEFuZFBhcmFtcyhwYXRoLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gcGF0aCArIChwYXJhbXMgPyAnPycgOiAnJykgKyBwYXJhbVN0cmluZyhwYXJhbXMpO1xufVxuZnVuY3Rpb24gbG9nUmVzcG9uc2VIYW5kbGVyKGNhbGxiYWNrLCBtZXRob2QsIHBhdGgsIHBhcmFtcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1Jlc291cmNlLicgKyBtZXRob2QgKyAnKCknLCAnUmVjZWl2ZWQgRXJyb3I7ICcgKyB1cmxGcm9tUGF0aEFuZFBhcmFtcyhwYXRoLCBwYXJhbXMpICsgJzsgRXJyb3I6ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1Jlc291cmNlLicgKyBtZXRob2QgKyAnKCknLCAnUmVjZWl2ZWQ7ICcgK1xuICAgICAgICAgICAgICAgIHVybEZyb21QYXRoQW5kUGFyYW1zKHBhdGgsIHBhcmFtcykgK1xuICAgICAgICAgICAgICAgICc7IEhlYWRlcnM6ICcgK1xuICAgICAgICAgICAgICAgIHBhcmFtU3RyaW5nKGhlYWRlcnMpICtcbiAgICAgICAgICAgICAgICAnOyBTdGF0dXNDb2RlOiAnICtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlICtcbiAgICAgICAgICAgICAgICAnOyBCb2R5OiAnICtcbiAgICAgICAgICAgICAgICAocGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGJvZHkpID8gYm9keS50b1N0cmluZygpIDogYm9keSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxudmFyIFJlc291cmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc291cmNlKCkge1xuICAgIH1cbiAgICBSZXNvdXJjZS5nZXQgPSBmdW5jdGlvbiAocmVzdCwgcGF0aCwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spIHtcbiAgICAgICAgUmVzb3VyY2UuZG8oSHR0cE1ldGhvZHNfMS5kZWZhdWx0LkdldCwgcmVzdCwgcGF0aCwgbnVsbCwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVzb3VyY2UuZGVsZXRlID0gZnVuY3Rpb24gKHJlc3QsIHBhdGgsIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIFJlc291cmNlLmRvKEh0dHBNZXRob2RzXzEuZGVmYXVsdC5EZWxldGUsIHJlc3QsIHBhdGgsIG51bGwsIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlc291cmNlLnBvc3QgPSBmdW5jdGlvbiAocmVzdCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spIHtcbiAgICAgICAgUmVzb3VyY2UuZG8oSHR0cE1ldGhvZHNfMS5kZWZhdWx0LlBvc3QsIHJlc3QsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlc291cmNlLnBhdGNoID0gZnVuY3Rpb24gKHJlc3QsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIFJlc291cmNlLmRvKEh0dHBNZXRob2RzXzEuZGVmYXVsdC5QYXRjaCwgcmVzdCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVzb3VyY2UucHV0ID0gZnVuY3Rpb24gKHJlc3QsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIFJlc291cmNlLmRvKEh0dHBNZXRob2RzXzEuZGVmYXVsdC5QdXQsIHJlc3QsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlc291cmNlLmRvID0gZnVuY3Rpb24gKG1ldGhvZCwgcmVzdCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGxvZ2dlcl8xLmRlZmF1bHQuc2hvdWxkTG9nKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBsb2dSZXNwb25zZUhhbmRsZXIoY2FsbGJhY2ssIG1ldGhvZCwgcGF0aCwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW52ZWxvcGUpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdW5lbnZlbG9wZShjYWxsYmFjaywgZW52ZWxvcGUpO1xuICAgICAgICAgICAgKHBhcmFtcyA9IHBhcmFtcyB8fCB7fSlbJ2VudmVsb3BlJ10gPSBlbnZlbG9wZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkb1JlcXVlc3QoaGVhZGVycywgcGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAobG9nZ2VyXzEuZGVmYXVsdC5zaG91bGRMb2cobG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZXNvdXJjZS4nICsgbWV0aG9kICsgJygpJywgJ1NlbmRpbmc7ICcgKyB1cmxGcm9tUGF0aEFuZFBhcmFtcyhwYXRoLCBwYXJhbXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb2dnZXJfMS5kZWZhdWx0LnNob3VsZExvZyhsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVjb2RlZEJvZHkgPSBib2R5O1xuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gaGVhZGVyc1snY29udGVudC10eXBlJ10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmRleE9mKCdtc2dwYWNrJykpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZEJvZHkgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm1zZ3BhY2suZGVjb2RlKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChkZWNvZGVFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVzb3VyY2UuJyArIG1ldGhvZCArICcoKScsICdTZW5kaW5nIE1zZ1BhY2sgRGVjb2RpbmcgRXJyb3I6ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZGVjb2RlRXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZXNvdXJjZS4nICsgbWV0aG9kICsgJygpJywgJ1NlbmRpbmc7ICcgKyB1cmxGcm9tUGF0aEFuZFBhcmFtcyhwYXRoLCBwYXJhbXMpICsgJzsgQm9keTogJyArIGRlY29kZWRCb2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3QuaHR0cC5kbyhtZXRob2QsIHJlc3QsIHBhdGgsIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgZnVuY3Rpb24gKGVyciwgcmVzLCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgYXV0aF8xLmRlZmF1bHQuaXNUb2tlbkVycihlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIHRva2VuIGhhcyBleHBpcmVkLCBzbyBnZXQgYSBuZXcgb25lICovXG4gICAgICAgICAgICAgICAgICAgIHJlc3QuYXV0aC5hdXRob3JpemUobnVsbCwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLyogcmV0cnkgLi4uICovXG4gICAgICAgICAgICAgICAgICAgICAgICB3aXRoQXV0aERldGFpbHMocmVzdCwgaGVhZGVycywgcGFyYW1zLCBjYWxsYmFjaywgZG9SZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXMsIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHdpdGhBdXRoRGV0YWlscyhyZXN0LCBoZWFkZXJzLCBwYXJhbXMsIGNhbGxiYWNrLCBkb1JlcXVlc3QpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc291cmNlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlc291cmNlO1xuXG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciBtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDkpKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xuZnVuY3Rpb24gdG9BY3Rpb25WYWx1ZShhY3Rpb25TdHJpbmcpIHtcbiAgICByZXR1cm4gUHJlc2VuY2VNZXNzYWdlLkFjdGlvbnMuaW5kZXhPZihhY3Rpb25TdHJpbmcpO1xufVxudmFyIFByZXNlbmNlTWVzc2FnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcmVzZW5jZU1lc3NhZ2UoKSB7XG4gICAgfVxuICAgIC8qIFJldHVybnMgd2hldGhlciB0aGlzIHByZXNlbmNlTWVzc2FnZSBpcyBzeW50aGVzaXplZCwgaS5lLiB3YXMgbm90IGFjdHVhbGx5XG4gICAgICogc2VudCBieSB0aGUgY29ubmVjdGlvbiAodXN1YWxseSBtZWFucyBhIGxlYXZlIGV2ZW50IHNlbnQgMTVzIGFmdGVyIGFcbiAgICAgKiBkaXNjb25uZWN0aW9uKS4gVGhpcyBpcyB1c2VmdWwgYmVjYXVzZSBzeW50aGVzaXplZCBtZXNzYWdlcyBjYW5ub3QgYmVcbiAgICAgKiBjb21wYXJlZCBmb3IgbmV3bmVzcyBieSBpZCBsZXhpY29ncmFwaGljYWxseSAtIFJUUDJiMVxuICAgICAqL1xuICAgIFByZXNlbmNlTWVzc2FnZS5wcm90b3R5cGUuaXNTeW50aGVzaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlkIHx8ICF0aGlzLmNvbm5lY3Rpb25JZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaWQuc3Vic3RyaW5nKHRoaXMuY29ubmVjdGlvbklkLmxlbmd0aCwgMCkgIT09IHRoaXMuY29ubmVjdGlvbklkO1xuICAgIH07XG4gICAgLyogUlRQMmIyICovXG4gICAgUHJlc2VuY2VNZXNzYWdlLnByb3RvdHlwZS5wYXJzZUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnNlSWQoKTogUHJlc2VuY2UgbWVzc2FnZSBkb2VzIG5vdCBjb250YWluIGFuIGlkJyk7XG4gICAgICAgIHZhciBwYXJ0cyA9IHRoaXMuaWQuc3BsaXQoJzonKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogcGFydHNbMF0sXG4gICAgICAgICAgICBtc2dTZXJpYWw6IHBhcnNlSW50KHBhcnRzWzFdLCAxMCksXG4gICAgICAgICAgICBpbmRleDogcGFyc2VJbnQocGFydHNbMl0sIDEwKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE92ZXJsb2FkIHRvSlNPTigpIHRvIGludGVyY2VwdCBKU09OLnN0cmluZ2lmeSgpXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBQcmVzZW5jZU1lc3NhZ2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyogZW5jb2RlIGRhdGEgdG8gYmFzZTY0IGlmIHByZXNlbnQgYW5kIHdlJ3JlIHJldHVybmluZyByZWFsIEpTT047XG4gICAgICAgICAqIGFsdGhvdWdoIG1zZ3BhY2sgY2FsbHMgdG9KU09OKCksIHdlIGtub3cgaXQgaXMgYSBzdHJpbmdpZnkoKVxuICAgICAgICAgKiBjYWxsIGlmIGl0IGhhcyBhIG5vbi1lbXB0eSBhcmd1bWVudHMgbGlzdCAqL1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgdmFyIGVuY29kaW5nID0gdGhpcy5lbmNvZGluZztcbiAgICAgICAgaWYgKGRhdGEgJiYgcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvKiBzdHJpbmdpZnkgY2FsbCAqL1xuICAgICAgICAgICAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgPyBlbmNvZGluZyArICcvYmFzZTY0JyA6ICdiYXNlNjQnO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogQ2FsbGVkIGJ5IG1zZ3BhY2suIHRvQnVmZmVyIHJldHVybnMgYSBkYXRhdHlwZSB1bmRlcnN0YW5kYWJsZSBieVxuICAgICAgICAgICAgICAgICAqIHRoYXQgcGxhdGZvcm0ncyBtc2dwYWNrIGltcGxlbWVudGF0aW9uIChCdWZmZXIgaW4gbm9kZSwgVWludDhBcnJheVxuICAgICAgICAgICAgICAgICAqIGluIGJyb3dzZXJzKSAqL1xuICAgICAgICAgICAgICAgIGRhdGEgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMudG9CdWZmZXIoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgICAgICAvKiBDb252ZXJ0IHByZXNlbmNlIGFjdGlvbiBiYWNrIHRvIGFuIGludCBmb3Igc2VuZGluZyB0byBBYmx5ICovXG4gICAgICAgICAgICBhY3Rpb246IHRvQWN0aW9uVmFsdWUodGhpcy5hY3Rpb24pLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgICAgICAgIGV4dHJhczogdGhpcy5leHRyYXMsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBQcmVzZW5jZU1lc3NhZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJ1tQcmVzZW5jZU1lc3NhZ2UnO1xuICAgICAgICByZXN1bHQgKz0gJzsgYWN0aW9uPScgKyB0aGlzLmFjdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuaWQpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgaWQ9JyArIHRoaXMuaWQ7XG4gICAgICAgIGlmICh0aGlzLnRpbWVzdGFtcClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyB0aW1lc3RhbXA9JyArIHRoaXMudGltZXN0YW1wO1xuICAgICAgICBpZiAodGhpcy5jbGllbnRJZClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBjbGllbnRJZD0nICsgdGhpcy5jbGllbnRJZDtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbklkKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGNvbm5lY3Rpb25JZD0nICsgdGhpcy5jb25uZWN0aW9uSWQ7XG4gICAgICAgIGlmICh0aGlzLmVuY29kaW5nKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGVuY29kaW5nPScgKyB0aGlzLmVuY29kaW5nO1xuICAgICAgICBpZiAodGhpcy5kYXRhKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGF0YSA9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJzsgZGF0YT0nICsgdGhpcy5kYXRhO1xuICAgICAgICAgICAgZWxzZSBpZiAocGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmlzQnVmZmVyKHRoaXMuZGF0YSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGRhdGEgKGJ1ZmZlcik9JyArIHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUodGhpcy5kYXRhKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJzsgZGF0YSAoanNvbik9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXh0cmFzKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgZXh0cmFzPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmV4dHJhcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICddJztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFByZXNlbmNlTWVzc2FnZS5mcm9tUmVzcG9uc2VCb2R5ID0gZnVuY3Rpb24gKGJvZHksIG9wdGlvbnMsIGZvcm1hdCkge1xuICAgICAgICB2YXIgbWVzc2FnZXMgPSBbXTtcbiAgICAgICAgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgYm9keSA9IFV0aWxzLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAobWVzc2FnZXNbaV0gPSBQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyhib2R5W2ldLCB0cnVlKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIFByZXNlbmNlTWVzc2FnZS5kZWNvZGUobXNnLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdQcmVzZW5jZU1lc3NhZ2UuZnJvbVJlc3BvbnNlQm9keSgpJywgZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uICh2YWx1ZXMsIHN0cmluZ2lmeUFjdGlvbikge1xuICAgICAgICBpZiAoc3RyaW5naWZ5QWN0aW9uKSB7XG4gICAgICAgICAgICB2YWx1ZXMuYWN0aW9uID0gUHJlc2VuY2VNZXNzYWdlLkFjdGlvbnNbdmFsdWVzLmFjdGlvbl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFByZXNlbmNlTWVzc2FnZSgpLCB2YWx1ZXMpO1xuICAgIH07XG4gICAgUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXNBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gdmFsdWVzLmxlbmd0aCwgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKVxuICAgICAgICAgICAgcmVzdWx0W2ldID0gUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXModmFsdWVzW2ldKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFByZXNlbmNlTWVzc2FnZS5mcm9tRW5jb2RlZCA9IGZ1bmN0aW9uIChlbmNvZGVkLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtc2cgPSBQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyhlbmNvZGVkLCB0cnVlKTtcbiAgICAgICAgLyogaWYgZGVjb2RpbmcgZmFpbHMgYXQgYW55IHBvaW50LCBjYXRjaCBhbmQgcmV0dXJuIHRoZSBtZXNzYWdlIGRlY29kZWQgdG9cbiAgICAgICAgICogdGhlIGZ1bGxlc3QgZXh0ZW50IHBvc3NpYmxlICovXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBQcmVzZW5jZU1lc3NhZ2UuZGVjb2RlKG1zZywgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1ByZXNlbmNlTWVzc2FnZS5mcm9tRW5jb2RlZCgpJywgZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXNnO1xuICAgIH07XG4gICAgUHJlc2VuY2VNZXNzYWdlLmZyb21FbmNvZGVkQXJyYXkgPSBmdW5jdGlvbiAoZW5jb2RlZEFycmF5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVkQXJyYXkubWFwKGZ1bmN0aW9uIChlbmNvZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJlc2VuY2VNZXNzYWdlLmZyb21FbmNvZGVkKGVuY29kZWQsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFByZXNlbmNlTWVzc2FnZS5mcm9tRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgUHJlc2VuY2VNZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1lc3NhZ2UuQWN0aW9ucyA9IFsnYWJzZW50JywgJ3ByZXNlbnQnLCAnZW50ZXInLCAnbGVhdmUnLCAndXBkYXRlJ107XG4gICAgUHJlc2VuY2VNZXNzYWdlLmVuY29kZSA9IG1lc3NhZ2VfMS5kZWZhdWx0LmVuY29kZTtcbiAgICBQcmVzZW5jZU1lc3NhZ2UuZGVjb2RlID0gbWVzc2FnZV8xLmRlZmF1bHQuZGVjb2RlO1xuICAgIFByZXNlbmNlTWVzc2FnZS5nZXRNZXNzYWdlc1NpemUgPSBtZXNzYWdlXzEuZGVmYXVsdC5nZXRNZXNzYWdlc1NpemU7XG4gICAgcmV0dXJuIFByZXNlbmNlTWVzc2FnZTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQcmVzZW5jZU1lc3NhZ2U7XG5cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGV2ZW50ZW1pdHRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIGRlZmF1bHRzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKTtcbnZhciBYSFJTdGF0ZXNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjEpKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG5mdW5jdGlvbiBpc0FibHlFcnJvcihyZXNwb25zZUJvZHksIGhlYWRlcnMpIHtcbiAgICByZXR1cm4gVXRpbHMuYXJySW4oVXRpbHMuYWxsVG9Mb3dlckNhc2UoVXRpbHMua2V5c0FycmF5KGhlYWRlcnMpKSwgJ3gtYWJseS1lcnJvcmNvZGUnKTtcbn1cbmZ1bmN0aW9uIGdldEFibHlFcnJvcihyZXNwb25zZUJvZHksIGhlYWRlcnMpIHtcbiAgICBpZiAoaXNBYmx5RXJyb3IocmVzcG9uc2VCb2R5LCBoZWFkZXJzKSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VCb2R5LmVycm9yICYmIGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyhyZXNwb25zZUJvZHkuZXJyb3IpO1xuICAgIH1cbn1cbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xudmFyIGlkQ291bnRlciA9IDA7XG52YXIgcGVuZGluZ1JlcXVlc3RzID0ge307XG52YXIgaXNJRSA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5YRG9tYWluUmVxdWVzdDtcbmZ1bmN0aW9uIGllVmVyc2lvbigpIHtcbiAgICB2YXIgbWF0Y2ggPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvU3RyaW5nKCkubWF0Y2goL01TSUVcXHMoW1xcZC5dKykvKTtcbiAgICByZXR1cm4gbWF0Y2ggJiYgTnVtYmVyKG1hdGNoWzFdKTtcbn1cbmZ1bmN0aW9uIG5lZWRKc29uRW52ZWxvcGUoKSB7XG4gICAgLyogSUUgMTAgeGhyIGJ1ZzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTYzMjAzMzkgKi9cbiAgICB2YXIgdmVyc2lvbjtcbiAgICByZXR1cm4gaXNJRSAmJiAodmVyc2lvbiA9IGllVmVyc2lvbigpKSAmJiB2ZXJzaW9uID09PSAxMDtcbn1cbmZ1bmN0aW9uIGdldEhlYWRlcih4aHIsIGhlYWRlcikge1xuICAgIHJldHVybiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIgJiYgeGhyLmdldFJlc3BvbnNlSGVhZGVyKGhlYWRlcik7XG59XG4vKiBTYWZhcmkgbXlzdGVyaW91c2x5IHJldHVybnMgJ0lkZW50aXR5JyBmb3IgdHJhbnNmZXItZW5jb2Rpbmcgd2hlbiBpbiBmYWN0XG4gKiBpdCBpcyAnY2h1bmtlZCcuIFNvIGluc3RlYWQsIGRlY2lkZSB0aGF0IGl0IGlzIGNodW5rZWQgd2hlblxuICogdHJhbnNmZXItZW5jb2RpbmcgaXMgcHJlc2VudCBvciBjb250ZW50LWxlbmd0aCBpcyBhYnNlbnQuICAoJ29yJyBiZWNhdXNlXG4gKiB3aGVuIHVzaW5nIGh0dHAyIHN0cmVhbWluZywgdGhlcmUncyBubyB0cmFuc2Zlci1lbmNvZGluZyBoZWFkZXIsIGJ1dCBjYW5cbiAqIHN0aWxsIGRlZHVjZSBzdHJlYW1pbmcgZnJvbSBsYWNrIG9mIGNvbnRlbnQtbGVuZ3RoKSAqL1xuZnVuY3Rpb24gaXNFbmNvZGluZ0NodW5rZWQoeGhyKSB7XG4gICAgcmV0dXJuICh4aHIuZ2V0UmVzcG9uc2VIZWFkZXIgJiYgKHhoci5nZXRSZXNwb25zZUhlYWRlcigndHJhbnNmZXItZW5jb2RpbmcnKSB8fCAheGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LWxlbmd0aCcpKSk7XG59XG5mdW5jdGlvbiBnZXRIZWFkZXJzQXNPYmplY3QoeGhyKSB7XG4gICAgdmFyIGhlYWRlclBhaXJzID0gVXRpbHMudHJpbSh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpLnNwbGl0KCdcXHJcXG4nKTtcbiAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVyUGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnRzID0gaGVhZGVyUGFpcnNbaV0uc3BsaXQoJzonKS5tYXAoVXRpbHMudHJpbSk7XG4gICAgICAgIGhlYWRlcnNbcGFydHNbMF0udG9Mb3dlckNhc2UoKV0gPSBwYXJ0c1sxXTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG52YXIgWEhSUmVxdWVzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhYSFJSZXF1ZXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFhIUlJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbWV0aG9kKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgcGFyYW1zLnJuZCA9IFV0aWxzLmNoZWFwUmFuZFN0cigpO1xuICAgICAgICBpZiAobmVlZEpzb25FbnZlbG9wZSgpICYmICFwYXJhbXMuZW52ZWxvcGUpXG4gICAgICAgICAgICBwYXJhbXMuZW52ZWxvcGUgPSAnanNvbic7XG4gICAgICAgIF90aGlzLnVyaSA9IHVyaSArIFV0aWxzLnRvUXVlcnlTdHJpbmcocGFyYW1zKTtcbiAgICAgICAgX3RoaXMuaGVhZGVycyA9IGhlYWRlcnMgfHwge307XG4gICAgICAgIF90aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICBfdGhpcy5tZXRob2QgPSBtZXRob2QgPyBtZXRob2QudG9VcHBlckNhc2UoKSA6IFV0aWxzLmlzRW1wdHlBcmcoYm9keSkgPyAnR0VUJyA6ICdQT1NUJztcbiAgICAgICAgX3RoaXMucmVxdWVzdE1vZGUgPSByZXF1ZXN0TW9kZTtcbiAgICAgICAgX3RoaXMudGltZW91dHMgPSB0aW1lb3V0cztcbiAgICAgICAgX3RoaXMudGltZWRPdXQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMucmVxdWVzdENvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmlkID0gU3RyaW5nKCsraWRDb3VudGVyKTtcbiAgICAgICAgcGVuZGluZ1JlcXVlc3RzW190aGlzLmlkXSA9IF90aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFhIUlJlcXVlc3QuY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uICh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBtZXRob2QpIHtcbiAgICAgICAgLyogWEhSIHJlcXVlc3RzIGFyZSB1c2VkIGVpdGhlciB3aXRoIHRoZSBjb250ZXh0IGJlaW5nIGEgcmVhbHRpbWVcbiAgICAgICAgICogdHJhbnNwb3J0LCBvciB3aXRoIHRpbWVvdXRzIHBhc3NlZCBpbiAoZm9yIHdoZW4gdXNlZCBieSBhIHJlc3QgY2xpZW50KSxcbiAgICAgICAgICogb3IgY29tcGxldGVseSBzdGFuZGFsb25lLiAgVXNlIHRoZSBhcHByb3ByaWF0ZSB0aW1lb3V0cyBpbiBlYWNoIGNhc2UgKi9cbiAgICAgICAgdmFyIF90aW1lb3V0cyA9IHRpbWVvdXRzIHx8IGRlZmF1bHRzXzEuZGVmYXVsdC5USU1FT1VUUztcbiAgICAgICAgcmV0dXJuIG5ldyBYSFJSZXF1ZXN0KHVyaSwgaGVhZGVycywgVXRpbHMuY29weShwYXJhbXMpLCBib2R5LCByZXF1ZXN0TW9kZSwgX3RpbWVvdXRzLCBtZXRob2QpO1xuICAgIH07XG4gICAgWEhSUmVxdWVzdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuICAgICAgICBpZiAoIXRoaXMucmVxdWVzdENvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIWVyciAmJiBib2R5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgYm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NvbXBsZXRlJywgZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWEhSUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgWEhSUmVxdWVzdC5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGhlYWRlcnMgPSB0aGlzLmhlYWRlcnM7XG4gICAgICAgIHZhciB0aW1lb3V0ID0gdGhpcy5yZXF1ZXN0TW9kZSA9PSBYSFJTdGF0ZXNfMS5kZWZhdWx0LlJFUV9TRU5EID8gdGhpcy50aW1lb3V0cy5odHRwUmVxdWVzdFRpbWVvdXQgOiB0aGlzLnRpbWVvdXRzLnJlY3ZUaW1lb3V0LCB0aW1lciA9ICh0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy50aW1lZE91dCA9IHRydWU7XG4gICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgfSwgdGltZW91dCkpLCBtZXRob2QgPSB0aGlzLm1ldGhvZCwgeGhyID0gKHRoaXMueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCkpLCBhY2NlcHQgPSBoZWFkZXJzWydhY2NlcHQnXTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLmJvZHk7XG4gICAgICAgIHZhciByZXNwb25zZVR5cGUgPSAndGV4dCc7XG4gICAgICAgIGlmICghYWNjZXB0KSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIEpTT05cbiAgICAgICAgICAgIGhlYWRlcnNbJ2FjY2VwdCddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFjY2VwdC5pbmRleE9mKCdhcHBsaWNhdGlvbi94LW1zZ3BhY2snKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTXNncGFjayByZXNwb25zZXMgd2lsbCBiZSB0eXBlZCBhcyBBcnJheUJ1ZmZlclxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gaGVhZGVyc1snY29udGVudC10eXBlJ10gfHwgKGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgICAgIGlmIChjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPiAtMSAmJiB0eXBlb2YgYm9keSAhPSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FuIHByb2JhYmx5IHJlbW92ZSB0aGlzIGRpcmVjdGl2ZSBpZiBodHRwczovL2dpdGh1Yi5jb20vbm9kZXNlY3VyaXR5L2VzbGludC1wbHVnaW4tc2VjdXJpdHkvaXNzdWVzLzI2IGlzIHJlc29sdmVkXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzZWN1cml0eS9kZXRlY3Qtbm9uLWxpdGVyYWwtZnMtZmlsZW5hbWVcbiAgICAgICAgeGhyLm9wZW4obWV0aG9kLCB0aGlzLnVyaSwgdHJ1ZSk7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XG4gICAgICAgIGlmICgnYXV0aG9yaXphdGlvbicgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaCBpbiBoZWFkZXJzKVxuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaCwgaGVhZGVyc1toXSk7XG4gICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoZXJyb3JFdmVudCwgbWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IG1lc3NhZ2UgKyAnIChldmVudCB0eXBlOiAnICsgZXJyb3JFdmVudC50eXBlICsgJyknO1xuICAgICAgICAgICAgaWYgKChfYSA9IF90aGlzID09PSBudWxsIHx8IF90aGlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcy54aHIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0dXNUZXh0KVxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSAnLCBjdXJyZW50IHN0YXR1c1RleHQgaXMgJyArIF90aGlzLnhoci5zdGF0dXNUZXh0O1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdSZXF1ZXN0Lm9uJyArIGVycm9yRXZlbnQudHlwZSArICcoKScsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICBfdGhpcy5jb21wbGV0ZShuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbyhlcnJvck1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JFdmVudCkge1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsICdYSFIgZXJyb3Igb2NjdXJyZWQnLCBudWxsLCA0MDApO1xuICAgICAgICB9O1xuICAgICAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uIChlcnJvckV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMudGltZWRPdXQpIHtcbiAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIoZXJyb3JFdmVudCwgJ1JlcXVlc3QgYWJvcnRlZCBkdWUgdG8gcmVxdWVzdCB0aW1lb3V0IGV4cGlyaW5nJywgbnVsbCwgNDA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcihlcnJvckV2ZW50LCAnUmVxdWVzdCBjYW5jZWxsZWQnLCBudWxsLCA0MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24gKGVycm9yRXZlbnQpIHtcbiAgICAgICAgICAgIGVycm9ySGFuZGxlcihlcnJvckV2ZW50LCAnUmVxdWVzdCB0aW1lZCBvdXQnLCBudWxsLCA0MDgpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc3RyZWFtaW5nO1xuICAgICAgICB2YXIgc3RhdHVzQ29kZTtcbiAgICAgICAgdmFyIHN1Y2Nlc3NSZXNwb25zZTtcbiAgICAgICAgdmFyIHN0cmVhbVBvcyA9IDA7XG4gICAgICAgIHZhciB1bnBhY2tlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgb25SZXNwb25zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICBzdWNjZXNzUmVzcG9uc2UgPSBzdGF0dXNDb2RlIDwgNDAwO1xuICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT0gMjA0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29tcGxldGUobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyZWFtaW5nID0gX3RoaXMucmVxdWVzdE1vZGUgPT0gWEhSU3RhdGVzXzEuZGVmYXVsdC5SRVFfUkVDVl9TVFJFQU0gJiYgc3VjY2Vzc1Jlc3BvbnNlICYmIGlzRW5jb2RpbmdDaHVua2VkKHhocik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbkVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWRSZXNwb25zZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gZ2V0SGVhZGVyKHhociwgJ2NvbnRlbnQtdHlwZScpO1xuICAgICAgICAgICAgICAgIC8qIEJlIGxpYmVyYWwgaW4gd2hhdCB3ZSBhY2NlcHQ7IGJ1Z2d5IGF1dGggc2VydmVycyBtYXkgcmVzcG9uZFxuICAgICAgICAgICAgICAgICAqIHdpdGhvdXQgdGhlIGNvcnJlY3QgY29udGVudHR5cGUsIGJ1dCBhc3N1bWUgdGhleSdyZSBzdGlsbFxuICAgICAgICAgICAgICAgICAqIHJlc3BvbmRpbmcgd2l0aCBqc29uICovXG4gICAgICAgICAgICAgICAgdmFyIGpzb24gPSBjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+PSAwIDogeGhyLnJlc3BvbnNlVHlwZSA9PSAndGV4dCc7XG4gICAgICAgICAgICAgICAgaWYgKGpzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLyogSWYgd2UgcmVxdWVzdGVkIG1zZ3BhY2sgYnV0IHNlcnZlciByZXNwb25kZWQgd2l0aCBqc29uLCB0aGVuIHNpbmNlXG4gICAgICAgICAgICAgICAgICAgICAqIHdlIHNldCB0aGUgcmVzcG9uc2VUeXBlIGV4cGVjdGluZyBtc2dwYWNrLCB0aGUgcmVzcG9uc2Ugd2lsbCBiZVxuICAgICAgICAgICAgICAgICAgICAgKiBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIGpzb24gKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGpzb25SZXNwb25zZUJvZHkgPSB4aHIucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy51dGY4RGVjb2RlKHhoci5yZXNwb25zZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogU3RyaW5nKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvblJlc3BvbnNlQm9keS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlID0gSlNPTi5wYXJzZShqc29uUmVzcG9uc2VCb2R5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlID0ganNvblJlc3BvbnNlQm9keTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1bnBhY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXNwb25zZSA9IHhoci5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZFJlc3BvbnNlLnJlc3BvbnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogdW53cmFwIEpTT04gZW52ZWxvcGUgKi9cbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZSA9IHBhcnNlZFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NSZXNwb25zZSA9IHN0YXR1c0NvZGUgPCA0MDA7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMgPSBwYXJzZWRSZXNwb25zZS5oZWFkZXJzO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXNwb25zZSA9IHBhcnNlZFJlc3BvbnNlLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycyA9IGdldEhlYWRlcnNBc09iamVjdCh4aHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29tcGxldGUobmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ01hbGZvcm1lZCByZXNwb25zZSBib2R5IGZyb20gc2VydmVyOiAnICsgZS5tZXNzYWdlLCBudWxsLCA0MDApKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBJZiByZXNwb25zZSBpcyBhbiBhcnJheSwgaXQncyBhbiBhcnJheSBvZiBwcm90b2NvbCBtZXNzYWdlcyAtLSBldmVuIGlmXG4gICAgICAgICAgICAgKiBpcyBjb250YWlucyBhbiBlcnJvciBhY3Rpb24gKGhlbmNlIHRoZSBub25zdWNjZXNzIHN0YXR1c2NvZGUpLCB3ZSBjYW5cbiAgICAgICAgICAgICAqIGNvbnNpZGVyIHRoZSByZXF1ZXN0IHRvIGhhdmUgc3VjY2VlZGVkLCBqdXN0IHBhc3MgaXQgb24gdG9cbiAgICAgICAgICAgICAqIG9uUHJvdG9jb2xNZXNzYWdlIHRvIGRlY2lkZSB3aGF0IHRvIGRvICovXG4gICAgICAgICAgICBpZiAoc3VjY2Vzc1Jlc3BvbnNlIHx8IFV0aWxzLmlzQXJyYXkocGFyc2VkUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29tcGxldGUobnVsbCwgcGFyc2VkUmVzcG9uc2UsIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXJyID0gZ2V0QWJseUVycm9yKHBhcnNlZFJlc3BvbnNlLCBoZWFkZXJzKTtcbiAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gbmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ0Vycm9yIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gc2VydmVyOiAnICtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZSArXG4gICAgICAgICAgICAgICAgICAgICcgYm9keSB3YXM6ICcgK1xuICAgICAgICAgICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QocGFyc2VkUmVzcG9uc2UpLCBudWxsLCBzdGF0dXNDb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKGVyciwgcGFyc2VkUmVzcG9uc2UsIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gb25Qcm9ncmVzcygpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZVRleHQgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgdmFyIGJvZHlFbmQgPSByZXNwb25zZVRleHQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHZhciBpZHgsIGNodW5rO1xuICAgICAgICAgICAgd2hpbGUgKHN0cmVhbVBvcyA8IGJvZHlFbmQgJiYgKGlkeCA9IHJlc3BvbnNlVGV4dC5pbmRleE9mKCdcXG4nLCBzdHJlYW1Qb3MpKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSByZXNwb25zZVRleHQuc2xpY2Uoc3RyZWFtUG9zLCBpZHgpO1xuICAgICAgICAgICAgICAgIHN0cmVhbVBvcyA9IGlkeCArIDE7XG4gICAgICAgICAgICAgICAgb25DaHVuayhjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9uQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBKU09OLnBhcnNlKGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29tcGxldGUobmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ01hbGZvcm1lZCByZXNwb25zZSBib2R5IGZyb20gc2VydmVyOiAnICsgZS5tZXNzYWdlLCBudWxsLCA0MDApKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb25TdHJlYW1FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvblByb2dyZXNzKCk7XG4gICAgICAgICAgICBfdGhpcy5zdHJlYW1Db21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlO1xuICAgICAgICAgICAgaWYgKHJlYWR5U3RhdGUgPCAzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlID0geGhyLnN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgLyogSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IDEyMjMpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlID0gMjA0O1xuICAgICAgICAgICAgICAgICAgICBvblJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWFkeVN0YXRlID09IDMgJiYgc3RyZWFtaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW1pbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBvblN0cmVhbUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgeGhyLnNlbmQoYm9keSk7XG4gICAgfTtcbiAgICBYSFJSZXF1ZXN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeGhyID0gdGhpcy54aHI7XG4gICAgICAgIGlmICh4aHIpIHtcbiAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9IG5vb3A7XG4gICAgICAgICAgICB0aGlzLnhociA9IG51bGw7XG4gICAgICAgICAgICB2YXIgdGltZXIgPSB0aGlzLnRpbWVyO1xuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5yZXF1ZXN0Q29tcGxldGUpXG4gICAgICAgICAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHBlbmRpbmdSZXF1ZXN0c1t0aGlzLmlkXTtcbiAgICB9O1xuICAgIHJldHVybiBYSFJSZXF1ZXN0O1xufShldmVudGVtaXR0ZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBYSFJSZXF1ZXN0O1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxMykpKVxuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIG11bHRpY2FzdGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBobWFjX3NoYTI1Nl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0NSkpO1xudmFyIGVuY19iYXNlNjRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xudmFyIEh0dHBNZXRob2RzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KSk7XG52YXIgSHR0cFN0YXR1c0NvZGVzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIHJlc291cmNlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSk7XG52YXIgTUFYX1RPS0VOX0xFTkdUSCA9IE1hdGgucG93KDIsIDE3KTtcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbmZ1bmN0aW9uIHJhbmRvbSgpIHtcbiAgICByZXR1cm4gKCcwMDAwMDAnICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWUxNikpLnNsaWNlKC0xNik7XG59XG5mdW5jdGlvbiBpc1JlYWx0aW1lKGNsaWVudCkge1xuICAgIHJldHVybiAhIWNsaWVudC5jb25uZWN0aW9uO1xufVxuLyogQSBjbGllbnQgYXV0aCBjYWxsYmFjayBtYXkgZ2l2ZSBlcnJvcnMgaW4gYW55IG51bWJlciBvZiBmb3JtYXRzOyBub3JtYWxpc2UgdG8gYW4gRXJyb3JJbmZvIG9yIFBhcnRpYWxFcnJvckluZm8gKi9cbmZ1bmN0aW9uIG5vcm1hbGlzZUF1dGhjYWxsYmFja0Vycm9yKGVycikge1xuICAgIGlmICghVXRpbHMuaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm8oZXJyKSkge1xuICAgICAgICByZXR1cm4gbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoVXRpbHMuaW5zcGVjdEVycm9yKGVyciksIGVyci5jb2RlIHx8IDQwMTcwLCBlcnIuc3RhdHVzQ29kZSB8fCA0MDEpO1xuICAgIH1cbiAgICAvKiBuZXR3b3JrIGVycm9ycyB3aWxsIG5vdCBoYXZlIGFuIGluaGVyZW50IGVycm9yIGNvZGUgKi9cbiAgICBpZiAoIWVyci5jb2RlKSB7XG4gICAgICAgIGlmIChlcnIuc3RhdHVzQ29kZSA9PT0gNDAzKSB7XG4gICAgICAgICAgICBlcnIuY29kZSA9IDQwMzAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyLmNvZGUgPSA0MDE3MDtcbiAgICAgICAgICAgIC8qIG5vcm1hbGlzZSBzdGF0dXNDb2RlIHRvIDQwMSBwZXIgUlNBNGUgKi9cbiAgICAgICAgICAgIGVyci5zdGF0dXNDb2RlID0gNDAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnI7XG59XG52YXIgaG1hYyA9IGZ1bmN0aW9uICh0ZXh0LCBrZXkpIHtcbiAgICBpZiAocGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5jcmVhdGVIbWFjKSB7XG4gICAgICAgIHZhciBpbnN0ID0gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5jcmVhdGVIbWFjKCdTSEEyNTYnLCBrZXkpO1xuICAgICAgICBpbnN0LnVwZGF0ZSh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIGluc3QuZGlnZXN0KCdiYXNlNjQnKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBlbmNfYmFzZTY0XzEuc3RyaW5naWZ5KSgoMCwgaG1hY19zaGEyNTZfMS5kZWZhdWx0KSh0ZXh0LCBrZXkpKTtcbn07XG5mdW5jdGlvbiBjMTRuKGNhcGFiaWxpdHkpIHtcbiAgICBpZiAoIWNhcGFiaWxpdHkpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBpZiAodHlwZW9mIGNhcGFiaWxpdHkgPT0gJ3N0cmluZycpXG4gICAgICAgIGNhcGFiaWxpdHkgPSBKU09OLnBhcnNlKGNhcGFiaWxpdHkpO1xuICAgIHZhciBjMTRuQ2FwYWJpbGl0eSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBVdGlscy5rZXlzQXJyYXkoY2FwYWJpbGl0eSwgdHJ1ZSk7XG4gICAgaWYgKCFrZXlzKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAga2V5cy5zb3J0KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGMxNG5DYXBhYmlsaXR5W2tleXNbaV1dID0gY2FwYWJpbGl0eVtrZXlzW2ldXS5zb3J0KCk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjMTRuQ2FwYWJpbGl0eSk7XG59XG5mdW5jdGlvbiBsb2dBbmRWYWxpZGF0ZVRva2VuQXV0aE1ldGhvZChhdXRoT3B0aW9ucykge1xuICAgIGlmIChhdXRoT3B0aW9ucy5hdXRoQ2FsbGJhY2spIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdBdXRoKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhDYWxsYmFjaycpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdXRoT3B0aW9ucy5hdXRoVXJsKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQXV0aCgpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoVXJsJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF1dGhPcHRpb25zLmtleSkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGgoKScsICd1c2luZyB0b2tlbiBhdXRoIHdpdGggY2xpZW50LXNpZGUgc2lnbmluZycpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdXRoT3B0aW9ucy50b2tlbkRldGFpbHMpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdBdXRoKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIHN1cHBsaWVkIHRva2VuIG9ubHknKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBtc2cgPSAnYXV0aE9wdGlvbnMgbXVzdCBpbmNsdWRlIHZhbGlkIGF1dGhlbnRpY2F0aW9uIHBhcmFtZXRlcnMnO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0F1dGgoKScsIG1zZyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJhc2ljQXV0aEZvcmNlZChvcHRpb25zKSB7XG4gICAgcmV0dXJuICd1c2VUb2tlbkF1dGgnIGluIG9wdGlvbnMgJiYgIW9wdGlvbnMudXNlVG9rZW5BdXRoO1xufVxuLyogUlNBNCAqL1xuZnVuY3Rpb24gdXNlVG9rZW5BdXRoKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMudXNlVG9rZW5BdXRoIHx8XG4gICAgICAgICghYmFzaWNBdXRoRm9yY2VkKG9wdGlvbnMpICYmIChvcHRpb25zLmF1dGhDYWxsYmFjayB8fCBvcHRpb25zLmF1dGhVcmwgfHwgb3B0aW9ucy50b2tlbiB8fCBvcHRpb25zLnRva2VuRGV0YWlscykpKTtcbn1cbi8qIFJTQTRhICovXG5mdW5jdGlvbiBub1dheVRvUmVuZXcob3B0aW9ucykge1xuICAgIHJldHVybiAhb3B0aW9ucy5rZXkgJiYgIW9wdGlvbnMuYXV0aENhbGxiYWNrICYmICFvcHRpb25zLmF1dGhVcmw7XG59XG52YXIgdHJJZCA9IDA7XG5mdW5jdGlvbiBnZXRUb2tlblJlcXVlc3RJZCgpIHtcbiAgICByZXR1cm4gdHJJZCsrO1xufVxudmFyIEF1dGggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXV0aChjbGllbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gVGhpcyBpbml0aWFsaXphdGlvbiBpcyBhbHdheXMgb3ZlcndyaXR0ZW4gYW5kIG9ubHkgdXNlZCB0byBwcmV2ZW50IGEgVHlwZVNjcmlwdCBjb21waWxlciBlcnJvclxuICAgICAgICB0aGlzLmF1dGhPcHRpb25zID0ge307XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICB0aGlzLnRva2VuUGFyYW1zID0gb3B0aW9ucy5kZWZhdWx0VG9rZW5QYXJhbXMgfHwge307XG4gICAgICAgIC8qIFRoZSBpZCBvZiB0aGUgY3VycmVudCB0b2tlbiByZXF1ZXN0IGlmIG9uZSBpcyBpbiBwcm9ncmVzcywgZWxzZSBudWxsICovXG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuUmVxdWVzdElkID0gbnVsbDtcbiAgICAgICAgdGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgaWYgKHVzZVRva2VuQXV0aChvcHRpb25zKSkge1xuICAgICAgICAgICAgLyogVG9rZW4gYXV0aCAqL1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMua2V5ICYmICFobWFjKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdjbGllbnQtc2lkZSB0b2tlbiByZXF1ZXN0IHNpZ25pbmcgbm90IHN1cHBvcnRlZCc7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdBdXRoKCknLCBtc2cpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vV2F5VG9SZW5ldyhvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQXV0aCgpJywgJ1dhcm5pbmc6IGxpYnJhcnkgaW5pdGlhbGl6ZWQgd2l0aCBhIHRva2VuIGxpdGVyYWwgd2l0aG91dCBhbnkgd2F5IHRvIHJlbmV3IHRoZSB0b2tlbiB3aGVuIGl0IGV4cGlyZXMgKG5vIGF1dGhVcmwsIGF1dGhDYWxsYmFjaywgb3Iga2V5KS4gU2VlIGh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yLzQwMTcxIGZvciBoZWxwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zYXZlVG9rZW5PcHRpb25zKG9wdGlvbnMuZGVmYXVsdFRva2VuUGFyYW1zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGxvZ0FuZFZhbGlkYXRlVG9rZW5BdXRoTWV0aG9kKHRoaXMuYXV0aE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogQmFzaWMgYXV0aCAqL1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmtleSkge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnTm8gYXV0aGVudGljYXRpb24gb3B0aW9ucyBwcm92aWRlZDsgbmVlZCBvbmUgb2Y6IGtleSwgYXV0aFVybCwgb3IgYXV0aENhbGxiYWNrIChvciBmb3IgdGVzdGluZyBvbmx5LCB0b2tlbiBvciB0b2tlbkRldGFpbHMpJztcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0F1dGgoKScsIG1zZyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA0MDE2MCwgNDAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQXV0aCgpJywgJ2Fub255bW91cywgdXNpbmcgYmFzaWMgYXV0aCcpO1xuICAgICAgICAgICAgdGhpcy5fc2F2ZUJhc2ljT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBdXRoLnByb3RvdHlwZS5hdXRob3JpemUgPSBmdW5jdGlvbiAodG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2F1dGhPcHRpb25zO1xuICAgICAgICAvKiBzaHVmZmxlIGFuZCBub3JtYWxpc2UgYXJndW1lbnRzIGFzIG5lY2Vzc2FyeSAqL1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuUGFyYW1zID09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHRva2VuUGFyYW1zO1xuICAgICAgICAgICAgX2F1dGhPcHRpb25zID0gdG9rZW5QYXJhbXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhdXRoT3B0aW9ucyA9PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhdXRoT3B0aW9ucztcbiAgICAgICAgICAgIF9hdXRoT3B0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfYXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2F1dGhvcml6ZScsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogUlNBMTBhOiBhdXRob3JpemUoKSBjYWxsIGltcGxpZXMgdG9rZW4gYXV0aC4gSWYgYSBrZXkgaXMgcGFzc2VkIGl0LCB3ZVxuICAgICAgICAgKiBqdXN0IGNoZWNrIGlmIGl0IGRvZXNuJ3QgY2xhc2ggYW5kIGFzc3VtZSB3ZSdyZSBnZW5lcmF0aW5nIGEgdG9rZW4gZnJvbSBpdCAqL1xuICAgICAgICBpZiAoX2F1dGhPcHRpb25zICYmIF9hdXRoT3B0aW9ucy5rZXkgJiYgdGhpcy5hdXRoT3B0aW9ucy5rZXkgIT09IF9hdXRoT3B0aW9ucy5rZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdVbmFibGUgdG8gdXBkYXRlIGF1dGggb3B0aW9ucyB3aXRoIGluY29tcGF0aWJsZSBrZXknLCA0MDEwMiwgNDAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2F1dGhPcHRpb25zICYmICdmb3JjZScgaW4gX2F1dGhPcHRpb25zKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0F1dGguYXV0aG9yaXplJywgJ0RlcHJlY2F0aW9uIHdhcm5pbmc6IHNwZWNpZnlpbmcge2ZvcmNlOiB0cnVlfSBpbiBhdXRoT3B0aW9ucyBpcyBubyBsb25nZXIgbmVjZXNzYXJ5LCBhdXRob3JpemUoKSBub3cgYWx3YXlzIGdldHMgYSBuZXcgdG9rZW4uIFBsZWFzZSByZW1vdmUgdGhpcywgYXMgaW4gdmVyc2lvbiAxLjAgYW5kIGxhdGVyLCBoYXZpbmcgYSBub24tbnVsbCBhdXRoT3B0aW9ucyB3aWxsIG92ZXJ3cml0ZSBzdG9yZWQgbGlicmFyeSBhdXRoT3B0aW9ucywgd2hpY2ggbWF5IG5vdCBiZSB3aGF0IHlvdSB3YW50Jyk7XG4gICAgICAgICAgICAvKiBFbXVsYXRlIHRoZSBvbGQgYmVoYXZpb3VyOiBpZiAnZm9yY2UnIHdhcyB0aGUgb25seSBtZW1iZXIgb2YgYXV0aE9wdGlvbnMsXG4gICAgICAgICAgICAgKiBzZXQgaXQgdG8gbnVsbCBzbyBpdCBkb2Vzbid0IG92ZXJ3cml0ZSBzdG9yZWQuIFRPRE86IHJlbW92ZSBpbiB2ZXJzaW9uIDEuMCAqL1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzT25seVByb3BJbihfYXV0aE9wdGlvbnMsICdmb3JjZScpKSB7XG4gICAgICAgICAgICAgICAgX2F1dGhPcHRpb25zID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mb3JjZU5ld1Rva2VuKHRva2VuUGFyYW1zLCBfYXV0aE9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIHRva2VuRGV0YWlscykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jbGllbnQuY29ubmVjdGlvbiAmJiBlcnIuc3RhdHVzQ29kZSA9PT0gSHR0cFN0YXR1c0NvZGVzXzEuZGVmYXVsdC5Gb3JiaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLyogUGVyIFJTQTRkICYgUlNBNGQxLCBpZiB0aGUgYXV0aCBzZXJ2ZXIgZXhwbGljaXRseSByZXB1ZGlhdGVzIG91ciByaWdodCB0b1xuICAgICAgICAgICAgICAgICAgICAgKiBzdGF5IGNvbm5lY3RpY2VkIGJ5IHJldHVybmluZyBhIDQwMywgd2UgYWN0aXZlbHkgZGlzY29ubmVjdCB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgKiBldmVuIHRob3VnaCB3ZSBtYXkgd2VsbCBzdGlsbCBoYXZlIHRpbWUgbGVmdCBpbiB0aGUgb2xkIHRva2VuLiAqL1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbGllbnQuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZShlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBSVEM4XG4gICAgICAgICAgICAgKiAtIFdoZW4gYXV0aG9yaXplIGNhbGxlZCBieSBhbiBlbmQgdXNlciBhbmQgaGF2ZSBhIHJlYWx0aW1lIGNvbm5lY3Rpb24sXG4gICAgICAgICAgICAgKiBkb24ndCBjYWxsIGJhY2sgdGlsbCBuZXcgdG9rZW4gaGFzIHRha2VuIGVmZmVjdC5cbiAgICAgICAgICAgICAqIC0gVXNlIHRoaXMuY2xpZW50LmNvbm5lY3Rpb24gYXMgYSBwcm94eSBmb3IgKHRoaXMuY2xpZW50IGluc3RhbmNlb2YgUmVhbHRpbWUpLFxuICAgICAgICAgICAgICogd2hpY2ggZG9lc24ndCB3b3JrIGluIG5vZGUgYXMgUmVhbHRpbWUgaXNuJ3QgcGFydCBvZiB0aGUgdm0gY29udGV4dCBmb3IgUmVzdCBjbGllbnRzICovXG4gICAgICAgICAgICBpZiAoaXNSZWFsdGltZShfdGhpcy5jbGllbnQpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2xpZW50LmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIub25BdXRoVXBkYXRlZCh0b2tlbkRldGFpbHMsIGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKG51bGwsIHRva2VuRGV0YWlscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXV0aC5wcm90b3R5cGUuYXV0aG9yaXNlID0gZnVuY3Rpb24gKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZXByZWNhdGVkKCdBdXRoLmF1dGhvcmlzZScsICdBdXRoLmF1dGhvcml6ZScpO1xuICAgICAgICB0aGlzLmF1dGhvcml6ZSh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8qIEZvciBpbnRlcm5hbCB1c2UsIGVnIGJ5IGNvbm5lY3Rpb25NYW5hZ2VyIC0gdXNlZnVsIHdoZW4gd2FudCB0byBjYWxsIGJhY2tcbiAgICAgKiBhcyBzb29uIGFzIHdlIGhhdmUgdGhlIG5ldyB0b2tlbiwgcmF0aGVyIHRoYW4gd2FpdGluZyBmb3IgaXQgdG8gdGFrZVxuICAgICAqIGVmZmVjdCBvbiB0aGUgY29ubmVjdGlvbiBhcyAjYXV0aG9yaXplIGRvZXMgKi9cbiAgICBBdXRoLnByb3RvdHlwZS5fZm9yY2VOZXdUb2tlbiA9IGZ1bmN0aW9uICh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qIGdldCByaWQgb2YgY3VycmVudCB0b2tlbiBldmVuIGlmIHN0aWxsIHZhbGlkICovXG4gICAgICAgIHRoaXMudG9rZW5EZXRhaWxzID0gbnVsbDtcbiAgICAgICAgLyogX3NhdmUgbm9ybWFsaXNlcyB0aGUgdG9rZW5QYXJhbXMgYW5kIGF1dGhPcHRpb25zIGFuZCB1cGRhdGVzIHRoZSBhdXRoXG4gICAgICAgICAqIG9iamVjdC4gQWxsIHN1YnNlcXVlbnQgb3BlcmF0aW9ucyBzaG91bGQgdXNlIHRoZSB2YWx1ZXMgb24gYHRoaXNgLFxuICAgICAgICAgKiBub3QgdGhlIHBhc3NlZCBpbiBvbmVzLiAqL1xuICAgICAgICB0aGlzLl9zYXZlVG9rZW5PcHRpb25zKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucyk7XG4gICAgICAgIGxvZ0FuZFZhbGlkYXRlVG9rZW5BdXRoTWV0aG9kKHRoaXMuYXV0aE9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyh0cnVlLCBmdW5jdGlvbiAoZXJyLCB0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgICAgIC8qIFJTQTEwZyAqL1xuICAgICAgICAgICAgZGVsZXRlIF90aGlzLnRva2VuUGFyYW1zLnRpbWVzdGFtcDtcbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5hdXRoT3B0aW9ucy5xdWVyeVRpbWU7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHRva2VuRGV0YWlscyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXV0aC5wcm90b3R5cGUucmVxdWVzdFRva2VuID0gZnVuY3Rpb24gKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyogc2h1ZmZsZSBhbmQgbm9ybWFsaXNlIGFyZ3VtZW50cyBhcyBuZWNlc3NhcnkgKi9cbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlblBhcmFtcyA9PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSB0b2tlblBhcmFtcztcbiAgICAgICAgICAgIGF1dGhPcHRpb25zID0gdG9rZW5QYXJhbXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhdXRoT3B0aW9ucyA9PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhdXRoT3B0aW9ucztcbiAgICAgICAgICAgIGF1dGhPcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbGxiYWNrICYmIHRoaXMuY2xpZW50Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3JlcXVlc3RUb2tlbicsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogUlNBOGU6IGlmIGF1dGhPcHRpb25zIHBhc3NlZCBpbiwgdGhleSdyZSB1c2VkIGluc3RlYWQgb2Ygc3RvcmVkLCBkb24ndCBtZXJnZSB0aGVtICovXG4gICAgICAgIGF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnMgfHwgdGhpcy5hdXRoT3B0aW9ucztcbiAgICAgICAgdG9rZW5QYXJhbXMgPSB0b2tlblBhcmFtcyB8fCBVdGlscy5jb3B5KHRoaXMudG9rZW5QYXJhbXMpO1xuICAgICAgICB2YXIgX2NhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgICAgICAgLyogZmlyc3Qgc2V0IHVwIHdoYXRldmVyIGNhbGxiYWNrIHdpbGwgYmUgdXNlZCB0byBnZXQgc2lnbmVkXG4gICAgICAgICAqIHRva2VuIHJlcXVlc3RzICovXG4gICAgICAgIHZhciB0b2tlblJlcXVlc3RDYWxsYmFjaywgY2xpZW50ID0gdGhpcy5jbGllbnQ7XG4gICAgICAgIGlmIChhdXRoT3B0aW9ucy5hdXRoQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsICd1c2luZyB0b2tlbiBhdXRoIHdpdGggYXV0aENhbGxiYWNrJyk7XG4gICAgICAgICAgICB0b2tlblJlcXVlc3RDYWxsYmFjayA9IGF1dGhPcHRpb25zLmF1dGhDYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdXRoT3B0aW9ucy5hdXRoVXJsKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhVcmwnKTtcbiAgICAgICAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrID0gZnVuY3Rpb24gKHBhcmFtcywgY2IpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXV0aEhlYWRlcnMgPSBVdGlscy5taXhpbih7IGFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4nIH0sIGF1dGhPcHRpb25zLmF1dGhIZWFkZXJzKTtcbiAgICAgICAgICAgICAgICB2YXIgdXNlUG9zdCA9IGF1dGhPcHRpb25zLmF1dGhNZXRob2QgJiYgYXV0aE9wdGlvbnMuYXV0aE1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSAncG9zdCc7XG4gICAgICAgICAgICAgICAgdmFyIHByb3ZpZGVkUXNQYXJhbXM7XG4gICAgICAgICAgICAgICAgLyogQ29tYmluZSBhdXRoUGFyYW1zIHdpdGggYW55IHFzIHBhcmFtcyBnaXZlbiBpbiB0aGUgYXV0aFVybCAqL1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeUlkeCA9IGF1dGhPcHRpb25zLmF1dGhVcmwuaW5kZXhPZignPycpO1xuICAgICAgICAgICAgICAgIGlmIChxdWVyeUlkeCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkUXNQYXJhbXMgPSBVdGlscy5wYXJzZVF1ZXJ5U3RyaW5nKGF1dGhPcHRpb25zLmF1dGhVcmwuc2xpY2UocXVlcnlJZHgpKTtcbiAgICAgICAgICAgICAgICAgICAgYXV0aE9wdGlvbnMuYXV0aFVybCA9IGF1dGhPcHRpb25zLmF1dGhVcmwuc2xpY2UoMCwgcXVlcnlJZHgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZVBvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIEluIGNhc2Ugb2YgY29uZmxpY3QsIGF1dGhQYXJhbXMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgcXMgcGFyYW1zIGluIHRoZSBhdXRoVXJsICovXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRoT3B0aW9ucy5hdXRoUGFyYW1zID0gVXRpbHMubWl4aW4ocHJvdmlkZWRRc1BhcmFtcywgYXV0aE9wdGlvbnMuYXV0aFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogUlNBOGMyICovXG4gICAgICAgICAgICAgICAgdmFyIGF1dGhQYXJhbXMgPSBVdGlscy5taXhpbih7fSwgYXV0aE9wdGlvbnMuYXV0aFBhcmFtcyB8fCB7fSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB2YXIgYXV0aFVybFJlcXVlc3RDYWxsYmFjayA9IGZ1bmN0aW9uIChlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdBdXRoLnJlcXVlc3RUb2tlbigpLnRva2VuUmVxdWVzdENhbGxiYWNrJywgJ1JlY2VpdmVkIEVycm9yOiAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGUgPSBoZWFkZXJzWydjb250ZW50LXR5cGUnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKS50b2tlblJlcXVlc3RDYWxsYmFjaycsICdSZWNlaXZlZDsgY29udGVudC10eXBlOiAnICsgY29udGVudFR5cGUgKyAnOyBib2R5OiAnICsgVXRpbHMuaW5zcGVjdEJvZHkoYm9keSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgfHwgdW5wYWNrZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoZXJyLCBib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5pc0J1ZmZlcihib2R5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdhdXRoVXJsIHJlc3BvbnNlIGlzIG1pc3NpbmcgYSBjb250ZW50LXR5cGUgaGVhZGVyJywgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBqc29uID0gY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTEsIHRleHQgPSBjb250ZW50VHlwZS5pbmRleE9mKCd0ZXh0L3BsYWluJykgPiAtMSB8fCBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qd3QnKSA+IC0xO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWpzb24gJiYgIXRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdhdXRoVXJsIHJlc3BvbmRlZCB3aXRoIHVuYWNjZXB0YWJsZSBjb250ZW50LXR5cGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcsIHNob3VsZCBiZSBlaXRoZXIgdGV4dC9wbGFpbiwgYXBwbGljYXRpb24vand0IG9yIGFwcGxpY2F0aW9uL2pzb24nLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib2R5Lmxlbmd0aCA+IE1BWF9UT0tFTl9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYihuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnYXV0aFVybCByZXNwb25zZSBleGNlZWRlZCBtYXggcGVybWl0dGVkIGxlbmd0aCcsIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYihuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVW5leHBlY3RlZCBlcnJvciBwcm9jZXNzaW5nIGF1dGhVUkwgcmVzcG9uc2U7IGVyciA9ICcgKyBlLm1lc3NhZ2UsIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2IobnVsbCwgYm9keSwgY29udGVudFR5cGUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdBdXRoLnJlcXVlc3RUb2tlbigpLnRva2VuUmVxdWVzdENhbGxiYWNrJywgJ1JlcXVlc3RpbmcgdG9rZW4gZnJvbSAnICtcbiAgICAgICAgICAgICAgICAgICAgYXV0aE9wdGlvbnMuYXV0aFVybCArXG4gICAgICAgICAgICAgICAgICAgICc7IFBhcmFtczogJyArXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGF1dGhQYXJhbXMpICtcbiAgICAgICAgICAgICAgICAgICAgJzsgbWV0aG9kOiAnICtcbiAgICAgICAgICAgICAgICAgICAgKHVzZVBvc3QgPyAnUE9TVCcgOiAnR0VUJykpO1xuICAgICAgICAgICAgICAgIGlmICh1c2VQb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIHNlbmQgYm9keSBmb3JtLWVuY29kZWQgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBhdXRoSGVhZGVycyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBVdGlscy50b1F1ZXJ5U3RyaW5nKGF1dGhQYXJhbXMpLnNsaWNlKDEpOyAvKiBzbGljZSBpcyB0byByZW1vdmUgdGhlIGluaXRpYWwgJz8nICovXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNsaWVudC5odHRwLmRvVXJpKEh0dHBNZXRob2RzXzEuZGVmYXVsdC5Qb3N0LCBjbGllbnQsIGF1dGhPcHRpb25zLmF1dGhVcmwsIGhlYWRlcnMsIGJvZHksIHByb3ZpZGVkUXNQYXJhbXMsIGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xpZW50Lmh0dHAuZG9VcmkoSHR0cE1ldGhvZHNfMS5kZWZhdWx0LkdldCwgY2xpZW50LCBhdXRoT3B0aW9ucy5hdXRoVXJsLCBhdXRoSGVhZGVycyB8fCB7fSwgbnVsbCwgYXV0aFBhcmFtcywgYXV0aFVybFJlcXVlc3RDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdXRoT3B0aW9ucy5rZXkpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsICd1c2luZyB0b2tlbiBhdXRoIHdpdGggY2xpZW50LXNpZGUgc2lnbmluZycpO1xuICAgICAgICAgICAgdG9rZW5SZXF1ZXN0Q2FsbGJhY2sgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgICAgICAgICAgICAgIF90aGlzLmNyZWF0ZVRva2VuUmVxdWVzdChwYXJhbXMsIGF1dGhPcHRpb25zLCBjYik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdOZWVkIGEgbmV3IHRva2VuLCBidXQgYXV0aE9wdGlvbnMgZG9lcyBub3QgaW5jbHVkZSBhbnkgd2F5IHRvIHJlcXVlc3Qgb25lIChubyBhdXRoVXJsLCBhdXRoQ2FsbGJhY2ssIG9yIGtleSknO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdBdXRoKCknLCAnbGlicmFyeSBpbml0aWFsaXplZCB3aXRoIGEgdG9rZW4gbGl0ZXJhbCB3aXRob3V0IGFueSB3YXkgdG8gcmVuZXcgdGhlIHRva2VuIHdoZW4gaXQgZXhwaXJlcyAobm8gYXV0aFVybCwgYXV0aENhbGxiYWNrLCBvciBrZXkpLiBTZWUgaHR0cHM6Ly9oZWxwLmFibHkuaW8vZXJyb3IvNDAxNzEgZm9yIGhlbHAnKTtcbiAgICAgICAgICAgIF9jYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDQwMTcxLCA0MDMpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBub3JtYWxpc2UgdG9rZW4gcGFyYW1zICovXG4gICAgICAgIGlmICgnY2FwYWJpbGl0eScgaW4gdG9rZW5QYXJhbXMpXG4gICAgICAgICAgICB0b2tlblBhcmFtcy5jYXBhYmlsaXR5ID0gYzE0bih0b2tlblBhcmFtcy5jYXBhYmlsaXR5KTtcbiAgICAgICAgdmFyIHRva2VuUmVxdWVzdCA9IGZ1bmN0aW9uIChzaWduZWRUb2tlblBhcmFtcywgdG9rZW5DYikge1xuICAgICAgICAgICAgdmFyIGtleU5hbWUgPSBzaWduZWRUb2tlblBhcmFtcy5rZXlOYW1lLCBwYXRoID0gJy9rZXlzLycgKyBrZXlOYW1lICsgJy9yZXF1ZXN0VG9rZW4nLCB0b2tlblVyaSA9IGZ1bmN0aW9uIChob3N0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5iYXNlVXJpKGhvc3QpICsgcGF0aDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBVdGlscy5kZWZhdWx0UG9zdEhlYWRlcnMoX3RoaXMuY2xpZW50Lm9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGF1dGhPcHRpb25zLnJlcXVlc3RIZWFkZXJzKVxuICAgICAgICAgICAgICAgIFV0aWxzLm1peGluKHJlcXVlc3RIZWFkZXJzLCBhdXRoT3B0aW9ucy5yZXF1ZXN0SGVhZGVycyk7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0F1dGgucmVxdWVzdFRva2VuKCkucmVxdWVzdFRva2VuJywgJ1NlbmRpbmcgUE9TVCB0byAnICsgcGF0aCArICc7IFRva2VuIHBhcmFtczogJyArIEpTT04uc3RyaW5naWZ5KHNpZ25lZFRva2VuUGFyYW1zKSk7XG4gICAgICAgICAgICBfdGhpcy5jbGllbnQuaHR0cC5kbyhIdHRwTWV0aG9kc18xLmRlZmF1bHQuUG9zdCwgY2xpZW50LCB0b2tlblVyaSwgcmVxdWVzdEhlYWRlcnMsIEpTT04uc3RyaW5naWZ5KHNpZ25lZFRva2VuUGFyYW1zKSwgbnVsbCwgdG9rZW5DYik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXRFeHBpcmVkID0gZmFsc2UsIHRpbWVvdXRMZW5ndGggPSB0aGlzLmNsaWVudC5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQsIHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0RXhwaXJlZCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ1Rva2VuIHJlcXVlc3QgY2FsbGJhY2sgdGltZWQgb3V0IGFmdGVyICcgKyB0aW1lb3V0TGVuZ3RoIC8gMTAwMCArICcgc2Vjb25kcyc7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCBtc2cpO1xuICAgICAgICAgICAgX2NhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgNDAxNzAsIDQwMSkpO1xuICAgICAgICB9LCB0aW1lb3V0TGVuZ3RoKTtcbiAgICAgICAgdG9rZW5SZXF1ZXN0Q2FsbGJhY2sodG9rZW5QYXJhbXMsIGZ1bmN0aW9uIChlcnIsIHRva2VuUmVxdWVzdE9yRGV0YWlscywgY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXRFeHBpcmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXQpO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsICd0b2tlbiByZXF1ZXN0IHNpZ25pbmcgY2FsbCByZXR1cm5lZCBlcnJvcjsgZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICBfY2FsbGJhY2sobm9ybWFsaXNlQXV0aGNhbGxiYWNrRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogdGhlIHJlc3BvbnNlIGZyb20gdGhlIGNhbGxiYWNrIG1pZ2h0IGJlIGEgdG9rZW4gc3RyaW5nLCBhIHNpZ25lZCByZXF1ZXN0IG9yIGEgdG9rZW4gZGV0YWlscyAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlblJlcXVlc3RPckRldGFpbHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuUmVxdWVzdE9yRGV0YWlscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdUb2tlbiBzdHJpbmcgaXMgZW1wdHknLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuUmVxdWVzdE9yRGV0YWlscy5sZW5ndGggPiBNQVhfVE9LRU5fTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVG9rZW4gc3RyaW5nIGV4Y2VlZGVkIG1heCBwZXJtaXR0ZWQgbGVuZ3RoICh3YXMgJyArIHRva2VuUmVxdWVzdE9yRGV0YWlscy5sZW5ndGggKyAnIGJ5dGVzKScsIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW5SZXF1ZXN0T3JEZXRhaWxzID09PSAndW5kZWZpbmVkJyB8fCB0b2tlblJlcXVlc3RPckRldGFpbHMgPT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgICAgICAvKiBjb21tb24gZmFpbHVyZSBtb2RlIHdpdGggcG9vcmx5LWltcGxlbWVudGVkIGF1dGhDYWxsYmFja3MgKi9cbiAgICAgICAgICAgICAgICAgICAgX2NhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdUb2tlbiBzdHJpbmcgd2FzIGxpdGVyYWwgbnVsbC91bmRlZmluZWQnLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuUmVxdWVzdE9yRGV0YWlsc1swXSA9PT0gJ3snICYmICEoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vand0JykgPiAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KFwiVG9rZW4gd2FzIGRvdWJsZS1lbmNvZGVkOyBtYWtlIHN1cmUgeW91J3JlIG5vdCBKU09OLWVuY29kaW5nIGFuIGFscmVhZHkgZW5jb2RlZCB0b2tlbiByZXF1ZXN0IG9yIGRldGFpbHNcIiwgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbGxiYWNrKG51bGwsIHsgdG9rZW46IHRva2VuUmVxdWVzdE9yRGV0YWlscyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlblJlcXVlc3RPckRldGFpbHMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdFeHBlY3RlZCB0b2tlbiByZXF1ZXN0IGNhbGxiYWNrIHRvIGNhbGwgYmFjayB3aXRoIGEgdG9rZW4gc3RyaW5nIG9yIHRva2VuIHJlcXVlc3QvZGV0YWlscyBvYmplY3QsIGJ1dCBnb3QgYSAnICtcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRva2VuUmVxdWVzdE9yRGV0YWlscztcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCBtc2cpO1xuICAgICAgICAgICAgICAgIF9jYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2JqZWN0U2l6ZSA9IEpTT04uc3RyaW5naWZ5KHRva2VuUmVxdWVzdE9yRGV0YWlscykubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9iamVjdFNpemUgPiBNQVhfVE9LRU5fTEVOR1RIICYmICFhdXRoT3B0aW9ucy5zdXBwcmVzc01heExlbmd0aENoZWNrKSB7XG4gICAgICAgICAgICAgICAgX2NhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdUb2tlbiByZXF1ZXN0L2RldGFpbHMgb2JqZWN0IGV4Y2VlZGVkIG1heCBwZXJtaXR0ZWQgc3RyaW5naWZpZWQgc2l6ZSAod2FzICcgKyBvYmplY3RTaXplICsgJyBieXRlcyknLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdpc3N1ZWQnIGluIHRva2VuUmVxdWVzdE9yRGV0YWlscykge1xuICAgICAgICAgICAgICAgIC8qIGEgdG9rZW5EZXRhaWxzIG9iamVjdCAqL1xuICAgICAgICAgICAgICAgIF9jYWxsYmFjayhudWxsLCB0b2tlblJlcXVlc3RPckRldGFpbHMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKCdrZXlOYW1lJyBpbiB0b2tlblJlcXVlc3RPckRldGFpbHMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdFeHBlY3RlZCB0b2tlbiByZXF1ZXN0IGNhbGxiYWNrIHRvIGNhbGwgYmFjayB3aXRoIGEgdG9rZW4gc3RyaW5nLCB0b2tlbiByZXF1ZXN0IG9iamVjdCwgb3IgdG9rZW4gZGV0YWlscyBvYmplY3QnO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsIG1zZyk7XG4gICAgICAgICAgICAgICAgX2NhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGl0J3MgYSB0b2tlbiByZXF1ZXN0LCBzbyBtYWtlIHRoZSByZXF1ZXN0ICovXG4gICAgICAgICAgICB0b2tlblJlcXVlc3QodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLCBmdW5jdGlvbiAoZXJyLCB0b2tlblJlc3BvbnNlLCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgJ3Rva2VuIHJlcXVlc3QgQVBJIGNhbGwgcmV0dXJuZWQgZXJyb3I7IGVyciA9ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIF9jYWxsYmFjayhub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXVucGFja2VkKVxuICAgICAgICAgICAgICAgICAgICB0b2tlblJlc3BvbnNlID0gSlNPTi5wYXJzZSh0b2tlblJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGguZ2V0VG9rZW4oKScsICd0b2tlbiByZWNlaXZlZCcpO1xuICAgICAgICAgICAgICAgIF9jYWxsYmFjayhudWxsLCB0b2tlblJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgc2lnbiBhIHRva2VuIHJlcXVlc3QgYmFzZWQgb24gdGhlIGdpdmVuIG9wdGlvbnMuXG4gICAgICogTk9URSB0aGlzIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiB0aGUga2V5IHZhbHVlIGlzIGF2YWlsYWJsZSBsb2NhbGx5LlxuICAgICAqIE90aGVyd2lzZSwgc2lnbmVkIHRva2VuIHJlcXVlc3RzIG11c3QgYmUgb2J0YWluZWQgZnJvbSB0aGUga2V5XG4gICAgICogb3duZXIgKGVpdGhlciB1c2luZyB0aGUgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayBvciB1cmwpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGF1dGhPcHRpb25zXG4gICAgICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3Qgb3B0aW9uczpcbiAgICAgKiAtIGtleTogICAgICAgICAgIHRoZSBrZXkgdG8gdXNlLiBJZiBub3Qgc3BlY2lmaWVkLCBhIGtleSBwYXNzZWQgaW4gY29uc3RydWN0aW5nXG4gICAgICogICAgICAgICAgICAgICAgICB0aGUgUmVzdCBpbnRlcmZhY2Ugd2lsbCBiZSB1c2VkXG4gICAgICpcbiAgICAgKiAtIHF1ZXJ5VGltZSAgICAgIChvcHRpb25hbCkgYm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgdGhlIGFibHkgc3lzdGVtIHNob3VsZCBiZVxuICAgICAqICAgICAgICAgICAgICAgICAgcXVlcmllZCBmb3IgdGhlIGN1cnJlbnQgdGltZSB3aGVuIG5vbmUgaXMgc3BlY2lmaWVkIGV4cGxpY2l0bHlcbiAgICAgKlxuICAgICAqIC0gcmVxdWVzdEhlYWRlcnMgKG9wdGlvbmFsLCB1bnN1cHBvcnRlZCwgZm9yIHRlc3Rpbmcgb25seSkgZXh0cmEgaGVhZGVycyB0byBhZGQgdG8gdGhlXG4gICAgICogICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW4gcmVxdWVzdFxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuUGFyYW1zXG4gICAgICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcmFtZXRlcnMgZm9yIHRoZSByZXF1ZXN0ZWQgdG9rZW46XG4gICAgICogLSB0dGw6ICAgICAgIChvcHRpb25hbCkgdGhlIHJlcXVlc3RlZCBsaWZlIG9mIHRoZSB0b2tlbiBpbiBtcy4gSWYgbm9uZSBpcyBzcGVjaWZpZWRcbiAgICAgKiAgICAgICAgICAgICAgICAgIGEgZGVmYXVsdCBvZiAxIGhvdXIgaXMgcHJvdmlkZWQuIFRoZSBtYXhpbXVtIGxpZmV0aW1lIGlzIDI0aG91cnM7IGFueSByZXF1ZXN0XG4gICAgICogICAgICAgICAgICAgICAgICBleGNlZWRpbmcgdGhhdCBsaWZldGltZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiAtIGNhcGFiaWxpdHk6ICAgIChvcHRpb25hbCkgdGhlIGNhcGFiaWxpdHkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGFjY2VzcyB0b2tlbi5cbiAgICAgKiAgICAgICAgICAgICAgICAgIElmIG5vbmUgaXMgc3BlY2lmaWVkLCBhIHRva2VuIHdpbGwgYmUgcmVxdWVzdGVkIHdpdGggYWxsIG9mIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzIG9mIHRoZSBzcGVjaWZpZWQga2V5LlxuICAgICAqXG4gICAgICogLSBjbGllbnRJZDogICAgICAob3B0aW9uYWwpIGEgY2xpZW50IElEIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSB0b2tlbjsgaWYgbm90XG4gICAgICogICAgICAgICAgICAgICAgICBzcGVjaWZpZWQsIGEgY2xpZW50SWQgcGFzc2VkIGluIGNvbnN0cnVjdGluZyB0aGUgUmVzdCBpbnRlcmZhY2Ugd2lsbCBiZSB1c2VkXG4gICAgICpcbiAgICAgKiAtIHRpbWVzdGFtcDogICAgIChvcHRpb25hbCkgdGhlIHRpbWUgaW4gbXMgc2luY2UgdGhlIGVwb2NoLiBJZiBub25lIGlzIHNwZWNpZmllZCxcbiAgICAgKiAgICAgICAgICAgICAgICAgIHRoZSBzeXN0ZW0gd2lsbCBiZSBxdWVyaWVkIGZvciBhIHRpbWUgdmFsdWUgdG8gdXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICovXG4gICAgQXV0aC5wcm90b3R5cGUuY3JlYXRlVG9rZW5SZXF1ZXN0ID0gZnVuY3Rpb24gKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyogc2h1ZmZsZSBhbmQgbm9ybWFsaXNlIGFyZ3VtZW50cyBhcyBuZWNlc3NhcnkgKi9cbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlblBhcmFtcyA9PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSB0b2tlblBhcmFtcztcbiAgICAgICAgICAgIGF1dGhPcHRpb25zID0gdG9rZW5QYXJhbXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhdXRoT3B0aW9ucyA9PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhdXRoT3B0aW9ucztcbiAgICAgICAgICAgIGF1dGhPcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbGxiYWNrICYmIHRoaXMuY2xpZW50Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2NyZWF0ZVRva2VuUmVxdWVzdCcsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogUlNBOWg6IGlmIGF1dGhPcHRpb25zIHBhc3NlZCBpbiwgdGhleSdyZSB1c2VkIGluc3RlYWQgb2Ygc3RvcmVkLCBkb24ndCBtZXJnZSB0aGVtICovXG4gICAgICAgIGF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnMgfHwgdGhpcy5hdXRoT3B0aW9ucztcbiAgICAgICAgdG9rZW5QYXJhbXMgPSB0b2tlblBhcmFtcyB8fCBVdGlscy5jb3B5KHRoaXMudG9rZW5QYXJhbXMpO1xuICAgICAgICB2YXIga2V5ID0gYXV0aE9wdGlvbnMua2V5O1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ05vIGtleSBzcGVjaWZpZWQnLCA0MDEwMSwgNDAzKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleVBhcnRzID0ga2V5LnNwbGl0KCc6JyksIGtleU5hbWUgPSBrZXlQYXJ0c1swXSwga2V5U2VjcmV0ID0ga2V5UGFydHNbMV07XG4gICAgICAgIGlmICgha2V5U2VjcmV0KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnSW52YWxpZCBrZXkgc3BlY2lmaWVkJywgNDAxMDEsIDQwMykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlblBhcmFtcy5jbGllbnRJZCA9PT0gJycpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdjbGllbnRJZCBjYW7igJl0IGJlIGFuIGVtcHR5IHN0cmluZycsIDQwMDEyLCA0MDApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2NhcGFiaWxpdHknIGluIHRva2VuUGFyYW1zKSB7XG4gICAgICAgICAgICB0b2tlblBhcmFtcy5jYXBhYmlsaXR5ID0gYzE0bih0b2tlblBhcmFtcy5jYXBhYmlsaXR5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVxdWVzdCA9IFV0aWxzLm1peGluKHsga2V5TmFtZToga2V5TmFtZSB9LCB0b2tlblBhcmFtcyksIGNsaWVudElkID0gdG9rZW5QYXJhbXMuY2xpZW50SWQgfHwgJycsIHR0bCA9IHRva2VuUGFyYW1zLnR0bCB8fCAnJywgY2FwYWJpbGl0eSA9IHRva2VuUGFyYW1zLmNhcGFiaWxpdHkgfHwgJyc7XG4gICAgICAgIChmdW5jdGlvbiAoYXV0aG9yaXNlQ2IpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIGF1dGhvcmlzZUNiKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZ2V0VGltZXN0YW1wKGF1dGhPcHRpb25zICYmIGF1dGhPcHRpb25zLnF1ZXJ5VGltZSwgZnVuY3Rpb24gKGVyciwgdGltZSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXF1ZXN0LnRpbWVzdGFtcCA9IHRpbWU7XG4gICAgICAgICAgICAgICAgYXV0aG9yaXNlQ2IoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvKiBub25jZSAqL1xuICAgICAgICAgICAgLyogTk9URTogdGhlcmUgaXMgbm8gZXhwZWN0YXRpb24gdGhhdCB0aGUgY2xpZW50XG4gICAgICAgICAgICAgKiBzcGVjaWZpZXMgdGhlIG5vbmNlOyB0aGlzIGlzIGRvbmUgYnkgdGhlIGxpYnJhcnlcbiAgICAgICAgICAgICAqIEhvd2V2ZXIsIHRoaXMgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGNsaWVudFxuICAgICAgICAgICAgICogc2ltcGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLiAqL1xuICAgICAgICAgICAgdmFyIG5vbmNlID0gcmVxdWVzdC5ub25jZSB8fCAocmVxdWVzdC5ub25jZSA9IHJhbmRvbSgpKSwgdGltZXN0YW1wID0gcmVxdWVzdC50aW1lc3RhbXA7XG4gICAgICAgICAgICB2YXIgc2lnblRleHQgPSByZXF1ZXN0LmtleU5hbWUgKyAnXFxuJyArIHR0bCArICdcXG4nICsgY2FwYWJpbGl0eSArICdcXG4nICsgY2xpZW50SWQgKyAnXFxuJyArIHRpbWVzdGFtcCArICdcXG4nICsgbm9uY2UgKyAnXFxuJztcbiAgICAgICAgICAgIC8qIG1hYyAqL1xuICAgICAgICAgICAgLyogTk9URTogdGhlcmUgaXMgbm8gZXhwZWN0YXRpb24gdGhhdCB0aGUgY2xpZW50XG4gICAgICAgICAgICAgKiBzcGVjaWZpZXMgdGhlIG1hYzsgdGhpcyBpcyBkb25lIGJ5IHRoZSBsaWJyYXJ5XG4gICAgICAgICAgICAgKiBIb3dldmVyLCB0aGlzIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBjbGllbnRcbiAgICAgICAgICAgICAqIHNpbXBseSBmb3IgdGVzdGluZyBwdXJwb3Nlcy4gKi9cbiAgICAgICAgICAgIHJlcXVlc3QubWFjID0gcmVxdWVzdC5tYWMgfHwgaG1hYyhzaWduVGV4dCwga2V5U2VjcmV0KTtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQXV0aC5nZXRUb2tlblJlcXVlc3QoKScsICdnZW5lcmF0ZWQgc2lnbmVkIHJlcXVlc3QnKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcXVlc3QpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXV0aCBxdWVyeSBwYXJhbXMgdG8gdXNlIGZvciBhIHdlYnNvY2tldCBjb25uZWN0aW9uLFxuICAgICAqIGJhc2VkIG9uIHRoZSBjdXJyZW50IGF1dGggcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIEF1dGgucHJvdG90eXBlLmdldEF1dGhQYXJhbXMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMubWV0aG9kID09ICdiYXNpYycpXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7IGtleTogdGhpcy5rZXkgfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKGZhbHNlLCBmdW5jdGlvbiAoZXJyLCB0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoLmdldEF1dGhQYXJhbXMoKTogX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzIHJldHVybmVkIG5vIGVycm9yIG9yIHRva2VuRGV0YWlscycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7IGFjY2Vzc190b2tlbjogdG9rZW5EZXRhaWxzLnRva2VuIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGF1dGhvcml6YXRpb24gaGVhZGVyIHRvIHVzZSBmb3IgYSBSRVNUIG9yIGNvbWV0IHJlcXVlc3QsXG4gICAgICogYmFzZWQgb24gdGhlIGN1cnJlbnQgYXV0aCBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgQXV0aC5wcm90b3R5cGUuZ2V0QXV0aEhlYWRlcnMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMubWV0aG9kID09ICdiYXNpYycpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsgYXV0aG9yaXphdGlvbjogJ0Jhc2ljICcgKyB0aGlzLmJhc2ljS2V5IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZmFsc2UsIGZ1bmN0aW9uIChlcnIsIHRva2VuRGV0YWlscykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuRGV0YWlscykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGguZ2V0QXV0aFBhcmFtcygpOiBfZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMgcmV0dXJuZWQgbm8gZXJyb3Igb3IgdG9rZW5EZXRhaWxzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsgYXV0aG9yaXphdGlvbjogJ0JlYXJlciAnICsgVXRpbHMudG9CYXNlNjQodG9rZW5EZXRhaWxzLnRva2VuKSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgdGltZSBiYXNlZCBvbiB0aGUgbG9jYWwgY2xvY2ssXG4gICAgICogb3IgaWYgdGhlIG9wdGlvbiBxdWVyeVRpbWUgaXMgdHJ1ZSwgcmV0dXJuIHRoZSBzZXJ2ZXIgdGltZS5cbiAgICAgKiBUaGUgc2VydmVyIHRpbWUgb2Zmc2V0IGZyb20gdGhlIGxvY2FsIHRpbWUgaXMgc3RvcmVkIHNvIHRoYXRcbiAgICAgKiBvbmx5IG9uZSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdG8gZ2V0IHRoZSB0aW1lIGlzIGV2ZXIgbmVlZGVkXG4gICAgICovXG4gICAgQXV0aC5wcm90b3R5cGUuZ2V0VGltZXN0YW1wID0gZnVuY3Rpb24gKHF1ZXJ5VGltZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVGltZU9mZnNldFNldCgpICYmIChxdWVyeVRpbWUgfHwgdGhpcy5hdXRoT3B0aW9ucy5xdWVyeVRpbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudC50aW1lKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRoaXMuZ2V0VGltZXN0YW1wVXNpbmdPZmZzZXQoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1dGgucHJvdG90eXBlLmdldFRpbWVzdGFtcFVzaW5nT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gVXRpbHMubm93KCkgKyAodGhpcy5jbGllbnQuc2VydmVyVGltZU9mZnNldCB8fCAwKTtcbiAgICB9O1xuICAgIEF1dGgucHJvdG90eXBlLmlzVGltZU9mZnNldFNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnNlcnZlclRpbWVPZmZzZXQgIT09IG51bGw7XG4gICAgfTtcbiAgICBBdXRoLnByb3RvdHlwZS5fc2F2ZUJhc2ljT3B0aW9ucyA9IGZ1bmN0aW9uIChhdXRoT3B0aW9ucykge1xuICAgICAgICB0aGlzLm1ldGhvZCA9ICdiYXNpYyc7XG4gICAgICAgIHRoaXMua2V5ID0gYXV0aE9wdGlvbnMua2V5O1xuICAgICAgICB0aGlzLmJhc2ljS2V5ID0gVXRpbHMudG9CYXNlNjQoYXV0aE9wdGlvbnMua2V5KTtcbiAgICAgICAgdGhpcy5hdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zIHx8IHt9O1xuICAgICAgICBpZiAoJ2NsaWVudElkJyBpbiBhdXRoT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fdXNlclNldENsaWVudElkKGF1dGhPcHRpb25zLmNsaWVudElkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXV0aC5wcm90b3R5cGUuX3NhdmVUb2tlbk9wdGlvbnMgPSBmdW5jdGlvbiAodG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gJ3Rva2VuJztcbiAgICAgICAgaWYgKHRva2VuUGFyYW1zKSB7XG4gICAgICAgICAgICAvKiBXZSB0ZW1wb3JhcmlseSBwZXJzaXN0IHRva2VuUGFyYW1zLnRpbWVzdGFtcCBpbiBjYXNlIGEgbmV3IHRva2VuIG5lZWRzXG4gICAgICAgICAgICAgKiB0byBiZSByZXF1ZXN0ZWQsIHRoZW4gbnVsbCBpdCBvdXQgaW4gdGhlIGNhbGxiYWNrIG9mXG4gICAgICAgICAgICAgKiBfZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMgZm9yIFJTQTEwZyBjb21wbGlhbmNlICovXG4gICAgICAgICAgICB0aGlzLnRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1dGhPcHRpb25zKSB7XG4gICAgICAgICAgICAvKiBub3JtYWxpc2UgKi9cbiAgICAgICAgICAgIGlmIChhdXRoT3B0aW9ucy50b2tlbikge1xuICAgICAgICAgICAgICAgIC8qIG9wdGlvbnMudG9rZW4gbWF5IGNvbnRhaW4gYSB0b2tlbiBzdHJpbmcgb3IsIGZvciBjb252ZW5pZW5jZSwgYSBUb2tlbkRldGFpbHMgKi9cbiAgICAgICAgICAgICAgICBhdXRoT3B0aW9ucy50b2tlbkRldGFpbHMgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgYXV0aE9wdGlvbnMudG9rZW4gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgdG9rZW46IGF1dGhPcHRpb25zLnRva2VuIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogYXV0aE9wdGlvbnMudG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2tlbkRldGFpbHMgPSBhdXRoT3B0aW9ucy50b2tlbkRldGFpbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ2NsaWVudElkJyBpbiBhdXRoT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VzZXJTZXRDbGllbnRJZChhdXRoT3B0aW9ucy5jbGllbnRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qIEBwYXJhbSBmb3JjZVN1cGVyc2VkZTogZm9yY2UgYSBuZXcgdG9rZW4gcmVxdWVzdCBldmVuIGlmIHRoZXJlJ3Mgb25lIGluXG4gICAgICogcHJvZ3Jlc3MsIG1ha2luZyBhbGwgcGVuZGluZyBjYWxsYmFja3Mgd2FpdCBmb3IgdGhlIG5ldyBvbmUgKi9cbiAgICBBdXRoLnByb3RvdHlwZS5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMgPSBmdW5jdGlvbiAoZm9yY2VTdXBlcnNlZGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMudG9rZW5EZXRhaWxzO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90b2tlbkNsaWVudElkTWlzbWF0Y2godG9rZW4uY2xpZW50SWQpKSB7XG4gICAgICAgICAgICAgICAgLyogNDAzIHRvIHRyaWdnZXIgYSBwZXJtYW5lbnRseSBmYWlsZWQgY2xpZW50IC0gUlNBMTVjICovXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ01pc21hdGNoIGJldHdlZW4gY2xpZW50SWQgaW4gdG9rZW4gKCcgKyB0b2tlbi5jbGllbnRJZCArICcpIGFuZCBjdXJyZW50IGNsaWVudElkICgnICsgdGhpcy5jbGllbnRJZCArICcpJywgNDAxMDIsIDQwMykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFJTQTRiMSAtLSBpZiB3ZSBoYXZlIGEgc2VydmVyIHRpbWUgb2Zmc2V0IHNldCBhbHJlYWR5LCB3ZSBjYW5cbiAgICAgICAgICAgICAqIGF1dG9tYXRpY2FsbHkgcmVtb3ZlIGV4cGlyZWQgdG9rZW5zLiBFbHNlIGp1c3QgdXNlIHRoZSBjYWNoZWQgdG9rZW4uIElmIGl0IGlzXG4gICAgICAgICAgICAgKiBleHBpcmVkIEFibHkgd2lsbCB0ZWxsIHVzIGFuZCB3ZSdsbCBkaXNjYXJkIGl0IHRoZW4uICovXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUaW1lT2Zmc2V0U2V0KCkgfHwgIXRva2VuLmV4cGlyZXMgfHwgdG9rZW4uZXhwaXJlcyA+PSB0aGlzLmdldFRpbWVzdGFtcFVzaW5nT2Zmc2V0KCkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGguZ2V0VG9rZW4oKScsICd1c2luZyBjYWNoZWQgdG9rZW47IGV4cGlyZXMgPSAnICsgdG9rZW4uZXhwaXJlcyk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGV4cGlyZWQsIHNvIHJlbW92ZSBhbmQgZmFsbHRocm91Z2ggdG8gZ2V0dGluZyBhIG5ldyBvbmUgKi9cbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQXV0aC5nZXRUb2tlbigpJywgJ2RlbGV0aW5nIGV4cGlyZWQgdG9rZW4nKTtcbiAgICAgICAgICAgIHRoaXMudG9rZW5EZXRhaWxzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAodGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0IHx8ICh0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBtdWx0aWNhc3Rlcl8xLmRlZmF1bHQuY3JlYXRlKCkpKS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFRva2VuUmVxdWVzdElkICE9PSBudWxsICYmICFmb3JjZVN1cGVyc2VkZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIFJlcXVlc3QgYSBuZXcgdG9rZW4gKi9cbiAgICAgICAgdmFyIHRva2VuUmVxdWVzdElkID0gKHRoaXMuY3VycmVudFRva2VuUmVxdWVzdElkID0gZ2V0VG9rZW5SZXF1ZXN0SWQoKSk7XG4gICAgICAgIHRoaXMucmVxdWVzdFRva2VuKHRoaXMudG9rZW5QYXJhbXMsIHRoaXMuYXV0aE9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIHRva2VuUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgPiB0b2tlblJlcXVlc3RJZCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQXV0aC5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoKScsICdEaXNjYXJkaW5nIHRva2VuIHJlcXVlc3QgcmVzcG9uc2U7IG92ZXJ0YWtlbiBieSBuZXdlciBvbmUnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IF90aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgfHwgbm9vcDtcbiAgICAgICAgICAgIF90aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrcyhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrcyhudWxsLCAoX3RoaXMudG9rZW5EZXRhaWxzID0gdG9rZW5SZXNwb25zZSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qIFVzZXItc2V0OiBjaGVjayB0eXBlcywgJyonIGlzIGRpc2FsbG93ZWQsIHRocm93IGFueSBlcnJvcnMgKi9cbiAgICBBdXRoLnByb3RvdHlwZS5fdXNlclNldENsaWVudElkID0gZnVuY3Rpb24gKGNsaWVudElkKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiBjbGllbnRJZCA9PT0gJ3N0cmluZycgfHwgY2xpZW50SWQgPT09IG51bGwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnY2xpZW50SWQgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVsbCcsIDQwMDEyLCA0MDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsaWVudElkID09PSAnKicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdDYW7igJl0IHVzZSBcIipcIiBhcyBhIGNsaWVudElkIGFzIHRoYXQgc3RyaW5nIGlzIHJlc2VydmVkLiAoVG8gY2hhbmdlIHRoZSBkZWZhdWx0IHRva2VuIHJlcXVlc3QgYmVoYXZpb3VyIHRvIHVzZSBhIHdpbGRjYXJkIGNsaWVudElkLCBpbnN0YW50aWF0ZSB0aGUgbGlicmFyeSB3aXRoIHtkZWZhdWx0VG9rZW5QYXJhbXM6IHtjbGllbnRJZDogXCIqXCJ9fSksIG9yIGlmIGNhbGxpbmcgYXV0aG9yaXplKCksIHBhc3MgaXQgaW4gYXMgYSB0b2tlblBhcmFtOiBhdXRob3JpemUoe2NsaWVudElkOiBcIipcIn0sIGF1dGhPcHRpb25zKScsIDQwMDEyLCA0MDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGVyciA9IHRoaXMuX3VuY2hlY2tlZFNldENsaWVudElkKGNsaWVudElkKTtcbiAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiBBYmx5LXNldDogbm8gdHlwZWNoZWNraW5nLCAnKicgaXMgYWxsb3dlZCBidXQgbm90IHNldCBvbiB0aGlzLmNsaWVudElkKSwgcmV0dXJuIGVycm9ycyB0byB0aGUgY2FsbGVyICovXG4gICAgQXV0aC5wcm90b3R5cGUuX3VuY2hlY2tlZFNldENsaWVudElkID0gZnVuY3Rpb24gKGNsaWVudElkKSB7XG4gICAgICAgIGlmICh0aGlzLl90b2tlbkNsaWVudElkTWlzbWF0Y2goY2xpZW50SWQpKSB7XG4gICAgICAgICAgICAvKiBTaG91bGQgbmV2ZXIgaGFwcGVuIGluIG5vcm1hbCBjaXJjdW1zdGFuY2VzIGFzIHJlYWx0aW1lIHNob3VsZFxuICAgICAgICAgICAgICogcmVjb2duaXNlIG1pc21hdGNoIGFuZCByZXR1cm4gYW4gZXJyb3IgKi9cbiAgICAgICAgICAgIHZhciBtc2cgPSAnVW5leHBlY3RlZCBjbGllbnRJZCBtaXNtYXRjaDogY2xpZW50IGhhcyAnICsgdGhpcy5jbGllbnRJZCArICcsIHJlcXVlc3RlZCAnICsgY2xpZW50SWQ7XG4gICAgICAgICAgICB2YXIgZXJyID0gbmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA0MDEwMiwgNDAxKTtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQXV0aC5fdW5jaGVja2VkU2V0Q2xpZW50SWQoKScsIG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogUlNBN2E0OiBpZiBvcHRpb25zLmNsaWVudElkIGlzIHByb3ZpZGVkIGFuZCBpcyBub3RcbiAgICAgICAgICAgICAqIG51bGwsIGl0IG92ZXJyaWRlcyBkZWZhdWx0VG9rZW5QYXJhbXMuY2xpZW50SWQgKi9cbiAgICAgICAgICAgIHRoaXMuY2xpZW50SWQgPSB0aGlzLnRva2VuUGFyYW1zLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXV0aC5wcm90b3R5cGUuX3Rva2VuQ2xpZW50SWRNaXNtYXRjaCA9IGZ1bmN0aW9uICh0b2tlbkNsaWVudElkKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLmNsaWVudElkICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudElkICE9PSAnKicgJiZcbiAgICAgICAgICAgIHRva2VuQ2xpZW50SWQgJiZcbiAgICAgICAgICAgIHRva2VuQ2xpZW50SWQgIT09ICcqJyAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRJZCAhPT0gdG9rZW5DbGllbnRJZCk7XG4gICAgfTtcbiAgICBBdXRoLmlzVG9rZW5FcnIgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLmNvZGUgJiYgZXJyb3IuY29kZSA+PSA0MDE0MCAmJiBlcnJvci5jb2RlIDwgNDAxNTA7XG4gICAgfTtcbiAgICBBdXRoLnByb3RvdHlwZS5yZXZva2VUb2tlbnMgPSBmdW5jdGlvbiAoc3BlY2lmaWVycywgb3B0aW9uc09yQ2FsbGJhY2tBcmcsIGNhbGxiYWNrQXJnKSB7XG4gICAgICAgIGlmICh1c2VUb2tlbkF1dGgodGhpcy5jbGllbnQub3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdDYW5ub3QgcmV2b2tlIHRva2VucyB3aGVuIHVzaW5nIHRva2VuIGF1dGgnLCA0MDE2MiwgNDAxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5TmFtZSA9IHRoaXMuY2xpZW50Lm9wdGlvbnMua2V5TmFtZTtcbiAgICAgICAgdmFyIHJlc29sdmVkT3B0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zT3JDYWxsYmFja0FyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2tBcmcgPSBvcHRpb25zT3JDYWxsYmFja0FyZztcbiAgICAgICAgICAgIHJlc29sdmVkT3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZWRPcHRpb25zID0gb3B0aW9uc09yQ2FsbGJhY2tBcmcgIT09IG51bGwgJiYgb3B0aW9uc09yQ2FsbGJhY2tBcmcgIT09IHZvaWQgMCA/IG9wdGlvbnNPckNhbGxiYWNrQXJnIDoge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrQXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAncmV2b2tlVG9rZW5zJywgW3NwZWNpZmllcnMsIHJlc29sdmVkT3B0aW9uc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2tBcmcgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrQXJnO1xuICAgICAgICB2YXIgcmVxdWVzdEJvZHlEVE8gPSB0c2xpYl8xLl9fYXNzaWduKHsgdGFyZ2V0czogc3BlY2lmaWVycy5tYXAoZnVuY3Rpb24gKHNwZWNpZmllcikgeyByZXR1cm4gXCJcIi5jb25jYXQoc3BlY2lmaWVyLnR5cGUsIFwiOlwiKS5jb25jYXQoc3BlY2lmaWVyLnZhbHVlKTsgfSkgfSwgcmVzb2x2ZWRPcHRpb25zKTtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuY2xpZW50Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdFBvc3RIZWFkZXJzKHRoaXMuY2xpZW50Lm9wdGlvbnMsIGZvcm1hdCk7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCB0aGlzLmNsaWVudC5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICB2YXIgcmVxdWVzdEJvZHkgPSBVdGlscy5lbmNvZGVCb2R5KHJlcXVlc3RCb2R5RFRPLCBmb3JtYXQpO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQucG9zdCh0aGlzLmNsaWVudCwgXCIva2V5cy9cIi5jb25jYXQoa2V5TmFtZSwgXCIvcmV2b2tlVG9rZW5zXCIpLCByZXF1ZXN0Qm9keSwgaGVhZGVycywgeyBuZXdCYXRjaFJlc3BvbnNlOiAndHJ1ZScgfSwgbnVsbCwgZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHJlbW92ZSB0aGlzIHR5cGUgYXNzZXJ0aW9uIGFmdGVyIGZpeGluZyBodHRwczovL2dpdGh1Yi5jb20vYWJseS9hYmx5LWpzL2lzc3Vlcy8xNDA1XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmF0Y2hSZXN1bHQgPSAodW5wYWNrZWQgPyBib2R5IDogVXRpbHMuZGVjb2RlQm9keShib2R5LCBmb3JtYXQpKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGJhdGNoUmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQXV0aDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBdXRoO1xuXG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBIdHRwTWV0aG9kcztcbihmdW5jdGlvbiAoSHR0cE1ldGhvZHMpIHtcbiAgICBIdHRwTWV0aG9kc1tcIkdldFwiXSA9IFwiZ2V0XCI7XG4gICAgSHR0cE1ldGhvZHNbXCJEZWxldGVcIl0gPSBcImRlbGV0ZVwiO1xuICAgIEh0dHBNZXRob2RzW1wiUG9zdFwiXSA9IFwicG9zdFwiO1xuICAgIEh0dHBNZXRob2RzW1wiUHV0XCJdID0gXCJwdXRcIjtcbiAgICBIdHRwTWV0aG9kc1tcIlBhdGNoXCJdID0gXCJwYXRjaFwiO1xufSkoSHR0cE1ldGhvZHMgfHwgKEh0dHBNZXRob2RzID0ge30pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEh0dHBNZXRob2RzO1xuXG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSHR0cFBhZ2luYXRlZFJlc3BvbnNlID0gZXhwb3J0cy5QYWdpbmF0ZWRSZXN1bHQgPSB2b2lkIDA7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIHJlc291cmNlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSk7XG5mdW5jdGlvbiBnZXRSZWxQYXJhbXMobGlua1VybCkge1xuICAgIHZhciB1cmxNYXRjaCA9IGxpbmtVcmwubWF0Y2goL15cXC5cXC8oXFx3KylcXD8oLiopJC8pO1xuICAgIHJldHVybiB1cmxNYXRjaCAmJiB1cmxNYXRjaFsyXSAmJiBVdGlscy5wYXJzZVF1ZXJ5U3RyaW5nKHVybE1hdGNoWzJdKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmVsTGlua3MobGlua0hlYWRlcikge1xuICAgIGlmICh0eXBlb2YgbGlua0hlYWRlciA9PSAnc3RyaW5nJylcbiAgICAgICAgbGlua0hlYWRlciA9IGxpbmtIZWFkZXIuc3BsaXQoJywnKTtcbiAgICB2YXIgcmVsUGFyYW1zID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rSGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5rTWF0Y2ggPSBsaW5rSGVhZGVyW2ldLm1hdGNoKC9eXFxzKjwoLispPjtcXHMqcmVsPVwiKFxcdyspXCIkLyk7XG4gICAgICAgIGlmIChsaW5rTWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBnZXRSZWxQYXJhbXMobGlua01hdGNoWzFdKTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMpXG4gICAgICAgICAgICAgICAgcmVsUGFyYW1zW2xpbmtNYXRjaFsyXV0gPSBwYXJhbXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlbFBhcmFtcztcbn1cbmZ1bmN0aW9uIHJldHVybkVyck9ubHkoZXJyLCBib2R5LCB1c2VIUFIpIHtcbiAgICAvKiBJZiB1c2luZyBodHRwUGFnaW5hdGVkUmVzcG9uc2UsIGVycm9ycyBmcm9tIEFibHkgYXJlIHJldHVybmVkIGFzIHBhcnQgb2ZcbiAgICAgKiB0aGUgSFBSLCBvbmx5IGRvIGNhbGxiYWNrKGVycikgZm9yIG5ldHdvcmsgZXJyb3JzIGV0Yy4gd2hpY2ggZG9uJ3RcbiAgICAgKiByZXR1cm4gYSBib2R5IGFuZC9vciBoYXZlIG5vIGFibHktb3JpZ2luYXRlZCBlcnJvciBjb2RlIChub24tbnVtZXJpY1xuICAgICAqIGVycm9yIGNvZGVzIG9yaWdpbmF0ZSBmcm9tIG5vZGUpICovXG4gICAgcmV0dXJuICEodXNlSFBSICYmIChib2R5IHx8IHR5cGVvZiBlcnIuY29kZSA9PT0gJ251bWJlcicpKTtcbn1cbnZhciBQYWdpbmF0ZWRSZXNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYWdpbmF0ZWRSZXNvdXJjZShyZXN0LCBwYXRoLCBoZWFkZXJzLCBlbnZlbG9wZSwgYm9keUhhbmRsZXIsIHVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSkge1xuICAgICAgICB0aGlzLnJlc3QgPSByZXN0O1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB0aGlzLmVudmVsb3BlID0gZW52ZWxvcGUgIT09IG51bGwgJiYgZW52ZWxvcGUgIT09IHZvaWQgMCA/IGVudmVsb3BlIDogbnVsbDtcbiAgICAgICAgdGhpcy5ib2R5SGFuZGxlciA9IGJvZHlIYW5kbGVyO1xuICAgICAgICB0aGlzLnVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSA9IHVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSB8fCBmYWxzZTtcbiAgICB9XG4gICAgUGFnaW5hdGVkUmVzb3VyY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdC5nZXQodGhpcy5yZXN0LCB0aGlzLnBhdGgsIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmdW5jdGlvbiAoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlUGFnZShlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUGFnaW5hdGVkUmVzb3VyY2UucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdC5kZWxldGUodGhpcy5yZXN0LCB0aGlzLnBhdGgsIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmdW5jdGlvbiAoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlUGFnZShlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUGFnaW5hdGVkUmVzb3VyY2UucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBib2R5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQucG9zdCh0aGlzLnJlc3QsIHRoaXMucGF0aCwgYm9keSwgdGhpcy5oZWFkZXJzLCBwYXJhbXMsIHRoaXMuZW52ZWxvcGUsIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlQm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVBhZ2UoZXJyLCByZXNwb25zZUJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUGFnaW5hdGVkUmVzb3VyY2UucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChwYXJhbXMsIGJvZHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdC5wdXQodGhpcy5yZXN0LCB0aGlzLnBhdGgsIGJvZHksIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZUJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVQYWdlKGVyciwgcmVzcG9uc2VCb2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBhZ2luYXRlZFJlc291cmNlLnByb3RvdHlwZS5wYXRjaCA9IGZ1bmN0aW9uIChwYXJhbXMsIGJvZHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdC5wYXRjaCh0aGlzLnJlc3QsIHRoaXMucGF0aCwgYm9keSwgdGhpcy5oZWFkZXJzLCBwYXJhbXMsIHRoaXMuZW52ZWxvcGUsIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlQm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVBhZ2UoZXJyLCByZXNwb25zZUJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUGFnaW5hdGVkUmVzb3VyY2UucHJvdG90eXBlLmhhbmRsZVBhZ2UgPSBmdW5jdGlvbiAoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGVyciAmJiByZXR1cm5FcnJPbmx5KGVyciwgYm9keSwgdGhpcy51c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1BhZ2luYXRlZFJlc291cmNlLmhhbmRsZVBhZ2UoKScsICdVbmV4cGVjdGVkIGVycm9yIGdldHRpbmcgcmVzb3VyY2U6IGVyciA9ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXRlbXMsIGxpbmtIZWFkZXIsIHJlbFBhcmFtcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGl0ZW1zID0gdGhpcy5ib2R5SGFuZGxlcihib2R5LCBoZWFkZXJzIHx8IHt9LCB1bnBhY2tlZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIElmIHdlIGdvdCBhbiBlcnJvciwgdGhlIGZhaWx1cmUgdG8gcGFyc2UgdGhlIGJvZHkgaXMgYWxtb3N0IGNlcnRhaW5seVxuICAgICAgICAgICAgICogZHVlIHRvIHRoYXQsIHNvIGNhbGxiYWNrIHdpdGggdGhhdCBpbiBwcmVmZXJlbmNlIG92ZXIgdGhlIHBhcnNlIGVycm9yICovXG4gICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soZXJyIHx8IGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXJzICYmIChsaW5rSGVhZGVyID0gaGVhZGVyc1snTGluayddIHx8IGhlYWRlcnNbJ2xpbmsnXSkpIHtcbiAgICAgICAgICAgIHJlbFBhcmFtcyA9IHBhcnNlUmVsTGlua3MobGlua0hlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBuZXcgSHR0cFBhZ2luYXRlZFJlc3BvbnNlKHRoaXMsIGl0ZW1zLCBoZWFkZXJzIHx8IHt9LCBzdGF0dXNDb2RlLCByZWxQYXJhbXMsIGVycikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbmV3IFBhZ2luYXRlZFJlc3VsdCh0aGlzLCBpdGVtcywgcmVsUGFyYW1zKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBQYWdpbmF0ZWRSZXNvdXJjZTtcbn0oKSk7XG52YXIgUGFnaW5hdGVkUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhZ2luYXRlZFJlc3VsdChyZXNvdXJjZSwgaXRlbXMsIHJlbFBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlc291cmNlID0gcmVzb3VyY2U7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAocmVsUGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoJ2ZpcnN0JyBpbiByZWxQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FsbGJhY2sgJiYgc2VsZi5yZXNvdXJjZS5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkoc2VsZiwgJ2ZpcnN0JywgW10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZ2V0KHJlbFBhcmFtcy5maXJzdCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ2N1cnJlbnQnIGluIHJlbFBhcmFtcykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrICYmIHNlbGYucmVzb3VyY2UucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHNlbGYsICdjdXJyZW50JywgW10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZ2V0KHJlbFBhcmFtcy5jdXJyZW50LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmV4dCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmICghY2FsbGJhY2sgJiYgc2VsZi5yZXNvdXJjZS5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeShzZWxmLCAnbmV4dCcsIFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCduZXh0JyBpbiByZWxQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5nZXQocmVsUGFyYW1zLm5leHQsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmhhc05leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICduZXh0JyBpbiByZWxQYXJhbXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5pc0xhc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiAhKChfYSA9IF90aGlzLmhhc05leHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKF90aGlzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIFdlIGFzc3VtZSB0aGF0IG9ubHkgdGhlIGluaXRpYWwgcmVxdWVzdCBjYW4gYmUgYSBQT1NULCBhbmQgdGhhdCBhY2Nlc3NpbmdcbiAgICAgKiB0aGUgcmVzdCBvZiBhIG11bHRpcGFnZSBzZXQgb2YgcmVzdWx0cyBjYW4gYWx3YXlzIGJlIGRvbmUgd2l0aCBHRVQgKi9cbiAgICBQYWdpbmF0ZWRSZXN1bHQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLnJlc291cmNlO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQuZ2V0KHJlcy5yZXN0LCByZXMucGF0aCwgcmVzLmhlYWRlcnMsIHBhcmFtcywgcmVzLmVudmVsb3BlLCBmdW5jdGlvbiAoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgcmVzLmhhbmRsZVBhZ2UoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBQYWdpbmF0ZWRSZXN1bHQ7XG59KCkpO1xuZXhwb3J0cy5QYWdpbmF0ZWRSZXN1bHQgPSBQYWdpbmF0ZWRSZXN1bHQ7XG52YXIgSHR0cFBhZ2luYXRlZFJlc3BvbnNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEh0dHBQYWdpbmF0ZWRSZXNwb25zZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIdHRwUGFnaW5hdGVkUmVzcG9uc2UocmVzb3VyY2UsIGl0ZW1zLCBoZWFkZXJzLCBzdGF0dXNDb2RlLCByZWxQYXJhbXMsIGVycikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByZXNvdXJjZSwgaXRlbXMsIHJlbFBhcmFtcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICAgIF90aGlzLnN1Y2Nlc3MgPSBzdGF0dXNDb2RlIDwgMzAwICYmIHN0YXR1c0NvZGUgPj0gMjAwO1xuICAgICAgICBfdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgX3RoaXMuZXJyb3JDb2RlID0gZXJyICYmIGVyci5jb2RlO1xuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSBlcnIgJiYgZXJyLm1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSHR0cFBhZ2luYXRlZFJlc3BvbnNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpdGVtczogdGhpcy5pdGVtcyxcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IHRoaXMuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRoaXMuc3VjY2VzcyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGVycm9yQ29kZTogdGhpcy5lcnJvckNvZGUsXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2U6IHRoaXMuZXJyb3JNZXNzYWdlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEh0dHBQYWdpbmF0ZWRSZXNwb25zZTtcbn0oUGFnaW5hdGVkUmVzdWx0KSk7XG5leHBvcnRzLkh0dHBQYWdpbmF0ZWRSZXNwb25zZSA9IEh0dHBQYWdpbmF0ZWRSZXNwb25zZTtcbmV4cG9ydHMuZGVmYXVsdCA9IFBhZ2luYXRlZFJlc291cmNlO1xuXG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNSZXRyaWFibGUgPSB2b2lkIDA7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBDb25uZWN0aW9uRXJyb3JDb2RlcyA9IHtcbiAgICBESVNDT05ORUNURUQ6IDgwMDAzLFxuICAgIFNVU1BFTkRFRDogODAwMDIsXG4gICAgRkFJTEVEOiA4MDAwMCxcbiAgICBDTE9TSU5HOiA4MDAxNyxcbiAgICBDTE9TRUQ6IDgwMDE3LFxuICAgIFVOS05PV05fQ09OTkVDVElPTl9FUlI6IDUwMDAyLFxuICAgIFVOS05PV05fQ0hBTk5FTF9FUlI6IDUwMDAxLFxufTtcbnZhciBDb25uZWN0aW9uRXJyb3JzID0ge1xuICAgIGRpc2Nvbm5lY3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICAgICAgICAgIGNvZGU6IENvbm5lY3Rpb25FcnJvckNvZGVzLkRJU0NPTk5FQ1RFRCxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdDb25uZWN0aW9uIHRvIHNlcnZlciB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZScsXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgc3VzcGVuZGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogNDAwLFxuICAgICAgICAgICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuU1VTUEVOREVELFxuICAgICAgICAgICAgbWVzc2FnZTogJ0Nvbm5lY3Rpb24gdG8gc2VydmVyIHVuYXZhaWxhYmxlJyxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBmYWlsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgICAgICAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5GQUlMRUQsXG4gICAgICAgICAgICBtZXNzYWdlOiAnQ29ubmVjdGlvbiBmYWlsZWQgb3IgZGlzY29ubmVjdGVkIGJ5IHNlcnZlcicsXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgY2xvc2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICAgICAgICAgIGNvZGU6IENvbm5lY3Rpb25FcnJvckNvZGVzLkNMT1NJTkcsXG4gICAgICAgICAgICBtZXNzYWdlOiAnQ29ubmVjdGlvbiBjbG9zaW5nJyxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBjbG9zZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgICAgICAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5DTE9TRUQsXG4gICAgICAgICAgICBtZXNzYWdlOiAnQ29ubmVjdGlvbiBjbG9zZWQnLFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHVua25vd25Db25uZWN0aW9uRXJyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogNTAwLFxuICAgICAgICAgICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuVU5LTk9XTl9DT05ORUNUSU9OX0VSUixcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdJbnRlcm5hbCBjb25uZWN0aW9uIGVycm9yJyxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICB1bmtub3duQ2hhbm5lbEVycjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICAgICAgICAgIGNvZGU6IENvbm5lY3Rpb25FcnJvckNvZGVzLlVOS05PV05fQ09OTkVDVElPTl9FUlIsXG4gICAgICAgICAgICBtZXNzYWdlOiAnSW50ZXJuYWwgY2hhbm5lbCBlcnJvcicsXG4gICAgICAgIH0pO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gaXNSZXRyaWFibGUoZXJyKSB7XG4gICAgaWYgKCFlcnIuc3RhdHVzQ29kZSB8fCAhZXJyLmNvZGUgfHwgZXJyLnN0YXR1c0NvZGUgPj0gNTAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhDb25uZWN0aW9uRXJyb3JDb2RlcykuaW5jbHVkZXMoZXJyLmNvZGUpO1xufVxuZXhwb3J0cy5pc1JldHJpYWJsZSA9IGlzUmV0cmlhYmxlO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvbkVycm9ycztcblxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgWEhSU3RhdGVzO1xuKGZ1bmN0aW9uIChYSFJTdGF0ZXMpIHtcbiAgICBYSFJTdGF0ZXNbWEhSU3RhdGVzW1wiUkVRX1NFTkRcIl0gPSAwXSA9IFwiUkVRX1NFTkRcIjtcbiAgICBYSFJTdGF0ZXNbWEhSU3RhdGVzW1wiUkVRX1JFQ1ZcIl0gPSAxXSA9IFwiUkVRX1JFQ1ZcIjtcbiAgICBYSFJTdGF0ZXNbWEhSU3RhdGVzW1wiUkVRX1JFQ1ZfUE9MTFwiXSA9IDJdID0gXCJSRVFfUkVDVl9QT0xMXCI7XG4gICAgWEhSU3RhdGVzW1hIUlN0YXRlc1tcIlJFUV9SRUNWX1NUUkVBTVwiXSA9IDNdID0gXCJSRVFfUkVDVl9TVFJFQU1cIjtcbn0pKFhIUlN0YXRlcyB8fCAoWEhSU3RhdGVzID0ge30pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFhIUlN0YXRlcztcblxuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg1KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg1OCksIF9fd2VicGFja19yZXF1aXJlX18oMTEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKSwgX193ZWJwYWNrX3JlcXVpcmVfXygzMiksIF9fd2VicGFja19yZXF1aXJlX18oMjQpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyOCksIF9fd2VicGFja19yZXF1aXJlX18oNTkpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHRyZXR1cm4gQ3J5cHRvSlM7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgTXVsdGljYXN0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gUHJpdmF0ZSBjb25zdHJ1Y3RvcjsgdXNlIHN0YXRpYyBNdWx0aWNhc3Rlci5jcmVhdGUgaW5zdGVhZFxuICAgIGZ1bmN0aW9uIE11bHRpY2FzdGVyKG1lbWJlcnMpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycyB8fCBbXTtcbiAgICB9XG4gICAgTXVsdGljYXN0ZXIucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBfYiA9IHRoaXMubWVtYmVyczsgX2EgPCBfYi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBtZW1iZXIgPSBfYltfYV07XG4gICAgICAgICAgICBpZiAobWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnTXVsdGljYXN0ZXIgbXVsdGlwbGUgY2FsbGJhY2sgaGFuZGxlcicsICdVbmV4cGVjdGVkIGV4Y2VwdGlvbjogJyArIGUgKyAnOyBzdGFjayA9ICcgKyBlLnN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE11bHRpY2FzdGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5tZW1iZXJzKS5wdXNoLmFwcGx5KF9hLCBhcmdzKTtcbiAgICB9O1xuICAgIE11bHRpY2FzdGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChtZW1iZXJzKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBNdWx0aWNhc3RlcihtZW1iZXJzKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLmNhbGwuYXBwbHkoaW5zdGFuY2UsIGFyZ3MpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGluc3RhbmNlLnB1c2goZm4pOyB9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBNdWx0aWNhc3Rlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBNdWx0aWNhc3RlcjtcblxuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmODtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8qKlxuXHQgICAgICogSE1BQyBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBITUFDID0gQ19hbGdvLkhNQUMgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIEhNQUMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBobWFjSGFzaGVyID0gQ3J5cHRvSlMuYWxnby5ITUFDLmNyZWF0ZShDcnlwdG9KUy5hbGdvLlNIQTI1Niwga2V5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoaGFzaGVyLCBrZXkpIHtcblx0ICAgICAgICAgICAgLy8gSW5pdCBoYXNoZXJcblx0ICAgICAgICAgICAgaGFzaGVyID0gdGhpcy5faGFzaGVyID0gbmV3IGhhc2hlci5pbml0KCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAga2V5ID0gVXRmOC5wYXJzZShrZXkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBoYXNoZXJCbG9ja1NpemUgPSBoYXNoZXIuYmxvY2tTaXplO1xuXHQgICAgICAgICAgICB2YXIgaGFzaGVyQmxvY2tTaXplQnl0ZXMgPSBoYXNoZXJCbG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEFsbG93IGFyYml0cmFyeSBsZW5ndGgga2V5c1xuXHQgICAgICAgICAgICBpZiAoa2V5LnNpZ0J5dGVzID4gaGFzaGVyQmxvY2tTaXplQnl0ZXMpIHtcblx0ICAgICAgICAgICAgICAgIGtleSA9IGhhc2hlci5maW5hbGl6ZShrZXkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAga2V5LmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ2xvbmUga2V5IGZvciBpbm5lciBhbmQgb3V0ZXIgcGFkc1xuXHQgICAgICAgICAgICB2YXIgb0tleSA9IHRoaXMuX29LZXkgPSBrZXkuY2xvbmUoKTtcblx0ICAgICAgICAgICAgdmFyIGlLZXkgPSB0aGlzLl9pS2V5ID0ga2V5LmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBvS2V5V29yZHMgPSBvS2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgaUtleVdvcmRzID0gaUtleS53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBYT1Iga2V5cyB3aXRoIHBhZCBjb25zdGFudHNcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYXNoZXJCbG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgb0tleVdvcmRzW2ldIF49IDB4NWM1YzVjNWM7XG5cdCAgICAgICAgICAgICAgICBpS2V5V29yZHNbaV0gXj0gMHgzNjM2MzYzNjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvS2V5LnNpZ0J5dGVzID0gaUtleS5zaWdCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZUJ5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIEhNQUMgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhtYWNIYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaGFzaGVyID0gdGhpcy5faGFzaGVyO1xuXG5cdCAgICAgICAgICAgIC8vIFJlc2V0XG5cdCAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAgICBoYXNoZXIudXBkYXRlKHRoaXMuX2lLZXkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVcGRhdGVzIHRoaXMgSE1BQyB3aXRoIGEgbWVzc2FnZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtITUFDfSBUaGlzIEhNQUMgaW5zdGFuY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhtYWNIYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIGhtYWNIYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoZXIudXBkYXRlKG1lc3NhZ2VVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBITUFDIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKCk7XG5cdCAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhhc2hlciA9IHRoaXMuX2hhc2hlcjtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIEhNQUNcblx0ICAgICAgICAgICAgdmFyIGlubmVySGFzaCA9IGhhc2hlci5maW5hbGl6ZShtZXNzYWdlVXBkYXRlKTtcblx0ICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICAgIHZhciBobWFjID0gaGFzaGVyLmZpbmFsaXplKHRoaXMuX29LZXkuY2xvbmUoKS5jb25jYXQoaW5uZXJIYXNoKSk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhtYWM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdH0oKSk7XG5cblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzU3VjY2Vzc0NvZGUgPSB2b2lkIDA7XG52YXIgSHR0cFN0YXR1c0NvZGVzO1xuKGZ1bmN0aW9uIChIdHRwU3RhdHVzQ29kZXMpIHtcbiAgICBIdHRwU3RhdHVzQ29kZXNbSHR0cFN0YXR1c0NvZGVzW1wiU3VjY2Vzc1wiXSA9IDIwMF0gPSBcIlN1Y2Nlc3NcIjtcbiAgICBIdHRwU3RhdHVzQ29kZXNbSHR0cFN0YXR1c0NvZGVzW1wiTm9Db250ZW50XCJdID0gMjA0XSA9IFwiTm9Db250ZW50XCI7XG4gICAgSHR0cFN0YXR1c0NvZGVzW0h0dHBTdGF0dXNDb2Rlc1tcIkJhZFJlcXVlc3RcIl0gPSA0MDBdID0gXCJCYWRSZXF1ZXN0XCI7XG4gICAgSHR0cFN0YXR1c0NvZGVzW0h0dHBTdGF0dXNDb2Rlc1tcIlVuYXV0aG9yaXplZFwiXSA9IDQwMV0gPSBcIlVuYXV0aG9yaXplZFwiO1xuICAgIEh0dHBTdGF0dXNDb2Rlc1tIdHRwU3RhdHVzQ29kZXNbXCJGb3JiaWRkZW5cIl0gPSA0MDNdID0gXCJGb3JiaWRkZW5cIjtcbiAgICBIdHRwU3RhdHVzQ29kZXNbSHR0cFN0YXR1c0NvZGVzW1wiUmVxdWVzdFRpbWVvdXRcIl0gPSA0MDhdID0gXCJSZXF1ZXN0VGltZW91dFwiO1xuICAgIEh0dHBTdGF0dXNDb2Rlc1tIdHRwU3RhdHVzQ29kZXNbXCJJbnRlcm5hbFNlcnZlckVycm9yXCJdID0gNTAwXSA9IFwiSW50ZXJuYWxTZXJ2ZXJFcnJvclwiO1xufSkoSHR0cFN0YXR1c0NvZGVzIHx8IChIdHRwU3RhdHVzQ29kZXMgPSB7fSkpO1xuZnVuY3Rpb24gaXNTdWNjZXNzQ29kZShzdGF0dXNDb2RlKSB7XG4gICAgcmV0dXJuIHN0YXR1c0NvZGUgPj0gSHR0cFN0YXR1c0NvZGVzLlN1Y2Nlc3MgJiYgc3RhdHVzQ29kZSA8IEh0dHBTdGF0dXNDb2Rlcy5CYWRSZXF1ZXN0O1xufVxuZXhwb3J0cy5pc1N1Y2Nlc3NDb2RlID0gaXNTdWNjZXNzQ29kZTtcbmV4cG9ydHMuZGVmYXVsdCA9IEh0dHBTdGF0dXNDb2RlcztcblxuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgcHJvdG9jb2xtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBldmVudGVtaXR0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNykpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgY29ubmVjdGlvbmVycm9yc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyMCkpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIGFjdGlvbnMgPSBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LkFjdGlvbjtcbnZhciBjbG9zZU1lc3NhZ2UgPSBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoeyBhY3Rpb246IGFjdGlvbnMuQ0xPU0UgfSk7XG52YXIgZGlzY29ubmVjdE1lc3NhZ2UgPSBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoeyBhY3Rpb246IGFjdGlvbnMuRElTQ09OTkVDVCB9KTtcbi8qXG4gKiBUcmFuc3BvcnQgaW5zdGFuY2VzIGluaGVyaXQgZnJvbSBFdmVudEVtaXR0ZXIgYW5kIGVtaXQgdGhlIGZvbGxvd2luZyBldmVudHM6XG4gKlxuICogZXZlbnQgbmFtZSAgICAgICBkYXRhXG4gKiBjbG9zZWQgICAgICAgICAgIGVycm9yXG4gKiBmYWlsZWQgICAgICAgICAgIGVycm9yXG4gKiBkaXNwb3NlZFxuICogY29ubmVjdGVkICAgICAgICBudWxsIGVycm9yLCBjb25uZWN0aW9uU2VyaWFsLCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzXG4gKiBldmVudCAgICAgICAgICAgIGNoYW5uZWwgbWVzc2FnZSBvYmplY3RcbiAqL1xudmFyIFRyYW5zcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUcmFuc3BvcnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMsIGZvcmNlSnNvblByb3RvY29sKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIGlmIChmb3JjZUpzb25Qcm90b2NvbCkge1xuICAgICAgICAgICAgcGFyYW1zLmZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHBhcmFtcy5oZWFydGJlYXRzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IGNvbm5lY3Rpb25NYW5hZ2VyO1xuICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5yZWdpc3RlclByb3Bvc2VkVHJhbnNwb3J0KF90aGlzKTtcbiAgICAgICAgX3RoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgIF90aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgX3RoaXMudGltZW91dHMgPSBwYXJhbXMub3B0aW9ucy50aW1lb3V0cztcbiAgICAgICAgX3RoaXMuZm9ybWF0ID0gcGFyYW1zLmZvcm1hdDtcbiAgICAgICAgX3RoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuaXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLm1heElkbGVJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIF90aGlzLmlkbGVUaW1lciA9IG51bGw7XG4gICAgICAgIF90aGlzLmxhc3RBY3Rpdml0eSA9IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RDbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluaXNoKCdjbG9zZWQnLCBjb25uZWN0aW9uZXJyb3JzXzEuZGVmYXVsdC5jbG9zZWQoKSk7XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8qIFVzZWQgZm9yIG5ldHdvcmsvdHJhbnNwb3J0IGlzc3VlcyB0aGF0IG5lZWQgdG8gcmVzdWx0IGluIHRoZSB0cmFuc3BvcnRcbiAgICAgICAgICogYmVpbmcgZGlzY29ubmVjdGVkLCBidXQgc2hvdWxkIG5vdCB0cmFuc2l0aW9uIHRoZSBjb25uZWN0aW9uIHRvICdmYWlsZWQnICovXG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3REaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVyciB8fCBjb25uZWN0aW9uZXJyb3JzXzEuZGVmYXVsdC5kaXNjb25uZWN0ZWQoKSk7XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLmZhaWwgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8qIFVzZWQgZm9yIGNsaWVudC1zaWRlLWRldGVjdGVkIGZhdGFsIGNvbm5lY3Rpb24gaXNzdWVzICovXG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3REaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5pc2goJ2ZhaWxlZCcsIGVyciB8fCBjb25uZWN0aW9uZXJyb3JzXzEuZGVmYXVsdC5mYWlsZWQoKSk7XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uIChldmVudCwgZXJyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICBjbGVhclRpbWVvdXQoKF9hID0gdGhpcy5pZGxlVGltZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KGV2ZW50LCBlcnIpO1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUub25Qcm90b2NvbE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAobG9nZ2VyXzEuZGVmYXVsdC5zaG91bGRMb2cobG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1RyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpJywgJ3JlY2VpdmVkIG9uICcgK1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvcnROYW1lICtcbiAgICAgICAgICAgICAgICAnOiAnICtcbiAgICAgICAgICAgICAgICBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LnN0cmluZ2lmeShtZXNzYWdlKSArXG4gICAgICAgICAgICAgICAgJzsgY29ubmVjdGlvbklkID0gJyArXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25BY3Rpdml0eSgpO1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UuYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIGFjdGlvbnMuSEVBUlRCRUFUOlxuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKCknLCB0aGlzLnNob3J0TmFtZSArICcgaGVhcnRiZWF0OyBjb25uZWN0aW9uSWQgPSAnICsgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0JywgbWVzc2FnZS5pZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGFjdGlvbnMuQ09OTkVDVEVEOlxuICAgICAgICAgICAgICAgIHRoaXMub25Db25uZWN0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGVkJywgbWVzc2FnZS5lcnJvciwgbWVzc2FnZS5jb25uZWN0aW9uSWQsIG1lc3NhZ2UuY29ubmVjdGlvbkRldGFpbHMsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLkNMT1NFRDpcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGFjdGlvbnMuRElTQ09OTkVDVEVEOlxuICAgICAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLkFDSzpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2FjaycsIG1lc3NhZ2UubXNnU2VyaWFsLCBtZXNzYWdlLmNvdW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5OQUNLOlxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbmFjaycsIG1lc3NhZ2UubXNnU2VyaWFsLCBtZXNzYWdlLmNvdW50LCBtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5TWU5DOlxuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZShtZXNzYWdlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5BQ1RJVkFURTpcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmVkLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLkFVVEg6XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRoLmF1dGhvcml6ZShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKCknLCAnQWJseSByZXF1ZXN0ZWQgcmUtYXV0aGVudGljYXRpb24sIGJ1dCB1bmFibGUgdG8gb2J0YWluIGEgbmV3IHRva2VuOiAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGFjdGlvbnMuRVJST1I6XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBlcnJvciBhY3Rpb247IGNvbm5lY3Rpb25JZCA9ICcgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZCArXG4gICAgICAgICAgICAgICAgICAgICc7IGVyciA9ICcgK1xuICAgICAgICAgICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QobWVzc2FnZS5lcnJvcikgK1xuICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5jaGFubmVsID8gJywgY2hhbm5lbDogJyArIG1lc3NhZ2UuY2hhbm5lbCA6ICcnKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhbm5lbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25GYXRhbEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogb3RoZXJ3aXNlIGl0J3MgYSBjaGFubmVsLXNwZWNpZmljIGVycm9yLCBzbyBoYW5kbGUgaXQgaW4gdGhlIGNoYW5uZWwgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8qIGFsbCBvdGhlciBhY3Rpb25zIGFyZSBjaGFubmVsLXNwZWNpZmljICovXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ29ubmVjdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIW1lc3NhZ2UuY29ubmVjdGlvbkRldGFpbHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0Lm9uQ29ubmVjdCgpOiBDb25uZWN0IG1lc3NhZ2UgcmVjaWV2ZWQgd2l0aG91dCBjb25uZWN0aW9uRGV0YWlscycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhQcm9taXNlZElkbGUgPSBtZXNzYWdlLmNvbm5lY3Rpb25EZXRhaWxzLm1heElkbGVJbnRlcnZhbDtcbiAgICAgICAgaWYgKG1heFByb21pc2VkSWRsZSkge1xuICAgICAgICAgICAgdGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBtYXhQcm9taXNlZElkbGUgKyB0aGlzLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQ7XG4gICAgICAgICAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBlbHNlIFJlYWx0aW1lIGRlY2xpbmVzIHRvIGd1YXJhbnRlZSBhbnkgbWF4aW11bSBpZGxlIGludGVydmFsIC0gQ0QyaCAqL1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAvKiBVc2VkIGZvciB3aGVuIHRoZSBzZXJ2ZXIgaGFzIGRpc2Nvbm5lY3RlZCB0aGUgY2xpZW50ICh1c3VhbGx5IHdpdGggYVxuICAgICAgICAgKiBESVNDT05ORUNURUQgYWN0aW9uKSAqL1xuICAgICAgICB2YXIgZXJyID0gbWVzc2FnZSAmJiBtZXNzYWdlLmVycm9yO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5vbkRpc2Nvbm5lY3QoKScsICdlcnIgPSAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuICAgICAgICB0aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgZXJyKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUub25GYXRhbEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgLyogT24gcmVjZWlwdCBvZiBhIGZhdGFsIGNvbm5lY3Rpb24gZXJyb3IsIHdlIGNhbiBhc3N1bWUgdGhhdCB0aGUgc2VydmVyXG4gICAgICAgICAqIHdpbGwgY2xvc2UgdGhlIGNvbm5lY3Rpb24gYW5kIHRoZSB0cmFuc3BvcnQsIGFuZCBkbyBub3QgbmVlZCB0byByZXF1ZXN0XG4gICAgICAgICAqIGEgZGlzY29ubmVjdGlvbiAtIFJUTjE1aSAqL1xuICAgICAgICB2YXIgZXJyID0gbWVzc2FnZSAmJiBtZXNzYWdlLmVycm9yO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5vbkZhdGFsRXJyb3IoKScsICdlcnIgPSAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuICAgICAgICB0aGlzLmZpbmlzaCgnZmFpbGVkJywgZXJyKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnVHJhbnNwb3J0Lm9uQ2xvc2UoKScsICdlcnIgPSAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuICAgICAgICB0aGlzLmZpbmlzaCgnY2xvc2VkJywgZXJyKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUucmVxdWVzdENsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5yZXF1ZXN0Q2xvc2UoKScsICcnKTtcbiAgICAgICAgdGhpcy5zZW5kKGNsb3NlTWVzc2FnZSk7XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLnJlcXVlc3REaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5yZXF1ZXN0RGlzY29ubmVjdCgpJywgJycpO1xuICAgICAgICB0aGlzLnNlbmQoZGlzY29ubmVjdE1lc3NhZ2UpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBtc2cgPSB7IGFjdGlvbjogcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5BY3Rpb24uSEVBUlRCRUFUIH07XG4gICAgICAgIGlmIChpZClcbiAgICAgICAgICAgIG1zZy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnNlbmQocHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKG1zZykpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5kaXNwb3NlKCknLCAnJyk7XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub2ZmKCk7XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQWN0aXZpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5tYXhJZGxlSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RBY3Rpdml0eSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIubGFzdEFjdGl2aXR5ID0gVXRpbHMubm93KCk7XG4gICAgICAgIHRoaXMuc2V0SWRsZVRpbWVyKHRoaXMubWF4SWRsZUludGVydmFsICsgMTAwKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuc2V0SWRsZVRpbWVyID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmlkbGVUaW1lcikge1xuICAgICAgICAgICAgdGhpcy5pZGxlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbklkbGVUaW1lckV4cGlyZSgpO1xuICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUub25JZGxlVGltZXJFeHBpcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5sYXN0QWN0aXZpdHkgfHwgIXRoaXMubWF4SWRsZUludGVydmFsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydC5vbklkbGVUaW1lckV4cGlyZSgpOiBsYXN0QWN0aXZpdHkvbWF4SWRsZUludGVydmFsIG5vdCBzZXQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkbGVUaW1lciA9IG51bGw7XG4gICAgICAgIHZhciBzaW5jZUxhc3QgPSBVdGlscy5ub3coKSAtIHRoaXMubGFzdEFjdGl2aXR5O1xuICAgICAgICB2YXIgdGltZVJlbWFpbmluZyA9IHRoaXMubWF4SWRsZUludGVydmFsIC0gc2luY2VMYXN0O1xuICAgICAgICBpZiAodGltZVJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ05vIGFjdGl2aXR5IHNlZW4gZnJvbSByZWFsdGltZSBpbiAnICsgc2luY2VMYXN0ICsgJ21zOyBhc3N1bWluZyBjb25uZWN0aW9uIGhhcyBkcm9wcGVkJztcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnVHJhbnNwb3J0Lm9uSWRsZVRpbWVyRXhwaXJlKCknLCBtc2cpO1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgODAwMDMsIDQwOCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRJZGxlVGltZXIodGltZVJlbWFpbmluZyArIDEwMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyYW5zcG9ydC50cnlDb25uZWN0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydEN0b3IsIGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCB0cmFuc3BvcnRQYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0Q3Rvcihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgdHJhbnNwb3J0UGFyYW1zKTtcbiAgICAgICAgdmFyIHRyYW5zcG9ydEF0dGVtcHRUaW1lcjtcbiAgICAgICAgdmFyIGVycm9yQ2IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodHJhbnNwb3J0QXR0ZW1wdFRpbWVyKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHsgZXZlbnQ6IHRoaXMuZXZlbnQsIGVycm9yOiBlcnIgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZWFsdGltZVJlcXVlc3RUaW1lb3V0ID0gY29ubmVjdGlvbk1hbmFnZXIub3B0aW9ucy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0O1xuICAgICAgICB0cmFuc3BvcnRBdHRlbXB0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5vZmYoWydwcmVjb25uZWN0JywgJ2Rpc2Nvbm5lY3RlZCcsICdmYWlsZWQnXSk7XG4gICAgICAgICAgICB0cmFuc3BvcnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgZXJyb3JDYi5jYWxsKHsgZXZlbnQ6ICdkaXNjb25uZWN0ZWQnIH0sIG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdUaW1lb3V0IHdhaXRpbmcgZm9yIHRyYW5zcG9ydCB0byBpbmRpY2F0ZSBpdHNlbGYgdmlhYmxlJywgNTAwMDAsIDUwMCkpO1xuICAgICAgICB9LCByZWFsdGltZVJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uKFsnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCBlcnJvckNiKTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uKCdwcmVjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdUcmFuc3BvcnQudHJ5Q29ubmVjdCgpJywgJ3ZpYWJsZSB0cmFuc3BvcnQgJyArIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodHJhbnNwb3J0QXR0ZW1wdFRpbWVyKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5vZmYoWydmYWlsZWQnLCAnZGlzY29ubmVjdGVkJ10sIGVycm9yQ2IpO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdHJhbnNwb3J0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyYW5zcG9ydC5jb25uZWN0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhbnNwb3J0O1xufShldmVudGVtaXR0ZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBUcmFuc3BvcnQ7XG5cblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNiksIF9fd2VicGFja19yZXF1aXJlX18oNDApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblx0ICAgIHZhciBNRDUgPSBDX2FsZ28uTUQ1O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFRoaXMga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gaXMgbWVhbnQgdG8gY29uZm9ybSB3aXRoIEVWUF9CeXRlc1RvS2V5LlxuXHQgICAgICogd3d3Lm9wZW5zc2wub3JnL2RvY3MvY3J5cHRvL0VWUF9CeXRlc1RvS2V5Lmh0bWxcblx0ICAgICAqL1xuXHQgICAgdmFyIEV2cEtERiA9IENfYWxnby5FdnBLREYgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhlIGtleSBzaXplIGluIHdvcmRzIHRvIGdlbmVyYXRlLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAgICAgKiBAcHJvcGVydHkge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoIGFsZ29yaXRobSB0byB1c2UuIERlZmF1bHQ6IE1ENVxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdGVyYXRpb25zIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtLiBEZWZhdWx0OiAxXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGtleVNpemU6IDEyOC8zMixcblx0ICAgICAgICAgICAgaGFzaGVyOiBNRDUsXG5cdCAgICAgICAgICAgIGl0ZXJhdGlvbnM6IDFcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhlIGRlcml2YXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IDggfSk7XG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBrZXkgPSBrZGYuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY29tcHV0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0KSB7XG5cdCAgICAgICAgICAgIHZhciBibG9jaztcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2ZnID0gdGhpcy5jZmc7XG5cblx0ICAgICAgICAgICAgLy8gSW5pdCBoYXNoZXJcblx0ICAgICAgICAgICAgdmFyIGhhc2hlciA9IGNmZy5oYXNoZXIuY3JlYXRlKCk7XG5cblx0ICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRLZXkgPSBXb3JkQXJyYXkuY3JlYXRlKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5V29yZHMgPSBkZXJpdmVkS2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIga2V5U2l6ZSA9IGNmZy5rZXlTaXplO1xuXHQgICAgICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IGNmZy5pdGVyYXRpb25zO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGtleVxuXHQgICAgICAgICAgICB3aGlsZSAoZGVyaXZlZEtleVdvcmRzLmxlbmd0aCA8IGtleVNpemUpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChibG9jaykge1xuXHQgICAgICAgICAgICAgICAgICAgIGhhc2hlci51cGRhdGUoYmxvY2spO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgYmxvY2sgPSBoYXNoZXIudXBkYXRlKHBhc3N3b3JkKS5maW5hbGl6ZShzYWx0KTtcblx0ICAgICAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBJdGVyYXRpb25zXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gaGFzaGVyLmZpbmFsaXplKGJsb2NrKTtcblx0ICAgICAgICAgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZGVyaXZlZEtleS5jb25jYXQoYmxvY2spO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGRlcml2ZWRLZXkuc2lnQnl0ZXMgPSBrZXlTaXplICogNDtcblxuXHQgICAgICAgICAgICByZXR1cm4gZGVyaXZlZEtleTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBEZXJpdmVzIGEga2V5IGZyb20gYSBwYXNzd29yZC5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgY29tcHV0YXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCB9KTtcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XG5cdCAgICAgKi9cblx0ICAgIEMuRXZwS0RGID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0LCBjZmcpIHtcblx0ICAgICAgICByZXR1cm4gRXZwS0RGLmNyZWF0ZShjZmcpLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgfTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5FdnBLREY7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNiksIF9fd2VicGFja19yZXF1aXJlX18oMjcpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBDaXBoZXIgY29yZSBjb21wb25lbnRzLlxuXHQgKi9cblx0Q3J5cHRvSlMubGliLkNpcGhlciB8fCAoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBDX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtO1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0Zjg7XG5cdCAgICB2YXIgQmFzZTY0ID0gQ19lbmMuQmFzZTY0O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblx0ICAgIHZhciBFdnBLREYgPSBDX2FsZ28uRXZwS0RGO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2UgY2lwaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoaXMgY2lwaGVyJ3Mga2V5IHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl2U2l6ZSBUaGlzIGNpcGhlcidzIElWIHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9FTkNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBlbmNyeXB0aW9uIG1vZGUuXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX0RFQ19YRk9STV9NT0RFIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGRlY3J5cHRpb24gbW9kZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENpcGhlciA9IENfbGliLkNpcGhlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gaXYgVGhlIElWIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBlbmNyeXB0aW9uIG1vZGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlcn0gQSBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGVFbmNyeXB0b3Ioa2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVFbmNyeXB0b3I6IGZ1bmN0aW9uIChrZXksIGNmZykge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fRU5DX1hGT1JNX01PREUsIGtleSwgY2ZnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBkZWNyeXB0aW9uIG1vZGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlcn0gQSBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGVEZWNyeXB0b3Ioa2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVEZWNyeXB0b3I6IGZ1bmN0aW9uIChrZXksIGNmZykge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fREVDX1hGT1JNX01PREUsIGtleSwgY2ZnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4Zm9ybU1vZGUgRWl0aGVyIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gdHJhbnNvcm1hdGlvbiBtb2RlIGNvbnN0YW50LlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlKENyeXB0b0pTLmFsZ28uQUVTLl9FTkNfWEZPUk1fTU9ERSwga2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoeGZvcm1Nb2RlLCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBTdG9yZSB0cmFuc2Zvcm0gbW9kZSBhbmQga2V5XG5cdCAgICAgICAgICAgIHRoaXMuX3hmb3JtTW9kZSA9IHhmb3JtTW9kZTtcblx0ICAgICAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGNpcGhlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgY2lwaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSBidWZmZXJcblx0ICAgICAgICAgICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtY2lwaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHRoaXMuX2RvUmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRkcyBkYXRhIHRvIGJlIGVuY3J5cHRlZCBvciBkZWNyeXB0ZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGFVcGRhdGUgVGhlIGRhdGEgdG8gZW5jcnlwdCBvciBkZWNyeXB0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBwcm9jZXNzaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLnByb2Nlc3MoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKGRhdGFVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBQcm9jZXNzIGF2YWlsYWJsZSBibG9ja3Ncblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3MoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gcHJvY2Vzcy5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBmaW5hbCBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgZmluYWwgcHJvY2Vzc2luZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKGRhdGFVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gRmluYWwgZGF0YSB1cGRhdGVcblx0ICAgICAgICAgICAgaWYgKGRhdGFVcGRhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtY2lwaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZERhdGEgPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkRGF0YTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAga2V5U2l6ZTogMTI4LzMyLFxuXG5cdCAgICAgICAgaXZTaXplOiAxMjgvMzIsXG5cblx0ICAgICAgICBfRU5DX1hGT1JNX01PREU6IDEsXG5cblx0ICAgICAgICBfREVDX1hGT1JNX01PREU6IDIsXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHNob3J0Y3V0IGZ1bmN0aW9ucyB0byBhIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggZW5jcnlwdCBhbmQgZGVjcnlwdCBzaG9ydGN1dCBmdW5jdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBBRVMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5BRVMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIZWxwZXI6IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGFzc3dvcmRCYXNlZENpcGhlcjtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZUNpcGhlcjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2lwaGVyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChtZXNzYWdlLCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5lbmNyeXB0KGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVydGV4dCwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZGVjcnlwdChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0oKSlcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2Ugc3RyZWFtIGNpcGhlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxICgzMiBiaXRzKVxuXHQgICAgICovXG5cdCAgICB2YXIgU3RyZWFtQ2lwaGVyID0gQ19saWIuU3RyZWFtQ2lwaGVyID0gQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBwYXJ0aWFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDFcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIE1vZGUgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19tb2RlID0gQy5tb2RlID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgbW9kZSB0ZW1wbGF0ZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJsb2NrQ2lwaGVyTW9kZSA9IENfbGliLkJsb2NrQ2lwaGVyTW9kZSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZW5jcnlwdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZUVuY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVFbmNyeXB0b3I6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBtb2RlIGZvciBkZWNyeXB0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuY3JlYXRlRGVjcnlwdG9yKGNpcGhlciwgaXYud29yZHMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZURlY3J5cHRvcjogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuRGVjcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG1vZGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYud29yZHMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NpcGhlciA9IGNpcGhlcjtcblx0ICAgICAgICAgICAgdGhpcy5faXYgPSBpdjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDaXBoZXIgQmxvY2sgQ2hhaW5pbmcgbW9kZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENCQyA9IENfbW9kZS5DQkMgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFic3RyYWN0IGJhc2UgQ0JDIG1vZGUuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdmFyIENCQyA9IEJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENCQyBlbmNyeXB0b3IuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgQ0JDLkVuY3J5cHRvciA9IENCQy5leHRlbmQoe1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogUHJvY2Vzc2VzIHRoZSBkYXRhIGJsb2NrIGF0IG9mZnNldC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgVGhlIGRhdGEgd29yZHMgdG8gb3BlcmF0ZSBvbi5cblx0ICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IHdoZXJlIHRoZSBibG9jayBzdGFydHMuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBtb2RlLnByb2Nlc3NCbG9jayhkYXRhLndvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFhPUiBhbmQgZW5jcnlwdFxuXHQgICAgICAgICAgICAgICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xuXHQgICAgICAgICAgICAgICAgY2lwaGVyLmVuY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENCQyBkZWNyeXB0b3IuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgQ0JDLkRlY3J5cHRvciA9IENCQy5leHRlbmQoe1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogUHJvY2Vzc2VzIHRoZSBkYXRhIGJsb2NrIGF0IG9mZnNldC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgVGhlIGRhdGEgd29yZHMgdG8gb3BlcmF0ZSBvbi5cblx0ICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IHdoZXJlIHRoZSBibG9jayBzdGFydHMuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBtb2RlLnByb2Nlc3NCbG9jayhkYXRhLndvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuXHQgICAgICAgICAgICAgICAgdmFyIHRoaXNCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gRGVjcnlwdCBhbmQgWE9SXG5cdCAgICAgICAgICAgICAgICBjaXBoZXIuZGVjcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBUaGlzIGJsb2NrIGJlY29tZXMgdGhlIHByZXZpb3VzIGJsb2NrXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB0aGlzQmxvY2s7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIGZ1bmN0aW9uIHhvckJsb2NrKHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSkge1xuXHQgICAgICAgICAgICB2YXIgYmxvY2s7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGl2ID0gdGhpcy5faXY7XG5cblx0ICAgICAgICAgICAgLy8gQ2hvb3NlIG1peGluZyBibG9ja1xuXHQgICAgICAgICAgICBpZiAoaXYpIHtcblx0ICAgICAgICAgICAgICAgIGJsb2NrID0gaXY7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgYmxvY2sgPSB0aGlzLl9wcmV2QmxvY2s7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBYT1IgYmxvY2tzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW29mZnNldCArIGldIF49IGJsb2NrW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIENCQztcblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogUGFkZGluZyBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX3BhZCA9IEMucGFkID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogUEtDUyAjNS83IHBhZGRpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBQa2NzNyA9IENfcGFkLlBrY3M3ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFBhZHMgZGF0YSB1c2luZyB0aGUgYWxnb3JpdGhtIGRlZmluZWQgaW4gUEtDUyAjNS83LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGRhdGEgVGhlIGRhdGEgdG8gcGFkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG11bHRpcGxlIHRoYXQgdGhlIGRhdGEgc2hvdWxkIGJlIHBhZGRlZCB0by5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgQ3J5cHRvSlMucGFkLlBrY3M3LnBhZCh3b3JkQXJyYXksIDQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhZDogZnVuY3Rpb24gKGRhdGEsIGJsb2NrU2l6ZSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvdW50IHBhZGRpbmcgYnl0ZXNcblx0ICAgICAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBibG9ja1NpemVCeXRlcyAtIGRhdGEuc2lnQnl0ZXMgJSBibG9ja1NpemVCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgcGFkZGluZyB3b3JkXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nV29yZCA9IChuUGFkZGluZ0J5dGVzIDw8IDI0KSB8IChuUGFkZGluZ0J5dGVzIDw8IDE2KSB8IChuUGFkZGluZ0J5dGVzIDw8IDgpIHwgblBhZGRpbmdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ1dvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblBhZGRpbmdCeXRlczsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nV29yZHMucHVzaChwYWRkaW5nV29yZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSBXb3JkQXJyYXkuY3JlYXRlKHBhZGRpbmdXb3JkcywgblBhZGRpbmdCeXRlcyk7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YS5jb25jYXQocGFkZGluZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVucGFkcyBkYXRhIHRoYXQgaGFkIGJlZW4gcGFkZGVkIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byB1bnBhZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgQ3J5cHRvSlMucGFkLlBrY3M3LnVucGFkKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdW5wYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgICAgIC8vIEdldCBudW1iZXIgb2YgcGFkZGluZyBieXRlcyBmcm9tIGxhc3QgYnl0ZVxuXHQgICAgICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGRhdGEud29yZHNbKGRhdGEuc2lnQnl0ZXMgLSAxKSA+Pj4gMl0gJiAweGZmO1xuXG5cdCAgICAgICAgICAgIC8vIFJlbW92ZSBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gblBhZGRpbmdCeXRlcztcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2UgYmxvY2sgY2lwaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBjaXBoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICovXG5cdCAgICB2YXIgQmxvY2tDaXBoZXIgPSBDX2xpYi5CbG9ja0NpcGhlciA9IENpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB0byB1c2UuIERlZmF1bHQ6IENCQ1xuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7UGFkZGluZ30gcGFkZGluZyBUaGUgcGFkZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IFBrY3M3XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBDaXBoZXIuY2ZnLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIG1vZGU6IENCQyxcblx0ICAgICAgICAgICAgcGFkZGluZzogUGtjczdcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBtb2RlQ3JlYXRvcjtcblxuXHQgICAgICAgICAgICAvLyBSZXNldCBjaXBoZXJcblx0ICAgICAgICAgICAgQ2lwaGVyLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjZmcgPSB0aGlzLmNmZztcblx0ICAgICAgICAgICAgdmFyIGl2ID0gY2ZnLml2O1xuXHQgICAgICAgICAgICB2YXIgbW9kZSA9IGNmZy5tb2RlO1xuXG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGJsb2NrIG1vZGVcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9FTkNfWEZPUk1fTU9ERSkge1xuXHQgICAgICAgICAgICAgICAgbW9kZUNyZWF0b3IgPSBtb2RlLmNyZWF0ZUVuY3J5cHRvcjtcblx0ICAgICAgICAgICAgfSBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcblx0ICAgICAgICAgICAgICAgIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVEZWNyeXB0b3I7XG5cdCAgICAgICAgICAgICAgICAvLyBLZWVwIGF0IGxlYXN0IG9uZSBibG9jayBpbiB0aGUgYnVmZmVyIGZvciB1bnBhZGRpbmdcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21pbkJ1ZmZlclNpemUgPSAxO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgJiYgdGhpcy5fbW9kZS5fX2NyZWF0b3IgPT0gbW9kZUNyZWF0b3IpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21vZGUuaW5pdCh0aGlzLCBpdiAmJiBpdi53b3Jkcyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9tb2RlID0gbW9kZUNyZWF0b3IuY2FsbChtb2RlLCB0aGlzLCBpdiAmJiBpdi53b3Jkcyk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9tb2RlLl9fY3JlYXRvciA9IG1vZGVDcmVhdG9yO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbW9kZS5wcm9jZXNzQmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcztcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuY2ZnLnBhZGRpbmc7XG5cblx0ICAgICAgICAgICAgLy8gRmluYWxpemVcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9FTkNfWEZPUk1fTU9ERSkge1xuXHQgICAgICAgICAgICAgICAgLy8gUGFkIGRhdGFcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmcucGFkKHRoaXMuX2RhdGEsIHRoaXMuYmxvY2tTaXplKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXHQgICAgICAgICAgICB9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi8ge1xuXHQgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBVbnBhZCBkYXRhXG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nLnVucGFkKGZpbmFsUHJvY2Vzc2VkQmxvY2tzKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2Nrcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiAxMjgvMzJcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgY29sbGVjdGlvbiBvZiBjaXBoZXIgcGFyYW1ldGVycy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gY2lwaGVydGV4dCBUaGUgcmF3IGNpcGhlcnRleHQuXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkgdG8gdGhpcyBjaXBoZXJ0ZXh0LlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGl2IFRoZSBJViB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IHNhbHQgVGhlIHNhbHQgdXNlZCB3aXRoIGEga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge0NpcGhlcn0gYWxnb3JpdGhtIFRoZSBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICogQHByb3BlcnR5IHtNb2RlfSBtb2RlIFRoZSBibG9jayBtb2RlIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge1BhZGRpbmd9IHBhZGRpbmcgVGhlIHBhZGRpbmcgc2NoZW1lIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBibG9jayBzaXplIG9mIHRoZSBjaXBoZXIuXG5cdCAgICAgKiBAcHJvcGVydHkge0Zvcm1hdH0gZm9ybWF0dGVyIFRoZSBkZWZhdWx0IGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gY29udmVydCB0aGlzIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgc3RyaW5nLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ2lwaGVyUGFyYW1zID0gQ19saWIuQ2lwaGVyUGFyYW1zID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaXBoZXJQYXJhbXMgQW4gb2JqZWN0IHdpdGggYW55IG9mIHRoZSBwb3NzaWJsZSBjaXBoZXIgcGFyYW1ldGVycy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmxpYi5DaXBoZXJQYXJhbXMuY3JlYXRlKHtcblx0ICAgICAgICAgKiAgICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHRXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBrZXk6IGtleVdvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIGl2OiBpdldvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIHNhbHQ6IHNhbHRXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBhbGdvcml0aG06IENyeXB0b0pTLmFsZ28uQUVTLFxuXHQgICAgICAgICAqICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DQkMsXG5cdCAgICAgICAgICogICAgICAgICBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuUEtDUzcsXG5cdCAgICAgICAgICogICAgICAgICBibG9ja1NpemU6IDQsXG5cdCAgICAgICAgICogICAgICAgICBmb3JtYXR0ZXI6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMXG5cdCAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcblx0ICAgICAgICAgICAgdGhpcy5taXhJbihjaXBoZXJQYXJhbXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtGb3JtYXR9IGZvcm1hdHRlciAoT3B0aW9uYWwpIFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIGNpcGhlciBwYXJhbXMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAdGhyb3dzIEVycm9yIElmIG5laXRoZXIgdGhlIGZvcm1hdHRlciBub3IgdGhlIGRlZmF1bHQgZm9ybWF0dGVyIGlzIHNldC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcyArICcnO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKCk7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMudG9TdHJpbmcoQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoZm9ybWF0dGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoZm9ybWF0dGVyIHx8IHRoaXMuZm9ybWF0dGVyKS5zdHJpbmdpZnkodGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRm9ybWF0IG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfZm9ybWF0ID0gQy5mb3JtYXQgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBPcGVuU1NMIGZvcm1hdHRpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBPcGVuU1NMRm9ybWF0dGVyID0gQ19mb3JtYXQuT3BlblNTTCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGFuIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc30gY2lwaGVyUGFyYW1zIFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBvcGVuU1NMU3RyaW5nID0gQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wuc3RyaW5naWZ5KGNpcGhlclBhcmFtcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG5cdCAgICAgICAgICAgIHZhciB3b3JkQXJyYXk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gY2lwaGVyUGFyYW1zLmNpcGhlcnRleHQ7XG5cdCAgICAgICAgICAgIHZhciBzYWx0ID0gY2lwaGVyUGFyYW1zLnNhbHQ7XG5cblx0ICAgICAgICAgICAgLy8gRm9ybWF0XG5cdCAgICAgICAgICAgIGlmIChzYWx0KSB7XG5cdCAgICAgICAgICAgICAgICB3b3JkQXJyYXkgPSBXb3JkQXJyYXkuY3JlYXRlKFsweDUzNjE2Yzc0LCAweDY1NjQ1ZjVmXSkuY29uY2F0KHNhbHQpLmNvbmNhdChjaXBoZXJ0ZXh0KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRBcnJheSA9IGNpcGhlcnRleHQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gd29yZEFycmF5LnRvU3RyaW5nKEJhc2U2NCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGFuIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcgdG8gYSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVuU1NMU3RyIFRoZSBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTC5wYXJzZShvcGVuU1NMU3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKG9wZW5TU0xTdHIpIHtcblx0ICAgICAgICAgICAgdmFyIHNhbHQ7XG5cblx0ICAgICAgICAgICAgLy8gUGFyc2UgYmFzZTY0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gQmFzZTY0LnBhcnNlKG9wZW5TU0xTdHIpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0V29yZHMgPSBjaXBoZXJ0ZXh0LndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFRlc3QgZm9yIHNhbHRcblx0ICAgICAgICAgICAgaWYgKGNpcGhlcnRleHRXb3Jkc1swXSA9PSAweDUzNjE2Yzc0ICYmIGNpcGhlcnRleHRXb3Jkc1sxXSA9PSAweDY1NjQ1ZjVmKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHNhbHRcblx0ICAgICAgICAgICAgICAgIHNhbHQgPSBXb3JkQXJyYXkuY3JlYXRlKGNpcGhlcnRleHRXb3Jkcy5zbGljZSgyLCA0KSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBzYWx0IGZyb20gY2lwaGVydGV4dFxuXHQgICAgICAgICAgICAgICAgY2lwaGVydGV4dFdvcmRzLnNwbGljZSgwLCA0KTtcblx0ICAgICAgICAgICAgICAgIGNpcGhlcnRleHQuc2lnQnl0ZXMgLT0gMTY7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGNpcGhlcnRleHQ6IGNpcGhlcnRleHQsIHNhbHQ6IHNhbHQgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIGNpcGhlciB3cmFwcGVyIHRoYXQgcmV0dXJucyBjaXBoZXJ0ZXh0IGFzIGEgc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICovXG5cdCAgICB2YXIgU2VyaWFsaXphYmxlQ2lwaGVyID0gQ19saWIuU2VyaWFsaXphYmxlQ2lwaGVyID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7Rm9ybWF0dGVyfSBmb3JtYXQgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gY29udmVydCBjaXBoZXIgcGFyYW0gb2JqZWN0cyB0byBhbmQgZnJvbSBhIHN0cmluZy4gRGVmYXVsdDogT3BlblNTTFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICBmb3JtYXQ6IE9wZW5TU0xGb3JtYXR0ZXJcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEVuY3J5cHRzIGEgbWVzc2FnZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYgfSk7XG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgIHZhciBlbmNyeXB0b3IgPSBjaXBoZXIuY3JlYXRlRW5jcnlwdG9yKGtleSwgY2ZnKTtcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBlbmNyeXB0b3IuZmluYWxpemUobWVzc2FnZSk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlckNmZyA9IGVuY3J5cHRvci5jZmc7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCByZXR1cm4gc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXNcblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoe1xuXHQgICAgICAgICAgICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dCxcblx0ICAgICAgICAgICAgICAgIGtleToga2V5LFxuXHQgICAgICAgICAgICAgICAgaXY6IGNpcGhlckNmZy5pdixcblx0ICAgICAgICAgICAgICAgIGFsZ29yaXRobTogY2lwaGVyLFxuXHQgICAgICAgICAgICAgICAgbW9kZTogY2lwaGVyQ2ZnLm1vZGUsXG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nOiBjaXBoZXJDZmcucGFkZGluZyxcblx0ICAgICAgICAgICAgICAgIGJsb2NrU2l6ZTogY2lwaGVyLmJsb2NrU2l6ZSxcblx0ICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogY2ZnLmZvcm1hdFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVjcnlwdHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwbGFpbnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGZvcm1hdHRlZENpcGhlcnRleHQsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGNpcGhlcnRleHRQYXJhbXMsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIENpcGhlclBhcmFtc1xuXHQgICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gdGhpcy5fcGFyc2UoY2lwaGVydGV4dCwgY2ZnLmZvcm1hdCk7XG5cblx0ICAgICAgICAgICAgLy8gRGVjcnlwdFxuXHQgICAgICAgICAgICB2YXIgcGxhaW50ZXh0ID0gY2lwaGVyLmNyZWF0ZURlY3J5cHRvcihrZXksIGNmZykuZmluYWxpemUoY2lwaGVydGV4dC5jaXBoZXJ0ZXh0KTtcblxuXHQgICAgICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQgdG8gQ2lwaGVyUGFyYW1zLFxuXHQgICAgICAgICAqIGVsc2UgYXNzdW1lZCBDaXBoZXJQYXJhbXMgYWxyZWFkeSBhbmQgcmV0dXJucyBjaXBoZXJ0ZXh0IHVuY2hhbmdlZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKiBAcGFyYW0ge0Zvcm1hdHRlcn0gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZSB0byBwYXJzZSBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSB1bnNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLl9wYXJzZShjaXBoZXJ0ZXh0U3RyaW5nT3JQYXJhbXMsIGZvcm1hdCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX3BhcnNlOiBmdW5jdGlvbiAoY2lwaGVydGV4dCwgZm9ybWF0KSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgY2lwaGVydGV4dCA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdC5wYXJzZShjaXBoZXJ0ZXh0LCB0aGlzKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogS2V5IGRlcml2YXRpb24gZnVuY3Rpb24gbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19rZGYgPSBDLmtkZiA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIE9wZW5TU0wga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG5cdCAgICAgKi9cblx0ICAgIHZhciBPcGVuU1NMS2RmID0gQ19rZGYuT3BlblNTTCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZXJpdmVzIGEga2V5IGFuZCBJViBmcm9tIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIHRvIGRlcml2ZSBmcm9tLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrZXlTaXplIFRoZSBzaXplIGluIHdvcmRzIG9mIHRoZSBrZXkgdG8gZ2VuZXJhdGUuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGl2U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUgSVYgdG8gZ2VuZXJhdGUuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IChPcHRpb25hbCkgQSA2NC1iaXQgc2FsdCB0byB1c2UuIElmIG9taXR0ZWQsIGEgc2FsdCB3aWxsIGJlIGdlbmVyYXRlZCByYW5kb21seS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdCB3aXRoIHRoZSBrZXksIElWLCBhbmQgc2FsdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBDcnlwdG9KUy5rZGYuT3BlblNTTC5leGVjdXRlKCdQYXNzd29yZCcsIDI1Ni8zMiwgMTI4LzMyKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBDcnlwdG9KUy5rZGYuT3BlblNTTC5leGVjdXRlKCdQYXNzd29yZCcsIDI1Ni8zMiwgMTI4LzMyLCAnc2FsdHNhbHQnKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBleGVjdXRlOiBmdW5jdGlvbiAocGFzc3dvcmQsIGtleVNpemUsIGl2U2l6ZSwgc2FsdCkge1xuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSByYW5kb20gc2FsdFxuXHQgICAgICAgICAgICBpZiAoIXNhbHQpIHtcblx0ICAgICAgICAgICAgICAgIHNhbHQgPSBXb3JkQXJyYXkucmFuZG9tKDY0LzgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgSVZcblx0ICAgICAgICAgICAgdmFyIGtleSA9IEV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiBrZXlTaXplICsgaXZTaXplIH0pLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXG5cdCAgICAgICAgICAgIC8vIFNlcGFyYXRlIGtleSBhbmQgSVZcblx0ICAgICAgICAgICAgdmFyIGl2ID0gV29yZEFycmF5LmNyZWF0ZShrZXkud29yZHMuc2xpY2Uoa2V5U2l6ZSksIGl2U2l6ZSAqIDQpO1xuXHQgICAgICAgICAgICBrZXkuc2lnQnl0ZXMgPSBrZXlTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gcGFyYW1zXG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsga2V5OiBrZXksIGl2OiBpdiwgc2FsdDogc2FsdCB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgc2VyaWFsaXphYmxlIGNpcGhlciB3cmFwcGVyIHRoYXQgZGVyaXZlcyB0aGUga2V5IGZyb20gYSBwYXNzd29yZCxcblx0ICAgICAqIGFuZCByZXR1cm5zIGNpcGhlcnRleHQgYXMgYSBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgKi9cblx0ICAgIHZhciBQYXNzd29yZEJhc2VkQ2lwaGVyID0gQ19saWIuUGFzc3dvcmRCYXNlZENpcGhlciA9IFNlcmlhbGl6YWJsZUNpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7S0RGfSBrZGYgVGhlIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIHRvIHVzZSB0byBnZW5lcmF0ZSBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLiBEZWZhdWx0OiBPcGVuU1NMXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBTZXJpYWxpemFibGVDaXBoZXIuY2ZnLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGtkZjogT3BlblNTTEtkZlxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRW5jcnlwdHMgYSBtZXNzYWdlIHVzaW5nIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZW5jcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwgJ3Bhc3N3b3JkJyk7XG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIG1lc3NhZ2UsIHBhc3N3b3JkLCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIG90aGVyIHBhcmFtc1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IGNmZy5rZGYuZXhlY3V0ZShwYXNzd29yZCwgY2lwaGVyLmtleVNpemUsIGNpcGhlci5pdlNpemUpO1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBJViB0byBjb25maWdcblx0ICAgICAgICAgICAgY2ZnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjtcblxuXHQgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQuY2FsbCh0aGlzLCBjaXBoZXIsIG1lc3NhZ2UsIGRlcml2ZWRQYXJhbXMua2V5LCBjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIE1peCBpbiBkZXJpdmVkIHBhcmFtc1xuXHQgICAgICAgICAgICBjaXBoZXJ0ZXh0Lm1peEluKGRlcml2ZWRQYXJhbXMpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQgdXNpbmcgYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHBsYWludGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGZvcm1hdHRlZENpcGhlcnRleHQsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGNpcGhlcnRleHRQYXJhbXMsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBwYXNzd29yZCwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcblx0ICAgICAgICAgICAgY2lwaGVydGV4dCA9IHRoaXMuX3BhcnNlKGNpcGhlcnRleHQsIGNmZy5mb3JtYXQpO1xuXG5cdCAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIG90aGVyIHBhcmFtc1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IGNmZy5rZGYuZXhlY3V0ZShwYXNzd29yZCwgY2lwaGVyLmtleVNpemUsIGNpcGhlci5pdlNpemUsIGNpcGhlcnRleHQuc2FsdCk7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIElWIHRvIGNvbmZpZ1xuXHQgICAgICAgICAgICBjZmcuaXYgPSBkZXJpdmVkUGFyYW1zLml2O1xuXG5cdCAgICAgICAgICAgIC8vIERlY3J5cHRcblx0ICAgICAgICAgICAgdmFyIHBsYWludGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0LmNhbGwodGhpcywgY2lwaGVyLCBjaXBoZXJ0ZXh0LCBkZXJpdmVkUGFyYW1zLmtleSwgY2ZnKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9KCkpO1xuXG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZXF1ZXN0ID0gZXhwb3J0cy5jcmVhdGVSZXF1ZXN0ID0gdm9pZCAwO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgY29tZXR0cmFuc3BvcnRfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTIpKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgZXZlbnRlbWl0dGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKTtcbnZhciBlcnJvcmluZm9fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgZGVmYXVsdHNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOCkpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgWEhSU3RhdGVzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKSk7XG4vLyBXb3JrYXJvdW5kIGZvciBzYWxlc2ZvcmNlIGxpZ2h0bmluZyBsb2NrZXIgY29tcGF0aWJpbGl0eVxudmFyIGdsb2JhbE9iamVjdCA9IFV0aWxzLmdldEdsb2JhbE9iamVjdCgpO1xudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG4vKiBDYW4ndCBqdXN0IHVzZSB3aW5kb3cuQWJseSwgYXMgdGhhdCB3b24ndCBleGlzdCBpZiB1c2luZyB0aGUgY29tbW9uanMgdmVyc2lvbi4gKi9cbnZhciBfID0gKGdsb2JhbE9iamVjdC5fYWJseWpzX2pzb25wID0ge30pO1xuLyogZXhwcmVzcyBzdHJpcHMgb3V0IHBhcmFudGhlc2VzIGZyb20gdGhlIGNhbGxiYWNrIVxuICogS2x1ZGdlIHRvIHN0aWxsIGFsb3cgaXRzIHJlc3BvbnNlcyB0byB3b3JrLCB3aGlsZSBub3Qga2VlcGluZyB0aGVcbiAqIGZ1bmN0aW9uIGZvcm0gZm9yIG5vcm1hbCB1c2UgYW5kIG5vdCBjbHV0dGVyaW5nIHdpbmRvdy5BYmx5XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZXhwcmVzc2pzL2V4cHJlc3MvYmxvYi81YjRkNGI0YWIxMzI0NzQzNTM0ZmJjZDQ3MDlmNGU3NWJiNGI0ZTlkL2xpYi9yZXNwb25zZS5qcyNMMzA1XG4gKi9cbl8uXyA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBfWydfJyArIGlkXSB8fCBub29wO1xufTtcbnZhciBpZENvdW50ZXIgPSAxO1xudmFyIHNob3J0TmFtZSA9ICdqc29ucCc7XG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCkge1xuICAgIC8qIEpTT05QIHJlcXVlc3RzIGFyZSB1c2VkIGVpdGhlciB3aXRoIHRoZSBjb250ZXh0IGJlaW5nIGEgcmVhbHRpbWVcbiAgICAgKiB0cmFuc3BvcnQsIG9yIHdpdGggdGltZW91dHMgcGFzc2VkIGluIChmb3Igd2hlbiB1c2VkIGJ5IGEgcmVzdCBjbGllbnQpLFxuICAgICAqIG9yIGNvbXBsZXRlbHkgc3RhbmRhbG9uZS4gIFVzZSB0aGUgYXBwcm9wcmlhdGUgdGltZW91dHMgaW4gZWFjaCBjYXNlICovXG4gICAgdGltZW91dHMgPSB0aW1lb3V0cyB8fCBkZWZhdWx0c18xLmRlZmF1bHQuVElNRU9VVFM7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVuZGVmaW5lZCwgdXJpLCBoZWFkZXJzLCBVdGlscy5jb3B5KHBhcmFtcyksIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbWV0aG9kKTtcbn1cbmV4cG9ydHMuY3JlYXRlUmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3Q7XG52YXIgSlNPTlBUcmFuc3BvcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSlNPTlBUcmFuc3BvcnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSlNPTlBUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWU7XG4gICAgICAgIHBhcmFtcy5zdHJlYW0gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBKU09OUFRyYW5zcG9ydC5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuanNvbnBTdXBwb3J0ZWQgJiYgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5hbGxvd0NvbWV0O1xuICAgIH07XG4gICAgSlNPTlBUcmFuc3BvcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0pTT05QVHJhbnNwb3J0OyB1cmk9JyArIHRoaXMuYmFzZVVyaSArICc7IGlzQ29ubmVjdGVkPScgKyB0aGlzLmlzQ29ubmVjdGVkO1xuICAgIH07XG4gICAgSlNPTlBUcmFuc3BvcnQucHJvdG90eXBlLmNyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbiAodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbWV0aG9kKSB7XG4gICAgICAgIC8qIEpTT05QIHJlcXVlc3RzIGFyZSB1c2VkIGVpdGhlciB3aXRoIHRoZSBjb250ZXh0IGJlaW5nIGEgcmVhbHRpbWVcbiAgICAgICAgICogdHJhbnNwb3J0LCBvciB3aXRoIHRpbWVvdXRzIHBhc3NlZCBpbiAoZm9yIHdoZW4gdXNlZCBieSBhIHJlc3QgY2xpZW50KSxcbiAgICAgICAgICogb3IgY29tcGxldGVseSBzdGFuZGFsb25lLiAgVXNlIHRoZSBhcHByb3ByaWF0ZSB0aW1lb3V0cyBpbiBlYWNoIGNhc2UgKi9cbiAgICAgICAgdGltZW91dHMgPSAodGhpcyA9PT0gbnVsbCB8fCB0aGlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aGlzLnRpbWVvdXRzKSB8fCB0aW1lb3V0cyB8fCBkZWZhdWx0c18xLmRlZmF1bHQuVElNRU9VVFM7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCk7XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTlBUcmFuc3BvcnQ7XG59KGNvbWV0dHJhbnNwb3J0XzEuZGVmYXVsdCkpO1xudmFyIFJlcXVlc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUmVxdWVzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXF1ZXN0KGlkLCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBtZXRob2QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgaWYgKGlkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBpZCA9IGlkQ291bnRlcisrO1xuICAgICAgICBfdGhpcy5pZCA9IGlkO1xuICAgICAgICBfdGhpcy51cmkgPSB1cmk7XG4gICAgICAgIF90aGlzLnBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgX3RoaXMucGFyYW1zLnJuZCA9IFV0aWxzLmNoZWFwUmFuZFN0cigpO1xuICAgICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICAgICAgLyogSlNPTlAgZG9lc24ndCBhbGxvdyBoZWFkZXJzLiBDaGVycnktcGljayBhIGNvdXBsZSB0byB0dXJuIGludG8gcXMgcGFyYW1zICovXG4gICAgICAgICAgICBpZiAoaGVhZGVyc1snWC1BYmx5LVZlcnNpb24nXSlcbiAgICAgICAgICAgICAgICBfdGhpcy5wYXJhbXMudiA9IGhlYWRlcnNbJ1gtQWJseS1WZXJzaW9uJ107XG4gICAgICAgICAgICBpZiAoaGVhZGVyc1snWC1BYmx5LUxpYiddKVxuICAgICAgICAgICAgICAgIF90aGlzLnBhcmFtcy5saWIgPSBoZWFkZXJzWydYLUFibHktTGliJ107XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgIF90aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgX3RoaXMucmVxdWVzdE1vZGUgPSByZXF1ZXN0TW9kZTtcbiAgICAgICAgX3RoaXMudGltZW91dHMgPSB0aW1lb3V0cztcbiAgICAgICAgX3RoaXMucmVxdWVzdENvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVxdWVzdC5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZCwgYm9keSA9IHRoaXMuYm9keSwgbWV0aG9kID0gdGhpcy5tZXRob2QsIHVyaSA9IHRoaXMudXJpLCBwYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgICAgICAgcGFyYW1zLmNhbGxiYWNrID0gJ19hYmx5anNfanNvbnAuXygnICsgaWQgKyAnKSc7XG4gICAgICAgIHBhcmFtcy5lbnZlbG9wZSA9ICdqc29ucCc7XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICBwYXJhbXMuYm9keSA9IGJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCAmJiBtZXRob2QgIT09ICdnZXQnKSB7XG4gICAgICAgICAgICBwYXJhbXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY3JpcHQgPSAodGhpcy5zY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSk7XG4gICAgICAgIHZhciBzcmMgPSB1cmkgKyBVdGlscy50b1F1ZXJ5U3RyaW5nKHBhcmFtcyk7XG4gICAgICAgIHNjcmlwdC5zcmMgPSBzcmM7XG4gICAgICAgIGlmIChzY3JpcHQuc3JjLnNwbGl0KCcvJykuc2xpY2UoLTEpWzBdICE9PSBzcmMuc3BsaXQoJy8nKS5zbGljZSgtMSlbMF0pIHtcbiAgICAgICAgICAgIC8qIFRoZSBzcmMgaGFzIGJlZW4gdHJ1bmNhdGVkLiBDYW4ndCBhYm9ydCwgYnV0IGNhbiBhdCBsZWFzdCBlbWl0IGFuXG4gICAgICAgICAgICAgKiBlcnJvciBzbyB0aGUgdXNlciBrbm93cyB3aGF0J3MgZ29uZSB3cm9uZy4gKENhbid0IGNvbXBhcmUgc3RyaW5nc1xuICAgICAgICAgICAgICogZGlyZWN0bHkgYXMgc3JjIG1heSBoYXZlIGEgcG9ydCwgc2NyaXB0LnNyYyB3b24ndCkgKi9cbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnSlNPTlAgUmVxdWVzdC5leGVjKCknLCAnV2FybmluZzogdGhlIGJyb3dzZXIgYXBwZWFycyB0byBoYXZlIHRydW5jYXRlZCB0aGUgc2NyaXB0IFVSSS4gVGhpcyB3aWxsIGxpa2VseSByZXN1bHQgaW4gdGhlIHJlcXVlc3QgZmFpbGluZyBkdWUgdG8gYW4gdW5wYXJzZWFibGUgYm9keSBwYXJhbScpO1xuICAgICAgICB9XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5jaGFyc2V0ID0gJ1VURi04JztcbiAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBfdGhpcy5jb21wbGV0ZShuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygnSlNPTlAgc2NyaXB0IGVycm9yIChldmVudDogJyArIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChlcnIpICsgJyknLCBudWxsLCA0MDApKTtcbiAgICAgICAgfTtcbiAgICAgICAgX1snXycgKyBpZF0gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgICAgIC8qIEhhbmRsZSBhcyBlbnZlbG9wZWQganNvbnAsIGFzIGFsbCBqc29ucCB0cmFuc3BvcnQgdXNlcyBzaG91bGQgYmUgKi9cbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBtZXNzYWdlLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0YXR1c0NvZGUgPT0gMjA0KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKG51bGwsIG51bGwsIG51bGwsIG1lc3NhZ2Uuc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wbGV0ZShuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygnSW52YWxpZCBzZXJ2ZXIgcmVzcG9uc2U6IG5vIGVudmVsb3BlIGRldGVjdGVkJywgbnVsbCwgNTAwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2Uuc3RhdHVzQ29kZSA8IDQwMCB8fCBVdGlscy5pc0FycmF5KHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgICAgICAvKiBJZiByZXNwb25zZSBpcyBhbiBhcnJheSwgaXQncyBhbiBhcnJheSBvZiBwcm90b2NvbCBtZXNzYWdlcyAtLSBldmVuIGlmXG4gICAgICAgICAgICAgICAgICAgICAqIGl0IGNvbnRhaW5zIGFuIGVycm9yIGFjdGlvbiAoaGVuY2UgdGhlIG5vbnN1Y2Nlc3Mgc3RhdHVzY29kZSksIHdlIGNhblxuICAgICAgICAgICAgICAgICAgICAgKiBjb25zaWRlciB0aGUgcmVxdWVzdCB0byBoYXZlIHN1Y2NlZWRlZCwganVzdCBwYXNzIGl0IG9uIHRvXG4gICAgICAgICAgICAgICAgICAgICAqIG9uUHJvdG9jb2xNZXNzYWdlIHRvIGRlY2lkZSB3aGF0IHRvIGRvICovXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKG51bGwsIHJlc3BvbnNlLCBtZXNzYWdlLmhlYWRlcnMsIG1lc3NhZ2Uuc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gcmVzcG9uc2UuZXJyb3IgfHwgbmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ0Vycm9yIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gc2VydmVyJywgbnVsbCwgbWVzc2FnZS5zdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcGxldGUoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBIYW5kbGUgYXMgbm9uLWVudmVsb3BlZCAtLSBhcyB3aWxsIGJlIGVnIGZyb20gYSBjdXN0b21lcidzIGF1dGhVcmwgc2VydmVyICovXG4gICAgICAgICAgICAgICAgX3RoaXMuY29tcGxldGUobnVsbCwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aW1lb3V0ID0gdGhpcy5yZXF1ZXN0TW9kZSA9PSBYSFJTdGF0ZXNfMS5kZWZhdWx0LlJFUV9TRU5EID8gdGhpcy50aW1lb3V0cy5odHRwUmVxdWVzdFRpbWVvdXQgOiB0aGlzLnRpbWVvdXRzLnJlY3ZUaW1lb3V0O1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCh0aGlzLmFib3J0LmJpbmQodGhpcyksIHRpbWVvdXQpO1xuICAgICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcbiAgICB9O1xuICAgIFJlcXVlc3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgc3RhdHVzQ29kZSkge1xuICAgICAgICBoZWFkZXJzID0gaGVhZGVycyB8fCB7fTtcbiAgICAgICAgaWYgKCF0aGlzLnJlcXVlc3RDb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Q29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IHR5cGVvZiBib2R5ID09ICdzdHJpbmcnID8gJ3RleHQvcGxhaW4nIDogJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gY29udGVudFR5cGU7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgYm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NvbXBsZXRlJywgZXJyLCBib2R5LCBoZWFkZXJzLCAvKiB1bnBhY2tlZDogKi8gdHJ1ZSwgc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgUmVxdWVzdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRpbWVyID0gdGhpcy50aW1lcjtcbiAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcmlwdCA9IHRoaXMuc2NyaXB0O1xuICAgICAgICBpZiAoc2NyaXB0LnBhcmVudE5vZGUpXG4gICAgICAgICAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICBkZWxldGUgX1t0aGlzLmlkXTtcbiAgICAgICAgdGhpcy5lbWl0KCdkaXNwb3NlZCcpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlcXVlc3Q7XG59KGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5mdW5jdGlvbiBkZWZhdWx0XzEoY29ubmVjdGlvbk1hbmFnZXIpIHtcbiAgICBnbG9iYWxPYmplY3QuSlNPTlBUcmFuc3BvcnQgPSBKU09OUFRyYW5zcG9ydDtcbiAgICBpZiAoSlNPTlBUcmFuc3BvcnQuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzW3Nob3J0TmFtZV0gPSBKU09OUFRyYW5zcG9ydDtcbiAgICB9XG4gICAgcmV0dXJuIEpTT05QVHJhbnNwb3J0O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZGVmYXVsdF8xO1xuXG5cbi8qKiovIH0pLFxuLyogMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgZGVmYXVsdHNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOCkpO1xudmFyIGF1dGhfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTcpKTtcbnZhciBwdXNoXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KSk7XG52YXIgcGFnaW5hdGVkcmVzb3VyY2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTkpKTtcbnZhciBjaGFubmVsXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBzdGF0c18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0OSkpO1xudmFyIEh0dHBNZXRob2RzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOSkpO1xudmFyIHByZXNlbmNlbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNSkpO1xudmFyIHJlc291cmNlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSk7XG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcbnZhciBSZXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc3Qob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnbm8gb3B0aW9ucyBwcm92aWRlZCc7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1Jlc3QoKScsIG1zZyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9uc09iaiA9IGRlZmF1bHRzXzEuZGVmYXVsdC5vYmplY3RpZnlPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9uc09iai5sb2cpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuc2V0TG9nKG9wdGlvbnNPYmoubG9nLmxldmVsLCBvcHRpb25zT2JqLmxvZy5oYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1Jlc3QoKScsICdpbml0aWFsaXplZCB3aXRoIGNsaWVudE9wdGlvbnMgJyArIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChvcHRpb25zKSk7XG4gICAgICAgIHZhciBub3JtYWxPcHRpb25zID0gKHRoaXMub3B0aW9ucyA9IGRlZmF1bHRzXzEuZGVmYXVsdC5ub3JtYWxpc2VPcHRpb25zKG9wdGlvbnNPYmopKTtcbiAgICAgICAgLyogcHJvY2VzcyBvcHRpb25zICovXG4gICAgICAgIGlmIChub3JtYWxPcHRpb25zLmtleSkge1xuICAgICAgICAgICAgdmFyIGtleU1hdGNoID0gbm9ybWFsT3B0aW9ucy5rZXkubWF0Y2goL14oW146XFxzXSspOihbXjouXFxzXSspJC8pO1xuICAgICAgICAgICAgaWYgKCFrZXlNYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnaW52YWxpZCBrZXkgcGFyYW1ldGVyJztcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1Jlc3QoKScsIG1zZyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA0MDQwMCwgNDA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vcm1hbE9wdGlvbnMua2V5TmFtZSA9IGtleU1hdGNoWzFdO1xuICAgICAgICAgICAgbm9ybWFsT3B0aW9ucy5rZXlTZWNyZXQgPSBrZXlNYXRjaFsyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2NsaWVudElkJyBpbiBub3JtYWxPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoISh0eXBlb2Ygbm9ybWFsT3B0aW9ucy5jbGllbnRJZCA9PT0gJ3N0cmluZycgfHwgbm9ybWFsT3B0aW9ucy5jbGllbnRJZCA9PT0gbnVsbCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ2NsaWVudElkIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bGwnLCA0MDAxMiwgNDAwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vcm1hbE9wdGlvbnMuY2xpZW50SWQgPT09ICcqJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnQ2Fu4oCZdCB1c2UgXCIqXCIgYXMgYSBjbGllbnRJZCBhcyB0aGF0IHN0cmluZyBpcyByZXNlcnZlZC4gKFRvIGNoYW5nZSB0aGUgZGVmYXVsdCB0b2tlbiByZXF1ZXN0IGJlaGF2aW91ciB0byB1c2UgYSB3aWxkY2FyZCBjbGllbnRJZCwgdXNlIHtkZWZhdWx0VG9rZW5QYXJhbXM6IHtjbGllbnRJZDogXCIqXCJ9fSknLCA0MDAxMiwgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1Jlc3QoKScsICdzdGFydGVkOyB2ZXJzaW9uID0gJyArIGRlZmF1bHRzXzEuZGVmYXVsdC52ZXJzaW9uKTtcbiAgICAgICAgdGhpcy5iYXNlVXJpID0gdGhpcy5hdXRob3JpdHkgPSBmdW5jdGlvbiAoaG9zdCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRzXzEuZGVmYXVsdC5nZXRIdHRwU2NoZW1lKG5vcm1hbE9wdGlvbnMpICsgaG9zdCArICc6JyArIGRlZmF1bHRzXzEuZGVmYXVsdC5nZXRQb3J0KG5vcm1hbE9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fY3VycmVudEZhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXJ2ZXJUaW1lT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5odHRwID0gbmV3IHBsYXRmb3JtXzEuZGVmYXVsdC5IdHRwKG5vcm1hbE9wdGlvbnMpO1xuICAgICAgICB0aGlzLmF1dGggPSBuZXcgYXV0aF8xLmRlZmF1bHQodGhpcywgbm9ybWFsT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSBuZXcgQ2hhbm5lbHModGhpcyk7XG4gICAgICAgIHRoaXMucHVzaCA9IG5ldyBwdXNoXzEuZGVmYXVsdCh0aGlzKTtcbiAgICB9XG4gICAgUmVzdC5wcm90b3R5cGUuc3RhdHMgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICAvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdzdGF0cycsIFtwYXJhbXNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdEdldEhlYWRlcnModGhpcy5vcHRpb25zKSwgZm9ybWF0ID0gdGhpcy5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgZW52ZWxvcGUgPSB0aGlzLmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgdGhpcy5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfMS5kZWZhdWx0KHRoaXMsICcvc3RhdHMnLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24gKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICB2YXIgc3RhdHNWYWx1ZXMgPSB1bnBhY2tlZCA/IGJvZHkgOiBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0c1ZhbHVlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBzdGF0c1ZhbHVlc1tpXSA9IHN0YXRzXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHN0YXRzVmFsdWVzW2ldKTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0c1ZhbHVlcztcbiAgICAgICAgfSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVzdC5wcm90b3R5cGUudGltZSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xuICAgICAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3RpbWUnLCBbcGFyYW1zXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBfY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICAgICAgICB2YXIgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHRoaXMub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgdmFyIHRpbWVVcmkgPSBmdW5jdGlvbiAoaG9zdCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmF1dGhvcml0eShob3N0KSArICcvdGltZSc7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaHR0cC5kbyhIdHRwTWV0aG9kc18xLmRlZmF1bHQuR2V0LCB0aGlzLCB0aW1lVXJpLCBoZWFkZXJzLCBudWxsLCBwYXJhbXMsIGZ1bmN0aW9uIChlcnIsIHJlcywgaGVhZGVycywgdW5wYWNrZWQpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXVucGFja2VkKVxuICAgICAgICAgICAgICAgIHJlcyA9IEpTT04ucGFyc2UocmVzKTtcbiAgICAgICAgICAgIHZhciB0aW1lID0gcmVzWzBdO1xuICAgICAgICAgICAgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICAgICAgX2NhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdJbnRlcm5hbCBlcnJvciAodW5leHBlY3RlZCByZXN1bHQgdHlwZSBmcm9tIEdFVCAvdGltZSknLCA1MDAwMCwgNTAwKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogY2FsY3VsYXRlIHRpbWUgb2Zmc2V0IG9ubHkgb25jZSBmb3IgdGhpcyBkZXZpY2UgYnkgYWRkaW5nIHRvIHRoZSBwcm90b3R5cGUgKi9cbiAgICAgICAgICAgIF90aGlzLnNlcnZlclRpbWVPZmZzZXQgPSB0aW1lIC0gVXRpbHMubm93KCk7XG4gICAgICAgICAgICBfY2FsbGJhY2sobnVsbCwgdGltZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVzdC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChtZXRob2QsIHBhdGgsIHBhcmFtcywgYm9keSwgY3VzdG9tSGVhZGVycywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHVzZUJpbmFyeSA9IHRoaXMub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCwgZW5jb2RlciA9IHVzZUJpbmFyeSA/IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubXNncGFjay5lbmNvZGUgOiBKU09OLnN0cmluZ2lmeSwgZGVjb2RlciA9IHVzZUJpbmFyeSA/IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubXNncGFjay5kZWNvZGUgOiBKU09OLnBhcnNlLCBmb3JtYXQgPSB1c2VCaW5hcnkgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBlbnZlbG9wZSA9IHRoaXMuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0O1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgIHZhciBfbWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBoZWFkZXJzID0gX21ldGhvZCA9PSAnZ2V0JyA/IFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzKHRoaXMub3B0aW9ucywgZm9ybWF0KSA6IFV0aWxzLmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLm9wdGlvbnMsIGZvcm1hdCk7XG4gICAgICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAncmVxdWVzdCcsIFttZXRob2QsIHBhdGgsIHBhcmFtcywgYm9keSwgY3VzdG9tSGVhZGVyc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYm9keSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSBlbmNvZGVyKGJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgdGhpcy5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXN0b21IZWFkZXJzKSB7XG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCBjdXN0b21IZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFnaW5hdGVkUmVzb3VyY2UgPSBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfMS5kZWZhdWx0KHRoaXMsIHBhdGgsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbiAocmVzYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5lbnN1cmVBcnJheSh1bnBhY2tlZCA/IHJlc2JvZHkgOiBkZWNvZGVyKHJlc2JvZHkpKTtcbiAgICAgICAgfSwgXG4gICAgICAgIC8qIHVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZTogKi8gdHJ1ZSk7XG4gICAgICAgIGlmICghVXRpbHMuYXJySW4ocGxhdGZvcm1fMS5kZWZhdWx0Lkh0dHAubWV0aG9kcywgX21ldGhvZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdVbnN1cHBvcnRlZCBtZXRob2QgJyArIF9tZXRob2QsIDQwNTAwLCA0MDUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChVdGlscy5hcnJJbihwbGF0Zm9ybV8xLmRlZmF1bHQuSHR0cC5tZXRob2RzV2l0aEJvZHksIF9tZXRob2QpKSB7XG4gICAgICAgICAgICBwYWdpbmF0ZWRSZXNvdXJjZVtfbWV0aG9kXShwYXJhbXMsIGJvZHksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhZ2luYXRlZFJlc291cmNlW19tZXRob2RdKHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXN0LnByb3RvdHlwZS5iYXRjaFB1Ymxpc2ggPSBmdW5jdGlvbiAoc3BlY09yU3BlY3MsIGNhbGxiYWNrQXJnKSB7XG4gICAgICAgIGlmIChjYWxsYmFja0FyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnYmF0Y2hQdWJsaXNoJywgW3NwZWNPclNwZWNzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFja0FyZyA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tBcmc7XG4gICAgICAgIHZhciByZXF1ZXN0Qm9keURUTztcbiAgICAgICAgdmFyIHNpbmdsZVNwZWNNb2RlO1xuICAgICAgICBpZiAoVXRpbHMuaXNBcnJheShzcGVjT3JTcGVjcykpIHtcbiAgICAgICAgICAgIHJlcXVlc3RCb2R5RFRPID0gc3BlY09yU3BlY3M7XG4gICAgICAgICAgICBzaW5nbGVTcGVjTW9kZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdEJvZHlEVE8gPSBbc3BlY09yU3BlY3NdO1xuICAgICAgICAgICAgc2luZ2xlU3BlY01vZGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdFBvc3RIZWFkZXJzKHRoaXMub3B0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgdGhpcy5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICB2YXIgcmVxdWVzdEJvZHkgPSBVdGlscy5lbmNvZGVCb2R5KHJlcXVlc3RCb2R5RFRPLCBmb3JtYXQpO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQucG9zdCh0aGlzLCAnL21lc3NhZ2VzJywgcmVxdWVzdEJvZHksIGhlYWRlcnMsIHsgbmV3QmF0Y2hSZXNwb25zZTogJ3RydWUnIH0sIG51bGwsIGZ1bmN0aW9uIChlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyByZW1vdmUgdGhpcyB0eXBlIGFzc2VydGlvbiBhZnRlciBmaXhpbmcgaHR0cHM6Ly9naXRodWIuY29tL2FibHkvYWJseS1qcy9pc3N1ZXMvMTQwNVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJhdGNoUmVzdWx0cyA9ICh1bnBhY2tlZCA/IGJvZHkgOiBVdGlscy5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCkpO1xuICAgICAgICAgICAgLy8gSSBkb24ndCBsb3ZlIHRoZSBiZWxvdyB0eXBlIGFzc2VydGlvbnMgZm9yIGBjYWxsYmFja2AgYnV0IG5vdCBzdXJlIGhvdyB0byBhdm9pZCB0aGVtXG4gICAgICAgICAgICBpZiAoc2luZ2xlU3BlY01vZGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBiYXRjaFJlc3VsdHNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYmF0Y2hSZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZXN0LnByb3RvdHlwZS5iYXRjaFByZXNlbmNlID0gZnVuY3Rpb24gKGNoYW5uZWxzLCBjYWxsYmFja0FyZykge1xuICAgICAgICBpZiAoY2FsbGJhY2tBcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2JhdGNoUHJlc2VuY2UnLCBbY2hhbm5lbHNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrQXJnID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFja0FyZztcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0UG9zdEhlYWRlcnModGhpcy5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCB0aGlzLm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIHZhciBjaGFubmVsc1BhcmFtID0gY2hhbm5lbHMuam9pbignLCcpO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQuZ2V0KHRoaXMsICcvcHJlc2VuY2UnLCBoZWFkZXJzLCB7IG5ld0JhdGNoUmVzcG9uc2U6ICd0cnVlJywgY2hhbm5lbHM6IGNoYW5uZWxzUGFyYW0gfSwgbnVsbCwgZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHJlbW92ZSB0aGlzIHR5cGUgYXNzZXJ0aW9uIGFmdGVyIGZpeGluZyBodHRwczovL2dpdGh1Yi5jb20vYWJseS9hYmx5LWpzL2lzc3Vlcy8xNDA1XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmF0Y2hSZXN1bHQgPSAodW5wYWNrZWQgPyBib2R5IDogVXRpbHMuZGVjb2RlQm9keShib2R5LCBmb3JtYXQpKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGJhdGNoUmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZXN0LnByb3RvdHlwZS5zZXRMb2cgPSBmdW5jdGlvbiAobG9nT3B0aW9ucykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LnNldExvZyhsb2dPcHRpb25zLmxldmVsLCBsb2dPcHRpb25zLmhhbmRsZXIpO1xuICAgIH07XG4gICAgUmVzdC5Qcm9taXNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRzXzEuZGVmYXVsdC5vYmplY3RpZnlPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zLnByb21pc2VzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVzdC5DYWxsYmFja3MgPSBSZXN0O1xuICAgIFJlc3QuUGxhdGZvcm0gPSBwbGF0Zm9ybV8xLmRlZmF1bHQ7XG4gICAgUmVzdC5NZXNzYWdlID0gbWVzc2FnZV8xLmRlZmF1bHQ7XG4gICAgUmVzdC5QcmVzZW5jZU1lc3NhZ2UgPSBwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0O1xuICAgIHJldHVybiBSZXN0O1xufSgpKTtcbnZhciBDaGFubmVscyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDaGFubmVscyhyZXN0KSB7XG4gICAgICAgIHRoaXMucmVzdCA9IHJlc3Q7XG4gICAgICAgIHRoaXMuYWxsID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgQ2hhbm5lbHMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lLCBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdO1xuICAgICAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgICAgICAgIHRoaXMuYWxsW25hbWVdID0gY2hhbm5lbCA9IG5ldyBjaGFubmVsXzEuZGVmYXVsdCh0aGlzLnJlc3QsIG5hbWUsIGNoYW5uZWxPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFubmVsT3B0aW9ucykge1xuICAgICAgICAgICAgY2hhbm5lbC5zZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbm5lbDtcbiAgICB9O1xuICAgIC8qIEluY2x1ZGVkIHRvIHN1cHBvcnQgY2VydGFpbiBuaWNoZSB1c2UtY2FzZXM7IG1vc3QgdXNlcnMgc2hvdWxkIGlnbm9yZSB0aGlzLlxuICAgICAqIFBsZWFzZSBkbyBub3QgdXNlIHRoaXMgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nICovXG4gICAgQ2hhbm5lbHMucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBkZWxldGUgdGhpcy5hbGxbU3RyaW5nKG5hbWUpXTtcbiAgICB9O1xuICAgIHJldHVybiBDaGFubmVscztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBSZXN0O1xuXG5cbi8qKiovIH0pLFxuLyogMzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDYpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuVXRmODtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKE1hdGgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBJbml0aWFsaXphdGlvbiBhbmQgcm91bmQgY29uc3RhbnRzIHRhYmxlc1xuXHQgICAgdmFyIEggPSBbXTtcblx0ICAgIHZhciBLID0gW107XG5cblx0ICAgIC8vIENvbXB1dGUgY29uc3RhbnRzXG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGlzUHJpbWUobikge1xuXHQgICAgICAgICAgICB2YXIgc3FydE4gPSBNYXRoLnNxcnQobik7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGZhY3RvciA9IDI7IGZhY3RvciA8PSBzcXJ0TjsgZmFjdG9yKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmICghKG4gJSBmYWN0b3IpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0RnJhY3Rpb25hbEJpdHMobikge1xuXHQgICAgICAgICAgICByZXR1cm4gKChuIC0gKG4gfCAwKSkgKiAweDEwMDAwMDAwMCkgfCAwO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBuID0gMjtcblx0ICAgICAgICB2YXIgblByaW1lID0gMDtcblx0ICAgICAgICB3aGlsZSAoblByaW1lIDwgNjQpIHtcblx0ICAgICAgICAgICAgaWYgKGlzUHJpbWUobikpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChuUHJpbWUgPCA4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgSFtuUHJpbWVdID0gZ2V0RnJhY3Rpb25hbEJpdHMoTWF0aC5wb3cobiwgMSAvIDIpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIEtbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sIDEgLyAzKSk7XG5cblx0ICAgICAgICAgICAgICAgIG5QcmltZSsrO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgbisrO1xuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdFxuXHQgICAgdmFyIFcgPSBbXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTSEEtMjU2IGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgU0hBMjU2ID0gQ19hbGdvLlNIQTI1NiA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoSC5zbGljZSgwKSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWJsZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXHQgICAgICAgICAgICB2YXIgZSA9IEhbNF07XG5cdCAgICAgICAgICAgIHZhciBmID0gSFs1XTtcblx0ICAgICAgICAgICAgdmFyIGcgPSBIWzZdO1xuXHQgICAgICAgICAgICB2YXIgaCA9IEhbN107XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IDE2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgV1tpXSA9IE1bb2Zmc2V0ICsgaV0gfCAwO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEweCA9IFdbaSAtIDE1XTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEwICA9ICgoZ2FtbWEweCA8PCAyNSkgfCAoZ2FtbWEweCA+Pj4gNykpICBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGdhbW1hMHggPDwgMTQpIHwgKGdhbW1hMHggPj4+IDE4KSkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnYW1tYTB4ID4+PiAzKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTF4ID0gV1tpIC0gMl07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMSAgPSAoKGdhbW1hMXggPDwgMTUpIHwgKGdhbW1hMXggPj4+IDE3KSkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChnYW1tYTF4IDw8IDEzKSB8IChnYW1tYTF4ID4+PiAxOSkpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZ2FtbWExeCA+Pj4gMTApO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgV1tpXSA9IGdhbW1hMCArIFdbaSAtIDddICsgZ2FtbWExICsgV1tpIC0gMTZdO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB2YXIgY2ggID0gKGUgJiBmKSBeICh+ZSAmIGcpO1xuXHQgICAgICAgICAgICAgICAgdmFyIG1haiA9IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHNpZ21hMCA9ICgoYSA8PCAzMCkgfCAoYSA+Pj4gMikpIF4gKChhIDw8IDE5KSB8IChhID4+PiAxMykpIF4gKChhIDw8IDEwKSB8IChhID4+PiAyMikpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNpZ21hMSA9ICgoZSA8PCAyNikgfCAoZSA+Pj4gNikpIF4gKChlIDw8IDIxKSB8IChlID4+PiAxMSkpIF4gKChlIDw8IDcpICB8IChlID4+PiAyNSkpO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgdDEgPSBoICsgc2lnbWExICsgY2ggKyBLW2ldICsgV1tpXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MiA9IHNpZ21hMCArIG1hajtcblxuXHQgICAgICAgICAgICAgICAgaCA9IGc7XG5cdCAgICAgICAgICAgICAgICBnID0gZjtcblx0ICAgICAgICAgICAgICAgIGYgPSBlO1xuXHQgICAgICAgICAgICAgICAgZSA9IChkICsgdDEpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGQgPSBjO1xuXHQgICAgICAgICAgICAgICAgYyA9IGI7XG5cdCAgICAgICAgICAgICAgICBiID0gYTtcblx0ICAgICAgICAgICAgICAgIGEgPSAodDEgKyB0MikgfCAwO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuXHQgICAgICAgICAgICBIWzFdID0gKEhbMV0gKyBiKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcblx0ICAgICAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuXHQgICAgICAgICAgICBIWzRdID0gKEhbNF0gKyBlKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNV0gPSAoSFs1XSArIGYpIHwgMDtcblx0ICAgICAgICAgICAgSFs2XSA9IChIWzZdICsgZykgfCAwO1xuXHQgICAgICAgICAgICBIWzddID0gKEhbN10gKyBoKSB8IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTI1NignbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjU2KHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuU0hBMjU2ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMjU2KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEEyNTYobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjU0hBMjU2ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTI1Nik7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlNIQTI1NjtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDMzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBldmVudGVtaXR0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNykpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgcHJlc2VuY2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzQpKTtcbnZhciBtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDkpKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIHBhZ2luYXRlZHJlc291cmNlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KSk7XG52YXIgcmVzb3VyY2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTQpKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG5mdW5jdGlvbiBub29wKCkgeyB9XG52YXIgTVNHX0lEX0VOVFJPUFlfQllURVMgPSA5O1xuZnVuY3Rpb24gYWxsRW1wdHlJZHMobWVzc2FnZXMpIHtcbiAgICByZXR1cm4gVXRpbHMuYXJyRXZlcnkobWVzc2FnZXMsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiAhbWVzc2FnZS5pZDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGlzZUNoYW5uZWxPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgY2hhbm5lbE9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChjaGFubmVsT3B0aW9ucy5jaXBoZXIpIHtcbiAgICAgICAgaWYgKCFwbGF0Zm9ybV8xLmRlZmF1bHQuQ3J5cHRvKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIG5vdCBlbmFibGVkOyB1c2UgYWJseS5lbmNyeXB0aW9uLmpzIGluc3RlYWQnKTtcbiAgICAgICAgdmFyIGNpcGhlciA9IHBsYXRmb3JtXzEuZGVmYXVsdC5DcnlwdG8uZ2V0Q2lwaGVyKGNoYW5uZWxPcHRpb25zLmNpcGhlcik7XG4gICAgICAgIGNoYW5uZWxPcHRpb25zLmNpcGhlciA9IGNpcGhlci5jaXBoZXJQYXJhbXM7XG4gICAgICAgIGNoYW5uZWxPcHRpb25zLmNoYW5uZWxDaXBoZXIgPSBjaXBoZXIuY2lwaGVyO1xuICAgIH1cbiAgICBlbHNlIGlmICgnY2lwaGVyJyBpbiBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICAvKiBEb24ndCBkZWFjdGl2YXRlIGFuIGV4aXN0aW5nIGNpcGhlciB1bmxlc3Mgb3B0aW9uc1xuICAgICAgICAgKiBoYXMgYSAnY2lwaGVyJyBrZXkgdGhhdCdzIGZhbHNleSAqL1xuICAgICAgICBjaGFubmVsT3B0aW9ucy5jaXBoZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNoYW5uZWxPcHRpb25zLmNoYW5uZWxDaXBoZXIgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbm5lbE9wdGlvbnM7XG59XG52YXIgQ2hhbm5lbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDaGFubmVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENoYW5uZWwocmVzdCwgbmFtZSwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDaGFubmVsKCknLCAnc3RhcnRlZDsgbmFtZSA9ICcgKyBuYW1lKTtcbiAgICAgICAgX3RoaXMucmVzdCA9IHJlc3Q7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5iYXNlUGF0aCA9ICcvY2hhbm5lbHMvJyArIGVuY29kZVVSSUNvbXBvbmVudChuYW1lKTtcbiAgICAgICAgX3RoaXMucHJlc2VuY2UgPSBuZXcgcHJlc2VuY2VfMS5kZWZhdWx0KF90aGlzKTtcbiAgICAgICAgX3RoaXMuY2hhbm5lbE9wdGlvbnMgPSBub3JtYWxpc2VDaGFubmVsT3B0aW9ucyhjaGFubmVsT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2hhbm5lbC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbE9wdGlvbnMgPSBub3JtYWxpc2VDaGFubmVsT3B0aW9ucyhvcHRpb25zKTtcbiAgICB9O1xuICAgIENoYW5uZWwucHJvdG90eXBlLmhpc3RvcnkgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0NoYW5uZWwuaGlzdG9yeSgpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5uYW1lKTtcbiAgICAgICAgLyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXG4gICAgICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdoaXN0b3J5JywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hpc3RvcnkocGFyYW1zLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBDaGFubmVsLnByb3RvdHlwZS5faGlzdG9yeSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5yZXN0LCBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBlbnZlbG9wZSA9IHRoaXMucmVzdC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQsIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0R2V0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCk7XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xuICAgICAgICBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfMS5kZWZhdWx0KHJlc3QsIHRoaXMuYmFzZVBhdGggKyAnL21lc3NhZ2VzJywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uIChib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoYm9keSwgb3B0aW9ucywgdW5wYWNrZWQgPyB1bmRlZmluZWQgOiBmb3JtYXQpO1xuICAgICAgICB9KS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBDaGFubmVsLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoLCBmaXJzdCA9IGFyZ3VtZW50c1swXSwgc2Vjb25kID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbYXJnQ291bnQgLSAxXTtcbiAgICAgICAgdmFyIG1lc3NhZ2VzO1xuICAgICAgICB2YXIgcGFyYW1zO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdwdWJsaXNoJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZpcnN0ID09PSAnc3RyaW5nJyB8fCBmaXJzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLyogKG5hbWUsIGRhdGEsIC4uLikgKi9cbiAgICAgICAgICAgIG1lc3NhZ2VzID0gW21lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoeyBuYW1lOiBmaXJzdCwgZGF0YTogc2Vjb25kIH0pXTtcbiAgICAgICAgICAgIHBhcmFtcyA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChVdGlscy5pc09iamVjdChmaXJzdCkpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzID0gW21lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoZmlyc3QpXTtcbiAgICAgICAgICAgIHBhcmFtcyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChVdGlscy5pc0FycmF5KGZpcnN0KSkge1xuICAgICAgICAgICAgbWVzc2FnZXMgPSBtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzQXJyYXkoZmlyc3QpO1xuICAgICAgICAgICAgcGFyYW1zID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1RoZSBzaW5nbGUtYXJndW1lbnQgZm9ybSBvZiBwdWJsaXNoKCkgZXhwZWN0cyBhIG1lc3NhZ2Ugb2JqZWN0IG9yIGFuIGFycmF5IG9mIG1lc3NhZ2Ugb2JqZWN0cycsIDQwMDEzLCA0MDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zICE9PSAnb2JqZWN0JyB8fCAhcGFyYW1zKSB7XG4gICAgICAgICAgICAvKiBObyBwYXJhbXMgc3VwcGxpZWQgKHNvIGFmdGVyLW1lc3NhZ2UgYXJndW1lbnQgaXMganVzdCB0aGUgY2FsbGJhY2sgb3IgdW5kZWZpbmVkKSAqL1xuICAgICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnJlc3QsIG9wdGlvbnMgPSByZXN0Lm9wdGlvbnMsIGZvcm1hdCA9IG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBpZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcgPSByZXN0Lm9wdGlvbnMuaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nLCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdFBvc3RIZWFkZXJzKHJlc3Qub3B0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIGlmIChpZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcgJiYgYWxsRW1wdHlJZHMobWVzc2FnZXMpKSB7XG4gICAgICAgICAgICB2YXIgbXNnSWRCYXNlXzEgPSBVdGlscy5yYW5kb21TdHJpbmcoTVNHX0lEX0VOVFJPUFlfQllURVMpO1xuICAgICAgICAgICAgVXRpbHMuYXJyRm9yRWFjaChtZXNzYWdlcywgZnVuY3Rpb24gKG1lc3NhZ2UsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pZCA9IG1zZ0lkQmFzZV8xICsgJzonICsgaW5kZXgudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2VfMS5kZWZhdWx0LmVuY29kZUFycmF5KG1lc3NhZ2VzLCB0aGlzLmNoYW5uZWxPcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBSU0wxaSAqL1xuICAgICAgICAgICAgdmFyIHNpemUgPSBtZXNzYWdlXzEuZGVmYXVsdC5nZXRNZXNzYWdlc1NpemUobWVzc2FnZXMpLCBtYXhNZXNzYWdlU2l6ZSA9IG9wdGlvbnMubWF4TWVzc2FnZVNpemU7XG4gICAgICAgICAgICBpZiAoc2l6ZSA+IG1heE1lc3NhZ2VTaXplKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ01heGltdW0gc2l6ZSBvZiBtZXNzYWdlcyB0aGF0IGNhbiBiZSBwdWJsaXNoZWQgYXQgb25jZSBleGNlZWRlZCAoIHdhcyAnICtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSArXG4gICAgICAgICAgICAgICAgICAgICcgYnl0ZXM7IGxpbWl0IGlzICcgK1xuICAgICAgICAgICAgICAgICAgICBtYXhNZXNzYWdlU2l6ZSArXG4gICAgICAgICAgICAgICAgICAgICcgYnl0ZXMpJywgNDAwMDksIDQwMCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl9wdWJsaXNoKG1lc3NhZ2VfMS5kZWZhdWx0LnNlcmlhbGl6ZShtZXNzYWdlcywgZm9ybWF0KSwgaGVhZGVycywgcGFyYW1zLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2hhbm5lbC5wcm90b3R5cGUuX3B1Ymxpc2ggPSBmdW5jdGlvbiAocmVxdWVzdEJvZHksIGhlYWRlcnMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LnBvc3QodGhpcy5yZXN0LCB0aGlzLmJhc2VQYXRoICsgJy9tZXNzYWdlcycsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMsIG51bGwsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIENoYW5uZWwucHJvdG90eXBlLnN0YXR1cyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nICYmIHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdzdGF0dXMnLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMucmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbjtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0UG9zdEhlYWRlcnModGhpcy5yZXN0Lm9wdGlvbnMsIGZvcm1hdCk7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdC5nZXQodGhpcy5yZXN0LCB0aGlzLmJhc2VQYXRoLCBoZWFkZXJzLCB7fSwgZm9ybWF0LCBjYWxsYmFjayB8fCBub29wKTtcbiAgICB9O1xuICAgIHJldHVybiBDaGFubmVsO1xufShldmVudGVtaXR0ZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGFubmVsO1xuXG5cbi8qKiovIH0pLFxuLyogMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGV2ZW50ZW1pdHRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBwYWdpbmF0ZWRyZXNvdXJjZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxOSkpO1xudmFyIHByZXNlbmNlbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNSkpO1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxudmFyIFByZXNlbmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFByZXNlbmNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByZXNlbmNlKGNoYW5uZWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIF90aGlzLmJhc2VQYXRoID0gY2hhbm5lbC5iYXNlUGF0aCArICcvcHJlc2VuY2UnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFByZXNlbmNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1ByZXNlbmNlLmdldCgpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5jaGFubmVsLm5hbWUpO1xuICAgICAgICAvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbC5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnZ2V0JywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5jaGFubmVsLnJlc3QsIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGVudmVsb3BlID0gdGhpcy5jaGFubmVsLnJlc3QuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0LCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdEdldEhlYWRlcnMocmVzdC5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICBpZiAocmVzdC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5jaGFubmVsLmNoYW5uZWxPcHRpb25zO1xuICAgICAgICBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfMS5kZWZhdWx0KHJlc3QsIHRoaXMuYmFzZVBhdGgsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbiAoYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoYm9keSwgb3B0aW9ucywgdW5wYWNrZWQgPyB1bmRlZmluZWQgOiBmb3JtYXQpO1xuICAgICAgICB9KS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBQcmVzZW5jZS5wcm90b3R5cGUuaGlzdG9yeSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUHJlc2VuY2UuaGlzdG9yeSgpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5jaGFubmVsLm5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5faGlzdG9yeShwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFByZXNlbmNlLnByb3RvdHlwZS5faGlzdG9yeSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xuICAgICAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdfaGlzdG9yeScsIFtwYXJhbXNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5jaGFubmVsLnJlc3QsIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGVudmVsb3BlID0gdGhpcy5jaGFubmVsLnJlc3QuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0LCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdEdldEhlYWRlcnMocmVzdC5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICBpZiAocmVzdC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5jaGFubmVsLmNoYW5uZWxPcHRpb25zO1xuICAgICAgICBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfMS5kZWZhdWx0KHJlc3QsIHRoaXMuYmFzZVBhdGggKyAnL2hpc3RvcnknLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24gKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIG9wdGlvbnMsIHVucGFja2VkID8gdW5kZWZpbmVkIDogZm9ybWF0KTtcbiAgICAgICAgfSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgcmV0dXJuIFByZXNlbmNlO1xufShldmVudGVtaXR0ZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQcmVzZW5jZTtcblxuXG4vKioqLyB9KSxcbi8qIDM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmFuc3BvcnRQYXJhbXMgPSB2b2lkIDA7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgcHJvdG9jb2xtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBwcm90b2NvbF8xID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg1MikpO1xudmFyIGRlZmF1bHRzXzEgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgZXZlbnRlbWl0dGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKTtcbnZhciBtZXNzYWdlcXVldWVfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzYpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIGNvbm5lY3Rpb25zdGF0ZWNoYW5nZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzNykpO1xudmFyIGNvbm5lY3Rpb25lcnJvcnNfMSA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMjApKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIGF1dGhfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTcpKTtcbnZhciBtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDkpKTtcbnZhciBtdWx0aWNhc3Rlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyMykpO1xudmFyIHdlYnNvY2tldHRyYW5zcG9ydF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg1MykpO1xudmFyIHRyYW5zcG9ydF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyNikpO1xudmFyIEh0dHBTdGF0dXNDb2Rlc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyNSkpO1xudmFyIGhhdmVXZWJTdG9yYWdlID0gZnVuY3Rpb24gKCkgeyB2YXIgX2E7IHJldHVybiB0eXBlb2YgcGxhdGZvcm1fMS5kZWZhdWx0LldlYlN0b3JhZ2UgIT09ICd1bmRlZmluZWQnICYmICgoX2EgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuV2ViU3RvcmFnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsU3VwcG9ydGVkKTsgfTtcbnZhciBoYXZlU2Vzc2lvblN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7IHZhciBfYTsgcmV0dXJuIHR5cGVvZiBwbGF0Zm9ybV8xLmRlZmF1bHQuV2ViU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcgJiYgKChfYSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5XZWJTdG9yYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2Vzc2lvblN1cHBvcnRlZCk7IH07XG52YXIgYWN0aW9ucyA9IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuQWN0aW9uO1xudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG52YXIgdHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUgPSAnYWJseS10cmFuc3BvcnQtcHJlZmVyZW5jZSc7XG52YXIgc2Vzc2lvblJlY292ZXJ5TmFtZSA9ICdhYmx5LWNvbm5lY3Rpb24tcmVjb3ZlcnknO1xuZnVuY3Rpb24gZ2V0U2Vzc2lvblJlY292ZXJEYXRhKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIGhhdmVTZXNzaW9uU3RvcmFnZSgpICYmICgoX2IgPSAoX2EgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuV2ViU3RvcmFnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFNlc3Npb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBzZXNzaW9uUmVjb3ZlcnlOYW1lKSk7XG59XG5mdW5jdGlvbiBzZXRTZXNzaW9uUmVjb3ZlckRhdGEodmFsdWUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBoYXZlU2Vzc2lvblN0b3JhZ2UoKSAmJiAoKF9iID0gKF9hID0gcGxhdGZvcm1fMS5kZWZhdWx0LldlYlN0b3JhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRTZXNzaW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgc2Vzc2lvblJlY292ZXJ5TmFtZSwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGNsZWFyU2Vzc2lvblJlY292ZXJEYXRhKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIGhhdmVTZXNzaW9uU3RvcmFnZSgpICYmICgoX2IgPSAoX2EgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuV2ViU3RvcmFnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZVNlc3Npb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBzZXNzaW9uUmVjb3ZlcnlOYW1lKSk7XG59XG5mdW5jdGlvbiBiZXR0ZXJUcmFuc3BvcnRUaGFuKGEsIGIpIHtcbiAgICByZXR1cm4gKFV0aWxzLmFyckluZGV4T2YocGxhdGZvcm1fMS5kZWZhdWx0LkRlZmF1bHRzLnRyYW5zcG9ydFByZWZlcmVuY2VPcmRlciwgYS5zaG9ydE5hbWUpID5cbiAgICAgICAgVXRpbHMuYXJySW5kZXhPZihwbGF0Zm9ybV8xLmRlZmF1bHQuRGVmYXVsdHMudHJhbnNwb3J0UHJlZmVyZW5jZU9yZGVyLCBiLnNob3J0TmFtZSkpO1xufVxuZnVuY3Rpb24gYnVuZGxlV2l0aChkZXN0LCBzcmMsIG1heFNpemUpIHtcbiAgICB2YXIgYWN0aW9uO1xuICAgIGlmIChkZXN0LmNoYW5uZWwgIT09IHNyYy5jaGFubmVsKSB7XG4gICAgICAgIC8qIFJUTDZkMyAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgoYWN0aW9uID0gZGVzdC5hY3Rpb24pICE9PSBhY3Rpb25zLlBSRVNFTkNFICYmIGFjdGlvbiAhPT0gYWN0aW9ucy5NRVNTQUdFKSB7XG4gICAgICAgIC8qIFJUTDZkIC0gY2FuIG9ubHkgYnVuZGxlIG1lc3NhZ2VzIG9yIHByZXNlbmNlICovXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGFjdGlvbiAhPT0gc3JjLmFjdGlvbikge1xuICAgICAgICAvKiBSVEw2ZDQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIga2luZCA9IGFjdGlvbiA9PT0gYWN0aW9ucy5QUkVTRU5DRSA/ICdwcmVzZW5jZScgOiAnbWVzc2FnZXMnLCBwcm9wb3NlZCA9IGRlc3Rba2luZF0uY29uY2F0KHNyY1traW5kXSksIHNpemUgPSBtZXNzYWdlXzEuZGVmYXVsdC5nZXRNZXNzYWdlc1NpemUocHJvcG9zZWQpO1xuICAgIGlmIChzaXplID4gbWF4U2l6ZSkge1xuICAgICAgICAvKiBSVEw2ZDEgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIVV0aWxzLmFsbFNhbWUocHJvcG9zZWQsICdjbGllbnRJZCcpKSB7XG4gICAgICAgIC8qIFJUTDZkMiAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghVXRpbHMuYXJyRXZlcnkocHJvcG9zZWQsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgcmV0dXJuICFtc2cuaWQ7XG4gICAgfSkpIHtcbiAgICAgICAgLyogUlRMNmQ3ICovXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyogd2UncmUgZ29vZCB0byBnbyEgKi9cbiAgICBkZXN0W2tpbmRdID0gcHJvcG9zZWQ7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBkZWNvZGVSZWNvdmVyeUtleShyZWNvdmVyeUtleSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlY292ZXJ5S2V5KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxudmFyIFRyYW5zcG9ydFBhcmFtcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmFuc3BvcnRQYXJhbXMob3B0aW9ucywgaG9zdCwgbW9kZSwgY29ubmVjdGlvbktleSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25LZXkgPSBjb25uZWN0aW9uS2V5O1xuICAgICAgICB0aGlzLmZvcm1hdCA9IG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uO1xuICAgIH1cbiAgICBUcmFuc3BvcnRQYXJhbXMucHJvdG90eXBlLmdldENvbm5lY3RQYXJhbXMgPSBmdW5jdGlvbiAoYXV0aFBhcmFtcykge1xuICAgICAgICB2YXIgcGFyYW1zID0gYXV0aFBhcmFtcyA/IFV0aWxzLmNvcHkoYXV0aFBhcmFtcykgOiB7fTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICAgICAgICBjYXNlICd1cGdyYWRlJzpcbiAgICAgICAgICAgICAgICBwYXJhbXMudXBncmFkZSA9IHRoaXMuY29ubmVjdGlvbktleTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jlc3VtZSc6XG4gICAgICAgICAgICAgICAgcGFyYW1zLnJlc3VtZSA9IHRoaXMuY29ubmVjdGlvbktleTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JlY292ZXInOiB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY292ZXJ5Q29udGV4dCA9IGRlY29kZVJlY292ZXJ5S2V5KG9wdGlvbnMucmVjb3Zlcik7XG4gICAgICAgICAgICAgICAgaWYgKHJlY292ZXJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMucmVjb3ZlciA9IHJlY292ZXJ5Q29udGV4dC5jb25uZWN0aW9uS2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2xpZW50SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmNsaWVudElkID0gb3B0aW9ucy5jbGllbnRJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lY2hvTWVzc2FnZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBwYXJhbXMuZWNobyA9ICdmYWxzZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5mb3JtYXQgPSB0aGlzLmZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdHJlYW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLnN0cmVhbSA9IHRoaXMuc3RyZWFtO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhlYXJ0YmVhdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmhlYXJ0YmVhdHMgPSB0aGlzLmhlYXJ0YmVhdHM7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLnYgPSBkZWZhdWx0c18xLmRlZmF1bHQucHJvdG9jb2xWZXJzaW9uO1xuICAgICAgICBwYXJhbXMuYWdlbnQgPSBlbmNvZGVVUklDb21wb25lbnQoKDAsIGRlZmF1bHRzXzEuZ2V0QWdlbnRTdHJpbmcpKHRoaXMub3B0aW9ucykpO1xuICAgICAgICBpZiAob3B0aW9ucy50cmFuc3BvcnRQYXJhbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgVXRpbHMubWl4aW4ocGFyYW1zLCBvcHRpb25zLnRyYW5zcG9ydFBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICAgIFRyYW5zcG9ydFBhcmFtcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnW21vZGU9JyArIHRoaXMubW9kZTtcbiAgICAgICAgaWYgKHRoaXMuaG9zdCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcsaG9zdD0nICsgdGhpcy5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25LZXkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnLGNvbm5lY3Rpb25LZXk9JyArIHRoaXMuY29ubmVjdGlvbktleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mb3JtYXQpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnLGZvcm1hdD0nICsgdGhpcy5mb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICddJztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBUcmFuc3BvcnRQYXJhbXM7XG59KCkpO1xuZXhwb3J0cy5UcmFuc3BvcnRQYXJhbXMgPSBUcmFuc3BvcnRQYXJhbXM7XG52YXIgQ29ubmVjdGlvbk1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ29ubmVjdGlvbk1hbmFnZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGlvbk1hbmFnZXIocmVhbHRpbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGlzY29ubmVjdGVkUmV0cnlDb3VudCA9IDA7XG4gICAgICAgIENvbm5lY3Rpb25NYW5hZ2VyLmluaXRUcmFuc3BvcnRzKCk7XG4gICAgICAgIF90aGlzLnJlYWx0aW1lID0gcmVhbHRpbWU7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB2YXIgdGltZW91dHMgPSBvcHRpb25zLnRpbWVvdXRzO1xuICAgICAgICAvKiBjb25uZWN0aW5nVGltZW91dDogbGVhdmUgcHJlZmVyZW5jZUNvbm5lY3RUaW1lb3V0ICh+NnMpIHRvIHRyeSB0aGVcbiAgICAgICAgICogcHJlZmVyZW5jZSB0cmFuc3BvcnQsIHRoZW4gcmVhbHRpbWVSZXF1ZXN0VGltZW91dCAofjEwcykgdG8gZXN0YWJsaXNoXG4gICAgICAgICAqIHRoZSBiYXNlIHRyYW5zcG9ydCBpbiBjYXNlIHRoYXQgZmFpbHMgKi9cbiAgICAgICAgdmFyIGNvbm5lY3RpbmdUaW1lb3V0ID0gdGltZW91dHMucHJlZmVyZW5jZUNvbm5lY3RUaW1lb3V0ICsgdGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dDtcbiAgICAgICAgX3RoaXMuc3RhdGVzID0ge1xuICAgICAgICAgICAgaW5pdGlhbGl6ZWQ6IHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2luaXRpYWxpemVkJyxcbiAgICAgICAgICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcXVldWVFdmVudHM6IHRydWUsXG4gICAgICAgICAgICAgICAgc2VuZEV2ZW50czogZmFsc2UsXG4gICAgICAgICAgICAgICAgZmFpbFN0YXRlOiAnZGlzY29ubmVjdGVkJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25uZWN0aW5nOiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdjb25uZWN0aW5nJyxcbiAgICAgICAgICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcXVldWVFdmVudHM6IHRydWUsXG4gICAgICAgICAgICAgICAgc2VuZEV2ZW50czogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmV0cnlEZWxheTogY29ubmVjdGluZ1RpbWVvdXQsXG4gICAgICAgICAgICAgICAgZmFpbFN0YXRlOiAnZGlzY29ubmVjdGVkJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25uZWN0ZWQ6IHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2Nvbm5lY3RlZCcsXG4gICAgICAgICAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHF1ZXVlRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZW5kRXZlbnRzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZhaWxTdGF0ZTogJ2Rpc2Nvbm5lY3RlZCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3luY2hyb25pemluZzoge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnY29ubmVjdGVkJyxcbiAgICAgICAgICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcXVldWVFdmVudHM6IHRydWUsXG4gICAgICAgICAgICAgICAgc2VuZEV2ZW50czogZmFsc2UsXG4gICAgICAgICAgICAgICAgZm9yY2VRdWV1ZUV2ZW50czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmYWlsU3RhdGU6ICdkaXNjb25uZWN0ZWQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc2Nvbm5lY3RlZDoge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnZGlzY29ubmVjdGVkJyxcbiAgICAgICAgICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcXVldWVFdmVudHM6IHRydWUsXG4gICAgICAgICAgICAgICAgc2VuZEV2ZW50czogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmV0cnlEZWxheTogdGltZW91dHMuZGlzY29ubmVjdGVkUmV0cnlUaW1lb3V0LFxuICAgICAgICAgICAgICAgIGZhaWxTdGF0ZTogJ2Rpc2Nvbm5lY3RlZCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VzcGVuZGVkOiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdzdXNwZW5kZWQnLFxuICAgICAgICAgICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBxdWV1ZUV2ZW50czogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VuZEV2ZW50czogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmV0cnlEZWxheTogdGltZW91dHMuc3VzcGVuZGVkUmV0cnlUaW1lb3V0LFxuICAgICAgICAgICAgICAgIGZhaWxTdGF0ZTogJ3N1c3BlbmRlZCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2luZzoge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnY2xvc2luZycsXG4gICAgICAgICAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHF1ZXVlRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZXRyeURlbGF5OiB0aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0LFxuICAgICAgICAgICAgICAgIGZhaWxTdGF0ZTogJ2Nsb3NlZCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2VkOiB7IHN0YXRlOiAnY2xvc2VkJywgdGVybWluYWw6IHRydWUsIHF1ZXVlRXZlbnRzOiBmYWxzZSwgc2VuZEV2ZW50czogZmFsc2UsIGZhaWxTdGF0ZTogJ2Nsb3NlZCcgfSxcbiAgICAgICAgICAgIGZhaWxlZDogeyBzdGF0ZTogJ2ZhaWxlZCcsIHRlcm1pbmFsOiB0cnVlLCBxdWV1ZUV2ZW50czogZmFsc2UsIHNlbmRFdmVudHM6IGZhbHNlLCBmYWlsU3RhdGU6ICdmYWlsZWQnIH0sXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnN0YXRlID0gX3RoaXMuc3RhdGVzLmluaXRpYWxpemVkO1xuICAgICAgICBfdGhpcy5lcnJvclJlYXNvbiA9IG51bGw7XG4gICAgICAgIF90aGlzLnF1ZXVlZE1lc3NhZ2VzID0gbmV3IG1lc3NhZ2VxdWV1ZV8xLmRlZmF1bHQoKTtcbiAgICAgICAgX3RoaXMubXNnU2VyaWFsID0gMDtcbiAgICAgICAgX3RoaXMuY29ubmVjdGlvbkRldGFpbHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLmNvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMuY29ubmVjdGlvbktleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMuY29ubmVjdGlvblN0YXRlVHRsID0gdGltZW91dHMuY29ubmVjdGlvblN0YXRlVHRsO1xuICAgICAgICBfdGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICBfdGhpcy50cmFuc3BvcnRzID0gVXRpbHMuaW50ZXJzZWN0KG9wdGlvbnMudHJhbnNwb3J0cyB8fCBkZWZhdWx0c18xLmRlZmF1bHQuZGVmYXVsdFRyYW5zcG9ydHMsIENvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHMpO1xuICAgICAgICAvKiBiYXNlVHJhbnNwb3J0cyBzZWxlY3RzIHRoZSBsZWZ0bW9zdCB0cmFuc3BvcnQgaW4gdGhlIERlZmF1bHRzLmJhc2VUcmFuc3BvcnRPcmRlciBsaXN0XG4gICAgICAgICAqIHRoYXQncyBib3RoIHJlcXVlc3RlZCBhbmQgc3VwcG9ydGVkLiBOb3JtYWxseSB0aGlzIHdpbGwgYmUgeGhyX3BvbGxpbmc7XG4gICAgICAgICAqIGlmIHhociBpc24ndCBzdXBwb3J0ZWQgaXQgd2lsbCBiZSBqc29ucC4gSWYgdGhlIHVzZXIgaGFzIGZvcmNlZCBhXG4gICAgICAgICAqIHRyYW5zcG9ydCwgaXQnbGwganVzdCBiZSB0aGF0IG9uZS4gKi9cbiAgICAgICAgX3RoaXMuYmFzZVRyYW5zcG9ydCA9IFV0aWxzLmludGVyc2VjdChkZWZhdWx0c18xLmRlZmF1bHQuYmFzZVRyYW5zcG9ydE9yZGVyLCBfdGhpcy50cmFuc3BvcnRzKVswXTtcbiAgICAgICAgX3RoaXMudXBncmFkZVRyYW5zcG9ydHMgPSBVdGlscy5pbnRlcnNlY3QoX3RoaXMudHJhbnNwb3J0cywgZGVmYXVsdHNfMS5kZWZhdWx0LnVwZ3JhZGVUcmFuc3BvcnRzKTtcbiAgICAgICAgX3RoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSA9IG51bGw7XG4gICAgICAgIF90aGlzLmh0dHBIb3N0cyA9IGRlZmF1bHRzXzEuZGVmYXVsdC5nZXRIb3N0cyhvcHRpb25zKTtcbiAgICAgICAgX3RoaXMuYWN0aXZlUHJvdG9jb2wgPSBudWxsO1xuICAgICAgICBfdGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMgPSBbXTtcbiAgICAgICAgX3RoaXMucGVuZGluZ1RyYW5zcG9ydHMgPSBbXTtcbiAgICAgICAgX3RoaXMuaG9zdCA9IG51bGw7XG4gICAgICAgIF90aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCA9IG51bGw7XG4gICAgICAgIF90aGlzLmxhc3RBY3Rpdml0eSA9IG51bGw7XG4gICAgICAgIF90aGlzLmZvcmNlRmFsbGJhY2tIb3N0ID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmNvbm5lY3RDb3VudGVyID0gMDtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpJywgJ3N0YXJ0ZWQnKTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpJywgJ3JlcXVlc3RlZCB0cmFuc3BvcnRzID0gWycgKyAob3B0aW9ucy50cmFuc3BvcnRzIHx8IGRlZmF1bHRzXzEuZGVmYXVsdC5kZWZhdWx0VHJhbnNwb3J0cykgKyAnXScpO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCAnYXZhaWxhYmxlIHRyYW5zcG9ydHMgPSBbJyArIF90aGlzLnRyYW5zcG9ydHMgKyAnXScpO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCAnaHR0cCBob3N0cyA9IFsnICsgX3RoaXMuaHR0cEhvc3RzICsgJ10nKTtcbiAgICAgICAgaWYgKCFfdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdubyByZXF1ZXN0ZWQgdHJhbnNwb3J0cyBhdmFpbGFibGUnO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdyZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpJywgbXNnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhZGRFdmVudExpc3RlbmVyID0gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5hZGRFdmVudExpc3RlbmVyO1xuICAgICAgICBpZiAoYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgLyogaW50ZXJjZXB0IGNsb3NlIGV2ZW50IGluIGJyb3dzZXIgdG8gcGVyc2lzdCBjb25uZWN0aW9uIGlkIGlmIHJlcXVlc3RlZCAqL1xuICAgICAgICAgICAgaWYgKGhhdmVTZXNzaW9uU3RvcmFnZSgpICYmIHR5cGVvZiBvcHRpb25zLnJlY292ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvKiBVc3VhbGx5IGNhbid0IHVzZSBiaW5kIGFzIG5vdCBzdXBwb3J0ZWQgaW4gSUU4LCBidXQgSUUgZG9lc24ndCBzdXBwb3J0IHNlc3Npb25TdG9yYWdlLCBzby4uLiAqL1xuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIF90aGlzLnBlcnNpc3RDb25uZWN0aW9uLmJpbmQoX3RoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNsb3NlT25VbmxvYWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01BSk9SLCAnUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKScsICdiZWZvcmV1bmxvYWQgZXZlbnQgaGFzIHRyaWdnZXJlZCB0aGUgY29ubmVjdGlvbiB0byBjbG9zZSBhcyBjbG9zZU9uVW5sb2FkIGlzIHRydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVxdWVzdFN0YXRlKHsgc3RhdGU6ICdjbG9zaW5nJyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIExpc3RlbiBmb3Igb25saW5lIGFuZCBvZmZsaW5lIGV2ZW50cyAqL1xuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZSA9PSBfdGhpcy5zdGF0ZXMuZGlzY29ubmVjdGVkIHx8IF90aGlzLnN0YXRlID09IF90aGlzLnN0YXRlcy5zdXNwZW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlciBjYXVnaHQgYnJvd3NlciDigJhvbmxpbmXigJkgZXZlbnQnLCAncmVhdHRlbXB0aW5nIGNvbm5lY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVxdWVzdFN0YXRlKHsgc3RhdGU6ICdjb25uZWN0aW5nJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMuc3RhdGUgPT0gX3RoaXMuc3RhdGVzLmNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUlROMjBjOiBpZiAnb25saW5lJyBldmVudCByZWNpZXZlZCB3aGlsZSBDT05ORUNUSU5HLCBhYmFuZG9uIGNvbm5lY3Rpb24gYXR0ZW1wdCBhbmQgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGVuZGluZ1RyYW5zcG9ydHMuZm9yRWFjaChmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXRhY2ggdHJhbnNwb3J0IGxpc3RlbmVycyB0byBhdm9pZCBjb25uZWN0aW9uIHN0YXRlIHNpZGUgZWZmZWN0cyBmcm9tIGNhbGxpbmcgZGlzcG9zZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0Lm9mZigpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhcnRDb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZSA9PSBfdGhpcy5zdGF0ZXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIgY2F1Z2h0IGJyb3dzZXIg4oCYb2ZmbGluZeKAmSBldmVudCcsICdkaXNjb25uZWN0aW5nIGFjdGl2ZSB0cmFuc3BvcnQnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IHN1ZmZpY2llbnQgdG8ganVzdCBnbyB0byB0aGUgJ2Rpc2Nvbm5lY3RlZCcgc3RhdGUsIHdhbnQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yY2UgYWxsIHRyYW5zcG9ydHMgdG8gcmVhdHRlbXB0IHRoZSBjb25uZWN0aW9uLiBXaWxsIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHJ5LlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIuaW5pdFRyYW5zcG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICgwLCB3ZWJzb2NrZXR0cmFuc3BvcnRfMS5kZWZhdWx0KShDb25uZWN0aW9uTWFuYWdlcik7XG4gICAgICAgIFV0aWxzLmFyckZvckVhY2gocGxhdGZvcm1fMS5kZWZhdWx0LlRyYW5zcG9ydHMsIGZ1bmN0aW9uIChpbml0Rm4pIHtcbiAgICAgICAgICAgIGluaXRGbihDb25uZWN0aW9uTWFuYWdlcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydFBhcmFtcyA9IGZ1bmN0aW9uIChob3N0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNwb3J0UGFyYW1zKHRoaXMub3B0aW9ucywgaG9zdCwgbW9kZSwgdGhpcy5jb25uZWN0aW9uS2V5KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRUcmFuc3BvcnRQYXJhbXMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRlY2lkZU1vZGUgPSBmdW5jdGlvbiAobW9kZUNiKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuY29ubmVjdGlvbktleSkge1xuICAgICAgICAgICAgICAgIG1vZGVDYigncmVzdW1lJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpcy5vcHRpb25zLnJlY292ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgbW9kZUNiKCdyZWNvdmVyJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlY292ZXJGbiA9IF90aGlzLm9wdGlvbnMucmVjb3ZlciwgbGFzdFNlc3Npb25EYXRhID0gZ2V0U2Vzc2lvblJlY292ZXJEYXRhKCk7XG4gICAgICAgICAgICBpZiAobGFzdFNlc3Npb25EYXRhICYmIHR5cGVvZiByZWNvdmVyRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmdldFRyYW5zcG9ydFBhcmFtcygpJywgJ0NhbGxpbmcgY2xpZW50T3B0aW9ucy1wcm92aWRlZCByZWNvdmVyIGZ1bmN0aW9uIHdpdGggbGFzdCBzZXNzaW9uIGRhdGEnKTtcbiAgICAgICAgICAgICAgICByZWNvdmVyRm4obGFzdFNlc3Npb25EYXRhLCBmdW5jdGlvbiAoc2hvdWxkUmVjb3Zlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUmVjb3Zlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub3B0aW9ucy5yZWNvdmVyID0gbGFzdFNlc3Npb25EYXRhLnJlY292ZXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZUNiKCdyZWNvdmVyJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlQ2IoJ2NsZWFuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RlQ2IoJ2NsZWFuJyk7XG4gICAgICAgIH07XG4gICAgICAgIGRlY2lkZU1vZGUoZnVuY3Rpb24gKG1vZGUpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc3BvcnRQYXJhbXMgPSBfdGhpcy5jcmVhdGVUcmFuc3BvcnRQYXJhbXMobnVsbCwgbW9kZSk7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ3JlY292ZXInKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5nZXRUcmFuc3BvcnRQYXJhbXMoKScsICdUcmFuc3BvcnQgcmVjb3ZlcnkgbW9kZSA9IHJlY292ZXI7IHJlY292ZXJ5S2V5ID0gJyArIF90aGlzLm9wdGlvbnMucmVjb3Zlcik7XG4gICAgICAgICAgICAgICAgdmFyIHJlY292ZXJ5Q29udGV4dCA9IGRlY29kZVJlY292ZXJ5S2V5KF90aGlzLm9wdGlvbnMucmVjb3Zlcik7XG4gICAgICAgICAgICAgICAgaWYgKHJlY292ZXJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tc2dTZXJpYWwgPSByZWNvdmVyeUNvbnRleHQubXNnU2VyaWFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZ2V0VHJhbnNwb3J0UGFyYW1zKCknLCAnVHJhbnNwb3J0IHBhcmFtcyA9ICcgKyB0cmFuc3BvcnRQYXJhbXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayh0cmFuc3BvcnRQYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gY29ubmVjdCB1c2luZyBhIGdpdmVuIHRyYW5zcG9ydFxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnRQYXJhbXNcbiAgICAgKiBAcGFyYW0gY2FuZGlkYXRlLCB0aGUgdHJhbnNwb3J0IHRvIHRyeVxuICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS50cnlBVHJhbnNwb3J0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydFBhcmFtcywgY2FuZGlkYXRlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKScsICd0cnlpbmcgJyArIGNhbmRpZGF0ZSk7XG4gICAgICAgIHRyYW5zcG9ydF8xLmRlZmF1bHQudHJ5Q29ubmVjdChDb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzW2NhbmRpZGF0ZV0sIHRoaXMsIHRoaXMucmVhbHRpbWUuYXV0aCwgdHJhbnNwb3J0UGFyYW1zLCBmdW5jdGlvbiAod3JhcHBlZEVyciwgdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBfdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PSBfdGhpcy5zdGF0ZXMuY2xvc2luZyB8fCBzdGF0ZSA9PSBfdGhpcy5zdGF0ZXMuY2xvc2VkIHx8IHN0YXRlID09IF90aGlzLnN0YXRlcy5mYWlsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpJywgJ2Nvbm5lY3Rpb24gJyArIHN0YXRlLnN0YXRlICsgJyB3aGlsZSB3ZSB3ZXJlIGF0dGVtcHRpbmcgdGhlIHRyYW5zcG9ydDsgY2xvc2luZyAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3cmFwcGVkRXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KCknLCAndHJhbnNwb3J0ICcgKyBjYW5kaWRhdGUgKyAnICcgKyB3cmFwcGVkRXJyLmV2ZW50ICsgJywgZXJyOiAnICsgd3JhcHBlZEVyci5lcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAvKiBDb21ldCB0cmFuc3BvcnQgb25jb25uZWN0IHRva2VuIGVycm9ycyBjYW4gYmUgZGVhbHQgd2l0aCBoZXJlLlxuICAgICAgICAgICAgICAgICAqIFdlYnNvY2tldCBvbmVzIG9ubHkgaGFwcGVuIGFmdGVyIHRoZSB0cmFuc3BvcnQgY2xhaW1zIHRvIGJlIHZpYWJsZSxcbiAgICAgICAgICAgICAgICAgKiBzbyBhcmUgZGVhbHQgd2l0aCBhcyBub24tb25jb25uZWN0IHRva2VuIGVycm9ycyAqL1xuICAgICAgICAgICAgICAgIGlmIChhdXRoXzEuZGVmYXVsdC5pc1Rva2VuRXJyKHdyYXBwZWRFcnIuZXJyb3IpICYmXG4gICAgICAgICAgICAgICAgICAgICEoX3RoaXMuZXJyb3JSZWFzb24gJiYgYXV0aF8xLmRlZmF1bHQuaXNUb2tlbkVycihfdGhpcy5lcnJvclJlYXNvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVycm9yUmVhc29uID0gd3JhcHBlZEVyci5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgLyogcmUtZ2V0IGEgdG9rZW4gYW5kIHRyeSBhZ2FpbiAqL1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWFsdGltZS5hdXRoLl9mb3JjZU5ld1Rva2VuKG51bGwsIG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCBjYW5kaWRhdGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdyYXBwZWRFcnIuZXZlbnQgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIEVycm9yIHRoYXQncyBmYXRhbCB0byB0aGUgY29ubmVjdGlvbiAqL1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiAnZmFpbGVkJywgZXJyb3I6IHdyYXBwZWRFcnIuZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3cmFwcGVkRXJyLmV2ZW50ID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBjb25uZWN0aW9uZXJyb3JzXzEuaXNSZXRyaWFibGUpKHdyYXBwZWRFcnIuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBFcnJvciByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIgdGhhdCBkb2VzIG5vdCBjYWxsIGZvciB0cnlpbmcgYSBmYWxsYmFjayBob3N0LCBlZyBhIHJhdGUgbGltaXQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IF90aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSwgZXJyb3I6IHdyYXBwZWRFcnIuZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIEVycm9yIHdpdGggdGhhdCB0cmFuc3BvcnQgb25seTsgY29udGludWUgdHJ5aW5nIG90aGVyIGZhbGxiYWNrIGhvc3RzICovXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KCknLCAndmlhYmxlIHRyYW5zcG9ydCAnICsgY2FuZGlkYXRlICsgJzsgc2V0dGluZyBwZW5kaW5nJyk7XG4gICAgICAgICAgICBfdGhpcy5zZXRUcmFuc3BvcnRQZW5kaW5nKHRyYW5zcG9ydCwgdHJhbnNwb3J0UGFyYW1zKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRyYW5zcG9ydCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSB0cmFuc3BvcnQgaXMgaW5kaWNhdGVkIHRvIGJlIHZpYWJsZSwgYW5kIHRoZSBDb25uZWN0aW9uTWFuYWdlclxuICAgICAqIGV4cGVjdHMgdG8gYWN0aXZhdGUgdGhpcyB0cmFuc3BvcnQgYXMgc29vbiBhcyBpdCBpcyBjb25uZWN0ZWQuXG4gICAgICogQHBhcmFtIHRyYW5zcG9ydFxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnRQYXJhbXNcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0VHJhbnNwb3J0UGVuZGluZyA9IGZ1bmN0aW9uICh0cmFuc3BvcnQsIHRyYW5zcG9ydFBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbW9kZSA9IHRyYW5zcG9ydFBhcmFtcy5tb2RlO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNldFRyYW5zcG9ydFBlbmRpbmcoKScsICd0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0ICsgJzsgbW9kZSA9ICcgKyBtb2RlKTtcbiAgICAgICAgVXRpbHMuYXJyRGVsZXRlVmFsdWUodGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMsIHRyYW5zcG9ydCk7XG4gICAgICAgIHRoaXMucGVuZGluZ1RyYW5zcG9ydHMucHVzaCh0cmFuc3BvcnQpO1xuICAgICAgICB2YXIgb3B0aW1hbFRyYW5zcG9ydCA9IHBsYXRmb3JtXzEuZGVmYXVsdC5EZWZhdWx0cy50cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXJbcGxhdGZvcm1fMS5kZWZhdWx0LkRlZmF1bHRzLnRyYW5zcG9ydFByZWZlcmVuY2VPcmRlci5sZW5ndGggLSAxXTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uY2UoJ2Nvbm5lY3RlZCcsIGZ1bmN0aW9uIChlcnJvciwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscykge1xuICAgICAgICAgICAgaWYgKG1vZGUgPT0gJ3VwZ3JhZGUnICYmIF90aGlzLmFjdGl2ZVByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgLyogIGlmIHdzIGFuZCB4aHJzIGFyZSBjb25uZWN0aW5nIGluIHBhcmFsbGVsLCBkZWxheSB4aHJzIGFjdGl2YXRpb24gdG8gbGV0IHdzIGdvIGFoZWFkICovXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zcG9ydC5zaG9ydE5hbWUgIT09IG9wdGltYWxUcmFuc3BvcnQgJiZcbiAgICAgICAgICAgICAgICAgICAgVXRpbHMuYXJySW4oX3RoaXMuZ2V0VXBncmFkZVBvc3NpYmlsaXRpZXMoKSwgb3B0aW1hbFRyYW5zcG9ydCkgJiZcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlUHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMudGltZW91dHMucGFyYWxsZWxVcGdyYWRlRGVsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2YXRlVHJhbnNwb3J0KGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMpO1xuICAgICAgICAgICAgICAgIC8qIGFsbG93IGNvbm5lY3RJbXBsIHRvIHN0YXJ0IHRoZSB1cGdyYWRlIHByb2Nlc3MgaWYgbmVlZGVkLCBidXQgYWxsb3dcbiAgICAgICAgICAgICAgICAgKiBvdGhlciBldmVudCBoYW5kbGVycywgaW5jbHVkaW5nIGFjdGl2YXRpbmcgdGhlIHRyYW5zcG9ydCwgdG8gcnVuIGZpcnN0ICovXG4gICAgICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ3JlY292ZXInICYmIF90aGlzLm9wdGlvbnMucmVjb3Zlcikge1xuICAgICAgICAgICAgICAgIC8qIEFmdGVyIGEgc3VjY2Vzc2Z1bCByZWNvdmVyeSwgd2UgdW5wZXJzaXN0LCBhcyBhIHJlY292ZXJ5IGtleSBjYW5ub3RcbiAgICAgICAgICAgICAgICAgKiBiZSB1c2VkIG1vcmUgdGhhbiBvbmNlICovXG4gICAgICAgICAgICAgICAgX3RoaXMub3B0aW9ucy5yZWNvdmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy51bnBlcnNpc3RDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRyYW5zcG9ydC5vbihbJ2Rpc2Nvbm5lY3RlZCcsICdjbG9zZWQnLCAnZmFpbGVkJ10sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5kZWFjdGl2YXRlVHJhbnNwb3J0KHRyYW5zcG9ydCwgdGhpcy5ldmVudCwgZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0KCd0cmFuc3BvcnQucGVuZGluZycsIHRyYW5zcG9ydCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhbiB1cGdyYWRlIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQsXG4gICAgICogdG8gc2NoZWR1bGUgdGhlIGFjdGl2YXRpb24gb2YgdGhhdCB0cmFuc3BvcnQuXG4gICAgICogQHBhcmFtIGVycm9yXG4gICAgICogQHBhcmFtIHRyYW5zcG9ydFxuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbkRldGFpbHNcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uID0gZnVuY3Rpb24gKGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGN1cnJlbnRUcmFuc3BvcnQgPSB0aGlzLmFjdGl2ZVByb3RvY29sICYmIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCksIGFiYW5kb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgVXRpbHMuYXJyRGVsZXRlVmFsdWUoX3RoaXMucGVuZGluZ1RyYW5zcG9ydHMsIHRyYW5zcG9ydCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQgJiYgdGhpcy5zdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZykge1xuICAgICAgICAgICAgLyogVGhpcyBpcyBtb3N0IGxpa2VseSB0byBoYXBwZW4gZm9yIHRoZSBkZWxheWVkIFhIUnMsIHdoZW4gWEhScyBhbmQgd3MgYXJlIHNjaGVkdWxlZCBpbiBwYXJhbGxlbCovXG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ0N1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZSAoJyArXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdGF0ZSArXG4gICAgICAgICAgICAgICAgKHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLnN5bmNocm9uaXppbmcgPyAnLCBidXQgd2l0aCBhbiB1cGdyYWRlIGFscmVhZHkgaW4gcHJvZ3Jlc3MnIDogJycpICtcbiAgICAgICAgICAgICAgICAnKSBpcyBub3QgdmFsaWQgdG8gdXBncmFkZSBpbjsgYWJhbmRvbmluZyB1cGdyYWRlIHRvICcgK1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zaG9ydE5hbWUpO1xuICAgICAgICAgICAgYWJhbmRvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50VHJhbnNwb3J0ICYmICFiZXR0ZXJUcmFuc3BvcnRUaGFuKHRyYW5zcG9ydCwgY3VycmVudFRyYW5zcG9ydCkpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnUHJvcG9zZWQgdHJhbnNwb3J0ICcgK1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zaG9ydE5hbWUgK1xuICAgICAgICAgICAgICAgICcgaXMgbm8gYmV0dGVyIHRoYW4gY3VycmVudCBhY3RpdmUgdHJhbnNwb3J0ICcgK1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc3BvcnQuc2hvcnROYW1lICtcbiAgICAgICAgICAgICAgICAnIC0gYWJhbmRvbmluZyB1cGdyYWRlJyk7XG4gICAgICAgICAgICBhYmFuZG9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdTY2hlZHVsaW5nIHRyYW5zcG9ydCB1cGdyYWRlOyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgdmFyIG9sZFByb3RvY29sID0gbnVsbDtcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIC8qIFRoaXMgaXMgb25seSBwb3NzaWJsZSBpZiB0aGUgeGhyIHN0cmVhbWluZyB0cmFuc3BvcnQgd2FzIGRpc2Nvbm5lY3RlZCBkdXJpbmcgdGhlIHBhcmFsbGVsVXBncmFkZURlbGF5ICovXG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1Byb3Bvc2VkIHRyYW5zcG9ydCAnICsgdHJhbnNwb3J0LnNob3J0TmFtZSArICdpcyBubyBsb25nZXIgY29ubmVjdGVkOyBhYmFuZG9uaW5nIHVwZ3JhZGUnKTtcbiAgICAgICAgICAgIGFiYW5kb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ0N1cnJlbnRseSBjb25uZWN0ZWQsIHNvIHRlbXBvcmFyaWx5IHBhdXNpbmcgZXZlbnRzIHVudGlsIHRoZSB1cGdyYWRlIGlzIGNvbXBsZXRlJyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMuc3luY2hyb25pemluZztcbiAgICAgICAgICAgIG9sZFByb3RvY29sID0gdGhpcy5hY3RpdmVQcm90b2NvbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAvKiBOb3RlOiB1cGdyYWRpbmcgZnJvbSB0aGUgY29ubmVjdGluZyBzdGF0ZSBpcyB2YWxpZCBpZiB0aGUgb2xkIGFjdGl2ZVxuICAgICAgICAgICAgICogdHJhbnNwb3J0IHdhcyBkZWFjdGl2YXRlZCBhZnRlciB0aGUgdXBncmFkZSB0cmFuc3BvcnQgZmlyc3QgY29ubmVjdGVkO1xuICAgICAgICAgICAgICogc2VlIGxvZ2ljIGluIGRlYWN0aXZhdGVUcmFuc3BvcnQgKi9cbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnQ3VycmVudCBjb25uZWN0aW9uIHN0YXRlICgnICtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnN0YXRlICtcbiAgICAgICAgICAgICAgICAodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuc3luY2hyb25pemluZyA/ICcsIGJ1dCB3aXRoIGFuIHVwZ3JhZGUgYWxyZWFkeSBpbiBwcm9ncmVzcycgOiAnJykgK1xuICAgICAgICAgICAgICAgICcpIGlzIG5vdCB2YWxpZCB0byB1cGdyYWRlIGluOyBhYmFuZG9uaW5nIHVwZ3JhZGUgdG8gJyArXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNob3J0TmFtZSk7XG4gICAgICAgICAgICBhYmFuZG9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdTeW5jaW5nIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG4gICAgICAgIHZhciBmaW5pc2hVcGdyYWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdBY3RpdmF0aW5nIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICAvLyBTZW5kIEFDVElWQVRFIHRvIHRlbGwgdGhlIHNlcnZlciB0byBtYWtlIHRoaXMgdHJhbnNwb3J0IHRoZVxuICAgICAgICAgICAgLy8gYWN0aXZlIHRyYW5zcG9ydCwgd2hpY2ggc3VzcGVuZHMgY2hhbm5lbHMgdW50aWwgd2UgcmUtYXR0YWNoLlxuICAgICAgICAgICAgdHJhbnNwb3J0LnNlbmQocHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IGFjdGlvbnMuQUNUSVZBVEUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBfdGhpcy5hY3RpdmF0ZVRyYW5zcG9ydChlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKTtcbiAgICAgICAgICAgIC8qIFJlc3RvcmUgcHJlLXN5bmMgc3RhdGUuIElmIHN0YXRlIGhhcyBjaGFuZ2VkIGluIHRoZSBtZWFudGltZSxcbiAgICAgICAgICAgICAqIGRvbid0IHRvdWNoIGl0IC0tIHNpbmNlIHRoZSB3ZWJzb2NrZXQgdHJhbnNwb3J0IHdhaXRzIGEgdGljayBiZWZvcmVcbiAgICAgICAgICAgICAqIGRpc3Bvc2luZyBpdHNlbGYsIGl0J3MgcG9zc2libGUgZm9yIGl0IHRvIGhhdmUgaGFwcGlseSBzeW5jZWRcbiAgICAgICAgICAgICAqIHdpdGhvdXQgZXJyIHdoaWxlLCB1bmtub3duIHRvIGl0LCB0aGUgY29ubmVjdGlvbiBoYXMgY2xvc2VkIGluIHRoZVxuICAgICAgICAgICAgICogbWVhbnRpbWUgYW5kIHRoZSB3cyB0cmFuc3BvcnQgaXMgc2NoZWR1bGVkIGZvciBkZWF0aCAqL1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlID09PSBfdGhpcy5zdGF0ZXMuc3luY2hyb25pemluZykge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnUHJlLXVwZ3JhZGUgcHJvdG9jb2wgaWRsZSwgc2VuZGluZyBxdWV1ZWQgbWVzc2FnZXMgb24gdXBncmFkZWQgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9IF90aGlzLnN0YXRlcy5jb25uZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1ByZS11cGdyYWRlIHByb3RvY29sIGlkbGUsIGJ1dCBzdGF0ZSBpcyBub3cgJyArIF90aGlzLnN0YXRlLnN0YXRlICsgJywgc28gbGVhdmluZyB1bmNoYW5nZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VuZFF1ZXVlZE1lc3NhZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qIFdhaXQgdW50aWwgc3luYyBpcyBkb25lIGFuZCBvbGQgdHJhbnNwb3J0IGlzIGlkbGUgYmVmb3JlIGFjdGl2YXRpbmcgbmV3IHRyYW5zcG9ydC4gVGhpc1xuICAgICAgICAgKiBndWFyYW50ZWVzIHRoYXQgbWVzc2FnZXMgYXJyaXZlIGF0IHJlYWx0aW1lIGluIHRoZSBzYW1lIG9yZGVyIHRoZXkgYXJlIHNlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGEgbWVzc2FnZSB0aW1lcyBvdXQgb24gdGhlIG9sZCB0cmFuc3BvcnQsIHNpbmNlIGl0J3Mgc3RpbGwgdGhlIGFjdGl2ZSB0cmFuc3BvcnQgdGhlXG4gICAgICAgICAqIG1lc3NhZ2Ugd2lsbCBiZSByZXF1ZXVlZC4gZGVhY3RpdmF0ZVRyYW5zcG9ydCB3aWxsIHNlZSB0aGUgcGVuZGluZyB0cmFuc3BvcnQgYW5kIG5vdGlmeVxuICAgICAgICAgKiB0aGUgYGNvbm5lY3RpbmdgIHN0YXRlIHdpdGhvdXQgc3RhcnRpbmcgYSBuZXcgY29ubmVjdGlvbiwgc28gdGhlIG5ldyB0cmFuc3BvcnQgY2FuIHRha2VcbiAgICAgICAgICogb3ZlciBvbmNlIGRlYWN0aXZhdGVUcmFuc3BvcnQgY2xlYXJzIHRoZSBvbGQgcHJvdG9jb2wncyBxdWV1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlcmUgaXMgbm8gb2xkIHByb3RvY29sLCB0aGF0IG1lYW50IHRoYXQgd2Ugd2VyZW4ndCBpbiB0aGUgY29ubmVjdGVkIHN0YXRlIGF0IHRoZVxuICAgICAgICAgKiBiZWdpbm5pbmcgb2YgdGhlIHN5bmMgLSBsaWtlbHkgdGhlIGJhc2UgdHJhbnNwb3J0IGRpZWQganVzdCBiZWZvcmUgdGhlIHN5bmMuIFNvIGNhbiBqdXN0XG4gICAgICAgICAqIGZpbmlzaCB0aGUgdXBncmFkZS4gSWYgd2UncmUgYWN0dWFsbHkgaW4gY2xvc2luZy9mYWlsZWQgcmF0aGVyIHRoYW4gY29ubmVjdGluZywgdGhhdCdzXG4gICAgICAgICAqIGZpbmUsIGFjdGl2YXRldHJhbnNwb3J0IHdpbGwgZGVhbCB3aXRoIHRoYXQuICovXG4gICAgICAgIGlmIChvbGRQcm90b2NvbCkge1xuICAgICAgICAgICAgLyogTW9zdCBvZiB0aGUgdGltZSB0aGlzIHdpbGwgYmUgYWxyZWFkeSB0cnVlOiB0aGUgbmV3LXRyYW5zcG9ydCBzeW5jIHdpbGwgaGF2ZSBnaXZlblxuICAgICAgICAgICAgICogZW5vdWdoIHRpbWUgZm9yIGluLWZsaWdodCBtZXNzYWdlcyBvbiB0aGUgb2xkIHRyYW5zcG9ydCB0byBjb21wbGV0ZS4gKi9cbiAgICAgICAgICAgIG9sZFByb3RvY29sLm9uY2VJZGxlKGZpbmlzaFVwZ3JhZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmluaXNoVXBncmFkZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQsIGFuZCB0aGUgY29ubmVjdGlvbm1hbmFnZXIgZGVjaWRlcyB0aGF0XG4gICAgICogaXQgd2lsbCBub3cgYmUgdGhlIGFjdGl2ZSB0cmFuc3BvcnQuIFJldHVybnMgd2hldGhlciBvciBub3QgaXQgYWN0aXZhdGVkXG4gICAgICogdGhlIHRyYW5zcG9ydCAoaWYgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZy9jbG9zZWQgaXQgd2lsbCBjaG9vc2Ugbm90IHRvKS5cbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0IHRoZSB0cmFuc3BvcnQgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbklkIHRoZSBpZCBvZiB0aGUgbmV3IGFjdGl2ZSBjb25uZWN0aW9uXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25EZXRhaWxzIHRoZSBkZXRhaWxzIG9mIHRoZSBuZXcgYWN0aXZlIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYWN0aXZhdGVUcmFuc3BvcnQgPSBmdW5jdGlvbiAoZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAndHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ2Vycm9yID0gJyArIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdGlvbklkKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnY29ubmVjdGlvbklkID0gICcgKyBjb25uZWN0aW9uSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0aW9uRGV0YWlscykge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ2Nvbm5lY3Rpb25EZXRhaWxzID0gICcgKyBKU09OLnN0cmluZ2lmeShjb25uZWN0aW9uRGV0YWlscykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UodHJhbnNwb3J0KTtcbiAgICAgICAgLyogaWYgdGhlIGNvbm5lY3Rpb25tYW5hZ2VyIG1vdmVkIHRvIHRoZSBjbG9zaW5nL2Nsb3NlZCBzdGF0ZSBiZWZvcmUgdGhpc1xuICAgICAgICAgKiBjb25uZWN0aW9uIGV2ZW50LCB0aGVuIHdlIHdvbid0IGFjdGl2YXRlIHRoaXMgdHJhbnNwb3J0ICovXG4gICAgICAgIHZhciBleGlzdGluZ1N0YXRlID0gdGhpcy5zdGF0ZSwgY29ubmVjdGVkU3RhdGUgPSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGU7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdjdXJyZW50IHN0YXRlID0gJyArIGV4aXN0aW5nU3RhdGUuc3RhdGUpO1xuICAgICAgICBpZiAoZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5jbG9zaW5nLnN0YXRlIHx8XG4gICAgICAgICAgICBleGlzdGluZ1N0YXRlLnN0YXRlID09IHRoaXMuc3RhdGVzLmNsb3NlZC5zdGF0ZSB8fFxuICAgICAgICAgICAgZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5mYWlsZWQuc3RhdGUpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdEaXNjb25uZWN0aW5nIHRyYW5zcG9ydCBhbmQgYWJhbmRvbmluZycpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKiByZW1vdmUgdGhpcyB0cmFuc3BvcnQgZnJvbSBwZW5kaW5nIHRyYW5zcG9ydHMgKi9cbiAgICAgICAgVXRpbHMuYXJyRGVsZXRlVmFsdWUodGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcbiAgICAgICAgLyogaWYgdGhlIHRyYW5zcG9ydCBpcyBub3QgY29ubmVjdGVkIHRoZW4gZG9uJ3QgYWN0aXZhdGUgaXQgKi9cbiAgICAgICAgaWYgKCF0cmFuc3BvcnQuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdEZWNsaW5pbmcgdG8gYWN0aXZhdGUgdHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQgKyAnIHNpbmNlIGl0IGFwcGVhcnMgdG8gbm8gbG9uZ2VyIGJlIGNvbm5lY3RlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qIHRoZSBnaXZlbiB0cmFuc3BvcnQgaXMgY29ubmVjdGVkOyB0aGlzIHdpbGwgaW1tZWRpYXRlbHlcbiAgICAgICAgICogdGFrZSBvdmVyIGFzIHRoZSBhY3RpdmUgdHJhbnNwb3J0ICovXG4gICAgICAgIHZhciBleGlzdGluZ0FjdGl2ZVByb3RvY29sID0gdGhpcy5hY3RpdmVQcm90b2NvbDtcbiAgICAgICAgdGhpcy5hY3RpdmVQcm90b2NvbCA9IG5ldyBwcm90b2NvbF8xLmRlZmF1bHQodHJhbnNwb3J0KTtcbiAgICAgICAgdGhpcy5ob3N0ID0gdHJhbnNwb3J0LnBhcmFtcy5ob3N0O1xuICAgICAgICB2YXIgY29ubmVjdGlvbktleSA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25LZXk7XG4gICAgICAgIGlmIChjb25uZWN0aW9uS2V5ICYmIHRoaXMuY29ubmVjdGlvbktleSAhPSBjb25uZWN0aW9uS2V5KSB7XG4gICAgICAgICAgICB0aGlzLnNldENvbm5lY3Rpb24oY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgISFlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgLyogUmVicm9hZGNhc3QgYW55IG5ldyBjb25uZWN0aW9uRGV0YWlscyBmcm9tIHRoZSBhY3RpdmUgdHJhbnNwb3J0LCB3aGljaFxuICAgICAgICAgKiBjYW4gY29tZSBhdCBhbnkgdGltZSAoZWcgZm9sbG93aW5nIGEgcmVhdXRoKSwgYW5kIGVtaXQgYW4gUlROMjQgVVBEQVRFXG4gICAgICAgICAqIGV2ZW50LiAoTGlzdGVuZXIgYWRkZWQgb24gbmV4dFRpY2sgYmVjYXVzZSB3ZSdyZSBpbiBhIHRyYW5zcG9ydC5vbignY29ubmVjdGVkJylcbiAgICAgICAgICogY2FsbGJhY2sgYXQgdGhlIG1vbWVudDsgaWYgd2UgYWRkIGl0IG5vdyB3ZSdsbCBiZSBhZGRpbmcgaXQgdG8gdGhlIGVuZFxuICAgICAgICAgKiBvZiB0aGUgbGlzdGVuZXJzIGFycmF5IGFuZCBpdCdsbCBiZSBjYWxsZWQgaW1tZWRpYXRlbHkpICovXG4gICAgICAgIHRoaXMub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZShjb25uZWN0aW9uRGV0YWlscywgdHJhbnNwb3J0KTtcbiAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQub24oJ2Nvbm5lY3RlZCcsIGZ1bmN0aW9uIChjb25uZWN0ZWRFcnIsIF9jb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZShjb25uZWN0aW9uRGV0YWlscywgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCd1cGRhdGUnLCBuZXcgY29ubmVjdGlvbnN0YXRlY2hhbmdlXzEuZGVmYXVsdChjb25uZWN0ZWRTdGF0ZSwgY29ubmVjdGVkU3RhdGUsIG51bGwsIGNvbm5lY3RlZEVycikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvKiBJZiBwcmV2aW91c2x5IG5vdCBjb25uZWN0ZWQsIG5vdGlmeSB0aGUgc3RhdGUgY2hhbmdlIChpbmNsdWRpbmcgYW55XG4gICAgICAgICAqIGVycm9yKS4gKi9cbiAgICAgICAgaWYgKGV4aXN0aW5nU3RhdGUuc3RhdGUgPT09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZC5zdGF0ZSkge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLyogaWYgdXBncmFkaW5nIHdpdGhvdXQgZXJyb3IsIGxlYXZlIGFueSBleGlzdGluZyBlcnJvclJlYXNvbiBhbG9uZSAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JSZWFzb24gPSB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uZXJyb3JSZWFzb24gPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAvKiBPbmx5IGJvdGhlciBlbWl0dGluZyBhbiB1cGdyYWRlIGlmIHRoZXJlJ3MgYW4gZXJyb3I7IG90aGVyd2lzZSBpdCdzXG4gICAgICAgICAgICAgICAgICoganVzdCBhIHRyYW5zcG9ydCB1cGdyYWRlLCBzbyBhdXRoIGRldGFpbHMgd29uJ3QgaGF2ZSBjaGFuZ2VkICovXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCBuZXcgY29ubmVjdGlvbnN0YXRlY2hhbmdlXzEuZGVmYXVsdChjb25uZWN0ZWRTdGF0ZSwgY29ubmVjdGVkU3RhdGUsIG51bGwsIGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6ICdjb25uZWN0ZWQnLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgICAgICB0aGlzLmVycm9yUmVhc29uID0gdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmVycm9yUmVhc29uID0gZXJyb3IgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKiBTZW5kIGFmdGVyIHRoZSBjb25uZWN0aW9uIHN0YXRlIHVwZGF0ZSwgYXMgQ2hhbm5lbHMgaG9va3MgaW50byB0aGlzIHRvXG4gICAgICAgICAqIHJlc2VuZCBhdHRhY2hlcyBvbiBhIG5ldyB0cmFuc3BvcnQgaWYgbmVjZXNzYXJ5ICovXG4gICAgICAgIHRoaXMuZW1pdCgndHJhbnNwb3J0LmFjdGl2ZScsIHRyYW5zcG9ydCk7XG4gICAgICAgIC8qIEdyYWNlZnVsbHkgdGVybWluYXRlIGV4aXN0aW5nIHByb3RvY29sICovXG4gICAgICAgIGlmIChleGlzdGluZ0FjdGl2ZVByb3RvY29sKSB7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdBY3RpdmVQcm90b2NvbC5tZXNzYWdlUXVldWUuY291bnQoKSA+IDApIHtcbiAgICAgICAgICAgICAgICAvKiBXZSBjb3VsZCBqdXN0IHJlcXVldWUgcGVuZGluZyBtZXNzYWdlcyBvbiB0aGUgbmV3IHRyYW5zcG9ydCwgYnV0XG4gICAgICAgICAgICAgICAgICogYWN0dWFsbHkgdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuOiB0cmFuc3BvcnRzIHNob3VsZCBvbmx5IHRha2Ugb3ZlclxuICAgICAgICAgICAgICAgICAqIGZyb20gb3RoZXIgYWN0aXZlIHRyYW5zcG9ydHMgd2hlbiB1cGdyYWRpbmcsIGFuZCB1cGdyYWRpbmcgd2FpdHMgZm9yXG4gICAgICAgICAgICAgICAgICogdGhlIG9sZCB0cmFuc3BvcnQgdG8gYmUgaWRsZS4gU28gbG9nIGFuIGVycm9yLiAqL1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdQcmV2aW91cyBhY3RpdmUgcHJvdG9jb2wgKGZvciB0cmFuc3BvcnQgJyArXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wudHJhbnNwb3J0LnNob3J0TmFtZSArXG4gICAgICAgICAgICAgICAgICAgICcsIG5ldyBvbmUgaXMgJyArXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zaG9ydE5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAnKSBmaW5pc2hpbmcgd2l0aCAnICtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdBY3RpdmVQcm90b2NvbC5tZXNzYWdlUXVldWUuY291bnQoKSArXG4gICAgICAgICAgICAgICAgICAgICcgbWVzc2FnZXMgc3RpbGwgcGVuZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wudHJhbnNwb3J0ID09PSB0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ0Fzc3VtcHRpb24gdmlvbGF0ZWQ6IGFjdGl2YXRpbmcgYSB0cmFuc3BvcnQgdGhhdCB3YXMgYWxzbyB0aGUgdHJhbnNwb3J0IGZvciB0aGUgcHJldmlvdXMgYWN0aXZlIHByb3RvY29sOyB0cmFuc3BvcnQgPSAnICtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNob3J0TmFtZSArXG4gICAgICAgICAgICAgICAgICAgICc7IHN0YWNrID0gJyArXG4gICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ0FjdGl2ZVByb3RvY29sLmZpbmlzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIFRlcm1pbmF0ZSBhbnkgb3RoZXIgcGVuZGluZyB0cmFuc3BvcnQocyksIGFuZFxuICAgICAgICAgKiBhYm9ydCBhbnkgbm90LXlldC1wZW5kaW5nIHRyYW5zcG9ydCBhdHRlbXB0cyAqL1xuICAgICAgICBVdGlscy5zYWZlQXJyRm9yRWFjaCh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCBmdW5jdGlvbiAocGVuZGluZ1RyYW5zcG9ydCkge1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdUcmFuc3BvcnQgPT09IHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnQXNzdW1wdGlvbiB2aW9sYXRlZDogYWN0aXZhdGluZyBhIHRyYW5zcG9ydCB0aGF0IGlzIHN0aWxsIG1hcmtlZCBhcyBhIHBlbmRpbmcgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNob3J0TmFtZSArXG4gICAgICAgICAgICAgICAgICAgICc7IHN0YWNrID0gJyArXG4gICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsIG1zZyk7XG4gICAgICAgICAgICAgICAgVXRpbHMuYXJyRGVsZXRlVmFsdWUoX3RoaXMucGVuZGluZ1RyYW5zcG9ydHMsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nVHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFV0aWxzLnNhZmVBcnJGb3JFYWNoKHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLCBmdW5jdGlvbiAocHJvcG9zZWRUcmFuc3BvcnQpIHtcbiAgICAgICAgICAgIGlmIChwcm9wb3NlZFRyYW5zcG9ydCA9PT0gdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ0Fzc3VtcHRpb24gdmlvbGF0ZWQ6IGFjdGl2YXRpbmcgYSB0cmFuc3BvcnQgdGhhdCBpcyBzdGlsbCBtYXJrZWQgYXMgYSBwcm9wb3NlZCB0cmFuc3BvcnQ7IHRyYW5zcG9ydCA9ICcgK1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc2hvcnROYW1lICtcbiAgICAgICAgICAgICAgICAgICAgJzsgc3RhY2sgPSAnICtcbiAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKCkuc3RhY2spO1xuICAgICAgICAgICAgICAgIFV0aWxzLmFyckRlbGV0ZVZhbHVlKF90aGlzLnByb3Bvc2VkVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3Bvc2VkVHJhbnNwb3J0LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSB0cmFuc3BvcnQgaXMgbm8gbG9uZ2VyIHRoZSBhY3RpdmUgdHJhbnNwb3J0LiBUaGlzIGNhbiBvY2N1clxuICAgICAqIGluIGFueSB0cmFuc3BvcnQgY29ubmVjdGlvbiBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0XG4gICAgICovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRlYWN0aXZhdGVUcmFuc3BvcnQgPSBmdW5jdGlvbiAodHJhbnNwb3J0LCBzdGF0ZSwgZXJyb3IpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRQcm90b2NvbCA9IHRoaXMuYWN0aXZlUHJvdG9jb2wsIHdhc0FjdGl2ZSA9IGN1cnJlbnRQcm90b2NvbCAmJiBjdXJyZW50UHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkgPT09IHRyYW5zcG9ydCwgd2FzUGVuZGluZyA9IFV0aWxzLmFyckRlbGV0ZVZhbHVlKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIHRyYW5zcG9ydCksIHdhc1Byb3Bvc2VkID0gVXRpbHMuYXJyRGVsZXRlVmFsdWUodGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMsIHRyYW5zcG9ydCksIG5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24gPSB0aGlzLm5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24oKTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KCknLCAndHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ3N0YXRlID0gJyArXG4gICAgICAgICAgICBzdGF0ZSArXG4gICAgICAgICAgICAod2FzQWN0aXZlID8gJzsgd2FzIGFjdGl2ZScgOiB3YXNQZW5kaW5nID8gJzsgd2FzIHBlbmRpbmcnIDogd2FzUHJvcG9zZWQgPyAnOyB3YXMgcHJvcG9zZWQnIDogJycpICtcbiAgICAgICAgICAgIChub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uID8gJycgOiAnOyBhbm90aGVyIHRyYW5zcG9ydCBpcyBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb24nKSk7XG4gICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5tZXNzYWdlKVxuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KCknLCAncmVhc29uID0gICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgaWYgKHdhc0FjdGl2ZSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KCknLCAnR2V0dGluZywgY2xlYXJpbmcsIGFuZCByZXF1ZXVpbmcgJyArXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVQcm90b2NvbC5tZXNzYWdlUXVldWUuY291bnQoKSArXG4gICAgICAgICAgICAgICAgJyBwZW5kaW5nIG1lc3NhZ2VzJyk7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlUGVuZGluZ01lc3NhZ2VzKGN1cnJlbnRQcm90b2NvbC5nZXRQZW5kaW5nTWVzc2FnZXMoKSk7XG4gICAgICAgICAgICAvKiBDbGVhciBhbnkgbWVzc2FnZXMgd2UgcmVxdWV1ZSB0byBhbGxvdyB0aGUgcHJvdG9jb2wgdG8gYmVjb21lIGlkbGUuXG4gICAgICAgICAgICAgKiBJbiBjYXNlIG9mIGFuIHVwZ3JhZGUsIHRoaXMgd2lsbCB0cmlnZ2VyIGFuIGltbWVkaWF0ZSBhY3RpdmF0aW9uIG9mXG4gICAgICAgICAgICAgKiB0aGUgdXBncmFkZSB0cmFuc3BvcnQsIHNvIGRlbGF5IGEgdGljayBzbyB0aGlzIHRyYW5zcG9ydCBjYW4gZmluaXNoXG4gICAgICAgICAgICAgKiBkZWFjdGl2YXRpbmcgKi9cbiAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm90b2NvbC5jbGVhclBlbmRpbmdNZXNzYWdlcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVByb3RvY29sID0gdGhpcy5ob3N0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3RyYW5zcG9ydC5pbmFjdGl2ZScsIHRyYW5zcG9ydCk7XG4gICAgICAgIC8qIHRoaXMgdHJhbnNwb3J0IHN0YXRlIGNoYW5nZSBpcyBhIHN0YXRlIGNoYW5nZSBmb3IgdGhlIGNvbm5lY3Rpb25tYW5hZ2VyIGlmXG4gICAgICAgICAqIC0gdGhlIHRyYW5zcG9ydCB3YXMgdGhlIGFjdGl2ZSB0cmFuc3BvcnQgYW5kIHRoZXJlIGFyZSBubyB0cmFuc3BvcnRzXG4gICAgICAgICAqICAgd2hpY2ggYXJlIGNvbm5lY3RlZCBhbmQgc2NoZWR1bGVkIGZvciBhY3RpdmF0aW9uLCBqdXN0IHdhaXRpbmcgZm9yIHRoZVxuICAgICAgICAgKiAgIGFjdGl2ZSB0cmFuc3BvcnQgdG8gZmluaXNoIHdoYXQgaXRzIGRvaW5nOyBvclxuICAgICAgICAgKiAtIHRoZSB0cmFuc3BvcnQgd2FzIHRoZSBhY3RpdmUgdHJhbnNwb3J0IGFuZCB0aGUgZXJyb3Igd2FzIGZhdGFsIChzb1xuICAgICAgICAgKiAgIHVuaGVhbGFibGUgYnkgYW5vdGhlciB0cmFuc3BvcnQpOyBvclxuICAgICAgICAgKiAtIHRoZXJlIGlzIG5vIGFjdGl2ZSB0cmFuc3BvcnQsIGFuZCB0aGlzIGlzIHRoZSBsYXN0IHJlbWFpbmluZ1xuICAgICAgICAgKiAgIHBlbmRpbmcgdHJhbnNwb3J0IChzbyB3ZSB3ZXJlIGluIHRoZSBjb25uZWN0aW5nIHN0YXRlKVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCh3YXNBY3RpdmUgJiYgbm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbikgfHxcbiAgICAgICAgICAgICh3YXNBY3RpdmUgJiYgc3RhdGUgPT09ICdmYWlsZWQnKSB8fFxuICAgICAgICAgICAgc3RhdGUgPT09ICdjbG9zZWQnIHx8XG4gICAgICAgICAgICAoY3VycmVudFByb3RvY29sID09PSBudWxsICYmIHdhc1BlbmRpbmcgJiYgdGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAvKiBJZiB3ZSdyZSBkaXNjb25uZWN0ZWQgd2l0aCBhIDV4eCB3ZSBuZWVkIHRvIHRyeSBmYWxsYmFjayBob3N0c1xuICAgICAgICAgICAgICogKFJUTjE0ZCksIGJ1dCAoYSkgZHVlIHRvIGhvdyB0aGUgdXBncmFkZSBzZXF1ZW5jZSB3b3JrcywgdGhlXG4gICAgICAgICAgICAgKiBob3N0L3RyYW5zcG9ydCBzZWxlY3Rpb24gc2VxdWVuY2Ugb25seSBjYXJlcyBhYm91dCBnZXR0aW5nIHRvXG4gICAgICAgICAgICAgKiBgcHJlY29ubmVjdGAgKGVnIGVzdGFibGlzaGluZyBhIHdlYnNvY2tldCkgZ2V0dGluZyBhIGBkaXNjb25uZWN0ZWRgXG4gICAgICAgICAgICAgKiBwcm90b2NvbCBtZXNzYWdlIGFmdGVyd2FyZHMgaXMgdG9vIGxhdGU7IGFuZCAoYikgaG9zdCByZXRyeSBvbmx5XG4gICAgICAgICAgICAgKiBhcHBsaWVzIHRvIGNvbm5lY3RCYXNlIHVubGVzcyB0aGUgc3RvcmVkIHByZWZlcmVuY2UgdHJhbnNwb3J0IGRvZXNuJ3RcbiAgICAgICAgICAgICAqIHdvcmsuIFdlIHNvbHZlIHRoaXMgYnkgdW5wZXJzaXN0aW5nIHRoZSB0cmFuc3BvcnQgcHJlZmVyZW5jZSBhbmRcbiAgICAgICAgICAgICAqIHNldHRpbmcgYW4gaW5zdGFuY2UgdmFyaWFibGUgdG8gZm9yY2UgZmFsbGJhY2sgaG9zdHMgdG8gYmUgdXNlZCAoaWZcbiAgICAgICAgICAgICAqIGFueSkgaGVyZS4gQml0IG9mIGEga2x1ZGdlLCBidXQgbm8gcmVhbCBiZXR0ZXIgYWx0ZXJuYXRpdmVzIHdpdGhvdXRcbiAgICAgICAgICAgICAqIHJld3JpdGluZyB0aGUgZW50aXJlIHRoaW5nICovXG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnICYmIGVycm9yICYmIGVycm9yLnN0YXR1c0NvZGUgPiA1MDAgJiYgdGhpcy5odHRwSG9zdHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VGYWxsYmFja0hvc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8qIGFuZCB0cnkgdG8gY29ubmVjdCBhZ2FpbiB0byB0cnkgYSBmYWxsYmFjayBob3N0IHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIHVzdWFsIDE1cyBkaXNjb25uZWN0ZWRSZXRyeVRpbWVvdXQgKi9cbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IHN0YXRlLCBlcnJvcjogZXJyb3IsIHJldHJ5SW1tZWRpYXRlbHk6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogVE9ETyByZW1vdmUgYmVsb3cgbGluZSBvbmNlIHJlYWx0aW1lIHNlbmRzIHRva2VuIGVycm9ycyBhcyBESVNDT05ORUNURURzICovXG4gICAgICAgICAgICB2YXIgbmV3Q29ubmVjdGlvblN0YXRlID0gc3RhdGUgPT09ICdmYWlsZWQnICYmIGF1dGhfMS5kZWZhdWx0LmlzVG9rZW5FcnIoZXJyb3IpID8gJ2Rpc2Nvbm5lY3RlZCcgOiBzdGF0ZTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogbmV3Q29ubmVjdGlvblN0YXRlLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdhc0FjdGl2ZSAmJiBzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgJiYgdGhpcy5zdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuc3luY2hyb25pemluZykge1xuICAgICAgICAgICAgLyogSWYgd2Ugd2VyZSBhY3RpdmUgYnV0IHRoZXJlIGlzIGFub3RoZXIgdHJhbnNwb3J0IHNjaGVkdWxlZCBmb3JcbiAgICAgICAgICAgICAqIGFjdGl2YXRpb24sIGdvIGludG8gdG8gdGhlIGNvbm5lY3Rpbmcgc3RhdGUgdW50aWwgdGhhdCB0cmFuc3BvcnRcbiAgICAgICAgICAgICAqIGFjdGl2YXRlcyBhbmQgc2V0cyB1cyBiYWNrIHRvIGNvbm5lY3RlZC4gKG1hbnVhbGx5IHN0YXJ0aW5nIHRoZVxuICAgICAgICAgICAgICogdHJhbnNpdGlvbiB0aW1lcnMgaW4gY2FzZSB0aGF0IG5ldmVyIGhhcHBlbnMpLiAoSWYgd2Ugd2VyZSBpbiB0aGVcbiAgICAgICAgICAgICAqIHN5bmNocm9uaXppbmcgc3RhdGUsIHRoZW4gdGhhdCdzIGZpbmUsIHRoZSBvbGQgdHJhbnNwb3J0IGp1c3QgZ290IGl0c1xuICAgICAgICAgICAgICogZGlzY29ubmVjdGVkIGJlZm9yZSB0aGUgbmV3IG9uZSBnb3QgdGhlIHN5bmMgLS0gaWdub3JlIGl0IGFuZCBrZWVwXG4gICAgICAgICAgICAgKiB3YWl0aW5nIGZvciB0aGUgc3luYy4gSWYgaXQgZmFpbHMgd2UgaGF2ZSBhIHNlcGFyYXRlIHN5bmMgdGltZXIgdGhhdFxuICAgICAgICAgICAgICogd2lsbCBleHBpcmUpLiAqL1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KCknLCAnd2FzQWN0aXZlIGJ1dCBhbm90aGVyIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQgYW5kIHNjaGVkdWxlZCBmb3IgYWN0aXZhdGlvbiwgc28gZ29pbmcgaW50byB0aGUgY29ubmVjdGluZyBzdGF0ZSB1bnRpbCBpdCBhY3RpdmF0ZXMnKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTdXNwZW5kVGltZXIoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUcmFuc2l0aW9uVGltZXIodGhpcy5zdGF0ZXMuY29ubmVjdGluZyk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6ICdjb25uZWN0aW5nJywgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiBIZWxwZXIgdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlcmUgYXJlIG5vIHRyYW5zcG9ydHMgd2hpY2ggYXJlIHBlbmRpbmcsXG4gICAgICogaGF2ZSBiZWVuIGNvbm5lY3RlZCwgYW5kIGFyZSBqdXN0IHdhaXRpbmcgZm9yIG9uY2VOb1BlbmRpbmcgdG8gZmlyZSBiZWZvcmVcbiAgICAgKiBiZWluZyBhY3RpdmF0ZWQgKi9cbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUubm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChVdGlscy5pc0VtcHR5KHRoaXMucGVuZGluZ1RyYW5zcG9ydHMpIHx8XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLmV2ZXJ5KGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXRyYW5zcG9ydC5pc0Nvbm5lY3RlZDtcbiAgICAgICAgICAgIH0pKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRDb25uZWN0aW9uID0gZnVuY3Rpb24gKGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMsIGhhc0Nvbm5lY3Rpb25FcnJvcikge1xuICAgICAgICAvKiBpZiBjb25uZWN0aW9uS2V5IGNoYW5nZXMgYnV0IGNvbm5lY3Rpb25JZCBzdGF5cyB0aGUgc2FtZSwgdGhlbiBqdXN0IGFcbiAgICAgICAgICogdHJhbnNwb3J0IGNoYW5nZSBvbiB0aGUgc2FtZSBjb25uZWN0aW9uLiBJZiBjb25uZWN0aW9uSWQgY2hhbmdlcywgd2UncmVcbiAgICAgICAgICogb24gYSBuZXcgY29ubmVjdGlvbiwgd2l0aCBpbXBsaWNhdGlvbnMgZm9yIG1zZ1NlcmlhbCBhbmQgY2hhbm5lbCBzdGF0ZSAqL1xuICAgICAgICAvKiBJZiBubyBwcmV2aW91cyBjb25uZWN0aW9uSWQsIGRvbid0IHJlc2V0IHRoZSBtc2dTZXJpYWwgYXMgaXQgbWF5IGhhdmVcbiAgICAgICAgICogYmVlbiBzZXQgYnkgcmVjb3ZlciBkYXRhICh1bmxlc3MgdGhlIHJlY292ZXIgZmFpbGVkKSAqL1xuICAgICAgICB2YXIgcHJldkNvbm5JZCA9IHRoaXMuY29ubmVjdGlvbklkLCBjb25uSWRDaGFuZ2VkID0gcHJldkNvbm5JZCAmJiBwcmV2Q29ubklkICE9PSBjb25uZWN0aW9uSWQsIHJlY292ZXJGYWlsdXJlID0gIXByZXZDb25uSWQgJiYgaGFzQ29ubmVjdGlvbkVycm9yO1xuICAgICAgICBpZiAoY29ubklkQ2hhbmdlZCB8fCByZWNvdmVyRmFpbHVyZSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zZXRDb25uZWN0aW9uKCknLCAnUmVzZXR0aW5nIG1zZ1NlcmlhbCcpO1xuICAgICAgICAgICAgdGhpcy5tc2dTZXJpYWwgPSAwO1xuICAgICAgICAgICAgLy8gUlROMTlhMjogSW4gdGhlIGV2ZW50IG9mIGEgbmV3IGNvbm5lY3Rpb25JZCwgcHJldmlvdXMgbXNnU2VyaWFscyBhcmVcbiAgICAgICAgICAgIC8vIG1lYW5pbmdsZXNzLlxuICAgICAgICAgICAgdGhpcy5xdWV1ZWRNZXNzYWdlcy5yZXNldFNlbmRBdHRlbXB0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uSWQgIT09IGNvbm5lY3Rpb25JZCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zZXRDb25uZWN0aW9uKCknLCAnTmV3IGNvbm5lY3Rpb25JZDsgcmVhdHRhY2hpbmcgYW55IGF0dGFjaGVkIGNoYW5uZWxzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmlkID0gdGhpcy5jb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uSWQ7XG4gICAgICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5rZXkgPSB0aGlzLmNvbm5lY3Rpb25LZXkgPSBjb25uZWN0aW9uRGV0YWlscy5jb25uZWN0aW9uS2V5O1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNsZWFyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmlkID0gdGhpcy5jb25uZWN0aW9uSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5rZXkgPSB0aGlzLmNvbm5lY3Rpb25LZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubXNnU2VyaWFsID0gMDtcbiAgICAgICAgdGhpcy51bnBlcnNpc3RDb25uZWN0aW9uKCk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlUmVjb3ZlcnlLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFJUTjE2ZzIuXG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0aW9uS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgY29ubmVjdGlvbktleTogdGhpcy5jb25uZWN0aW9uS2V5LFxuICAgICAgICAgICAgbXNnU2VyaWFsOiB0aGlzLm1zZ1NlcmlhbCxcbiAgICAgICAgICAgIGNoYW5uZWxTZXJpYWxzOiB0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLmNoYW5uZWxTZXJpYWxzKCksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMubGFzdEFjdGl2aXR5IHx8ICF0aGlzLmNvbm5lY3Rpb25JZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaW5jZUxhc3QgPSBVdGlscy5ub3coKSAtIHRoaXMubGFzdEFjdGl2aXR5O1xuICAgICAgICBpZiAoc2luY2VMYXN0ID4gdGhpcy5jb25uZWN0aW9uU3RhdGVUdGwgKyB0aGlzLm1heElkbGVJbnRlcnZhbCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jaGVja0Nvbm5lY3Rpb25TdGF0ZUZyZXNobmVzcygpJywgJ0xhc3Qga25vd24gYWN0aXZpdHkgZnJvbSByZWFsdGltZSB3YXMgJyArIHNpbmNlTGFzdCArICdtcyBhZ287IGRpc2NhcmRpbmcgY29ubmVjdGlvbiBzdGF0ZScpO1xuICAgICAgICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlID0gJ3N1c3BlbmRlZCc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9ubWFuYWdlciB3YW50cyB0byBwZXJzaXN0IHRyYW5zcG9ydFxuICAgICAqIHN0YXRlIGZvciBsYXRlciByZWNvdmVyeS4gT25seSBhcHBsaWNhYmxlIGluIHRoZSBicm93c2VyIGNvbnRleHQuXG4gICAgICovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnBlcnNpc3RDb25uZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaGF2ZVNlc3Npb25TdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIHZhciByZWNvdmVyeUtleSA9IHRoaXMuY3JlYXRlUmVjb3ZlcnlLZXkoKTtcbiAgICAgICAgICAgIGlmIChyZWNvdmVyeUtleSkge1xuICAgICAgICAgICAgICAgIHNldFNlc3Npb25SZWNvdmVyRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIHJlY292ZXJ5S2V5OiByZWNvdmVyeUtleSxcbiAgICAgICAgICAgICAgICAgICAgZGlzY29ubmVjdGVkQXQ6IFV0aWxzLm5vdygpLFxuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogZ2xvYmFsLmxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRJZDogdGhpcy5yZWFsdGltZS5hdXRoLmNsaWVudElkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbm1hbmFnZXIgd2FudHMgdG8gcGVyc2lzdCB0cmFuc3BvcnRcbiAgICAgKiBzdGF0ZSBmb3IgbGF0ZXIgcmVjb3ZlcnkuIE9ubHkgYXBwbGljYWJsZSBpbiB0aGUgYnJvd3NlciBjb250ZXh0LlxuICAgICAqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS51bnBlcnNpc3RDb25uZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclNlc3Npb25SZWNvdmVyRGF0YSgpO1xuICAgIH07XG4gICAgLyoqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIHN0YXRlIG1hbmFnZW1lbnRcbiAgICAgKioqKioqKioqKioqKioqKioqKioqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JSZWFzb24gfHwgdGhpcy5nZXRTdGF0ZUVycm9yKCk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0U3RhdGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IGNvbm5lY3Rpb25lcnJvcnNfMS5kZWZhdWx0KVt0aGlzLnN0YXRlLnN0YXRlXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmFjdGl2ZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5xdWV1ZUV2ZW50cyB8fCB0aGlzLnN0YXRlLnNlbmRFdmVudHM7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZW5hY3RTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uIChzdGF0ZUNoYW5nZSkge1xuICAgICAgICB2YXIgbG9nTGV2ZWwgPSBzdGF0ZUNoYW5nZS5jdXJyZW50ID09PSAnZmFpbGVkJyA/IGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SIDogbG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUFKT1I7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ0xldmVsLCAnQ29ubmVjdGlvbiBzdGF0ZScsIHN0YXRlQ2hhbmdlLmN1cnJlbnQgKyAoc3RhdGVDaGFuZ2UucmVhc29uID8gJzsgcmVhc29uOiAnICsgc3RhdGVDaGFuZ2UucmVhc29uIDogJycpKTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5lbmFjdFN0YXRlQ2hhbmdlJywgJ3NldHRpbmcgbmV3IHN0YXRlOiAnICtcbiAgICAgICAgICAgIHN0YXRlQ2hhbmdlLmN1cnJlbnQgK1xuICAgICAgICAgICAgJzsgcmVhc29uID0gJyArXG4gICAgICAgICAgICAoc3RhdGVDaGFuZ2UucmVhc29uICYmIHN0YXRlQ2hhbmdlLnJlYXNvbi5tZXNzYWdlKSk7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9ICh0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXNbc3RhdGVDaGFuZ2UuY3VycmVudF0pO1xuICAgICAgICBpZiAoc3RhdGVDaGFuZ2UucmVhc29uKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yUmVhc29uID0gc3RhdGVDaGFuZ2UucmVhc29uO1xuICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmVycm9yUmVhc29uID0gc3RhdGVDaGFuZ2UucmVhc29uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdTdGF0ZS50ZXJtaW5hbCB8fCBuZXdTdGF0ZS5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcbiAgICAgICAgICAgIC8qIHN1c3BlbmRlZCBpcyBub250ZXJtaW5hbCwgYnV0IG9uY2UgaW4gdGhlIHN1c3BlbmRlZCBzdGF0ZSwgcmVhbHRpbWVcbiAgICAgICAgICAgICAqIHdpbGwgaGF2ZSBkaXNjYXJkZWQgb3VyIGNvbm5lY3Rpb24gc3RhdGUsIHNvIGZ1dGhlciBjb25uZWN0aW9uXG4gICAgICAgICAgICAgKiBhdHRlbXB0cyBzaG91bGQgc3RhcnQgZnJvbSBzY3JhdGNoICovXG4gICAgICAgICAgICB0aGlzLmNsZWFyQ29ubmVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvbnN0YXRlJywgc3RhdGVDaGFuZ2UpO1xuICAgIH07XG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBDb25uZWN0aW9uTWFuYWdlciBjb25uZWN0aW9uIGxpZmVjeWNsZVxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zdGFydFRyYW5zaXRpb25UaW1lciA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU3RhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zdGFydFRyYW5zaXRpb25UaW1lcigpJywgJ3RyYW5zaXRpb25TdGF0ZTogJyArIHRyYW5zaXRpb25TdGF0ZS5zdGF0ZSk7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25UaW1lcikge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zdGFydFRyYW5zaXRpb25UaW1lcigpJywgJ2NsZWFyaW5nIGFscmVhZHktcnVubmluZyB0aW1lcicpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudHJhbnNpdGlvblRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zaXRpb25UaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnRyYW5zaXRpb25UaW1lcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnRyYW5zaXRpb25UaW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlciAnICsgdHJhbnNpdGlvblN0YXRlLnN0YXRlICsgJyB0aW1lciBleHBpcmVkJywgJ3JlcXVlc3RpbmcgbmV3IHN0YXRlOiAnICsgdHJhbnNpdGlvblN0YXRlLmZhaWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogdHJhbnNpdGlvblN0YXRlLmZhaWxTdGF0ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJhbnNpdGlvblN0YXRlLnJldHJ5RGVsYXkpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNhbmNlbFRyYW5zaXRpb25UaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jYW5jZWxUcmFuc2l0aW9uVGltZXIoKScsICcnKTtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvblRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50cmFuc2l0aW9uVGltZXIpO1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc3RhcnRTdXNwZW5kVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnN1c3BlbmRUaW1lcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zdXNwZW5kVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdXNwZW5kVGltZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdXNwZW5kVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIgc3VzcGVuZCB0aW1lciBleHBpcmVkJywgJ3JlcXVlc3RpbmcgbmV3IHN0YXRlOiBzdXNwZW5kZWQnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUgPSAnc3VzcGVuZGVkJztcbiAgICAgICAgICAgICAgICBfdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiAnc3VzcGVuZGVkJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5jb25uZWN0aW9uU3RhdGVUdGwpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNoZWNrU3VzcGVuZFRpbWVyID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZSAhPT0gJ2Rpc2Nvbm5lY3RlZCcgJiYgc3RhdGUgIT09ICdzdXNwZW5kZWQnICYmIHN0YXRlICE9PSAnY29ubmVjdGluZycpXG4gICAgICAgICAgICB0aGlzLmNhbmNlbFN1c3BlbmRUaW1lcigpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNhbmNlbFN1c3BlbmRUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUgPSAnZGlzY29ubmVjdGVkJztcbiAgICAgICAgaWYgKHRoaXMuc3VzcGVuZFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zdXNwZW5kVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5zdXNwZW5kVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc3RhcnRSZXRyeVRpbWVyID0gZnVuY3Rpb24gKGludGVydmFsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmV0cnlUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlciByZXRyeSB0aW1lciBleHBpcmVkJywgJ3JldHJ5aW5nJyk7XG4gICAgICAgICAgICBfdGhpcy5yZXRyeVRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiAnY29ubmVjdGluZycgfSk7XG4gICAgICAgIH0sIGludGVydmFsKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jYW5jZWxSZXRyeVRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yZXRyeVRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMucmV0cnlUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5ub3RpZnlTdGF0ZSA9IGZ1bmN0aW9uIChpbmRpY2F0ZWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIHN0YXRlID0gaW5kaWNhdGVkLnN0YXRlO1xuICAgICAgICAvKiBXZSByZXRyeSBpbW1lZGlhdGVseSBpZjpcbiAgICAgICAgICogLSBzb21ldGhpbmcgZGlzY29ubmVjdHMgdXMgd2hpbGUgd2UncmUgY29ubmVjdGVkLCBvclxuICAgICAgICAgKiAtIGEgdmlhYmxlIChidXQgbm90IHlldCBhY3RpdmUpIHRyYW5zcG9ydCBmYWlscyBkdWUgdG8gYSB0b2tlbiBlcnJvciAoc29cbiAgICAgICAgICogICB0aGlzLmVycm9yUmVhc29uIHdpbGwgYmUgc2V0LCBhbmQgc3RhcnRDb25uZWN0IHdpbGwgZG8gYSBmb3JjZWRcbiAgICAgICAgICogICBhdXRob3JpemUpLiBJZiB0aGlzLmVycm9yUmVhc29uIGlzIGFscmVhZHkgc2V0ICh0byBhIHRva2VuIGVycm9yKSxcbiAgICAgICAgICogICB0aGVuIHRoZXJlIGhhcyBiZWVuIGF0IGxlYXN0IG9uZSBwcmV2aW91cyBhdHRlbXB0IHRvIGNvbm5lY3QgdGhhdCBhbHNvXG4gICAgICAgICAqICAgZmFpbGVkIGZvciBhIHRva2VuIGVycm9yLCBzbyBieSBSVE4xNGIgd2UgZ28gdG8gRElTQ09OTkVDVEVEIGFuZCB3YWl0XG4gICAgICAgICAqICAgYmVmb3JlIHRyeWluZyBhZ2FpbiAqL1xuICAgICAgICB2YXIgcmV0cnlJbW1lZGlhdGVseSA9IHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyAmJlxuICAgICAgICAgICAgKHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLnN5bmNocm9uaXppbmcgfHxcbiAgICAgICAgICAgICAgICBpbmRpY2F0ZWQucmV0cnlJbW1lZGlhdGVseSB8fFxuICAgICAgICAgICAgICAgICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nICYmXG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRlZC5lcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBhdXRoXzEuZGVmYXVsdC5pc1Rva2VuRXJyKGluZGljYXRlZC5lcnJvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgISh0aGlzLmVycm9yUmVhc29uICYmIGF1dGhfMS5kZWZhdWx0LmlzVG9rZW5FcnIodGhpcy5lcnJvclJlYXNvbikpKSk7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKScsICduZXcgc3RhdGU6ICcgKyBzdGF0ZSArIChyZXRyeUltbWVkaWF0ZWx5ID8gJzsgd2lsbCByZXRyeSBjb25uZWN0aW9uIGltbWVkaWF0ZWx5JyA6ICcnKSk7XG4gICAgICAgIC8qIGRvIG5vdGhpbmcgaWYgd2UncmUgYWxyZWFkeSBpbiB0aGUgaW5kaWNhdGVkIHN0YXRlICovXG4gICAgICAgIGlmIChzdGF0ZSA9PSB0aGlzLnN0YXRlLnN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKiBraWxsIHRpbWVycyAocG9zc2libHkgZXhjZXB0aW5nIHN1c3BlbmQgdGltZXIgZGVwZW5kaW5nIG9uIHRoZSBub3RpZmllZFxuICAgICAgICAgKiBzdGF0ZSksIGFzIHRoZXNlIGFyZSBzdXBlcnNlZGVkIGJ5IHRoaXMgbm90aWZpY2F0aW9uICovXG4gICAgICAgIHRoaXMuY2FuY2VsVHJhbnNpdGlvblRpbWVyKCk7XG4gICAgICAgIHRoaXMuY2FuY2VsUmV0cnlUaW1lcigpO1xuICAgICAgICB0aGlzLmNoZWNrU3VzcGVuZFRpbWVyKGluZGljYXRlZC5zdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ3N1c3BlbmRlZCcgfHwgc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RlZFJldHJ5Q291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qIGRvIG5vdGhpbmcgaWYgd2UncmUgdW5hYmxlIHRvIG1vdmUgZnJvbSB0aGUgY3VycmVudCBzdGF0ZSAqL1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS50ZXJtaW5hbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLyogcHJvY2VzcyBuZXcgc3RhdGUgKi9cbiAgICAgICAgdmFyIG5ld1N0YXRlID0gdGhpcy5zdGF0ZXNbaW5kaWNhdGVkLnN0YXRlXTtcbiAgICAgICAgdmFyIHJldHJ5RGVsYXkgPSBuZXdTdGF0ZS5yZXRyeURlbGF5O1xuICAgICAgICBpZiAobmV3U3RhdGUuc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RlZFJldHJ5Q291bnQrKztcbiAgICAgICAgICAgIHJldHJ5RGVsYXkgPSBVdGlscy5nZXRSZXRyeVRpbWUobmV3U3RhdGUucmV0cnlEZWxheSwgdGhpcy5kaXNjb25uZWN0ZWRSZXRyeUNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhbmdlID0gbmV3IGNvbm5lY3Rpb25zdGF0ZWNoYW5nZV8xLmRlZmF1bHQodGhpcy5zdGF0ZS5zdGF0ZSwgbmV3U3RhdGUuc3RhdGUsIHJldHJ5RGVsYXksIGluZGljYXRlZC5lcnJvciB8fCAoKF9iID0gKF9hID0gY29ubmVjdGlvbmVycm9yc18xLmRlZmF1bHQpW25ld1N0YXRlLnN0YXRlXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKSk7XG4gICAgICAgIGlmIChyZXRyeUltbWVkaWF0ZWx5KSB7XG4gICAgICAgICAgICB2YXIgYXV0b1JlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUgPT09IF90aGlzLnN0YXRlcy5kaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ID0gVXRpbHMubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiAnY29ubmVjdGluZycgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBzaW5jZUxhc3QgPSB0aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCAmJiBVdGlscy5ub3coKSAtIHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ICsgMTtcbiAgICAgICAgICAgIGlmIChzaW5jZUxhc3QgJiYgc2luY2VMYXN0IDwgMTAwMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKScsICdMYXN0IHJlY29ubmVjdCBhdHRlbXB0IHdhcyBvbmx5ICcgK1xuICAgICAgICAgICAgICAgICAgICBzaW5jZUxhc3QgK1xuICAgICAgICAgICAgICAgICAgICAnbXMgYWdvLCB3YWl0aW5nIGFub3RoZXIgJyArXG4gICAgICAgICAgICAgICAgICAgICgxMDAwIC0gc2luY2VMYXN0KSArXG4gICAgICAgICAgICAgICAgICAgICdtcyBiZWZvcmUgdHJ5aW5nIGFnYWluJyk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChhdXRvUmVjb25uZWN0LCAxMDAwIC0gc2luY2VMYXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soYXV0b1JlY29ubmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnIHx8IHN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuICAgICAgICAgICAgdGhpcy5zdGFydFJldHJ5VGltZXIocmV0cnlEZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogSWYgZ29pbmcgaW50byBkaXNjb25uZWN0L3N1c3BlbmRlZCAoYW5kIG5vdCByZXRyeWluZyBpbW1lZGlhdGVseSksIG9yIGFcbiAgICAgICAgICogdGVybWluYWwgc3RhdGUsIGVuc3VyZSB0aGVyZSBhcmUgbm8gb3JwaGFuZWQgdHJhbnNwb3J0cyBoYW5naW5nIGFyb3VuZC4gKi9cbiAgICAgICAgaWYgKChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgJiYgIXJldHJ5SW1tZWRpYXRlbHkpIHx8IHN0YXRlID09PSAnc3VzcGVuZGVkJyB8fCBuZXdTdGF0ZS50ZXJtaW5hbCkge1xuICAgICAgICAgICAgLyogV2FpdCB0aWxsIHRoZSBuZXh0IHRpY2sgc28gdGhlIGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlIGlzIGVuYWN0ZWQsXG4gICAgICAgICAgICAgKiBzbyBhYm9ydGluZyB0cmFuc3BvcnRzIGRvZXNuJ3QgdHJpZ2dlciByZWR1bmRhbnQgc3RhdGUgY2hhbmdlcyAqL1xuICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PSAnY29ubmVjdGVkJyAmJiAhdGhpcy5hY3RpdmVQcm90b2NvbCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5ub3RpZnlTdGF0ZSgpJywgJ0Jyb2tlbiBpbnZhcmlhbnQ6IGF0dGVtcHRlZCB0byBnbyBpbnRvIGNvbm5lY3RlZCBzdGF0ZSwgYnV0IHRoZXJlIGlzIG5vIGFjdGl2ZSBwcm90b2NvbCcpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGltcGxlbWVudCB0aGUgY2hhbmdlIGFuZCBub3RpZnkgKi9cbiAgICAgICAgdGhpcy5lbmFjdFN0YXRlQ2hhbmdlKGNoYW5nZSk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZFF1ZXVlZE1lc3NhZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuc3RhdGUucXVldWVFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuY2hhbm5lbHMucHJvcG9nYXRlQ29ubmVjdGlvbkludGVycnVwdGlvbihzdGF0ZSwgY2hhbmdlLnJlYXNvbik7XG4gICAgICAgICAgICB0aGlzLmZhaWxRdWV1ZWRNZXNzYWdlcyhjaGFuZ2UucmVhc29uKTsgLy8gUlRON2NcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlcXVlc3RTdGF0ZSA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBzdGF0ZSA9IHJlcXVlc3Quc3RhdGU7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIucmVxdWVzdFN0YXRlKCknLCAncmVxdWVzdGVkIHN0YXRlOiAnICsgc3RhdGUgKyAnOyBjdXJyZW50IHN0YXRlOiAnICsgdGhpcy5zdGF0ZS5zdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZSA9PSB0aGlzLnN0YXRlLnN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuOyAvKiBzaWxlbnRseSBkbyBub3RoaW5nICovXG4gICAgICAgIC8qIGtpbGwgcnVubmluZyB0aW1lcnMsIGFzIHRoaXMgcmVxdWVzdCBzdXBlcnNlZGVzIHRoZW0gKi9cbiAgICAgICAgdGhpcy5jYW5jZWxUcmFuc2l0aW9uVGltZXIoKTtcbiAgICAgICAgdGhpcy5jYW5jZWxSZXRyeVRpbWVyKCk7XG4gICAgICAgIC8qIGZvciBzdXNwZW5kIHRpbWVyIGNoZWNrIHJhdGhlciB0aGFuIGNhbmNlbCAtLSBlZyByZXF1ZXN0aW5nIGEgY29ubmVjdGluZ1xuICAgICAgICAgKiBzdGF0ZSBzaG91bGQgbm90IHJlc2V0IHRoZSBzdXNwZW5kIHRpbWVyICovXG4gICAgICAgIHRoaXMuY2hlY2tTdXNwZW5kVGltZXIoc3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUgPT0gJ2Nvbm5lY3RpbmcnICYmIHRoaXMuc3RhdGUuc3RhdGUgPT0gJ2Nvbm5lY3RlZCcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChzdGF0ZSA9PSAnY2xvc2luZycgJiYgdGhpcy5zdGF0ZS5zdGF0ZSA9PSAnY2xvc2VkJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gdGhpcy5zdGF0ZXNbc3RhdGVdLCBjaGFuZ2UgPSBuZXcgY29ubmVjdGlvbnN0YXRlY2hhbmdlXzEuZGVmYXVsdCh0aGlzLnN0YXRlLnN0YXRlLCBuZXdTdGF0ZS5zdGF0ZSwgbnVsbCwgcmVxdWVzdC5lcnJvciB8fCAoKF9iID0gKF9hID0gY29ubmVjdGlvbmVycm9yc18xLmRlZmF1bHQpW25ld1N0YXRlLnN0YXRlXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKSk7XG4gICAgICAgIHRoaXMuZW5hY3RTdGF0ZUNoYW5nZShjaGFuZ2UpO1xuICAgICAgICBpZiAoc3RhdGUgPT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGFydENvbm5lY3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PSAnY2xvc2luZycpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VJbXBsKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zdGFydENvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0Q29ubmVjdCgpJywgJ011c3QgYmUgaW4gY29ubmVjdGluZyBzdGF0ZSB0byBjb25uZWN0LCBidXQgd2FzICcgKyB0aGlzLnN0YXRlLnN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXV0aCA9IHRoaXMucmVhbHRpbWUuYXV0aDtcbiAgICAgICAgLyogVGhlIHBvaW50IG9mIHRoZSBjb25uZWN0Q291bnRlciBtZWNoYW5pc20gaXMgdG8gZW5zdXJlIHRoYXQgdGhlXG4gICAgICAgICAqIGNvbm5lY3Rpb24gcHJvY2VkdXJlIGNhbiBiZSBjYW5jZWxsZWQuIFdlIHdhbnQgZGlzY29ubmVjdEFsbFRyYW5zcG9ydHNcbiAgICAgICAgICogdG8gYmUgYWJsZSB0byBzdG9wIGFueSBpbi1wcm9ncmVzcyBjb25uZWN0aW9uLCBldmVuIGJlZm9yZSBpdCBnZXRzIHRvXG4gICAgICAgICAqIHRoZSBzdGFnZSBvZiBoYXZpbmcgYSBwZW5kaW5nIChvciBldmVuIGEgcHJvcG9zZWQpIHRyYW5zcG9ydCB0aGF0IGl0IGNhblxuICAgICAgICAgKiBkaXNwb3NlKCkgb2YuIFNvIHdlIGNoZWNrIHRoYXQgaXQncyBzdGlsbCBjdXJyZW50IGFmdGVyIGFueSBhc3luYyBzdGFnZSxcbiAgICAgICAgICogdXAgdW50aWwgdGhlIHN0YWdlIHRoYXQgaXMgc3luY2hyb25vdXMgd2l0aCBpbnN0YW50aWF0aW5nIGEgdHJhbnNwb3J0ICovXG4gICAgICAgIHZhciBjb25uZWN0Q291bnQgPSArK3RoaXMuY29ubmVjdENvdW50ZXI7XG4gICAgICAgIHZhciBjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2hlY2tDb25uZWN0aW9uU3RhdGVGcmVzaG5lc3MoKTtcbiAgICAgICAgICAgIF90aGlzLmdldFRyYW5zcG9ydFBhcmFtcyhmdW5jdGlvbiAodHJhbnNwb3J0UGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zcG9ydFBhcmFtcy5tb2RlID09PSAncmVjb3ZlcicgJiYgdHJhbnNwb3J0UGFyYW1zLm9wdGlvbnMucmVjb3Zlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjb3ZlcnlDb250ZXh0ID0gZGVjb2RlUmVjb3ZlcnlLZXkodHJhbnNwb3J0UGFyYW1zLm9wdGlvbnMucmVjb3Zlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvdmVyeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlYWx0aW1lLmNoYW5uZWxzLnJlY292ZXJDaGFubmVscyhyZWNvdmVyeUNvbnRleHQuY2hhbm5lbFNlcmlhbHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0Q291bnQgIT09IF90aGlzLmNvbm5lY3RDb3VudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuY29ubmVjdEltcGwodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRDb25uZWN0KCknLCAnc3RhcnRpbmcgY29ubmVjdGlvbicpO1xuICAgICAgICB0aGlzLnN0YXJ0U3VzcGVuZFRpbWVyKCk7XG4gICAgICAgIHRoaXMuc3RhcnRUcmFuc2l0aW9uVGltZXIodGhpcy5zdGF0ZXMuY29ubmVjdGluZyk7XG4gICAgICAgIGlmIChhdXRoLm1ldGhvZCA9PT0gJ2Jhc2ljJykge1xuICAgICAgICAgICAgY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGF1dGhDYiA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdENvdW50ICE9PSBfdGhpcy5jb25uZWN0Q291bnRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3JSZWFzb24gJiYgYXV0aF8xLmRlZmF1bHQuaXNUb2tlbkVycih0aGlzLmVycm9yUmVhc29uKSkge1xuICAgICAgICAgICAgICAgIC8qIEZvcmNlIGEgcmVmZXRjaCBvZiBhIG5ldyB0b2tlbiAqL1xuICAgICAgICAgICAgICAgIGF1dGguX2ZvcmNlTmV3VG9rZW4obnVsbCwgbnVsbCwgYXV0aENiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF1dGguX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKGZhbHNlLCBhdXRoQ2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGVyZSBhcmUgdGhyZWUgc3RhZ2VzIGluIGNvbm5lY3Rpbmc6XG4gICAgICogLSBwcmVmZXJlbmNlOiBpZiB0aGVyZSBpcyBhIGNhY2hlZCB0cmFuc3BvcnQgcHJlZmVyZW5jZSwgd2UgdHJ5IHRvIGNvbm5lY3RcbiAgICAgKiAgIG9uIHRoYXQuIElmIHRoYXQgZmFpbHMgb3IgdGltZXMgb3V0IHdlIGFib3J0IHRoZSBhdHRlbXB0LCByZW1vdmUgdGhlXG4gICAgICogICBwcmVmZXJlbmNlIGFuZCBmYWxsIGJhY2sgdG8gYmFzZS4gSWYgaXQgc3VjY2VlZHMsIHdlIHRyeSB1cGdyYWRpbmcgaXQgaWZcbiAgICAgKiAgIG5lZWRlZCAod2lsbCBvbmx5IGJlIGluIHRoZSBjYXNlIHdoZXJlIHRoZSBwcmVmZXJlbmNlIGlzIHhocnMgYW5kIHRoZVxuICAgICAqICAgYnJvd3NlciBzdXBwb3J0cyB3cykuXG4gICAgICogLSBiYXNlOiB3ZSB0cnkgdG8gY29ubmVjdCB3aXRoIHRoZSBiZXN0IHRyYW5zcG9ydCB0aGF0IHdlIHRoaW5rIHdpbGxcbiAgICAgKiAgIG5ldmVyIGZhaWwgZm9yIHRoaXMgYnJvd3NlciAodXN1YWxseSB0aGlzIGlzIHhocl9wb2xsaW5nOyBmb3IgdmVyeSBvbGRcbiAgICAgKiAgIGJyb3dzZXJzIHdpbGwgYmUganNvbnAsIGZvciBub2RlIHdpbGwgYmUgY29tZXQpLiBJZiBpdCBkb2Vzbid0IHdvcmssIHdlXG4gICAgICogICB0cnkgZmFsbGJhY2sgaG9zdHMuXG4gICAgICogLSB1cGdyYWRlOiBnaXZlbiBhIGNvbm5lY3RlZCB0cmFuc3BvcnQsIHdlIHNlZSBpZiB0aGVyZSBhcmUgYW55IGJldHRlclxuICAgICAqICAgb25lcywgYW5kIGlmIHNvLCB0cnkgdG8gdXBncmFkZSB0byB0aGVtLlxuICAgICAqXG4gICAgICogY29ubmVjdEltcGwgd29ya3Mgb3V0IHdoYXQgc3RhZ2UgeW91J3JlIGF0ICh3aGljaCBpcyBwdXJlbHkgYSBmdW5jdGlvbiBvZlxuICAgICAqIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gc3RhdGUgYW5kIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBzdG9yZWQgcHJlZmVyZW5jZXMpLFxuICAgICAqIGFuZCBkaXNwYXRjaGVzIGFjY29yZGluZ2x5LiBBZnRlciBhIHRyYW5zcG9ydCBoYXMgYmVlbiBzZXQgcGVuZGluZyxcbiAgICAgKiB0cnlBVHJhbnNwb3J0IGNhbGxzIGNvbm5lY3RJbXBsIHRvIHNlZSBpZiB0aGVyZSdzIGFub3RoZXIgc3RhZ2UgdG8gYmUgZG9uZS5cbiAgICAgKiAqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0SW1wbCA9IGZ1bmN0aW9uICh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlLnN0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3Rpbmcuc3RhdGUgJiYgc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZC5zdGF0ZSkge1xuICAgICAgICAgICAgLyogT25seSBrZWVwIHRyeWluZyBhcyBsb25nIGFzIGluIHRoZSAnY29ubmVjdGluZycgc3RhdGUgKG9yICdjb25uZWN0ZWQnXG4gICAgICAgICAgICAgKiBmb3IgdXBncmFkaW5nKS4gQW55IG9wZXJhdGlvbiBjYW4gcHV0IHVzIGludG8gJ2Rpc2Nvbm5lY3RlZCcgdG8gY2FuY2VsXG4gICAgICAgICAgICAgKiBjb25uZWN0aW9uIGF0dGVtcHRzIGFuZCB3YWl0IGJlZm9yZSByZXRyeWluZywgb3IgJ2ZhaWxlZCcgdG8gZmFpbC4gKi9cbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdEltcGwoKScsICdNdXN0IGJlIGluIGNvbm5lY3Rpbmcgc3RhdGUgdG8gY29ubmVjdCAob3IgY29ubmVjdGVkIHRvIHVwZ3JhZGUpLCBidXQgd2FzICcgKyBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdEltcGwoKScsICdUcmFuc3BvcnRzICcgKyB0aGlzLnBlbmRpbmdUcmFuc3BvcnRzWzBdLnRvU3RyaW5nKCkgKyAnIGN1cnJlbnRseSBwZW5kaW5nOyB0YWtpbmcgbm8gYWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZ3JhZGVJZk5lZWRlZCh0cmFuc3BvcnRQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHJhbnNwb3J0cy5sZW5ndGggPiAxICYmIHRoaXMuZ2V0VHJhbnNwb3J0UHJlZmVyZW5jZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RQcmVmZXJlbmNlKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdEJhc2UodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdFByZWZlcmVuY2UgPSBmdW5jdGlvbiAodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHByZWZlcmVuY2UgPSB0aGlzLmdldFRyYW5zcG9ydFByZWZlcmVuY2UoKTtcbiAgICAgICAgdmFyIHByZWZlcmVuY2VUaW1lb3V0RXhwaXJlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoIVV0aWxzLmFyckluKHRoaXMudHJhbnNwb3J0cywgcHJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHRoaXMudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0UHJlZmVyZW5jZSgpJywgJ1RyeWluZyB0byBjb25uZWN0IHdpdGggc3RvcmVkIHRyYW5zcG9ydCBwcmVmZXJlbmNlICcgKyBwcmVmZXJlbmNlKTtcbiAgICAgICAgdmFyIHByZWZlcmVuY2VUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwcmVmZXJlbmNlVGltZW91dEV4cGlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCEoX3RoaXMuc3RhdGUuc3RhdGUgPT09IF90aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0UHJlZmVyZW5jZSgpJywgJ1Nob3J0Y2lyY3VpdCBjb25uZWN0aW9uIGF0dGVtcHQgd2l0aCAnICsgcHJlZmVyZW5jZSArICcgZmFpbGVkOyBjbGVhcmluZyBwcmVmZXJlbmNlIGFuZCB0cnlpbmcgZnJvbSBzY3JhdGNoJyk7XG4gICAgICAgICAgICAgICAgLyogQWJvcnQgYWxsIGNvbm5lY3Rpb24gYXR0ZW1wdHMuIChUaGlzIGFsc28gZGlzY29ubmVjdHMgdGhlIGFjdGl2ZVxuICAgICAgICAgICAgICAgICAqIHByb3RvY29sLCBidXQgbm9uZSBleGlzdHMgaWYgd2UncmUgbm90IGluIHRoZSBjb25uZWN0ZWQgc3RhdGUpICovXG4gICAgICAgICAgICAgICAgX3RoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcbiAgICAgICAgICAgICAgICAvKiBCZSBxdWl0ZSBhZ3Jlc3NpdmUgYWJvdXQgY2xlYXJpbmcgdGhlIHN0b3JlZCBwcmVmZXJlbmNlIGlmIGV2ZXIgaXQgZG9lc24ndCB3b3JrICovXG4gICAgICAgICAgICAgICAgX3RoaXMudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuY29ubmVjdEltcGwodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpO1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMudGltZW91dHMucHJlZmVyZW5jZUNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgLyogRm9yIGNvbm5lY3RQcmVmZXJlbmNlLCBqdXN0IHVzZSB0aGUgbWFpbiBob3N0LiBJZiBob3N0IGZhbGxiYWNrIGlzIG5lZWRlZCwgZG8gaXQgaW4gY29ubmVjdEJhc2UuXG4gICAgICAgICAqIFRoZSB3c3RyYW5zcG9ydCBpdCB3aWxsIHN1YnN0aXR1dGUgdGhlIGh0dHBob3N0IGZvciBhbiBhcHByb3ByaWF0ZSB3c2hvc3QgKi9cbiAgICAgICAgdHJhbnNwb3J0UGFyYW1zLmhvc3QgPSB0aGlzLmh0dHBIb3N0c1swXTtcbiAgICAgICAgdGhpcy50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgcHJlZmVyZW5jZSwgZnVuY3Rpb24gKGZhdGFsLCB0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChwcmVmZXJlbmNlVGltZW91dCk7XG4gICAgICAgICAgICBpZiAocHJlZmVyZW5jZVRpbWVvdXRFeHBpcmVkICYmIHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIC8qIFZpYWJsZSwgYnV0IHRvbyBsYXRlIC0gY29ubmVjdEltcGwoKSB3aWxsIGFscmVhZHkgYmUgdHJ5aW5nXG4gICAgICAgICAgICAgICAgICogY29ubmVjdEJhc2UsIGFuZCB3ZSB3ZXJlbid0IGluIHVwZ3JhZGUgbW9kZS4gSnVzdCByZW1vdmUgdGhlXG4gICAgICAgICAgICAgICAgICogb25jb25uZWN0ZWQgbGlzdGVuZXIgYW5kIGdldCByaWQgb2YgaXQgKi9cbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQub2ZmKCk7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBVdGlscy5hcnJEZWxldGVWYWx1ZShfdGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0cmFuc3BvcnQgJiYgIWZhdGFsKSB7XG4gICAgICAgICAgICAgICAgLyogUHJlZmVyZW5jZSBmYWlsZWQgaW4gYSB0cmFuc3BvcnQtc3BlY2lmaWMgd2F5LiBUcnkgbW9yZSAqL1xuICAgICAgICAgICAgICAgIF90aGlzLnVucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBJZiBzdWNlZWRlZCwgb3IgZmFpbGVkIGZhdGFsbHksIG5vdGhpbmcgdG8gZG8gKi9cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcnkgdG8gZXN0YWJsaXNoIGEgdHJhbnNwb3J0IG9uIHRoZSBiYXNlIHRyYW5zcG9ydCAodGhlIGJlc3QgdHJhbnNwb3J0XG4gICAgICogc3VjaCB0aGF0IGlmIGl0IGRvZXNuJ3Qgd29yaywgbm90aGluZyB3aWxsIHdvcmspIGFzIGRldGVybWluZWQgdGhyb3VnaFxuICAgICAqIHN0YXRpYyBmZWF0dXJlIGRldGVjdGlvbiwgY2hlY2tpbmcgZm9yIG5ldHdvcmsgY29ubmVjdGl2aXR5IGFuZCB0cnlpbmdcbiAgICAgKiBmYWxsYmFjayBob3N0cyBpZiBhcHBsaWNhYmxlLlxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnRQYXJhbXNcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdEJhc2UgPSBmdW5jdGlvbiAodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGdpdmVVcCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIF90aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IF90aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSwgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZUhvc3RzID0gdGhpcy5odHRwSG9zdHMuc2xpY2UoKTtcbiAgICAgICAgdmFyIGhvc3RBdHRlbXB0Q2IgPSBmdW5jdGlvbiAoZmF0YWwsIHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgaWYgKGNvbm5lY3RDb3VudCAhPT0gX3RoaXMuY29ubmVjdENvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRyYW5zcG9ydCAmJiAhZmF0YWwpIHtcbiAgICAgICAgICAgICAgICB0cnlGYWxsYmFja0hvc3RzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdEJhc2UoKScsICdUcnlpbmcgdG8gY29ubmVjdCB3aXRoIGJhc2UgdHJhbnNwb3J0ICcgKyB0aGlzLmJhc2VUcmFuc3BvcnQpO1xuICAgICAgICAvKiBmaXJzdCB0cnkgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB3aXRoIHRoZSBwcmlvcml0eSBob3N0IHdpdGggaHR0cCB0cmFuc3BvcnQgKi9cbiAgICAgICAgdmFyIGhvc3QgPSBjYW5kaWRhdGVIb3N0cy5zaGlmdCgpO1xuICAgICAgICBpZiAoIWhvc3QpIHtcbiAgICAgICAgICAgIGdpdmVVcChuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVW5hYmxlIHRvIGNvbm5lY3QgKG5vIGF2YWlsYWJsZSBob3N0KScsIDgwMDAzLCA0MDQpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc3BvcnRQYXJhbXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIC8qIHRoaXMgaXMgd2hhdCB3ZSdsbCBiZSBkb2luZyBpZiB0aGUgYXR0ZW1wdCBmb3IgdGhlIG1haW4gaG9zdCBmYWlscyAqL1xuICAgICAgICB2YXIgdHJ5RmFsbGJhY2tIb3N0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8qIGlmIHRoZXJlIGFyZW4ndCBhbnkgZmFsbGJhY2sgaG9zdHMsIGZhaWwgKi9cbiAgICAgICAgICAgIGlmICghY2FuZGlkYXRlSG9zdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZ2l2ZVVwKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdVbmFibGUgdG8gY29ubmVjdCAoYW5kIG5vIG1vcmUgZmFsbGJhY2sgaG9zdHMgdG8gdHJ5KScsIDgwMDAzLCA0MDQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBiZWZvcmUgdHJ5aW5nIGFueSBmYWxsYmFjayAob3IgYW55IHJlbWFpbmluZyBmYWxsYmFjaykgd2UgZGVjaWRlIGlmXG4gICAgICAgICAgICAgKiB0aGVyZSBpcyBhIHByb2JsZW0gd2l0aCB0aGUgYWJseSBob3N0LCBvciB0aGVyZSBpcyBhIGdlbmVyYWwgY29ubmVjdGl2aXR5XG4gICAgICAgICAgICAgKiBwcm9ibGVtICovXG4gICAgICAgICAgICBpZiAoIV90aGlzLnJlYWx0aW1lLmh0dHAuY2hlY2tDb25uZWN0aXZpdHkpIHtcbiAgICAgICAgICAgICAgICBnaXZlVXAobmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ0ludGVybmFsIGVycm9yOiBIdHRwLmNoZWNrQ29ubmVjdGl2aXR5IG5vdCBzZXQnLCBudWxsLCA1MDApKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5yZWFsdGltZS5odHRwLmNoZWNrQ29ubmVjdGl2aXR5KGZ1bmN0aW9uIChlcnIsIGNvbm5lY3Rpdml0eSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0Q291bnQgIT09IF90aGlzLmNvbm5lY3RDb3VudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogd2Uga25vdyBlcnIgd29uJ3QgaGFwcGVuIGJ1dCBoYW5kbGUgaXQgaGVyZSBhbnl3YXkgKi9cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGdpdmVVcChlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY29ubmVjdGl2aXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIHRoZSBpbnRlcm5ldCBpc24ndCByZWFjaGFibGUsIHNvIGRvbid0IHRyeSB0aGUgZmFsbGJhY2sgaG9zdHMgKi9cbiAgICAgICAgICAgICAgICAgICAgZ2l2ZVVwKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdVbmFibGUgdG8gY29ubmVjdCAobmV0d29yayB1bnJlYWNoYWJsZSknLCA4MDAwMywgNDA0KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogdGhlIG5ldHdvcmsgaXMgdGhlcmUsIHNvIHRoZXJlJ3MgYSBwcm9ibGVtIHdpdGggdGhlIG1haW4gaG9zdCwgb3JcbiAgICAgICAgICAgICAgICAgKiBpdHMgZG5zLiBUcnkgdGhlIGZhbGxiYWNrIGhvc3RzLiBXZSBjb3VsZCB0cnkgdGhlbSBzaW11bHRhbmVvdXNseSBidXRcbiAgICAgICAgICAgICAgICAgKiB0aGF0IHdvdWxkIHBvdGVudGlhbGx5IGNhdXNlIGEgaHVnZSBzcGlrZSBpbiBsb2FkIG9uIHRoZSBsb2FkIGJhbGFuY2VyICovXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0UGFyYW1zLmhvc3QgPSBVdGlscy5hcnJQb3BSYW5kb21FbGVtZW50KGNhbmRpZGF0ZUhvc3RzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgX3RoaXMuYmFzZVRyYW5zcG9ydCwgaG9zdEF0dGVtcHRDYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VGYWxsYmFja0hvc3QgJiYgY2FuZGlkYXRlSG9zdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmZvcmNlRmFsbGJhY2tIb3N0ID0gZmFsc2U7XG4gICAgICAgICAgICB0cnlGYWxsYmFja0hvc3RzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgdGhpcy5iYXNlVHJhbnNwb3J0LCBob3N0QXR0ZW1wdENiKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRVcGdyYWRlUG9zc2liaWxpdGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyogcmV0dXJucyB0aGUgc3Vic2V0IG9mIHVwZ3JhZGVUcmFuc3BvcnRzIHRvIHRoZSByaWdodCBvZiB0aGUgY3VycmVudFxuICAgICAgICAgKiB0cmFuc3BvcnQgaW4gdXBncmFkZVRyYW5zcG9ydHMgKGlmIGl0J3MgaW4gdGhlcmUgLSBpZiBub3QsIGN1cnJlbnRTZXJpYWxcbiAgICAgICAgICogd2lsbCBiZSAtMSwgc28gcmV0dXJuIHVwZ3JhZGVUcmFuc3BvcnRzLnNsaWNlKDApID09IHVwZ3JhZGVUcmFuc3BvcnRzICovXG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5zaG9ydE5hbWU7XG4gICAgICAgIHZhciBjdXJyZW50U2VyaWFsID0gVXRpbHMuYXJySW5kZXhPZih0aGlzLnVwZ3JhZGVUcmFuc3BvcnRzLCBjdXJyZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBncmFkZVRyYW5zcG9ydHMuc2xpY2UoY3VycmVudFNlcmlhbCArIDEpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnVwZ3JhZGVJZk5lZWRlZCA9IGZ1bmN0aW9uICh0cmFuc3BvcnRQYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHVwZ3JhZGVQb3NzaWJpbGl0aWVzID0gdGhpcy5nZXRVcGdyYWRlUG9zc2liaWxpdGllcygpO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnVwZ3JhZGVJZk5lZWRlZCgpJywgJ3VwZ3JhZGUgcG9zc2liaWxpdGllczogJyArIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdCh1cGdyYWRlUG9zc2liaWxpdGllcykpO1xuICAgICAgICBpZiAoIXVwZ3JhZGVQb3NzaWJpbGl0aWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFV0aWxzLmFyckZvckVhY2godXBncmFkZVBvc3NpYmlsaXRpZXMsIGZ1bmN0aW9uICh1cGdyYWRlVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAvKiBOb3RlOiB0aGUgdHJhbnNwb3J0IG1heSBtdXRhdGUgdGhlIHBhcmFtcywgc28gZ2l2ZSBlYWNoIHRyYW5zcG9ydCBhIGZyZXNoIG9uZSAqL1xuICAgICAgICAgICAgdmFyIHVwZ3JhZGVUcmFuc3BvcnRQYXJhbXMgPSBfdGhpcy5jcmVhdGVUcmFuc3BvcnRQYXJhbXModHJhbnNwb3J0UGFyYW1zLmhvc3QsICd1cGdyYWRlJyk7XG4gICAgICAgICAgICBfdGhpcy50cnlBVHJhbnNwb3J0KHVwZ3JhZGVUcmFuc3BvcnRQYXJhbXMsIHVwZ3JhZGVUcmFuc3BvcnQsIG5vb3ApO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbG9zZUltcGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKCknLCAnY2xvc2luZyBjb25uZWN0aW9uJyk7XG4gICAgICAgIHRoaXMuY2FuY2VsU3VzcGVuZFRpbWVyKCk7XG4gICAgICAgIHRoaXMuc3RhcnRUcmFuc2l0aW9uVGltZXIodGhpcy5zdGF0ZXMuY2xvc2luZyk7XG4gICAgICAgIFV0aWxzLnNhZmVBcnJGb3JFYWNoKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKCknLCAnQ2xvc2luZyBwZW5kaW5nIHRyYW5zcG9ydDogJyArIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICBpZiAodHJhbnNwb3J0KVxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgVXRpbHMuc2FmZUFyckZvckVhY2godGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMsIGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKCknLCAnRGlzcG9zaW5nIG9mIHByb3Bvc2VkIHRyYW5zcG9ydDogJyArIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICBpZiAodHJhbnNwb3J0KVxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVQcm90b2NvbCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5jbG9zZUltcGwoKScsICdDbG9zaW5nIGFjdGl2ZSB0cmFuc3BvcnQ6ICcgKyB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBJZiB0aGVyZSB3YXMgYW4gYWN0aXZlIHRyYW5zcG9ydCwgdGhpcyB3aWxsIHByb2JhYmx5IGJlXG4gICAgICAgICAqIHByZWVtcHRlZCBieSB0aGUgbm90aWZ5U3RhdGUgY2FsbCBpbiBkZWFjdGl2YXRlVHJhbnNwb3J0ICovXG4gICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogJ2Nsb3NlZCcgfSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25BdXRoVXBkYXRlZCA9IGZ1bmN0aW9uICh0b2tlbkRldGFpbHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKCknLCAnU2VuZGluZyBBVVRIIG1lc3NhZ2Ugb24gYWN0aXZlIHRyYW5zcG9ydCcpO1xuICAgICAgICAgICAgICAgIC8qIElmIHRoZXJlIGFyZSBhbnkgcHJvcG9zZWQvcGVuZGluZyB0cmFuc3BvcnRzIChlZyBhbiB1cGdyYWRlIHRoYXRcbiAgICAgICAgICAgICAgICAgKiBpc24ndCB5ZXQgc2NoZWR1bGVkIGZvciBhY3RpdmF0aW9uKSB0aGF0IGhhc24ndCB5ZXQgc3RhcnRlZCBzeW5jaW5nLFxuICAgICAgICAgICAgICAgICAqIGp1c3QgdG8gZ2V0IHJpZCBvZiB0aGVtICYgcmVzdGFydCB0aGUgdXBncmFkZSB3aXRoIHRoZSBuZXcgdG9rZW4sIHRvXG4gICAgICAgICAgICAgICAgICogYXZvaWQgYSByYWNlIGNvbmRpdGlvbi4gKElmIGl0IGhhcyBzdGFydGVkIHN5bmNpbmcsIHRoZSBBVVRIIHdpbGwgYmVcbiAgICAgICAgICAgICAgICAgKiBxdWV1ZWQgdW50aWwgdGhlIHVwZ3JhZGUgaXMgY29tcGxldGUsIHNvIGV2ZXJ5dGhpbmcncyBmaW5lKSAqL1xuICAgICAgICAgICAgICAgIGlmICgodGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5sZW5ndGggfHwgdGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMubGVuZ3RoKSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoLyogZXhjZXB0QWN0aXZlOiAqLyB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zcG9ydFBhcmFtc18xID0gdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5wYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLnN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZ3JhZGVJZk5lZWRlZCh0cmFuc3BvcnRQYXJhbXNfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBEbyBhbnkgdHJhbnNwb3J0LXNwZWNpZmljIG5ldy10b2tlbiBhY3Rpb24gKi9cbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZlVHJhbnNwb3J0ID0gKF9hID0gdGhpcy5hY3RpdmVQcm90b2NvbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFRyYW5zcG9ydCgpO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVUcmFuc3BvcnQgJiYgYWN0aXZlVHJhbnNwb3J0Lm9uQXV0aFVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlVHJhbnNwb3J0Lm9uQXV0aFVwZGF0ZWQodG9rZW5EZXRhaWxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGF1dGhNc2cgPSBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGFjdGlvbnMuQVVUSCxcbiAgICAgICAgICAgICAgICAgICAgYXV0aDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW46IHRva2VuRGV0YWlscy50b2tlbixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmQoYXV0aE1zZyk7XG4gICAgICAgICAgICAgICAgLyogVGhlIGFuc3dlciB3aWxsIGNvbWUgYmFjayBhcyBlaXRoZXIgYSBjb25uZWN0aW9uZGV0YWlscyBldmVudFxuICAgICAgICAgICAgICAgICAqIChyZWFsdGltZSBzZW5kcyBhIENPTk5FQ1RFRCB0byBhY2tub3dsZWRnZSB0aGUgcmVhdXRoKSBvciBhXG4gICAgICAgICAgICAgICAgICogc3RhdGVjaGFuZ2UgdG8gZmFpbGVkICovXG4gICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3NMaXN0ZW5lcl8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmYoZmFpbHVyZUxpc3RlbmVyXzEpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB0b2tlbkRldGFpbHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGZhaWx1cmVMaXN0ZW5lcl8xID0gZnVuY3Rpb24gKHN0YXRlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZUNoYW5nZS5jdXJyZW50ID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub2ZmKHN1Y2Nlc3NMaXN0ZW5lcl8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZihmYWlsdXJlTGlzdGVuZXJfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhzdGF0ZUNoYW5nZS5yZWFzb24gfHwgX3RoaXMuZ2V0U3RhdGVFcnJvcigpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKCdjb25uZWN0aW9uZGV0YWlscycsIHN1Y2Nlc3NMaXN0ZW5lcl8xKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKCdjb25uZWN0aW9uc3RhdGUnLCBmYWlsdXJlTGlzdGVuZXJfMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdjb25uZWN0aW5nJzpcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoKScsICdBYm9ydGluZyBjdXJyZW50IGNvbm5lY3Rpb24gYXR0ZW1wdHMgaW4gb3JkZXIgdG8gc3RhcnQgYWdhaW4gd2l0aCB0aGUgbmV3IGF1dGggZGV0YWlscycpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcbiAgICAgICAgICAgIC8qIGZhbGx0aHJvdWdoIHRvIGFkZCBzdGF0ZWNoYW5nZSBsaXN0ZW5lciAqL1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIub25BdXRoVXBkYXRlZCgpJywgJ0Nvbm5lY3Rpb24gc3RhdGUgaXMgJyArIHRoaXMuc3RhdGUuc3RhdGUgKyAnOyB3YWl0aW5nIHVudGlsIGVpdGhlciBjb25uZWN0ZWQgb3IgZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyXzEgPSBmdW5jdGlvbiAoc3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZUNoYW5nZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZihsaXN0ZW5lcl8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB0b2tlbkRldGFpbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nsb3NlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdXNwZW5kZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZihsaXN0ZW5lcl8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhzdGF0ZUNoYW5nZS5yZWFzb24gfHwgX3RoaXMuZ2V0U3RhdGVFcnJvcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogaWdub3JlIHRpbGwgd2UgZ2V0IGVpdGhlciBjb25uZWN0ZWQgb3IgZmFpbGVkICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMub24oJ2Nvbm5lY3Rpb25zdGF0ZScsIGxpc3RlbmVyXzEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnN0YXRlID09PSAnY29ubmVjdGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogY2FuIGhhcHBlbiBpZiBpbiB0aGUgY29ubmVjdGluZyBzdGF0ZSBidXQgbm8gdHJhbnNwb3J0IHdhcyBwZW5kaW5nXG4gICAgICAgICAgICAgICAgICAgICAqIHlldCwgc28gZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMgZGlkIG5vdCB0cmlnZ2VyIGEgZGlzY29ubmVjdGVkIHN0YXRlICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRDb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiAnY29ubmVjdGluZycgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMgPSBmdW5jdGlvbiAoZXhjZXB0QWN0aXZlKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKScsICdEaXNjb25uZWN0aW5nIGFsbCB0cmFuc3BvcnRzJyArIChleGNlcHRBY3RpdmUgPyAnIGV4Y2VwdCB0aGUgYWN0aXZlIHRyYW5zcG9ydCcgOiAnJykpO1xuICAgICAgICAvKiBUaGlzIHdpbGwgcHJldmVudCBhbnkgY29ubmVjdGlvbiBwcm9jZWR1cmUgaW4gYW4gYXN5bmMgcGFydCBvZiBvbmUgb2YgaXRzIGVhcmx5IHN0YWdlcyBmcm9tIGNvbnRpbnVpbmcgKi9cbiAgICAgICAgdGhpcy5jb25uZWN0Q291bnRlcisrO1xuICAgICAgICBVdGlscy5zYWZlQXJyRm9yRWFjaCh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCknLCAnRGlzY29ubmVjdGluZyBwZW5kaW5nIHRyYW5zcG9ydDogJyArIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICBpZiAodHJhbnNwb3J0KVxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBlbmRpbmdUcmFuc3BvcnRzID0gW107XG4gICAgICAgIFV0aWxzLnNhZmVBcnJGb3JFYWNoKHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLCBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCknLCAnRGlzcG9zaW5nIG9mIHByb3Bvc2VkIHRyYW5zcG9ydDogJyArIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICBpZiAodHJhbnNwb3J0KVxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVQcm90b2NvbCAmJiAhZXhjZXB0QWN0aXZlKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCknLCAnRGlzY29ubmVjdGluZyBhY3RpdmUgdHJhbnNwb3J0OiAnICsgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBObyBuZWVkIHRvIG5vdGlmeSBzdGF0ZSBkaXNjb25uZWN0ZWQ7IGRpc2Nvbm5lY3RpbmcgdGhlIGFjdGl2ZSB0cmFuc3BvcnRcbiAgICAgICAgICogd2lsbCBoYXZlIHRoYXQgZWZmZWN0ICovXG4gICAgfTtcbiAgICAvKioqKioqKioqKioqKioqKioqXG4gICAgICogZXZlbnQgcXVldWVpbmdcbiAgICAgKioqKioqKioqKioqKioqKioqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1zZywgcXVldWVFdmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAoc3RhdGUuc2VuZEV2ZW50cykge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZW5kKCknLCAnc2VuZGluZyBldmVudCcpO1xuICAgICAgICAgICAgdGhpcy5zZW5kSW1wbChuZXcgcHJvdG9jb2xfMS5QZW5kaW5nTWVzc2FnZShtc2csIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3VsZFF1ZXVlID0gKHF1ZXVlRXZlbnQgJiYgc3RhdGUucXVldWVFdmVudHMpIHx8IHN0YXRlLmZvcmNlUXVldWVFdmVudHM7XG4gICAgICAgIGlmICghc2hvdWxkUXVldWUpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSAncmVqZWN0aW5nIGV2ZW50LCBxdWV1ZUV2ZW50IHdhcyAnICsgcXVldWVFdmVudCArICcsIHN0YXRlIHdhcyAnICsgc3RhdGUuc3RhdGU7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoKScsIGVycik7XG4gICAgICAgICAgICBjYWxsYmFjayh0aGlzLmVycm9yUmVhc29uIHx8IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KGVyciwgOTAwMDAsIDQwMCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2dnZXJfMS5kZWZhdWx0LnNob3VsZExvZyhsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2VuZCgpJywgJ3F1ZXVlaW5nIG1zZzsgJyArIHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuc3RyaW5naWZ5KG1zZykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucXVldWUobXNnLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2VuZEltcGwgPSBmdW5jdGlvbiAocGVuZGluZ01lc3NhZ2UpIHtcbiAgICAgICAgdmFyIG1zZyA9IHBlbmRpbmdNZXNzYWdlLm1lc3NhZ2U7XG4gICAgICAgIC8qIElmIGhhdmUgYWxyZWFkeSBhdHRlbXB0ZWQgdG8gc2VuZCB0aGlzLCByZXNlbmQgd2l0aCB0aGUgc2FtZSBtc2dTZXJpYWwsXG4gICAgICAgICAqIHNvIEFibHkgY2FuIGRlZHVwIGlmIHRoZSBwcmV2aW91cyBzZW5kIHN1Y2NlZWRlZCAqL1xuICAgICAgICBpZiAocGVuZGluZ01lc3NhZ2UuYWNrUmVxdWlyZWQgJiYgIXBlbmRpbmdNZXNzYWdlLnNlbmRBdHRlbXB0ZWQpIHtcbiAgICAgICAgICAgIG1zZy5tc2dTZXJpYWwgPSB0aGlzLm1zZ1NlcmlhbCsrO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVByb3RvY29sLnNlbmQocGVuZGluZ01lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNlbmRJbXBsKCknLCAnVW5leHBlY3RlZCBleGNlcHRpb24gaW4gdHJhbnNwb3J0LnNlbmQoKTogJyArIGUuc3RhY2spO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucXVldWUgPSBmdW5jdGlvbiAobXNnLCBjYWxsYmFjaykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnF1ZXVlKCknLCAncXVldWVpbmcgZXZlbnQnKTtcbiAgICAgICAgdmFyIGxhc3RRdWV1ZWQgPSB0aGlzLnF1ZXVlZE1lc3NhZ2VzLmxhc3QoKTtcbiAgICAgICAgdmFyIG1heFNpemUgPSB0aGlzLm9wdGlvbnMubWF4TWVzc2FnZVNpemU7XG4gICAgICAgIC8qIElmIGhhdmUgYWxyZWFkeSBhdHRlbXB0ZWQgdG8gc2VuZCBhIG1lc3NhZ2UsIGRvbid0IG1lcmdlIG1vcmUgbWVzc2FnZXNcbiAgICAgICAgICogaW50byBpdCwgYXMgaWYgdGhlIHByZXZpb3VzIHNlbmQgYWN0dWFsbHkgc3VjY2VlZGVkIGFuZCByZWFsdGltZSBpZ25vcmVzXG4gICAgICAgICAqIHRoZSBkdXAsIHRoZXknbGwgYmUgbG9zdCAqL1xuICAgICAgICBpZiAobGFzdFF1ZXVlZCAmJiAhbGFzdFF1ZXVlZC5zZW5kQXR0ZW1wdGVkICYmIGJ1bmRsZVdpdGgobGFzdFF1ZXVlZC5tZXNzYWdlLCBtc2csIG1heFNpemUpKSB7XG4gICAgICAgICAgICBpZiAoIWxhc3RRdWV1ZWQubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgbGFzdFF1ZXVlZC5jYWxsYmFjayA9IG11bHRpY2FzdGVyXzEuZGVmYXVsdC5jcmVhdGUoW2xhc3RRdWV1ZWQuY2FsbGJhY2tdKTtcbiAgICAgICAgICAgICAgICBsYXN0UXVldWVkLm1lcmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0UXVldWVkLmNhbGxiYWNrLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZWRNZXNzYWdlcy5wdXNoKG5ldyBwcm90b2NvbF8xLlBlbmRpbmdNZXNzYWdlKG1zZywgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNlbmRRdWV1ZWRNZXNzYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZW5kUXVldWVkTWVzc2FnZXMoKScsICdzZW5kaW5nICcgKyB0aGlzLnF1ZXVlZE1lc3NhZ2VzLmNvdW50KCkgKyAnIHF1ZXVlZCBtZXNzYWdlcycpO1xuICAgICAgICB2YXIgcGVuZGluZ01lc3NhZ2U7XG4gICAgICAgIHdoaWxlICgocGVuZGluZ01lc3NhZ2UgPSB0aGlzLnF1ZXVlZE1lc3NhZ2VzLnNoaWZ0KCkpKVxuICAgICAgICAgICAgdGhpcy5zZW5kSW1wbChwZW5kaW5nTWVzc2FnZSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucXVldWVQZW5kaW5nTWVzc2FnZXMgPSBmdW5jdGlvbiAocGVuZGluZ01lc3NhZ2VzKSB7XG4gICAgICAgIGlmIChwZW5kaW5nTWVzc2FnZXMgJiYgcGVuZGluZ01lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5xdWV1ZVBlbmRpbmdNZXNzYWdlcygpJywgJ3F1ZXVlaW5nICcgKyBwZW5kaW5nTWVzc2FnZXMubGVuZ3RoICsgJyBwZW5kaW5nIG1lc3NhZ2VzJyk7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlZE1lc3NhZ2VzLnByZXBlbmQocGVuZGluZ01lc3NhZ2VzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmZhaWxRdWV1ZWRNZXNzYWdlcyA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIG51bVF1ZXVlZCA9IHRoaXMucXVldWVkTWVzc2FnZXMuY291bnQoKTtcbiAgICAgICAgaWYgKG51bVF1ZXVlZCA+IDApIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZmFpbFF1ZXVlZE1lc3NhZ2VzKCknLCAnZmFpbGluZyAnICsgbnVtUXVldWVkICsgJyBxdWV1ZWQgbWVzc2FnZXMsIGVyciA9ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlZE1lc3NhZ2VzLmNvbXBsZXRlQWxsTWVzc2FnZXMoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uQ2hhbm5lbE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSwgdHJhbnNwb3J0KSB7XG4gICAgICAgIHZhciBvbkFjdGl2ZVRyYW5zcG9ydCA9IHRoaXMuYWN0aXZlUHJvdG9jb2wgJiYgdHJhbnNwb3J0ID09PSB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLCBvblVwZ3JhZGVUcmFuc3BvcnQgPSBVdGlscy5hcnJJbih0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCB0cmFuc3BvcnQpICYmIHRoaXMuc3RhdGUgPT0gdGhpcy5zdGF0ZXMuc3luY2hyb25pemluZztcbiAgICAgICAgLyogQXMgdGhlIGxpYiBub3cgaGFzIGEgcGVyaW9kIHdoZXJlIHRoZSB1cGdyYWRlIHRyYW5zcG9ydCBpcyBzeW5jZWQgYnV0XG4gICAgICAgICAqIGJlZm9yZSBpdCdzIGJlY29tZSBhY3RpdmUgKHdoaWxlIHdhaXRpbmcgZm9yIHRoZSBvbGQgb25lIHRvIGJlY29tZVxuICAgICAgICAgKiBpZGxlKSwgbWVzc2FnZSBjYW4gdmFsaWRseSBhcnJpdmUgb24gaXQgZXZlbiB0aG91Z2ggaXQgaXNuJ3QgYWN0aXZlICovXG4gICAgICAgIGlmIChvbkFjdGl2ZVRyYW5zcG9ydCB8fCBvblVwZ3JhZGVUcmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuY2hhbm5lbHMub25DaGFubmVsTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE1lc3NhZ2UgY2FtZSBpbiBvbiBhIGRlZnVuY3QgdHJhbnNwb3J0LiBBbGxvdyBvbmx5IGFja3MsIG5hY2tzLCAmIGVycm9ycyBmb3Igb3V0c3RhbmRpbmdcbiAgICAgICAgICAgIC8vIG1lc3NhZ2VzLCAgbm8gbmV3IG1lc3NhZ2VzIChhcyBzeW5jIGhhcyBiZWVuIHNlbnQgb24gbmV3IHRyYW5zcG9ydCBzbyBuZXcgbWVzc2FnZXMgd2lsbFxuICAgICAgICAgICAgLy8gYmUgcmVzZW50IHRoZXJlLCBvciBjb25uZWN0aW9uIGhhcyBiZWVuIGNsb3NlZCBzbyBkb24ndCB3YW50IG5ldyBtZXNzYWdlcylcbiAgICAgICAgICAgIGlmIChVdGlscy5hcnJJbmRleE9mKFthY3Rpb25zLkFDSywgYWN0aW9ucy5OQUNLLCBhY3Rpb25zLkVSUk9SXSwgbWVzc2FnZS5hY3Rpb24pID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBtZXNzYWdlICcgKyBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSArICdvbiBkZWZ1bmN0IHRyYW5zcG9ydDsgZGlzY2FyZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uICh0cmFuc3BvcnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qIGlmIHRyYW5zcG9ydCBpcyBzcGVjaWZpZWQsIHRyeSB0aGF0ICovXG4gICAgICAgIGlmICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIucGluZygpJywgJ3RyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgdmFyIG9uVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQub2ZmKCdoZWFydGJlYXQnLCBvbkhlYXJ0YmVhdF8xKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVGltZW91dCB3YWl0aW5nIGZvciBoZWFydGJlYXQgcmVzcG9uc2UnLCA1MDAwMCwgNTAwKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHBpbmdTdGFydF8xID0gVXRpbHMubm93KCksIGlkXzEgPSBVdGlscy5jaGVhcFJhbmRTdHIoKTtcbiAgICAgICAgICAgIHZhciBvbkhlYXJ0YmVhdF8xID0gZnVuY3Rpb24gKHJlc3BvbnNlSWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VJZCA9PT0gaWRfMSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQub2ZmKCdoZWFydGJlYXQnLCBvbkhlYXJ0YmVhdF8xKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyXzEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VUaW1lID0gVXRpbHMubm93KCkgLSBwaW5nU3RhcnRfMTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzcG9uc2VUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRpbWVyXzEgPSBzZXRUaW1lb3V0KG9uVGltZW91dCwgdGhpcy5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQpO1xuICAgICAgICAgICAgdHJhbnNwb3J0Lm9uKCdoZWFydGJlYXQnLCBvbkhlYXJ0YmVhdF8xKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5waW5nKGlkXzEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlmIHdlJ3JlIG5vdCBjb25uZWN0ZWQsIGRvbid0IGF0dGVtcHQgKi9cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RhdGUgIT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVW5hYmxlIHRvIHBpbmcgc2VydmljZTsgbm90IGNvbm5lY3RlZCcsIDQwMDAwLCA0MDApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBubyB0cmFuc3BvcnQgd2FzIHNwZWNpZmllZCwgc28gdXNlIHRoZSBjdXJyZW50IChjb25uZWN0ZWQpIG9uZVxuICAgICAgICAgKiBidXQgZW5zdXJlIHRoYXQgd2UgcmV0cnkgaWYgdGhlIHRyYW5zcG9ydCBpcyBzdXBlcnNlZGVkIGJlZm9yZSB3ZSBjb21wbGV0ZSAqL1xuICAgICAgICB2YXIgY29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBvblBpbmdDb21wbGV0ZSA9IGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlVGltZSkge1xuICAgICAgICAgICAgX3RoaXMub2ZmKCd0cmFuc3BvcnQuYWN0aXZlJywgb25UcmFuc3BvcnRBY3RpdmUpO1xuICAgICAgICAgICAgaWYgKCFjb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2VUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uVHJhbnNwb3J0QWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFjb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAvKiBlbnN1cmUgdGhhdCBubyBjYWxsYmFjayBoYXBwZW5zIGZvciB0aGUgY3VycmVudGx5IG91dHN0YW5kaW5nIG9wZXJhdGlvbiAqL1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLyogcmVwZWF0IGJ1dCBwaWNraW5nIHVwIHRoZSBuZXcgdHJhbnNwb3J0ICovXG4gICAgICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBpbmcobnVsbCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uKCd0cmFuc3BvcnQuYWN0aXZlJywgb25UcmFuc3BvcnRBY3RpdmUpO1xuICAgICAgICB0aGlzLnBpbmcodGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSwgb25QaW5nQ29tcGxldGUpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuZmFpbChlcnJvcik7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVnaXN0ZXJQcm9wb3NlZFRyYW5zcG9ydCA9IGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgICAgICAgdGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMucHVzaCh0cmFuc3BvcnQpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFRyYW5zcG9ydFByZWZlcmVuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgfHwgKGhhdmVXZWJTdG9yYWdlKCkgJiYgKChfYiA9IChfYSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5XZWJTdG9yYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUpKSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UgPSBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChVdGlscy5hcnJJbihkZWZhdWx0c18xLmRlZmF1bHQudXBncmFkZVRyYW5zcG9ydHMsIHRyYW5zcG9ydC5zaG9ydE5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgPSB0cmFuc3BvcnQuc2hvcnROYW1lO1xuICAgICAgICAgICAgaWYgKGhhdmVXZWJTdG9yYWdlKCkpIHtcbiAgICAgICAgICAgICAgICAoX2IgPSAoX2EgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuV2ViU3RvcmFnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lLCB0cmFuc3BvcnQuc2hvcnROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnVucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSA9IG51bGw7XG4gICAgICAgIGlmIChoYXZlV2ViU3RvcmFnZSgpKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuV2ViU3RvcmFnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyogVGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGR1cmluZyBjb25uZWN0aW9uIGF0dGVtcHRzLCBzbyBpbXBsZW1lbnRzIFJTQTRjMSwgUlNBNGMyLFxuICAgICAqIGFuZCBSU0E0ZC4gSXQgaXMgZ2VuZXJhbGx5IG5vdCBpbnZva2VkIGZvciBzZXJ2ZXJzaWRlLXRyaWdnZXJlZCByZWF1dGhzIG9yIG1hbnVhbFxuICAgICAqIHJlYXV0aHMsIHNvIFJTQTRjMyBkb2VzIG5vdCBhcHBseSwgZXhjZXB0IChwZXIgcGVyIFJTQTRkMSkgaW4gdGhlIGNhc2UgdGhhdCB0aGUgYXV0aFxuICAgICAqIHNlcnZlciByZXR1cm5zIDQwMy4gKi9cbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYWN0T25FcnJvckZyb21BdXRob3JpemUgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gNDAxNzEpIHtcbiAgICAgICAgICAgIC8qIE5vIHdheSB0byByZWF1dGggKi9cbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogJ2ZhaWxlZCcsIGVycm9yOiBlcnIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyLmNvZGUgPT09IDQwMTAyKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6ICdmYWlsZWQnLCBlcnJvcjogZXJyIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVyci5zdGF0dXNDb2RlID09PSBIdHRwU3RhdHVzQ29kZXNfMS5kZWZhdWx0LkZvcmJpZGRlbikge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdDbGllbnQgY29uZmlndXJlZCBhdXRoZW50aWNhdGlvbiBwcm92aWRlciByZXR1cm5lZCA0MDM7IGZhaWxpbmcgdGhlIGNvbm5lY3Rpb24nO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZSgpJywgbXNnKTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogJ2ZhaWxlZCcsIGVycm9yOiBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDgwMDE5LCA0MDMsIGVycikgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ0NsaWVudCBjb25maWd1cmVkIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIHJlcXVlc3QgZmFpbGVkJztcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0T25FcnJvckZyb21BdXRob3JpemUnLCBtc2cpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiB0aGlzLnN0YXRlLmZhaWxTdGF0ZSwgZXJyb3I6IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgODAwMTksIDQwMSwgZXJyKSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uQ29ubmVjdGlvbkRldGFpbHNVcGRhdGUgPSBmdW5jdGlvbiAoY29ubmVjdGlvbkRldGFpbHMsIHRyYW5zcG9ydCkge1xuICAgICAgICBpZiAoIWNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uRGV0YWlscyA9IGNvbm5lY3Rpb25EZXRhaWxzO1xuICAgICAgICBpZiAoY29ubmVjdGlvbkRldGFpbHMubWF4TWVzc2FnZVNpemUpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tYXhNZXNzYWdlU2l6ZSA9IGNvbm5lY3Rpb25EZXRhaWxzLm1heE1lc3NhZ2VTaXplO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbGllbnRJZCA9IGNvbm5lY3Rpb25EZXRhaWxzLmNsaWVudElkO1xuICAgICAgICBpZiAoY2xpZW50SWQpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSB0aGlzLnJlYWx0aW1lLmF1dGguX3VuY2hlY2tlZFNldENsaWVudElkKGNsaWVudElkKTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm9uQ29ubmVjdGlvbkRldGFpbHNVcGRhdGUoKScsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAvKiBFcnJvcnMgc2V0dGluZyB0aGUgY2xpZW50SWQgYXJlIGZhdGFsIHRvIHRoZSBjb25uZWN0aW9uICovXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmZhaWwoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbm5lY3Rpb25TdGF0ZVR0bCA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25TdGF0ZVR0bDtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25TdGF0ZVR0bCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdGVUdGwgPSBjb25uZWN0aW9uU3RhdGVUdGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBjb25uZWN0aW9uRGV0YWlscy5tYXhJZGxlSW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvbmRldGFpbHMnLCBjb25uZWN0aW9uRGV0YWlscyk7XG4gICAgfTtcbiAgICAvKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogdHJhbnNwb3J0IG1hbmFnZW1lbnRcbiAgICAgKioqKioqKioqKioqKioqKioqKioqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHMgPSB7fTtcbiAgICByZXR1cm4gQ29ubmVjdGlvbk1hbmFnZXI7XG59KGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25NYW5hZ2VyO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxMykpKVxuXG4vKioqLyB9KSxcbi8qIDM2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgZXZlbnRlbWl0dGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIE1lc3NhZ2VRdWV1ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZXNzYWdlUXVldWUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZVF1ZXVlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLmxlbmd0aDtcbiAgICB9O1xuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICB9O1xuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLnNoaWZ0KCk7XG4gICAgfTtcbiAgICBNZXNzYWdlUXVldWUucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzW3RoaXMubWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgfTtcbiAgICBNZXNzYWdlUXVldWUucHJvdG90eXBlLmNvcHlBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLnNsaWNlKCk7XG4gICAgfTtcbiAgICBNZXNzYWdlUXVldWUucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChtZXNzYWdlcykge1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLnB1c2guYXBwbHkodGhpcy5tZXNzYWdlcywgbWVzc2FnZXMpO1xuICAgIH07XG4gICAgTWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gKG1lc3NhZ2VzKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMudW5zaGlmdC5hcHBseSh0aGlzLm1lc3NhZ2VzLCBtZXNzYWdlcyk7XG4gICAgfTtcbiAgICBNZXNzYWdlUXVldWUucHJvdG90eXBlLmNvbXBsZXRlTWVzc2FnZXMgPSBmdW5jdGlvbiAoc2VyaWFsLCBjb3VudCwgZXJyKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnTWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoKScsICdzZXJpYWwgPSAnICsgc2VyaWFsICsgJzsgY291bnQgPSAnICsgY291bnQpO1xuICAgICAgICBlcnIgPSBlcnIgfHwgbnVsbDtcbiAgICAgICAgdmFyIG1lc3NhZ2VzID0gdGhpcy5tZXNzYWdlcztcbiAgICAgICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNzYWdlUXVldWUuY29tcGxldGVNZXNzYWdlcygpOiBjb21wbGV0ZU1lc3NhZ2VzIGNhbGxlZCBvbiBhbnkgZW1wdHkgTWVzc2FnZVF1ZXVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0ID0gbWVzc2FnZXNbMF07XG4gICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0U2VyaWFsID0gZmlyc3QubWVzc2FnZS5tc2dTZXJpYWw7XG4gICAgICAgICAgICB2YXIgZW5kU2VyaWFsID0gc2VyaWFsICsgY291bnQ7IC8qIHRoZSBzZXJpYWwgb2YgdGhlIGZpcnN0IG1lc3NhZ2UgdGhhdCBpcyAqbm90KiB0aGUgc3ViamVjdCBvZiB0aGlzIGNhbGwgKi9cbiAgICAgICAgICAgIGlmIChlbmRTZXJpYWwgPiBzdGFydFNlcmlhbCkge1xuICAgICAgICAgICAgICAgIHZhciBjb21wbGV0ZU1lc3NhZ2VzID0gbWVzc2FnZXMuc3BsaWNlKDAsIGVuZFNlcmlhbCAtIHN0YXJ0U2VyaWFsKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNvbXBsZXRlTWVzc2FnZXNfMSA9IGNvbXBsZXRlTWVzc2FnZXM7IF9pIDwgY29tcGxldGVNZXNzYWdlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGNvbXBsZXRlTWVzc2FnZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdpZGxlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuY29tcGxldGVBbGxNZXNzYWdlcyA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZU1lc3NhZ2VzKDAsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IE51bWJlci5NQVhfVkFMVUUsIGVycik7XG4gICAgfTtcbiAgICBNZXNzYWdlUXVldWUucHJvdG90eXBlLnJlc2V0U2VuZEF0dGVtcHRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMubWVzc2FnZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gX2FbX2ldO1xuICAgICAgICAgICAgbXNnLnNlbmRBdHRlbXB0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdNZXNzYWdlUXVldWUuY2xlYXIoKScsICdjbGVhcmluZyAnICsgdGhpcy5tZXNzYWdlcy5sZW5ndGggKyAnIG1lc3NhZ2VzJyk7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5lbWl0KCdpZGxlJyk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVzc2FnZVF1ZXVlO1xufShldmVudGVtaXR0ZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBNZXNzYWdlUXVldWU7XG5cblxuLyoqKi8gfSksXG4vKiAzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25uZWN0aW9uU3RhdGVDaGFuZ2UocHJldmlvdXMsIGN1cnJlbnQsIHJldHJ5SW4sIHJlYXNvbikge1xuICAgICAgICB0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgIGlmIChyZXRyeUluKVxuICAgICAgICAgICAgdGhpcy5yZXRyeUluID0gcmV0cnlJbjtcbiAgICAgICAgaWYgKHJlYXNvbilcbiAgICAgICAgICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIH1cbiAgICByZXR1cm4gQ29ubmVjdGlvblN0YXRlQ2hhbmdlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25TdGF0ZUNoYW5nZTtcblxuXG4vKioqLyB9KSxcbi8qIDM4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgcHJvdG9jb2xtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSk7XG52YXIgZXZlbnRlbWl0dGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGNoYW5uZWxfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzMpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIHJlYWx0aW1lcHJlc2VuY2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNTQpKTtcbnZhciBtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDkpKTtcbnZhciBjaGFubmVsc3RhdGVjaGFuZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzkpKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIHByZXNlbmNlbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNSkpO1xudmFyIGNvbm5lY3Rpb25lcnJvcnNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjApKTtcbnZhciBhY3Rpb25zID0gcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5BY3Rpb247XG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcbmZ1bmN0aW9uIHZhbGlkYXRlQ2hhbm5lbE9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmICdwYXJhbXMnIGluIG9wdGlvbnMgJiYgIVV0aWxzLmlzT2JqZWN0KG9wdGlvbnMucGFyYW1zKSkge1xuICAgICAgICByZXR1cm4gbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ29wdGlvbnMucGFyYW1zIG11c3QgYmUgYW4gb2JqZWN0JywgNDAwMDAsIDQwMCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmICdtb2RlcycgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAoIVV0aWxzLmlzQXJyYXkob3B0aW9ucy5tb2RlcykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnb3B0aW9ucy5tb2RlcyBtdXN0IGJlIGFuIGFycmF5JywgNDAwMDAsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLm1vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudE1vZGUgPSBvcHRpb25zLm1vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50TW9kZSB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiBjdXJyZW50TW9kZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgICAgICAhVXRpbHMuYXJySW4ocHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5jaGFubmVsTW9kZXMsIFN0cmluZy5wcm90b3R5cGUudG9VcHBlckNhc2UuY2FsbChjdXJyZW50TW9kZSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdJbnZhbGlkIGNoYW5uZWwgbW9kZTogJyArIGN1cnJlbnRNb2RlLCA0MDAwMCwgNDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbnZhciBSZWFsdGltZUNoYW5uZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUmVhbHRpbWVDaGFubmVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlYWx0aW1lQ2hhbm5lbChyZWFsdGltZSwgbmFtZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByZWFsdGltZSwgbmFtZSwgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmV0cnlDb3VudCA9IDA7XG4gICAgICAgIF90aGlzLmhpc3RvcnkgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwuaGlzdG9yeSgpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5uYW1lKTtcbiAgICAgICAgICAgIC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdoaXN0b3J5JywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMudW50aWxBdHRhY2gpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ2F0dGFjaGVkJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnb3B0aW9uIHVudGlsQXR0YWNoIHJlcXVpcmVzIHRoZSBjaGFubmVsIHRvIGJlIGF0dGFjaGVkJywgNDAwMDAsIDQwMCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgndW50aWxBdHRhY2ggd2FzIHNwZWNpZmllZCBhbmQgY2hhbm5lbCBpcyBhdHRhY2hlZCwgYnV0IGF0dGFjaFNlcmlhbCBpcyBub3QgZGVmaW5lZCcsIDQwMDAwLCA0MDApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW1zLnVudGlsQXR0YWNoO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5mcm9tX3NlcmlhbCA9IHRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFubmVsXzEuZGVmYXVsdC5wcm90b3R5cGUuX2hpc3RvcnkuY2FsbCh0aGlzLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMud2hlblN0YXRlID0gKGZ1bmN0aW9uIChzdGF0ZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudGVtaXR0ZXJfMS5kZWZhdWx0LnByb3RvdHlwZS53aGVuU3RhdGUuY2FsbChfdGhpcywgc3RhdGUsIF90aGlzLnN0YXRlLCBsaXN0ZW5lcik7XG4gICAgICAgIH0pO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbCgpJywgJ3N0YXJ0ZWQ7IG5hbWUgPSAnICsgbmFtZSk7XG4gICAgICAgIF90aGlzLnJlYWx0aW1lID0gcmVhbHRpbWU7XG4gICAgICAgIF90aGlzLnByZXNlbmNlID0gbmV3IHJlYWx0aW1lcHJlc2VuY2VfMS5kZWZhdWx0KF90aGlzKTtcbiAgICAgICAgX3RoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSByZWFsdGltZS5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9ICdpbml0aWFsaXplZCc7XG4gICAgICAgIF90aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICBfdGhpcy5zeW5jQ2hhbm5lbFNlcmlhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMucHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIGF0dGFjaFNlcmlhbDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2hhbm5lbFNlcmlhbDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBfdGhpcy5lcnJvclJlYXNvbiA9IG51bGw7XG4gICAgICAgIF90aGlzLl9yZXF1ZXN0ZWRGbGFncyA9IG51bGw7XG4gICAgICAgIF90aGlzLl9tb2RlID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX2F0dGFjaFJlc3VtZSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fZGVjb2RpbmdDb250ZXh0ID0ge1xuICAgICAgICAgICAgY2hhbm5lbE9wdGlvbnM6IF90aGlzLmNoYW5uZWxPcHRpb25zLFxuICAgICAgICAgICAgcGx1Z2luczogcmVhbHRpbWUub3B0aW9ucy5wbHVnaW5zIHx8IHt9LFxuICAgICAgICAgICAgYmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX2xhc3RQYXlsb2FkID0ge1xuICAgICAgICAgICAgbWVzc2FnZUlkOiBudWxsLFxuICAgICAgICAgICAgcHJvdG9jb2xNZXNzYWdlQ2hhbm5lbFNlcmlhbDogbnVsbCxcbiAgICAgICAgICAgIGRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3M6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIC8qIE9ubHkgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGlzIGFuZCB0aGUgcHVibGljIGV2ZW50IGVtaXR0ZXIgaXMgdGhhdCB0aGlzIGVtaXRzIGFuXG4gICAgICAgICAqIHVwZGF0ZSBldmVudCBmb3IgYWxsIEFUVEFDSEVEcywgd2hldGhlciByZXN1bWVkIG9yIG5vdCAqL1xuICAgICAgICBfdGhpcy5fYWxsQ2hhbm5lbENoYW5nZXMgPSBuZXcgZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuaW52YWxpZFN0YXRlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnQ2hhbm5lbCBvcGVyYXRpb24gZmFpbGVkIGFzIGNoYW5uZWwgc3RhdGUgaXMgJyArIHRoaXMuc3RhdGUsIDkwMDAxLCA0MDAsIHRoaXMuZXJyb3JSZWFzb24gfHwgdW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgLyogW2V2ZW50XSwgbGlzdGVuZXIsIFtjYWxsYmFja10gKi9cbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJnc1thcmdzLmxlbmd0aCAtIDFdID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXJncy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJncztcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdzZXRPcHRpb25zJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgX2NhbGxiYWNrID0gY2FsbGJhY2sgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnUmVhbHRpbWVDaGFubmVsLnNldE9wdGlvbnMoKScsICdTZXQgb3B0aW9ucyBmYWlsZWQ6ICcgKyBlcnIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdmFyIGVyciA9IHZhbGlkYXRlQ2hhbm5lbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIF9jYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5uZWxfMS5kZWZhdWx0LnByb3RvdHlwZS5zZXRPcHRpb25zLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLl9kZWNvZGluZ0NvbnRleHQpXG4gICAgICAgICAgICB0aGlzLl9kZWNvZGluZ0NvbnRleHQuY2hhbm5lbE9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xuICAgICAgICBpZiAodGhpcy5fc2hvdWxkUmVhdHRhY2hUb1NldE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgICAgICAgIC8qIFRoaXMgZG9lcyBub3QganVzdCBkbyBfYXR0YWNoKHRydWUsIG51bGwsIGNhbGxiYWNrKSBiZWNhdXNlIHRoYXQgd291bGQgcHV0IHVzXG4gICAgICAgICAgICAgKiBpbnRvIHRoZSAnYXR0YWNoaW5nJyBzdGF0ZSB1bnRpbCB3ZSByZWNlaXZlIHRoZSBuZXcgYXR0YWNoZWQsIHdoaWNoIGlzXG4gICAgICAgICAgICAgKiBjb25jZXB0dWFsbHkgaW5jb3JyZWN0OiB3ZSBhcmUgc3RpbGwgYXR0YWNoZWQsIHdlIGp1c3QgaGF2ZSBhIHBlbmRpbmcgcmVxdWVzdCB0b1xuICAgICAgICAgICAgICogY2hhbmdlIHNvbWUgY2hhbm5lbCBwYXJhbXMuIFBlciBSVEwxNyBnb2luZyBpbnRvIHRoZSBhdHRhY2hpbmcgc3RhdGUgd291bGQgbWVhblxuICAgICAgICAgICAgICogcmVqZWN0aW5nIG1lc3NhZ2VzIHVudGlsIHdlIGhhdmUgY29uZmlybWF0aW9uIHRoYXQgdGhlIG9wdGlvbnMgaGF2ZSBjaGFuZ2VkLFxuICAgICAgICAgICAgICogd2hpY2ggd291bGQgdW5uZWNlc3NhcmlseSBsb3NlIG1lc3NhZ2UgY29udGludWl0eS4gKi9cbiAgICAgICAgICAgIHRoaXMuYXR0YWNoSW1wbCgpO1xuICAgICAgICAgICAgLy8gSWdub3JlICdhdHRhY2hpbmcnIC0tIGNvdWxkIGJlIGp1c3QgZHVlIHRvIHRvIGEgcmVzdW1lICYgcmVhdHRhY2gsIHNob3VsZCBub3RcbiAgICAgICAgICAgIC8vIGNhbGwgYmFjayBzZXRPcHRpb25zIHVudGlsIHdlJ3JlIGRlZmluaXRlbHkgYXR0YWNoZWQgd2l0aCB0aGUgbmV3IG9wdGlvbnMgKG9yXG4gICAgICAgICAgICAvLyBlbHNlIGluIGEgdGVybWluYWwgc3RhdGUpXG4gICAgICAgICAgICB0aGlzLl9hbGxDaGFubmVsQ2hhbmdlcy5vbmNlKFsnYXR0YWNoZWQnLCAndXBkYXRlJywgJ2RldGFjaGVkJywgJ2ZhaWxlZCddLCBmdW5jdGlvbiAoc3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndXBkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXR0YWNoZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2NhbGxiYWNrID09PSBudWxsIHx8IF9jYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2NhbGxiYWNrID09PSBudWxsIHx8IF9jYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5fc2hvdWxkUmVhdHRhY2hUb1NldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGUgPT09ICdhdHRhY2hlZCcgfHwgdGhpcy5zdGF0ZSA9PT0gJ2F0dGFjaGluZycpICYmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhcmFtcykgfHwgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tb2RlcykpO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXNzYWdlcyA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBhcmdDb3VudCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzW2FyZ0NvdW50IC0gMV07XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdwdWJsaXNoJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgICAgICsrYXJnQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ0NvdW50ID09IDIpIHtcbiAgICAgICAgICAgIGlmIChVdGlscy5pc09iamVjdChtZXNzYWdlcykpXG4gICAgICAgICAgICAgICAgbWVzc2FnZXMgPSBbbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyhtZXNzYWdlcyldO1xuICAgICAgICAgICAgZWxzZSBpZiAoVXRpbHMuaXNBcnJheShtZXNzYWdlcykpXG4gICAgICAgICAgICAgICAgbWVzc2FnZXMgPSBtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzQXJyYXkobWVzc2FnZXMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdUaGUgc2luZ2xlLWFyZ3VtZW50IGZvcm0gb2YgcHVibGlzaCgpIGV4cGVjdHMgYSBtZXNzYWdlIG9iamVjdCBvciBhbiBhcnJheSBvZiBtZXNzYWdlIG9iamVjdHMnLCA0MDAxMywgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzID0gW21lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoeyBuYW1lOiBhcmdzWzBdLCBkYXRhOiBhcmdzWzFdIH0pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4TWVzc2FnZVNpemUgPSB0aGlzLnJlYWx0aW1lLm9wdGlvbnMubWF4TWVzc2FnZVNpemU7XG4gICAgICAgIG1lc3NhZ2VfMS5kZWZhdWx0LmVuY29kZUFycmF5KG1lc3NhZ2VzLCB0aGlzLmNoYW5uZWxPcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBSU0wxaSAqL1xuICAgICAgICAgICAgdmFyIHNpemUgPSBtZXNzYWdlXzEuZGVmYXVsdC5nZXRNZXNzYWdlc1NpemUobWVzc2FnZXMpO1xuICAgICAgICAgICAgaWYgKHNpemUgPiBtYXhNZXNzYWdlU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdNYXhpbXVtIHNpemUgb2YgbWVzc2FnZXMgdGhhdCBjYW4gYmUgcHVibGlzaGVkIGF0IG9uY2UgZXhjZWVkZWQgKCB3YXMgJyArXG4gICAgICAgICAgICAgICAgICAgIHNpemUgK1xuICAgICAgICAgICAgICAgICAgICAnIGJ5dGVzOyBsaW1pdCBpcyAnICtcbiAgICAgICAgICAgICAgICAgICAgbWF4TWVzc2FnZVNpemUgK1xuICAgICAgICAgICAgICAgICAgICAnIGJ5dGVzKScsIDQwMDA5LCA0MDApKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fX3B1Ymxpc2gobWVzc2FnZXMsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBEb3VibGUgdW5kZXJzY29yZSB1c2VkIHRvIHByZXZlbnQgdHlwZSBjb25mbGljdCB3aXRoIHVuZGVybHlpbmcgQ2hhbm5lbC5fcHVibGlzaCBtZXRob2RcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLl9fcHVibGlzaCA9IGZ1bmN0aW9uIChtZXNzYWdlcywgY2FsbGJhY2spIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwucHVibGlzaCgpJywgJ21lc3NhZ2UgY291bnQgPSAnICsgbWVzc2FnZXMubGVuZ3RoKTtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ3N1c3BlbmRlZCc6XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHRoaXMuaW52YWxpZFN0YXRlRXJyb3IoKSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLnB1Ymxpc2goKScsICdzZW5kaW5nIG1lc3NhZ2U7IGNoYW5uZWwgc3RhdGUgaXMgJyArIHN0YXRlKTtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gbmV3IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBtc2cuYWN0aW9uID0gYWN0aW9ucy5NRVNTQUdFO1xuICAgICAgICAgICAgICAgIG1zZy5jaGFubmVsID0gdGhpcy5uYW1lO1xuICAgICAgICAgICAgICAgIG1zZy5tZXNzYWdlcyA9IG1lc3NhZ2VzO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UobXNnLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUub25FdmVudCA9IGZ1bmN0aW9uIChtZXNzYWdlcykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5vbkV2ZW50KCknLCAncmVjZWl2ZWQgbWVzc2FnZScpO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBtZXNzYWdlc1tpXTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuZW1pdChtZXNzYWdlLm5hbWUsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChmbGFncywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF9mbGFncztcbiAgICAgICAgaWYgKHR5cGVvZiBmbGFncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBmbGFncztcbiAgICAgICAgICAgIF9mbGFncyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfZmxhZ3MgPSBmbGFncztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnYXR0YWNoJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUFKT1IsICdSZWFsdGltZUNoYW5uZWwuYXR0YWNoKCknLCAnQ2hhbm5lbCBhdHRhY2ggZmFpbGVkOiAnICsgZXJyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9mbGFncykge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZXByZWNhdGVkKCdjaGFubmVsLmF0dGFjaCgpIHdpdGggZmxhZ3MnLCAnY2hhbm5lbC5zZXRPcHRpb25zKCkgd2l0aCBjaGFubmVsT3B0aW9ucy5wYXJhbXMnKTtcbiAgICAgICAgICAgIC8qIElmIGZsYWdzIHJlcXVlc3RlZCwgYWx3YXlzIGRvIGEgcmUtYXR0YWNoLiBUT0RPIG9ubHkgZG8gdGhpcyBpZlxuICAgICAgICAgICAgICogY3VycmVudCBtb2RlIGRpZmZlcnMgZnJvbSByZXF1ZXN0ZWQgbW9kZSAqL1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdGVkRmxhZ3MgPSBfZmxhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ2F0dGFjaGVkJykge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXR0YWNoKGZhbHNlLCBudWxsLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLl9hdHRhY2ggPSBmdW5jdGlvbiAoZm9yY2VSZWF0dGFjaCwgYXR0YWNoUmVhc29uLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnUmVhbHRpbWVDaGFubmVsLl9hdHRhY2goKScsICdDaGFubmVsIGF0dGFjaCBmYWlsZWQ6ICcgKyBlcnIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyO1xuICAgICAgICBpZiAoIWNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnYXR0YWNoaW5nJyB8fCBmb3JjZVJlYXR0YWNoKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZSgnYXR0YWNoaW5nJywgYXR0YWNoUmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uY2UoZnVuY3Rpb24gKHN0YXRlQ2hhbmdlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdhdHRhY2hlZCc6XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhudWxsLCBzdGF0ZUNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RldGFjaGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzdXNwZW5kZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhzdGF0ZUNoYW5nZS5yZWFzb24gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdVbmFibGUgdG8gYXR0YWNoOyByZWFzb24gdW5rbm93bjsgc3RhdGUgPSAnICsgdGhpcy5ldmVudCwgOTAwMDAsIDUwMCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkZXRhY2hpbmcnOlxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0F0dGFjaCByZXF1ZXN0IHN1cGVyc2VkZWQgYnkgYSBzdWJzZXF1ZW50IGRldGFjaCByZXF1ZXN0JywgOTAwMDAsIDQwOSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmF0dGFjaEltcGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLmF0dGFjaEltcGwoKScsICdzZW5kaW5nIEFUVEFDSCBtZXNzYWdlJyk7XG4gICAgICAgIHZhciBhdHRhY2hNc2cgPSBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25zLkFUVEFDSCxcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy5jaGFubmVsT3B0aW9ucy5wYXJhbXMsXG4gICAgICAgICAgICAvLyBSVEw0YzE6IEluY2x1ZGVzIHRoZSBjaGFubmVsIHNlcmlhbCB0byByZXN1bWUgZnJvbSBhIHByZXZpb3VzIG1lc3NhZ2VcbiAgICAgICAgICAgIC8vIG9yIGF0dGFjaG1lbnQuXG4gICAgICAgICAgICBjaGFubmVsU2VyaWFsOiB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ZWRGbGFncykge1xuICAgICAgICAgICAgYXR0YWNoTXNnLmVuY29kZU1vZGVzVG9GbGFncyh0aGlzLl9yZXF1ZXN0ZWRGbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jaGFubmVsT3B0aW9ucy5tb2Rlcykge1xuICAgICAgICAgICAgYXR0YWNoTXNnLmVuY29kZU1vZGVzVG9GbGFncyhVdGlscy5hbGxUb1VwcGVyQ2FzZSh0aGlzLmNoYW5uZWxPcHRpb25zLm1vZGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2F0dGFjaFJlc3VtZSkge1xuICAgICAgICAgICAgYXR0YWNoTXNnLnNldEZsYWcoJ0FUVEFDSF9SRVNVTUUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgYXR0YWNoTXNnLmNoYW5uZWxTZXJpYWwgPSB0aGlzLl9sYXN0UGF5bG9hZC5wcm90b2NvbE1lc3NhZ2VDaGFubmVsU2VyaWFsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoYXR0YWNoTXNnLCBub29wKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdkZXRhY2gnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25uZWN0aW9uTWFuYWdlciA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgICAgIGlmICghY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgICAgICAgY2FsbGJhY2soY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdzdXNwZW5kZWQnOlxuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoJ2RldGFjaGVkJyk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RldGFjaGVkJzpcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVW5hYmxlIHRvIGRldGFjaDsgY2hhbm5lbCBzdGF0ZSA9IGZhaWxlZCcsIDkwMDAxLCA0MDApKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoJ2RldGFjaGluZycpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlICdkZXRhY2hpbmcnOlxuICAgICAgICAgICAgICAgIHRoaXMub25jZShmdW5jdGlvbiAoc3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkZXRhY2hlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F0dGFjaGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N1c3BlbmRlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdVbmFibGUgdG8gZGV0YWNoOyByZWFzb24gdW5rbm93bjsgc3RhdGUgPSAnICsgdGhpcy5ldmVudCwgOTAwMDAsIDUwMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXR0YWNoaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnRGV0YWNoIHJlcXVlc3Qgc3VwZXJzZWRlZCBieSBhIHN1YnNlcXVlbnQgYXR0YWNoIHJlcXVlc3QnLCA5MDAwMCwgNDA5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5kZXRhY2hJbXBsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLmRldGFjaCgpJywgJ3NlbmRpbmcgREVUQUNIIG1lc3NhZ2UnKTtcbiAgICAgICAgdmFyIG1zZyA9IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyh7IGFjdGlvbjogYWN0aW9ucy5ERVRBQ0gsIGNoYW5uZWw6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShtc2csIGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107IC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovXG4gICAgICAgIGZvciAodmFyIF9pID0gMCAvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqLzsgX2kgPCBhcmd1bWVudHMubGVuZ3RoIC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovOyBfaSsrIC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07IC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovXG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NMaXN0ZW5lckFyZ3MoYXJncyksIGV2ZW50ID0gX2FbMF0sIGxpc3RlbmVyID0gX2FbMV0sIGNhbGxiYWNrID0gX2FbMl07XG4gICAgICAgIGlmICghY2FsbGJhY2sgJiYgdGhpcy5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdzdWJzY3JpYmUnLCBbZXZlbnQsIGxpc3RlbmVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHRoaXMuaW52YWxpZFN0YXRlRXJyb3IoKSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbHRlcmVkXG4gICAgICAgIGlmIChldmVudCAmJiB0eXBlb2YgZXZlbnQgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlRmlsdGVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hdHRhY2goY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLl9zdWJzY3JpYmVGaWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgZmlsdGVyZWRMaXN0ZW5lciA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgIHZhciBtYXBwaW5nID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IG0ubmFtZSxcbiAgICAgICAgICAgICAgICByZWZUaW1lc2VyaWFsOiAoX2IgPSAoX2EgPSBtLmV4dHJhcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRpbWVzZXJpYWwsXG4gICAgICAgICAgICAgICAgcmVmVHlwZTogKF9kID0gKF9jID0gbS5leHRyYXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZWYpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50eXBlLFxuICAgICAgICAgICAgICAgIGlzUmVmOiAhISgoX2YgPSAoX2UgPSBtLmV4dHJhcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnJlZikgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnRpbWVzZXJpYWwpLFxuICAgICAgICAgICAgICAgIGNsaWVudElkOiBtLmNsaWVudElkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGFueSB2YWx1ZXMgYXJlIGRlZmluZWQgaW4gdGhlIGZpbHRlciBhbmQgaWYgdGhleSBtYXRjaCB0aGUgdmFsdWUgaW4gdGhlIG1lc3NhZ2Ugb2JqZWN0XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmVudHJpZXMoZmlsdGVyKS5maW5kKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfYVswXSwgdmFsdWUgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IG1hcHBpbmdba2V5XSAhPT0gdmFsdWUgOiBmYWxzZTtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdGVuZXIobSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2FkZEZpbHRlcmVkU3Vic2NyaXB0aW9uKGZpbHRlciwgbGlzdGVuZXIsIGZpbHRlcmVkTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMub24oZmlsdGVyZWRMaXN0ZW5lcik7XG4gICAgfTtcbiAgICAvLyBBZGRzIGEgbmV3IGZpbHRlcmVkIHN1YnNjcmlwdGlvblxuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuX2FkZEZpbHRlcmVkU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKGZpbHRlciwgcmVhbExpc3RlbmVyLCBmaWx0ZXJlZExpc3RlbmVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLmZpbHRlcmVkU3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmhhcyhyZWFsTGlzdGVuZXIpKSB7XG4gICAgICAgICAgICB2YXIgcmVhbExpc3RlbmVyTWFwID0gdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuZ2V0KHJlYWxMaXN0ZW5lcik7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGZpbHRlcmVkIGxpc3RlbmVyIHRvIHRoZSBtYXAsIG9yIGFwcGVuZCB0byB0aGUgYXJyYXkgaWYgdGhpcyBmaWx0ZXIgaGFzIGFscmVhZHkgYmVlbiB1c2VkXG4gICAgICAgICAgICByZWFsTGlzdGVuZXJNYXAuc2V0KGZpbHRlciwgKChfYSA9IHJlYWxMaXN0ZW5lck1hcCA9PT0gbnVsbCB8fCByZWFsTGlzdGVuZXJNYXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlYWxMaXN0ZW5lck1hcC5nZXQoZmlsdGVyKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmNhdChmaWx0ZXJlZExpc3RlbmVyKSkgfHwgW2ZpbHRlcmVkTGlzdGVuZXJdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRTdWJzY3JpcHRpb25zLnNldChyZWFsTGlzdGVuZXIsIG5ldyBNYXAoW1tmaWx0ZXIsIFtmaWx0ZXJlZExpc3RlbmVyXV1dKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuX2dldEFuZERlbGV0ZUZpbHRlcmVkU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uIChmaWx0ZXIsIHJlYWxMaXN0ZW5lcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBObyBmaWx0ZXJlZCBzdWJzY3JpcHRpb25zIG1hcCBtZWFucyB0aGVyZSBoYXMgYmVlbiBubyBmaWx0ZXJlZCBzdWJzY3JpcHRpb25zIHlldCwgc28gcmV0dXJuIG5vdGhpbmdcbiAgICAgICAgaWYgKCF0aGlzLmZpbHRlcmVkU3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgYSBmaWx0ZXIgaXMgcGFzc2VkIGluIHdpdGggbm8gc3BlY2lmaWMgbGlzdGVuZXJcbiAgICAgICAgaWYgKCFyZWFsTGlzdGVuZXIgJiYgZmlsdGVyKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gZWFjaCBsaXN0ZW5lciB3aGljaCBpcyBhdHRhY2hlZCB0byB0aGUgc3BlY2lmaWVkIGZpbHRlciBvYmplY3RcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmVudHJpZXMoKSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBfYjtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2FbMF0sIGZpbHRlck1hcHMgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgKHRoZW4gZGVsZXRlKSB0aGUgbWFwcyBtYXRjaGluZyB0aGlzIGZpbHRlclxuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lck1hcHMgPSBmaWx0ZXJNYXBzLmdldChmaWx0ZXIpO1xuICAgICAgICAgICAgICAgIGZpbHRlck1hcHMuZGVsZXRlKGZpbHRlcik7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIHBhcmVudCBpZiBub3RoaW5nIGlzIGxlZnRcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyTWFwcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYiA9IF90aGlzLmZpbHRlcmVkU3Vic2NyaXB0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXJNYXBzO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjdXIgPyAoX2EgPSBwcmV2KS5jb25jYXQuYXBwbHkoX2EsIGN1cikgOiBwcmV2KTtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBzdWJzY3JpcHRpb25zIGZvciB0aGlzIGxpc3RlbmVyXG4gICAgICAgIGlmICghcmVhbExpc3RlbmVyIHx8ICF0aGlzLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5oYXMocmVhbExpc3RlbmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWFsTGlzdGVuZXJNYXAgPSB0aGlzLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5nZXQocmVhbExpc3RlbmVyKTtcbiAgICAgICAgLy8gSWYgbm8gZmlsdGVyIGlzIHNwZWNpZmllZCByZXR1cm4gYWxsIGxpc3RlbmVycyB1c2luZyB0aGF0IGZ1bmN0aW9uXG4gICAgICAgIGlmICghZmlsdGVyKSB7XG4gICAgICAgICAgICAvLyBhcnJheS5mbGF0IGlzIG5vdCBhdmFpbGFibGUgdW5sZXNzIHdlIHN1cHBvcnQgZXMyMDE5IG9yIGhpZ2hlclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVyc18xID0gQXJyYXkuZnJvbShyZWFsTGlzdGVuZXJNYXAudmFsdWVzKCkpLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7IHJldHVybiBwcmV2LmNvbmNhdC5hcHBseShwcmV2LCBjdXIpOyB9LCBbXSk7XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIGxpc3RlbmVyIGZyb20gdGhlIG1hcFxuICAgICAgICAgICAgdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuZGVsZXRlKHJlYWxMaXN0ZW5lcik7XG4gICAgICAgICAgICByZXR1cm4gbGlzdGVuZXJzXzE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHJlYWxMaXN0ZW5lck1hcC5nZXQoZmlsdGVyKTtcbiAgICAgICAgcmVhbExpc3RlbmVyTWFwLmRlbGV0ZShmaWx0ZXIpO1xuICAgICAgICByZXR1cm4gbGlzdGVuZXJzIHx8IFtdO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgYXJncyA9IFtdOyAvKiBbZXZlbnRdLCBsaXN0ZW5lciAqL1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAgLyogW2V2ZW50XSwgbGlzdGVuZXIgKi87IF9pIDwgYXJndW1lbnRzLmxlbmd0aCAvKiBbZXZlbnRdLCBsaXN0ZW5lciAqLzsgX2krKyAvKiBbZXZlbnRdLCBsaXN0ZW5lciAqLykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldOyAvKiBbZXZlbnRdLCBsaXN0ZW5lciAqL1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYiA9IFJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzKGFyZ3MpLCBldmVudCA9IF9iWzBdLCBsaXN0ZW5lciA9IF9iWzFdO1xuICAgICAgICAvLyBJZiB3ZSBlaXRoZXIgaGF2ZSBhIGZpbHRlcmVkIGxpc3RlbmVyLCBhIGZpbHRlciBvciBib3RoIHdlIG5lZWQgdG8gZG8gYWRkaXRpb25hbCBwcm9jZXNzaW5nIHRvIGZpbmQgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uKHMpXG4gICAgICAgIGlmICgodHlwZW9mIGV2ZW50ID09PSAnb2JqZWN0JyAmJiAhbGlzdGVuZXIpIHx8ICgoX2EgPSB0aGlzLmZpbHRlcmVkU3Vic2NyaXB0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhcyhsaXN0ZW5lcikpKSB7XG4gICAgICAgICAgICB0aGlzLl9nZXRBbmREZWxldGVGaWx0ZXJlZFN1YnNjcmlwdGlvbnMoZXZlbnQsIGxpc3RlbmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7IHJldHVybiBfdGhpcy5zdWJzY3JpcHRpb25zLm9mZihsKTsgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiBjaGVjayBwcmVjb25kaXRpb25zICovXG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnaW5pdGlhbGl6ZWQnOlxuICAgICAgICAgICAgY2FzZSAnZGV0YWNoaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ2RldGFjaGVkJzpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygnVW5hYmxlIHRvIHN5bmMgdG8gY2hhbm5lbDsgbm90IGF0dGFjaGVkJywgNDAwMDApO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyO1xuICAgICAgICBpZiAoIWNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgICAgICAgIHRocm93IGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogc2VuZCBzeW5jIHJlcXVlc3QgKi9cbiAgICAgICAgdmFyIHN5bmNNZXNzYWdlID0gcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHsgYWN0aW9uOiBhY3Rpb25zLlNZTkMsIGNoYW5uZWw6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgaWYgKHRoaXMuc3luY0NoYW5uZWxTZXJpYWwpIHtcbiAgICAgICAgICAgIHN5bmNNZXNzYWdlLmNoYW5uZWxTZXJpYWwgPSB0aGlzLnN5bmNDaGFubmVsU2VyaWFsO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoc3luY01lc3NhZ2UpO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uIChtc2csIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc2VuZChtc2csIHRoaXMucmVhbHRpbWUub3B0aW9ucy5xdWV1ZU1lc3NhZ2VzLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnNlbmRQcmVzZW5jZSA9IGZ1bmN0aW9uIChwcmVzZW5jZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG1zZyA9IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbnMuUFJFU0VOQ0UsXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBwcmVzZW5jZTogVXRpbHMuaXNBcnJheShwcmVzZW5jZSlcbiAgICAgICAgICAgICAgICA/IHByZXNlbmNlbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlc0FycmF5KHByZXNlbmNlKVxuICAgICAgICAgICAgICAgIDogW3ByZXNlbmNlbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyhwcmVzZW5jZSldLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShtc2csIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUub25NZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYWN0aW9uID09PSBhY3Rpb25zLkFUVEFDSEVEIHx8XG4gICAgICAgICAgICBtZXNzYWdlLmFjdGlvbiA9PT0gYWN0aW9ucy5NRVNTQUdFIHx8XG4gICAgICAgICAgICBtZXNzYWdlLmFjdGlvbiA9PT0gYWN0aW9ucy5QUkVTRU5DRSkge1xuICAgICAgICAgICAgLy8gUlRMMTViXG4gICAgICAgICAgICB0aGlzLnNldENoYW5uZWxTZXJpYWwobWVzc2FnZS5jaGFubmVsU2VyaWFsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3luY0NoYW5uZWxTZXJpYWwsIGlzU3luYyA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UuYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIGFjdGlvbnMuQVRUQUNIRUQ6IHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsID0gbWVzc2FnZS5jaGFubmVsU2VyaWFsO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vZGUgPSBtZXNzYWdlLmdldE1vZGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcyA9IG1lc3NhZ2UucGFyYW1zIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciBtb2Rlc0Zyb21GbGFncyA9IG1lc3NhZ2UuZGVjb2RlTW9kZXNGcm9tRmxhZ3MoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVzID0gKG1vZGVzRnJvbUZsYWdzICYmIFV0aWxzLmFsbFRvTG93ZXJDYXNlKG1vZGVzRnJvbUZsYWdzKSkgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bWVkID0gbWVzc2FnZS5oYXNGbGFnKCdSRVNVTUVEJyk7XG4gICAgICAgICAgICAgICAgdmFyIGhhc1ByZXNlbmNlID0gbWVzc2FnZS5oYXNGbGFnKCdIQVNfUFJFU0VOQ0UnKTtcbiAgICAgICAgICAgICAgICB2YXIgaGFzQmFja2xvZyA9IG1lc3NhZ2UuaGFzRmxhZygnSEFTX0JBQ0tMT0cnKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2F0dGFjaGVkJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VtZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIE9uIGEgbG9zcyBvZiBjb250aW51aXR5LCB0aGUgcHJlc2VuY2Ugc2V0IG5lZWRzIHRvIGJlIHJlLXN5bmNlZCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmVzZW5jZS5vbkF0dGFjaGVkKGhhc1ByZXNlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlID0gbmV3IGNoYW5uZWxzdGF0ZWNoYW5nZV8xLmRlZmF1bHQodGhpcy5zdGF0ZSwgdGhpcy5zdGF0ZSwgcmVzdW1lZCwgaGFzQmFja2xvZywgbWVzc2FnZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLmVtaXQoJ3VwZGF0ZScsIGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdW1lZCB8fCB0aGlzLmNoYW5uZWxPcHRpb25zLnVwZGF0ZU9uQXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgY2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAnZGV0YWNoaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvKiBSVEw1aTogcmUtc2VuZCBERVRBQ0ggYW5kIHJlbWFpbiBpbiB0aGUgJ2RldGFjaGluZycgc3RhdGUgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSgnYXR0YWNoZWQnLCBtZXNzYWdlLmVycm9yLCByZXN1bWVkLCBoYXNQcmVzZW5jZSwgaGFzQmFja2xvZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLkRFVEFDSEVEOiB7XG4gICAgICAgICAgICAgICAgdmFyIGRldGFjaEVyciA9IG1lc3NhZ2UuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMobWVzc2FnZS5lcnJvcilcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnQ2hhbm5lbCBkZXRhY2hlZCcsIDkwMDAxLCA0MDQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnZGV0YWNoaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKCdkZXRhY2hlZCcsIGRldGFjaEVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICdhdHRhY2hpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIE9ubHkgcmV0cnkgaW1tZWRpYXRlbHkgaWYgd2Ugd2VyZSBwcmV2aW91c2x5IGF0dGFjaGVkLiBJZiB3ZSB3ZXJlXG4gICAgICAgICAgICAgICAgICAgICAqIGF0dGFjaGluZywgZ28gaW50byBzdXNwZW5kZWQsIGZhaWwgbWVzc2FnZXMsIGFuZCB3YWl0IGEgZmV3IHNlY29uZHNcbiAgICAgICAgICAgICAgICAgICAgICogYmVmb3JlIHJldHJ5aW5nICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoJ3N1c3BlbmRlZCcsIGRldGFjaEVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZSgnYXR0YWNoaW5nJywgZGV0YWNoRXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGFjdGlvbnMuU1lOQzpcbiAgICAgICAgICAgICAgICAvKiBzeW5jcyBjYW4gaGF2ZSBjaGFubmVsU2VyaWFscywgYnV0IG1pZ2h0IG5vdCBpZiB0aGUgc3luYyBpcyBvbmUgcGFnZSBsb25nICovXG4gICAgICAgICAgICAgICAgaXNTeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzeW5jQ2hhbm5lbFNlcmlhbCA9IHRoaXMuc3luY0NoYW5uZWxTZXJpYWwgPSBtZXNzYWdlLmNoYW5uZWxTZXJpYWw7XG4gICAgICAgICAgICAgICAgLyogc3luY3MgY2FuIGhhcHBlbiBvbiBjaGFubmVscyB3aXRoIG5vIHByZXNlbmNlIGRhdGEgYXMgcGFydCBvZiBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICogcmVzdW1pbmcsIGluIHdoaWNoIGNhc2UgcHJvdG9jb2wgbWVzc2FnZSBoYXMgbm8gcHJlc2VuY2UgcHJvcGVydHkgKi9cbiAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2UucHJlc2VuY2UpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIGFjdGlvbnMuUFJFU0VOQ0U6IHtcbiAgICAgICAgICAgICAgICB2YXIgcHJlc2VuY2UgPSBtZXNzYWdlLnByZXNlbmNlO1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IG1lc3NhZ2UuaWQsIGNvbm5lY3Rpb25JZCA9IG1lc3NhZ2UuY29ubmVjdGlvbklkLCB0aW1lc3RhbXAgPSBtZXNzYWdlLnRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuY2hhbm5lbE9wdGlvbnM7XG4gICAgICAgICAgICAgICAgdmFyIHByZXNlbmNlTXNnID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlc2VuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbmNlTXNnID0gcHJlc2VuY2VbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmRlY29kZShwcmVzZW5jZU1zZywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXNlbmNlTXNnLmNvbm5lY3Rpb25JZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZU1zZy5jb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXNlbmNlTXNnLnRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZU1zZy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXNlbmNlTXNnLmlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbmNlTXNnLmlkID0gaWQgKyAnOicgKyBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbk1lc3NhZ2UoKScsIGUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVzZW5jZS5zZXRQcmVzZW5jZShwcmVzZW5jZSwgaXNTeW5jLCBzeW5jQ2hhbm5lbFNlcmlhbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGFjdGlvbnMuTUVTU0FHRToge1xuICAgICAgICAgICAgICAgIC8vUlRMMTdcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ2F0dGFjaGVkJykge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NQUpPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbk1lc3NhZ2UoKScsICdNZXNzYWdlIFwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcIiBza2lwcGVkIGFzIHRoaXMgY2hhbm5lbCBcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcIiBzdGF0ZSBpcyBub3QgXCJhdHRhY2hlZFwiIChzdGF0ZSBpcyBcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXCIpLicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlcyA9IG1lc3NhZ2UubWVzc2FnZXMsIGZpcnN0TWVzc2FnZSA9IG1lc3NhZ2VzWzBdLCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdLCBpZCA9IG1lc3NhZ2UuaWQsIGNvbm5lY3Rpb25JZCA9IG1lc3NhZ2UuY29ubmVjdGlvbklkLCB0aW1lc3RhbXAgPSBtZXNzYWdlLnRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RNZXNzYWdlLmV4dHJhcyAmJlxuICAgICAgICAgICAgICAgICAgICBmaXJzdE1lc3NhZ2UuZXh0cmFzLmRlbHRhICYmXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0TWVzc2FnZS5leHRyYXMuZGVsdGEuZnJvbSAhPT0gdGhpcy5fbGFzdFBheWxvYWQubWVzc2FnZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnRGVsdGEgbWVzc2FnZSBkZWNvZGUgZmFpbHVyZSAtIHByZXZpb3VzIG1lc3NhZ2Ugbm90IGF2YWlsYWJsZSBmb3IgbWVzc2FnZSBcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXCIgb24gdGhpcyBjaGFubmVsIFwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1wiLic7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uTWVzc2FnZSgpJywgbXNnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnREZWNvZGVGYWlsdXJlUmVjb3ZlcnkobmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA0MDAxOCwgNDAwKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBtZXNzYWdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VfMS5kZWZhdWx0LmRlY29kZShtc2csIHRoaXMuX2RlY29kaW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGRlY3J5cHQgZmFpbGVkIC4uIHRoZSBtb3N0IGxpa2VseSBjYXVzZSBpcyB0aGF0IHdlIGhhdmUgdGhlIHdyb25nIGtleSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCBlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQwMDE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkZWNvZGUgZmFpbHVyZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydERlY29kZUZhaWx1cmVSZWNvdmVyeShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDAwMTk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogTm8gdmNkaWZmIHBsdWdpbiBwYXNzZWQgaW4gLSBubyBwb2ludCByZWNvdmVyaW5nLCBnaXZlIHVwICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MDAyMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGRlbHRhcywgc2ltaWxhcmx5IG5vIHBvaW50IHJlY292ZXJpbmcgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSgnZmFpbGVkJywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1zZy5jb25uZWN0aW9uSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1zZy50aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1zZy5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZy5pZCA9IGlkICsgJzonICsgaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFBheWxvYWQubWVzc2FnZUlkID0gbGFzdE1lc3NhZ2UuaWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFBheWxvYWQucHJvdG9jb2xNZXNzYWdlQ2hhbm5lbFNlcmlhbCA9IG1lc3NhZ2UuY2hhbm5lbFNlcmlhbDtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRXZlbnQobWVzc2FnZXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLkVSUk9SOiB7XG4gICAgICAgICAgICAgICAgLyogdGhlcmUgd2FzIGEgY2hhbm5lbC1zcGVjaWZpYyBlcnJvciAqL1xuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBtZXNzYWdlLmVycm9yO1xuICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT0gODAwMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogYXR0YWNoL2RldGFjaCBvcGVyYXRpb24gYXR0ZW1wdGVkIG9uIHN1cGVyc2VkZWQgdHJhbnNwb3J0IGhhbmRsZSAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKCdmYWlsZWQnLCBlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMoZXJyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbk1lc3NhZ2UoKScsICdGYXRhbCBwcm90b2NvbCBlcnJvcjogdW5yZWNvZ25pc2VkIGFjdGlvbiAoJyArIG1lc3NhZ2UuYWN0aW9uICsgJyknKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmFib3J0KGNvbm5lY3Rpb25lcnJvcnNfMS5kZWZhdWx0LnVua25vd25DaGFubmVsRXJyKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLl9zdGFydERlY29kZUZhaWx1cmVSZWNvdmVyeSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NQUpPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbk1lc3NhZ2UoKScsICdTdGFydGluZyBkZWNvZGUgZmFpbHVyZSByZWNvdmVyeSBwcm9jZXNzLicpO1xuICAgICAgICAgICAgdGhpcy5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9hdHRhY2godHJ1ZSwgcmVhc29uLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLm9uQXR0YWNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uQXR0YWNoZWQnLCAnYWN0aXZhdGluZyBjaGFubmVsOyBuYW1lID0gJyArIHRoaXMubmFtZSk7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLm5vdGlmeVN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCByZWFzb24sIHJlc3VtZWQsIGhhc1ByZXNlbmNlLCBoYXNCYWNrbG9nKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLm5vdGlmeVN0YXRlJywgJ25hbWUgPSAnICsgdGhpcy5uYW1lICsgJywgY3VycmVudCBzdGF0ZSA9ICcgKyB0aGlzLnN0YXRlICsgJywgbm90aWZ5aW5nIHN0YXRlICcgKyBzdGF0ZSk7XG4gICAgICAgIHRoaXMuY2xlYXJTdGF0ZVRpbWVyKCk7XG4gICAgICAgIC8vIFJUUDVhMVxuICAgICAgICBpZiAoVXRpbHMuYXJySW4oWydkZXRhY2hlZCcsICdzdXNwZW5kZWQnLCAnZmFpbGVkJ10sIHN0YXRlKSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gdGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlc2VuY2UuYWN0T25DaGFubmVsU3RhdGUoc3RhdGUsIGhhc1ByZXNlbmNlLCByZWFzb24pO1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdzdXNwZW5kZWQnICYmIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc2VuZEV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5zdGFydFJldHJ5VGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsUmV0cnlUaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFzb24pIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JSZWFzb24gPSByZWFzb247XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYW5nZSA9IG5ldyBjaGFubmVsc3RhdGVjaGFuZ2VfMS5kZWZhdWx0KHRoaXMuc3RhdGUsIHN0YXRlLCByZXN1bWVkLCBoYXNCYWNrbG9nLCByZWFzb24pO1xuICAgICAgICB2YXIgbG9nTGV2ZWwgPSBzdGF0ZSA9PT0gJ2ZhaWxlZCcgPyBsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiA6IGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01BSk9SO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dMZXZlbCwgJ0NoYW5uZWwgc3RhdGUgZm9yIGNoYW5uZWwgXCInICsgdGhpcy5uYW1lICsgJ1wiJywgc3RhdGUgKyAocmVhc29uID8gJzsgcmVhc29uOiAnICsgcmVhc29uIDogJycpKTtcbiAgICAgICAgaWYgKHN0YXRlICE9PSAnYXR0YWNoaW5nJyAmJiBzdGF0ZSAhPT0gJ3N1c3BlbmRlZCcpIHtcbiAgICAgICAgICAgIHRoaXMucmV0cnlDb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyogTm90ZTogd2UgZG9uJ3Qgc2V0IGluUHJvZ3Jlc3MgZm9yIHBlbmRpbmcgc3RhdGVzIHVudGlsIHRoZSByZXF1ZXN0IGlzIGFjdHVhbGx5IGluIHByb2dyZXNzICovXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2F0dGFjaGVkJykge1xuICAgICAgICAgICAgdGhpcy5vbkF0dGFjaGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09PSAnYXR0YWNoZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9hdHRhY2hSZXN1bWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAnZGV0YWNoaW5nJyB8fCBzdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaFJlc3VtZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5fYWxsQ2hhbm5lbENoYW5nZXMuZW1pdChzdGF0ZSwgY2hhbmdlKTtcbiAgICAgICAgdGhpcy5lbWl0KHN0YXRlLCBjaGFuZ2UpO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5yZXF1ZXN0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHJlYXNvbikge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5yZXF1ZXN0U3RhdGUnLCAnbmFtZSA9ICcgKyB0aGlzLm5hbWUgKyAnLCBzdGF0ZSA9ICcgKyBzdGF0ZSk7XG4gICAgICAgIHRoaXMubm90aWZ5U3RhdGUoc3RhdGUsIHJlYXNvbik7XG4gICAgICAgIC8qIHNlbmQgdGhlIGV2ZW50IGFuZCBhd2FpdCByZXNwb25zZSAqL1xuICAgICAgICB0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmNoZWNrUGVuZGluZ1N0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiBpZiBjYW4ndCBzZW5kIGV2ZW50cywgZG8gbm90aGluZyAqL1xuICAgICAgICB2YXIgY21TdGF0ZSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGU7XG4gICAgICAgIC8qIEFsbG93IGF0dGFjaCBtZXNzYWdlcyB0byBxdWV1ZSB1cCB3aGVuIHN5bmNocm9uaXppbmcsIHNpbmNlIHRoaXMgd2lsbCBiZVxuICAgICAgICAgKiB0aGUgc3RhdGUgd2UnbGwgYmUgaW4gd2hlbiB1cGdyYWRlIHRyYW5zcG9ydC5hY3RpdmUgdHJpZ2dlcnMgYSBjaGVja3BlbmRpbmdzdGF0ZSAqL1xuICAgICAgICBpZiAoIShjbVN0YXRlLnNlbmRFdmVudHMgfHwgY21TdGF0ZS5mb3JjZVF1ZXVlRXZlbnRzKSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGUnLCAnc2VuZEV2ZW50cyBpcyBmYWxzZTsgc3RhdGUgaXMgJyArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLmNoZWNrUGVuZGluZ1N0YXRlJywgJ25hbWUgPSAnICsgdGhpcy5uYW1lICsgJywgc3RhdGUgPSAnICsgdGhpcy5zdGF0ZSk7XG4gICAgICAgIC8qIE9ubHkgc3RhcnQgdGhlIHN0YXRlIHRpbWVyIHJ1bm5pbmcgd2hlbiBhY3R1YWxseSBzZW5kaW5nIHRoZSBldmVudCAqL1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2F0dGFjaGluZyc6XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaEltcGwoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RldGFjaGluZyc6XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaEltcGwoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2F0dGFjaGVkJzpcbiAgICAgICAgICAgICAgICAvKiByZXN1bWUgYW55IHN5bmMgb3BlcmF0aW9uIHRoYXQgd2FzIGluIHByb2dyZXNzICovXG4gICAgICAgICAgICAgICAgdGhpcy5zeW5jKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnRpbWVvdXRQZW5kaW5nU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnYXR0YWNoaW5nJzoge1xuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnQ2hhbm5lbCBhdHRhY2ggdGltZWQgb3V0JywgOTAwMDcsIDQwOCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSgnc3VzcGVuZGVkJywgZXJyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2RldGFjaGluZyc6IHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0NoYW5uZWwgZGV0YWNoIHRpbWVkIG91dCcsIDkwMDA3LCA0MDgpO1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoJ2F0dGFjaGVkJywgZXJyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlVGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZycsICd0aW1lciBleHBpcmVkJyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGVUaW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgX3RoaXMudGltZW91dFBlbmRpbmdTdGF0ZSgpO1xuICAgICAgICAgICAgfSwgdGhpcy5yZWFsdGltZS5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmNsZWFyU3RhdGVUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlVGltZXIgPSB0aGlzLnN0YXRlVGltZXI7XG4gICAgICAgIGlmIChzdGF0ZVRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoc3RhdGVUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnN0YXJ0UmV0cnlUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMucmV0cnlUaW1lcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yZXRyeUNvdW50Kys7XG4gICAgICAgIHZhciByZXRyeURlbGF5ID0gVXRpbHMuZ2V0UmV0cnlUaW1lKHRoaXMucmVhbHRpbWUub3B0aW9ucy50aW1lb3V0cy5jaGFubmVsUmV0cnlUaW1lb3V0LCB0aGlzLnJldHJ5Q291bnQpO1xuICAgICAgICB0aGlzLnJldHJ5VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8qIElmIGNvbm5lY3Rpb24gaXMgbm90IGNvbm5lY3RlZCwganVzdCBsZWF2ZSBpbiBzdXNwZW5kZWQsIGEgcmVhdHRhY2hcbiAgICAgICAgICAgICAqIHdpbGwgYmUgdHJpZ2dlcmVkIG9uY2UgaXQgY29ubmVjdHMgYWdhaW4gKi9cbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcgJiYgX3RoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc2VuZEV2ZW50cykge1xuICAgICAgICAgICAgICAgIF90aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsIHJldHJ5IHRpbWVyIGV4cGlyZWQnLCAnYXR0ZW1wdGluZyBhIG5ldyBhdHRhY2gnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXF1ZXN0U3RhdGUoJ2F0dGFjaGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCByZXRyeURlbGF5KTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuY2FuY2VsUmV0cnlUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmV0cnlUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiBAcmV0dXJucyBudWxsIChpZiBjYW4gc2FmZWx5IGJlIHJlbGVhc2VkKSB8IEVycm9ySW5mbyAoaWYgY2Fubm90KSAqL1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuZ2V0UmVsZWFzZUVyciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAocyA9PT0gJ2luaXRpYWxpemVkJyB8fCBzID09PSAnZGV0YWNoZWQnIHx8IHMgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0NhbiBvbmx5IHJlbGVhc2UgYSBjaGFubmVsIGluIGEgc3RhdGUgd2hlcmUgdGhlcmUgaXMgbm8gcG9zc2liaWxpdHkgb2YgZnVydGhlciB1cGRhdGVzIGZyb20gdGhlIHNlcnZlciBiZWluZyByZWNlaXZlZCAoaW5pdGlhbGl6ZWQsIGRldGFjaGVkLCBvciBmYWlsZWQpOyB3YXMgJyArXG4gICAgICAgICAgICBzLCA5MDAwMSwgNDAwKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc2V0Q2hhbm5lbFNlcmlhbCA9IGZ1bmN0aW9uIChjaGFubmVsU2VyaWFsKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLnNldENoYW5uZWxTZXJpYWwoKScsICdVcGRhdGluZyBjaGFubmVsIHNlcmlhbDsgc2VyaWFsID0gJyArIGNoYW5uZWxTZXJpYWwgKyAnOyBwcmV2aW91cyA9ICcgKyB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCk7XG4gICAgICAgIC8vIFJUUDE3aDogT25seSB1cGRhdGUgdGhlIGNoYW5uZWwgc2VyaWFsIGlmIGl0cyBwcmVzZW50IChpdCB3b24ndCBhbHdheXNcbiAgICAgICAgLy8gYmUgc2V0KS5cbiAgICAgICAgaWYgKGNoYW5uZWxTZXJpYWwpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5jaGFubmVsU2VyaWFsID0gY2hhbm5lbFNlcmlhbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJlYWx0aW1lQ2hhbm5lbDtcbn0oY2hhbm5lbF8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlYWx0aW1lQ2hhbm5lbDtcblxuXG4vKioqLyB9KSxcbi8qIDM5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2hhbm5lbFN0YXRlQ2hhbmdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYW5uZWxTdGF0ZUNoYW5nZShwcmV2aW91cywgY3VycmVudCwgcmVzdW1lZCwgaGFzQmFja2xvZywgcmVhc29uKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09ICdhdHRhY2hlZCcpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdW1lZCA9IHJlc3VtZWQ7XG4gICAgICAgICAgICB0aGlzLmhhc0JhY2tsb2cgPSBoYXNCYWNrbG9nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFzb24pXG4gICAgICAgICAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB9XG4gICAgcmV0dXJuIENoYW5uZWxTdGF0ZUNoYW5nZTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDaGFubmVsU3RhdGVDaGFuZ2U7XG5cblxuLyoqKi8gfSksXG4vKiA0MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3Rcblx0ICAgIHZhciBXID0gW107XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTEgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEExID0gQ19hbGdvLlNIQTEgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KFtcblx0ICAgICAgICAgICAgICAgIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksXG5cdCAgICAgICAgICAgICAgICAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LFxuXHQgICAgICAgICAgICAgICAgMHhjM2QyZTFmMFxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBiID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XG5cdCAgICAgICAgICAgIHZhciBlID0gSFs0XTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDgwOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMTYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gTVtvZmZzZXQgKyBpXSB8IDA7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XTtcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gKG4gPDwgMSkgfCAobiA+Pj4gMzEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB2YXIgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZSArIFdbaV07XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IDIwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoKGIgJiBjKSB8ICh+YiAmIGQpKSArIDB4NWE4Mjc5OTk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPCA0MCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKGIgXiBjIF4gZCkgKyAweDZlZDllYmExO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgNjApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9ICgoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCkpIC0gMHg3MGU0NDMyNDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAoaSA8IDgwKSAqLyB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoYiBeIGMgXiBkKSAtIDB4MzU5ZDNlMmE7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGUgPSBkO1xuXHQgICAgICAgICAgICAgICAgZCA9IGM7XG5cdCAgICAgICAgICAgICAgICBjID0gKGIgPDwgMzApIHwgKGIgPj4+IDIpO1xuXHQgICAgICAgICAgICAgICAgYiA9IGE7XG5cdCAgICAgICAgICAgICAgICBhID0gdDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICAgICAgSFs0XSA9IChIWzRdICsgZSkgfCAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEExKCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEExKHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuU0hBMSA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTEpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTEobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjU0hBMSA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEExKTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEExO1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogNDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGluc3BlY3QoYnVmZmVyKSB7XG4gICAgaWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgdmFyIHZpZXc7XG4gICAgdmFyIHR5cGU7XG4gICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHR5cGUgPSAnQXJyYXlCdWZmZXInO1xuICAgICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgICAgIHR5cGUgPSAnRGF0YVZpZXcnO1xuICAgICAgICB2aWV3ID0gYnVmZmVyO1xuICAgIH1cbiAgICBpZiAoIXZpZXcpXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShidWZmZXIpO1xuICAgIHZhciBieXRlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA+IDIwKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKCcuLi4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBieXRlXyA9IHZpZXcuZ2V0VWludDgoaSkudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoYnl0ZV8ubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgYnl0ZV8gPSAnMCcgKyBieXRlXztcbiAgICAgICAgYnl0ZXMucHVzaChieXRlXyk7XG4gICAgfVxuICAgIHJldHVybiAnPCcgKyB0eXBlICsgJyAnICsgYnl0ZXMuam9pbignICcpICsgJz4nO1xufVxuLy8gRW5jb2RlIHN0cmluZyBhcyB1dGY4IGludG8gZGF0YXZpZXcgYXQgb2Zmc2V0XG5mdW5jdGlvbiB1dGY4V3JpdGUodmlldywgb2Zmc2V0LCBzdHJpbmcpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBPbmUgYnl0ZSBvZiBVVEYtOFxuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgKChjb2RlUG9pbnQgPj4+IDApICYgMHg3ZikgfCAweDAwKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFR3byBieXRlcyBvZiBVVEYtOFxuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssICgoY29kZVBvaW50ID4+PiA2KSAmIDB4MWYpIHwgMHhjMCk7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAoKGNvZGVQb2ludCA+Pj4gMCkgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhyZWUgYnl0ZXMgb2YgVVRGLTguXG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAoKGNvZGVQb2ludCA+Pj4gMTIpICYgMHgwZikgfCAweGUwKTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssICgoY29kZVBvaW50ID4+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAoKGNvZGVQb2ludCA+Pj4gMCkgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm91ciBieXRlcyBvZiBVVEYtOFxuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssICgoY29kZVBvaW50ID4+PiAxOCkgJiAweDA3KSB8IDB4ZjApO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgKChjb2RlUG9pbnQgPj4+IDEyKSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAoKGNvZGVQb2ludCA+Pj4gNikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgKChjb2RlUG9pbnQgPj4+IDApICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGNvZGVwb2ludCAnICsgY29kZVBvaW50KTtcbiAgICB9XG59XG5mdW5jdGlvbiB1dGY4UmVhZCh2aWV3LCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIHZhciBzdHJpbmcgPSAnJztcbiAgICBmb3IgKHZhciBpID0gb2Zmc2V0LCBlbmQgPSBvZmZzZXQgKyBsZW5ndGg7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICB2YXIgYnl0ZV8gPSB2aWV3LmdldFVpbnQ4KGkpO1xuICAgICAgICAvLyBPbmUgYnl0ZSBjaGFyYWN0ZXJcbiAgICAgICAgaWYgKChieXRlXyAmIDB4ODApID09PSAweDAwKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlXyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUd28gYnl0ZSBjaGFyYWN0ZXJcbiAgICAgICAgaWYgKChieXRlXyAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGJ5dGVfICYgMHgwZikgPDwgNikgfCAodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhyZWUgYnl0ZSBjaGFyYWN0ZXJcbiAgICAgICAgaWYgKChieXRlXyAmIDB4ZjApID09PSAweGUwKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGJ5dGVfICYgMHgwZikgPDwgMTIpIHwgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCA2KSB8ICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgMCkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm91ciBieXRlIGNoYXJhY3RlclxuICAgICAgICBpZiAoKGJ5dGVfICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYnl0ZV8gJiAweDA3KSA8PCAxOCkgfFxuICAgICAgICAgICAgICAgICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgMTIpIHxcbiAgICAgICAgICAgICAgICAoKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpIDw8IDYpIHxcbiAgICAgICAgICAgICAgICAoKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpIDw8IDApKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlICcgKyBieXRlXy50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nO1xufVxuZnVuY3Rpb24gdXRmOEJ5dGVDb3VudChzdHJpbmcpIHtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3RyaW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICAgICAgICBjb3VudCArPSAyO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIGNvdW50ICs9IDM7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgIGNvdW50ICs9IDQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBjb2RlcG9pbnQgJyArIGNvZGVQb2ludCk7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIGVuY29kZSh2YWx1ZSwgc3BhcnNlKSB7XG4gICAgdmFyIHNpemUgPSBzaXplb2YodmFsdWUsIHNwYXJzZSk7XG4gICAgaWYgKHNpemUgPT09IDApXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihzaXplKTtcbiAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIF9lbmNvZGUodmFsdWUsIHZpZXcsIDAsIHNwYXJzZSk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbnZhciBTSF9MXzMyID0gKDEgPDwgMTYpICogKDEgPDwgMTYpLCBTSF9SXzMyID0gMSAvIFNIX0xfMzI7XG5mdW5jdGlvbiBnZXRJbnQ2NCh2aWV3LCBvZmZzZXQpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICByZXR1cm4gdmlldy5nZXRJbnQzMihvZmZzZXQpICogU0hfTF8zMiArIHZpZXcuZ2V0VWludDMyKG9mZnNldCArIDQpO1xufVxuZnVuY3Rpb24gZ2V0VWludDY0KHZpZXcsIG9mZnNldCkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgIHJldHVybiB2aWV3LmdldFVpbnQzMihvZmZzZXQpICogU0hfTF8zMiArIHZpZXcuZ2V0VWludDMyKG9mZnNldCArIDQpO1xufVxuZnVuY3Rpb24gc2V0SW50NjQodmlldywgb2Zmc2V0LCB2YWwpIHtcbiAgICBpZiAodmFsIDwgMHg4MDAwMDAwMDAwMDAwMDAwKSB7XG4gICAgICAgIHZpZXcuc2V0SW50MzIob2Zmc2V0LCBNYXRoLmZsb29yKHZhbCAqIFNIX1JfMzIpKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMihvZmZzZXQgKyA0LCB2YWwgJiAtMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIDB4N2ZmZmZmZmYpO1xuICAgICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQgKyA0LCAweDdmZmZmZmZmKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRVaW50NjQodmlldywgb2Zmc2V0LCB2YWwpIHtcbiAgICBpZiAodmFsIDwgMHgxMDAwMDAwMDAwMDAwMDAwMCkge1xuICAgICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIE1hdGguZmxvb3IodmFsICogU0hfUl8zMikpO1xuICAgICAgICB2aWV3LnNldEludDMyKG9mZnNldCArIDQsIHZhbCAmIC0xKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgMHhmZmZmZmZmZik7XG4gICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCArIDQsIDB4ZmZmZmZmZmYpO1xuICAgIH1cbn1cbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2Zyc3l1a2kvNTQzMjU1OSAtIHY1IHNwZWNcbi8vXG4vLyBJJ3ZlIHVzZWQgb25lIGV4dGVuc2lvbiBwb2ludCBmcm9tIGBmaXhleHQgMWAgdG8gc3RvcmUgYHVuZGVmaW5lZGAuIE9uIHRoZSB3aXJlIHRoaXNcbi8vIHNob3VsZCB0cmFuc2xhdGUgdG8gZXhhY3RseSAweGQ0MDAwMFxuLy9cbi8vICstLS0tLS0tLSstLS0tLS0tLSstLS0tLS0tLStcbi8vIHwgIDB4ZDQgIHwgIDB4MDAgIHwgIDB4MDAgIHxcbi8vICstLS0tLS0tLSstLS0tLS0tLSstLS0tLS0tLStcbi8vICAgIF4gZml4ZXh0IHwgICAgICAgIF4gdmFsdWUgcGFydCB1bnVzZWQgKGZpeGVkIHRvIGJlIDApXG4vLyAgICAgICAgICAgICBeIGluZGljYXRlcyB1bmRlZmluZWQgdmFsdWVcbi8vXG52YXIgRGVjb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWNvZGVyKHZpZXcsIG9mZnNldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm1hcCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfdGhpcy5wYXJzZSgpO1xuICAgICAgICAgICAgICAgIHZhbHVlW2tleV0gPSBfdGhpcy5wYXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJpbiA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5ldyBBcnJheUJ1ZmZlcihsZW5ndGgpO1xuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkodmFsdWUpLnNldChuZXcgVWludDhBcnJheShfdGhpcy52aWV3LmJ1ZmZlciwgX3RoaXMub2Zmc2V0LCBsZW5ndGgpLCAwKTtcbiAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSBsZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYnVmID0gdGhpcy5iaW47XG4gICAgICAgIHRoaXMuc3RyID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdXRmOFJlYWQoX3RoaXMudmlldywgX3RoaXMub2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hcnJheSA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhbHVlW2ldID0gX3RoaXMucGFyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5leHQgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBfdGhpcy52aWV3LmdldEludDgoX3RoaXMub2Zmc2V0KSxcbiAgICAgICAgICAgICAgICBkYXRhOiBfdGhpcy5idWYobGVuZ3RoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGFyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IF90aGlzLnZpZXcuZ2V0VWludDgoX3RoaXMub2Zmc2V0KTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSwgbGVuZ3RoO1xuICAgICAgICAgICAgLy8gUG9zaXRpdmUgRml4SW50IC0gMHh4eHh4eHhcbiAgICAgICAgICAgIGlmICgodHlwZSAmIDB4ODApID09PSAweDAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaXhNYXAgLSAxMDAweHh4eFxuICAgICAgICAgICAgaWYgKCh0eXBlICYgMHhmMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB0eXBlICYgMHgwZjtcbiAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubWFwKGxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaXhBcnJheSAtIDEwMDF4eHh4XG4gICAgICAgICAgICBpZiAoKHR5cGUgJiAweGYwKSA9PT0gMHg5MCkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHR5cGUgJiAweDBmO1xuICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5hcnJheShsZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRml4U3RyIC0gMTAxeHh4eHhcbiAgICAgICAgICAgIGlmICgodHlwZSAmIDB4ZTApID09PSAweGEwKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdHlwZSAmIDB4MWY7XG4gICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnN0cihsZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTmVnYXRpdmUgRml4SW50IC0gMTExeHh4eHhcbiAgICAgICAgICAgIGlmICgodHlwZSAmIDB4ZTApID09PSAweGUwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy52aWV3LmdldEludDgoX3RoaXMub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBuaWxcbiAgICAgICAgICAgICAgICBjYXNlIDB4YzA6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyAweGMxIG5ldmVyIHVzZWQgLSB1c2UgZm9yIHVuZGVmaW5lZCAoTk9OLVNUQU5EQVJEKVxuICAgICAgICAgICAgICAgIGNhc2UgMHhjMTpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgLy8gZmFsc2VcbiAgICAgICAgICAgICAgICBjYXNlIDB4YzI6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gdHJ1ZVxuICAgICAgICAgICAgICAgIGNhc2UgMHhjMzpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGJpbiA4XG4gICAgICAgICAgICAgICAgY2FzZSAweGM0OlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBfdGhpcy52aWV3LmdldFVpbnQ4KF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmJpbihsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIGJpbiAxNlxuICAgICAgICAgICAgICAgIGNhc2UgMHhjNTpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX3RoaXMudmlldy5nZXRVaW50MTYoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYmluKGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gYmluIDMyXG4gICAgICAgICAgICAgICAgY2FzZSAweGM2OlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBfdGhpcy52aWV3LmdldFVpbnQzMihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5iaW4obGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBleHQgOFxuICAgICAgICAgICAgICAgIGNhc2UgMHhjNzpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX3RoaXMudmlldy5nZXRVaW50OChfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5leHQobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBleHQgMTZcbiAgICAgICAgICAgICAgICBjYXNlIDB4Yzg6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IF90aGlzLnZpZXcuZ2V0VWludDE2KF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV4dChsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIGV4dCAzMlxuICAgICAgICAgICAgICAgIGNhc2UgMHhjOTpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX3RoaXMudmlldy5nZXRVaW50MzIoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gZmxvYXQgMzJcbiAgICAgICAgICAgICAgICBjYXNlIDB4Y2E6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMudmlldy5nZXRGbG9hdDMyKF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIGZsb2F0IDY0XG4gICAgICAgICAgICAgICAgY2FzZSAweGNiOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnZpZXcuZ2V0RmxvYXQ2NChfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyB1aW50OFxuICAgICAgICAgICAgICAgIGNhc2UgMHhjYzpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy52aWV3LmdldFVpbnQ4KF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIHVpbnQgMTZcbiAgICAgICAgICAgICAgICBjYXNlIDB4Y2Q6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMudmlldy5nZXRVaW50MTYoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gdWludCAzMlxuICAgICAgICAgICAgICAgIGNhc2UgMHhjZTpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy52aWV3LmdldFVpbnQzMihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyB1aW50IDY0XG4gICAgICAgICAgICAgICAgY2FzZSAweGNmOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldFVpbnQ2NChfdGhpcy52aWV3LCBfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyBpbnQgOFxuICAgICAgICAgICAgICAgIGNhc2UgMHhkMDpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy52aWV3LmdldEludDgoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gaW50IDE2XG4gICAgICAgICAgICAgICAgY2FzZSAweGQxOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnZpZXcuZ2V0SW50MTYoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gaW50IDMyXG4gICAgICAgICAgICAgICAgY2FzZSAweGQyOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnZpZXcuZ2V0SW50MzIoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gaW50IDY0XG4gICAgICAgICAgICAgICAgY2FzZSAweGQzOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldEludDY0KF90aGlzLnZpZXcsIF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gOTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIGZpeGV4dCAxXG4gICAgICAgICAgICAgICAgY2FzZSAweGQ0OlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV4dChsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIGZpeGV4dCAyXG4gICAgICAgICAgICAgICAgY2FzZSAweGQ1OlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSAyO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV4dChsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIGZpeGV4dCA0XG4gICAgICAgICAgICAgICAgY2FzZSAweGQ2OlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSA0O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV4dChsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIGZpeGV4dCA4XG4gICAgICAgICAgICAgICAgY2FzZSAweGQ3OlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSA4O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV4dChsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIGZpeGV4dCAxNlxuICAgICAgICAgICAgICAgIGNhc2UgMHhkODpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gMTY7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gc3RyOFxuICAgICAgICAgICAgICAgIGNhc2UgMHhkOTpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX3RoaXMudmlldy5nZXRVaW50OChfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zdHIobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBzdHIgMTZcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZGE6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IF90aGlzLnZpZXcuZ2V0VWludDE2KF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnN0cihsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIHN0ciAzMlxuICAgICAgICAgICAgICAgIGNhc2UgMHhkYjpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX3RoaXMudmlldy5nZXRVaW50MzIoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc3RyKGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gYXJyYXkgMTZcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZGM6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IF90aGlzLnZpZXcuZ2V0VWludDE2KF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gYXJyYXkgMzJcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZGQ6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IF90aGlzLnZpZXcuZ2V0VWludDMyKF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gbWFwIDE2XG4gICAgICAgICAgICAgICAgY2FzZSAweGRlOlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBfdGhpcy52aWV3LmdldFVpbnQxNihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5tYXAobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBtYXAgMzJcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZGY6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IF90aGlzLnZpZXcuZ2V0VWludDMyKF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm1hcChsZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGUgMHgnICsgdHlwZS50b1N0cmluZygxNikpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIH1cbiAgICByZXR1cm4gRGVjb2Rlcjtcbn0oKSk7XG5mdW5jdGlvbiBkZWNvZGUoYnVmZmVyKSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICB2YXIgZGVjb2RlciA9IG5ldyBEZWNvZGVyKHZpZXcpO1xuICAgIHZhciB2YWx1ZSA9IGRlY29kZXIucGFyc2UoKTtcbiAgICBpZiAoZGVjb2Rlci5vZmZzZXQgIT09IGJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYnVmZmVyLmJ5dGVMZW5ndGggLSBkZWNvZGVyLm9mZnNldCArICcgdHJhaWxpbmcgYnl0ZXMnKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBlbmNvZGVhYmxlS2V5cyh2YWx1ZSwgc3BhcnNlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHZhbCA9IHZhbHVlW2VdLCB0eXBlID0gdHlwZW9mIHZhbDtcbiAgICAgICAgcmV0dXJuICghc3BhcnNlIHx8ICh2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09IG51bGwpKSAmJiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZSB8fCAhIXZhbC50b0pTT04pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gX2VuY29kZSh2YWx1ZSwgdmlldywgb2Zmc2V0LCBzcGFyc2UpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAvLyBTdHJpbmdzIEJ5dGVzXG4gICAgLy8gVGhlcmUgYXJlIGZvdXIgc3RyaW5nIHR5cGVzOiBmaXhzdHIvc3RyOC9zdHIxNi9zdHIzMlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBsZW5ndGhfMSA9IHV0ZjhCeXRlQ291bnQodmFsdWUpO1xuICAgICAgICAvLyBmaXhzdHJcbiAgICAgICAgaWYgKGxlbmd0aF8xIDwgMHgyMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIGxlbmd0aF8xIHwgMHhhMCk7XG4gICAgICAgICAgICB1dGY4V3JpdGUodmlldywgb2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIDEgKyBsZW5ndGhfMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdHI4XG4gICAgICAgIGlmIChsZW5ndGhfMSA8IDB4MTAwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkOSk7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIDEsIGxlbmd0aF8xKTtcbiAgICAgICAgICAgIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQgKyAyLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gMiArIGxlbmd0aF8xO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0cjE2XG4gICAgICAgIGlmIChsZW5ndGhfMSA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGRhKTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDE2KG9mZnNldCArIDEsIGxlbmd0aF8xKTtcbiAgICAgICAgICAgIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQgKyAzLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gMyArIGxlbmd0aF8xO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0cjMyXG4gICAgICAgIGlmIChsZW5ndGhfMSA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkYik7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQgKyAxLCBsZW5ndGhfMSk7XG4gICAgICAgICAgICB1dGY4V3JpdGUodmlldywgb2Zmc2V0ICsgNSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIDUgKyBsZW5ndGhfMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3ICYmIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICAgICAgLy8gZXh0cmFjdCB0aGUgYXJyYXlidWZmZXIgYW5kIGZhbGx0aHJvdWdoXG4gICAgICAgIHZhbHVlID0gdmFsdWUuYnVmZmVyO1xuICAgIH1cbiAgICAvLyBUaGVyZSBhcmUgdGhyZWUgYmluIHR5cGVzOiBiaW44L2JpbjE2L2JpbjMyXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdmFyIGxlbmd0aF8yID0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgLy8gYmluOFxuICAgICAgICBpZiAobGVuZ3RoXzIgPCAweDEwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4YzQpO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQgKyAxLCBsZW5ndGhfMik7XG4gICAgICAgICAgICBuZXcgVWludDhBcnJheSh2aWV3LmJ1ZmZlcikuc2V0KG5ldyBVaW50OEFycmF5KHZhbHVlKSwgb2Zmc2V0ICsgMik7XG4gICAgICAgICAgICByZXR1cm4gMiArIGxlbmd0aF8yO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJpbjE2XG4gICAgICAgIGlmIChsZW5ndGhfMiA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGM1KTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDE2KG9mZnNldCArIDEsIGxlbmd0aF8yKTtcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHZpZXcuYnVmZmVyKS5zZXQobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCBvZmZzZXQgKyAzKTtcbiAgICAgICAgICAgIHJldHVybiAzICsgbGVuZ3RoXzI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmluIDMyXG4gICAgICAgIGlmIChsZW5ndGhfMiA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjNik7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQgKyAxLCBsZW5ndGhfMik7XG4gICAgICAgICAgICBuZXcgVWludDhBcnJheSh2aWV3LmJ1ZmZlcikuc2V0KG5ldyBVaW50OEFycmF5KHZhbHVlKSwgb2Zmc2V0ICsgNSk7XG4gICAgICAgICAgICByZXR1cm4gNSArIGxlbmd0aF8yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIEZsb2F0aW5nIFBvaW50XG4gICAgICAgIC8vIE5PVEU6IFdlJ3JlIGFsd2F5cyB1c2luZyBmbG9hdDY0XG4gICAgICAgIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGNiKTtcbiAgICAgICAgICAgIHZpZXcuc2V0RmxvYXQ2NChvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnRlZ2Vyc1xuICAgICAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgLy8gcG9zaXRpdmUgZml4bnVtXG4gICAgICAgICAgICBpZiAodmFsdWUgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVpbnQgOFxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHgxMDApIHtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjYyk7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1aW50IDE2XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4Y2QpO1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDE2KG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVpbnQgMzJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4Y2UpO1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVpbnQgNjRcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4MTAwMDAwMDAwMDAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjZik7XG4gICAgICAgICAgICAgICAgc2V0VWludDY0KHZpZXcsIG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIHRvbyBiaWcgMHgnICsgdmFsdWUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZWdhdGl2ZSBmaXhudW1cbiAgICAgICAgaWYgKHZhbHVlID49IC0weDIwKSB7XG4gICAgICAgICAgICB2aWV3LnNldEludDgob2Zmc2V0LCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbnQgOFxuICAgICAgICBpZiAodmFsdWUgPj0gLTB4ODApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGQwKTtcbiAgICAgICAgICAgIHZpZXcuc2V0SW50OChvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbnQgMTZcbiAgICAgICAgaWYgKHZhbHVlID49IC0weDgwMDApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGQxKTtcbiAgICAgICAgICAgIHZpZXcuc2V0SW50MTYob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW50IDMyXG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMHg4MDAwMDAwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDIpO1xuICAgICAgICAgICAgdmlldy5zZXRJbnQzMihvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbnQgNjRcbiAgICAgICAgaWYgKHZhbHVlID49IC0weDgwMDAwMDAwMDAwMDAwMDApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGQzKTtcbiAgICAgICAgICAgIHNldEludDY0KHZpZXcsIG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIHRvbyBzbWFsbCAtMHgnICsgKC12YWx1ZSkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG4gICAgfVxuICAgIC8vIHVuZGVmaW5lZCAtIHVzZSBkNCAoTk9OLVNUQU5EQVJEKVxuICAgIGlmICh0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoc3BhcnNlKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGQ0KTtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQgKyAxLCAweDAwKTtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQgKyAyLCAweDAwKTtcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgfVxuICAgIC8vIG51bGxcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNwYXJzZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjMCk7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICAvLyBCb29sZWFuXG4gICAgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgdmFsdWUgPyAweGMzIDogMHhjMik7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHZhbHVlLnRvSlNPTilcbiAgICAgICAgcmV0dXJuIF9lbmNvZGUodmFsdWUudG9KU09OKCksIHZpZXcsIG9mZnNldCwgc3BhcnNlKTtcbiAgICAvLyBDb250YWluZXIgVHlwZXNcbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIGxlbmd0aF8zLCBzaXplID0gMDtcbiAgICAgICAgdmFyIGtleXMgPSB2b2lkIDA7XG4gICAgICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICBsZW5ndGhfMyA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGtleXMgPSBlbmNvZGVhYmxlS2V5cyh2YWx1ZSwgc3BhcnNlKTtcbiAgICAgICAgICAgIGxlbmd0aF8zID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aF8zIDwgMHgxMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIGxlbmd0aF8zIHwgKGlzQXJyYXkgPyAweDkwIDogMHg4MCkpO1xuICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoXzMgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgaXNBcnJheSA/IDB4ZGMgOiAweGRlKTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDE2KG9mZnNldCArIDEsIGxlbmd0aF8zKTtcbiAgICAgICAgICAgIHNpemUgPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aF8zIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCBpc0FycmF5ID8gMHhkZCA6IDB4ZGYpO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgMSwgbGVuZ3RoXzMpO1xuICAgICAgICAgICAgc2l6ZSA9IDU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoXzM7IGkrKykge1xuICAgICAgICAgICAgICAgIHNpemUgKz0gX2VuY29kZSh2YWx1ZVtpXSwgdmlldywgb2Zmc2V0ICsgc2l6ZSwgc3BhcnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXlzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aF8zOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBzaXplICs9IF9lbmNvZGUoa2V5LCB2aWV3LCBvZmZzZXQgKyBzaXplKTtcbiAgICAgICAgICAgICAgICBzaXplICs9IF9lbmNvZGUodmFsdWVba2V5XSwgdmlldywgb2Zmc2V0ICsgc2l6ZSwgc3BhcnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiAwO1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlICcgKyB0eXBlKTtcbn1cbmZ1bmN0aW9uIHNpemVvZih2YWx1ZSwgc3BhcnNlKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgLy8gZml4c3RyIG9yIHN0cjggb3Igc3RyMTYgb3Igc3RyMzJcbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGxlbmd0aF80ID0gdXRmOEJ5dGVDb3VudCh2YWx1ZSk7XG4gICAgICAgIGlmIChsZW5ndGhfNCA8IDB4MjApIHtcbiAgICAgICAgICAgIHJldHVybiAxICsgbGVuZ3RoXzQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aF80IDwgMHgxMDApIHtcbiAgICAgICAgICAgIHJldHVybiAyICsgbGVuZ3RoXzQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aF80IDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgcmV0dXJuIDMgKyBsZW5ndGhfNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoXzQgPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgcmV0dXJuIDUgKyBsZW5ndGhfNDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3ICYmIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICAgICAgLy8gZXh0cmFjdCB0aGUgYXJyYXlidWZmZXIgYW5kIGZhbGx0aHJvdWdoXG4gICAgICAgIHZhbHVlID0gdmFsdWUuYnVmZmVyO1xuICAgIH1cbiAgICAvLyBiaW44IG9yIGJpbjE2IG9yIGJpbjMyXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdmFyIGxlbmd0aF81ID0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aF81IDwgMHgxMDApIHtcbiAgICAgICAgICAgIHJldHVybiAyICsgbGVuZ3RoXzU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aF81IDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgcmV0dXJuIDMgKyBsZW5ndGhfNTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoXzUgPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgcmV0dXJuIDUgKyBsZW5ndGhfNTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBGbG9hdGluZyBQb2ludCAoMzIgYml0cylcbiAgICAgICAgLy8gZG91YmxlXG4gICAgICAgIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgLy8gSW50ZWdlcnNcbiAgICAgICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgICAgIC8vIHBvc2l0aXZlIGZpeGludFxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHg4MClcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIC8vIHVpbnQgOFxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHgxMDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICAvLyB1aW50IDE2XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAweDEwMDAwKVxuICAgICAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAgICAgLy8gdWludCAzMlxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHgxMDAwMDAwMDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgICAgICAvLyB1aW50IDY0XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAweDEwMDAwMDAwMDAwMDAwMDAwKVxuICAgICAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICAgICAgLy8gVG9vIGJpZ1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgdG9vIGJpZyAweCcgKyB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5lZ2F0aXZlIGZpeGludFxuICAgICAgICBpZiAodmFsdWUgPj0gLTB4MjApXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgLy8gaW50IDhcbiAgICAgICAgaWYgKHZhbHVlID49IC0weDgwKVxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIC8vIGludCAxNlxuICAgICAgICBpZiAodmFsdWUgPj0gLTB4ODAwMClcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAvLyBpbnQgMzJcbiAgICAgICAgaWYgKHZhbHVlID49IC0weDgwMDAwMDAwKVxuICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgIC8vIGludCA2NFxuICAgICAgICBpZiAodmFsdWUgPj0gLTB4ODAwMDAwMDAwMDAwMDAwMClcbiAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICAvLyBUb28gc21hbGxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgdG9vIHNtYWxsIC0weCcgKyB2YWx1ZS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbiAgICB9XG4gICAgLy8gQm9vbGVhblxuICAgIGlmICh0eXBlID09PSAnYm9vbGVhbicpXG4gICAgICAgIHJldHVybiAxO1xuICAgIC8vIHVuZGVmaW5lZCwgbnVsbFxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHNwYXJzZSA/IDAgOiAxO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gc3BhcnNlID8gMCA6IDM7XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiB2YWx1ZS50b0pTT04pXG4gICAgICAgIHJldHVybiBzaXplb2YodmFsdWUudG9KU09OKCksIHNwYXJzZSk7XG4gICAgLy8gQ29udGFpbmVyIFR5cGVzXG4gICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBsZW5ndGhfNiwgc2l6ZSA9IDA7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgbGVuZ3RoXzYgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aF82OyBpKyspIHtcbiAgICAgICAgICAgICAgICBzaXplICs9IHNpemVvZih2YWx1ZVtpXSwgc3BhcnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gZW5jb2RlYWJsZUtleXModmFsdWUsIHNwYXJzZSk7XG4gICAgICAgICAgICBsZW5ndGhfNiA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGhfNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgc2l6ZSArPSBzaXplb2Yoa2V5KSArIHNpemVvZih2YWx1ZVtrZXldLCBzcGFyc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGhfNiA8IDB4MTApIHtcbiAgICAgICAgICAgIHJldHVybiAxICsgc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoXzYgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMyArIHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aF82IDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgIHJldHVybiA1ICsgc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5IG9yIG9iamVjdCB0b28gbG9uZyAweCcgKyBsZW5ndGhfNi50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGUgJyArIHR5cGUpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZTogZGVjb2RlLFxuICAgIGluc3BlY3Q6IGluc3BlY3QsXG4gICAgdXRmOFdyaXRlOiB1dGY4V3JpdGUsXG4gICAgdXRmOFJlYWQ6IHV0ZjhSZWFkLFxuICAgIHV0ZjhCeXRlQ291bnQ6IHV0ZjhCeXRlQ291bnQsXG59O1xuXG5cbi8qKiovIH0pLFxuLyogNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8vIENvbW1vblxudmFyIHJlc3RfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzApKTtcbnZhciByZWFsdGltZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg1MCkpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbi8vIFBsYXRmb3JtIFNwZWNpZmljXG52YXIgYnVmZmVydXRpbHNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNTUpKTtcbi8vIEB0cy1pZ25vcmVcbnZhciBjcnlwdG9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNTcpKTtcbnZhciBodHRwXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKSk7XG52YXIgY29uZmlnXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KSk7XG4vLyBAdHMtaWdub3JlXG52YXIgdHJhbnNwb3J0XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBkZWZhdWx0c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbnZhciB3ZWJzdG9yYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KSk7XG52YXIgZGVmYXVsdHNfMiA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNjYpKTtcbnZhciBtc2dwYWNrXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKSk7XG52YXIgQ3J5cHRvID0gKDAsIGNyeXB0b18xLmRlZmF1bHQpKGNvbmZpZ18xLmRlZmF1bHQsIGJ1ZmZlcnV0aWxzXzEuZGVmYXVsdCk7XG5wbGF0Zm9ybV8xLmRlZmF1bHQuQ3J5cHRvID0gQ3J5cHRvO1xucGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzID0gYnVmZmVydXRpbHNfMS5kZWZhdWx0O1xucGxhdGZvcm1fMS5kZWZhdWx0Lkh0dHAgPSBodHRwXzEuZGVmYXVsdDtcbnBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcgPSBjb25maWdfMS5kZWZhdWx0O1xucGxhdGZvcm1fMS5kZWZhdWx0LlRyYW5zcG9ydHMgPSB0cmFuc3BvcnRfMS5kZWZhdWx0O1xucGxhdGZvcm1fMS5kZWZhdWx0LldlYlN0b3JhZ2UgPSB3ZWJzdG9yYWdlXzEuZGVmYXVsdDtcbnJlc3RfMS5kZWZhdWx0LkNyeXB0byA9IENyeXB0bztcbnJlYWx0aW1lXzEuZGVmYXVsdC5DcnlwdG8gPSBDcnlwdG87XG5sb2dnZXJfMS5kZWZhdWx0LmluaXRMb2dIYW5kbGVycygpO1xucGxhdGZvcm1fMS5kZWZhdWx0LkRlZmF1bHRzID0gKDAsIGRlZmF1bHRzXzEuZ2V0RGVmYXVsdHMpKGRlZmF1bHRzXzIuZGVmYXVsdCk7XG5pZiAocGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5hZ2VudCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuRGVmYXVsdHMuYWdlbnQgKz0gJyAnICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5hZ2VudDtcbn1cbi8qIElmIHVzaW5nIElFOCwgZG9uJ3QgYXR0ZW1wdCB0byB1cGdyYWRlIGZyb20geGhyX3BvbGxpbmcgdG8geGhyX3N0cmVhbWluZyAtXG4gKiB3aGlsZSBpdCBjYW4gZG8gc3RyZWFtaW5nLCB0aGUgbG93IG1heCBodHRwLWNvbm5lY3Rpb25zLXBlci1ob3N0IGxpbWl0IG1lYW5zXG4gKiB0aGF0IHRoZSBwb2xsaW5nIHRyYW5zcG9ydCBpcyBjcmlwcGxlZCBkdXJpbmcgdGhlIHVwZ3JhZGUgcHJvY2Vzcy4gU28ganVzdFxuICogbGVhdmUgaXQgYXQgdGhlIGJhc2UgdHJhbnNwb3J0ICovXG5pZiAocGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5ub1VwZ3JhZGUpIHtcbiAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuRGVmYXVsdHMudXBncmFkZVRyYW5zcG9ydHMgPSBbXTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBSZXN0OiByZXN0XzEuZGVmYXVsdCxcbiAgICBSZWFsdGltZTogcmVhbHRpbWVfMS5kZWZhdWx0LFxuICAgIG1zZ3BhY2s6IG1zZ3BhY2tfMS5kZWZhdWx0LFxufTtcblxuXG4vKioqLyB9KSxcbi8qIDQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTi5wYXJzZShcIntcXFwibmFtZVxcXCI6XFxcImFibHlcXFwiLFxcXCJkZXNjcmlwdGlvblxcXCI6XFxcIlJlYWx0aW1lIGNsaWVudCBsaWJyYXJ5IGZvciBBYmx5LCB0aGUgcmVhbHRpbWUgbWVzc2FnaW5nIHNlcnZpY2VcXFwiLFxcXCJ2ZXJzaW9uXFxcIjpcXFwiMS4yLjQzXFxcIixcXFwibGljZW5zZVxcXCI6XFxcIkFwYWNoZS0yLjBcXFwiLFxcXCJidWdzXFxcIjp7XFxcInVybFxcXCI6XFxcImh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5L2FibHktanMvaXNzdWVzXFxcIixcXFwiZW1haWxcXFwiOlxcXCJzdXBwb3J0QGFibHkuY29tXFxcIn0sXFxcIm1haW5cXFwiOlxcXCIuL2J1aWxkL2FibHktbm9kZS5qc1xcXCIsXFxcInR5cGluZ3NcXFwiOlxcXCIuL2FibHkuZC50c1xcXCIsXFxcInJlYWN0LW5hdGl2ZVxcXCI6e1xcXCIuL2J1aWxkL2FibHktbm9kZS5qc1xcXCI6XFxcIi4vYnVpbGQvYWJseS1yZWFjdG5hdGl2ZS5qc1xcXCJ9LFxcXCJicm93c2VyXFxcIjp7XFxcIi4vYnVpbGQvYWJseS1ub2RlLmpzXFxcIjpcXFwiLi9idWlsZC9hYmx5LWNvbW1vbmpzLmpzXFxcIn0sXFxcImZpbGVzXFxcIjpbXFxcImJ1aWxkLyoqXFxcIixcXFwiYWJseS5kLnRzXFxcIixcXFwiY2FsbGJhY2tzLmQudHNcXFwiLFxcXCJjYWxsYmFja3MuanNcXFwiLFxcXCJwcm9taXNlcy5kLnRzXFxcIixcXFwicHJvbWlzZXMuanNcXFwiLFxcXCJyZXNvdXJjZXMvKipcXFwiXSxcXFwiZGVwZW5kZW5jaWVzXFxcIjp7XFxcIkBhYmx5L21zZ3BhY2stanNcXFwiOlxcXCJeMC40LjBcXFwiLFxcXCJnb3RcXFwiOlxcXCJeMTEuOC41XFxcIixcXFwid3NcXFwiOlxcXCJeNS4xXFxcIn0sXFxcImRldkRlcGVuZGVuY2llc1xcXCI6e1xcXCJAYWJseS92Y2RpZmYtZGVjb2RlclxcXCI6XFxcIjEuMC40XFxcIixcXFwiQHR5cGVzL2NyeXB0by1qc1xcXCI6XFxcIl40LjAuMVxcXCIsXFxcIkB0eXBlcy9ub2RlXFxcIjpcXFwiXjE1LjAuMFxcXCIsXFxcIkB0eXBlcy9yZXF1ZXN0XFxcIjpcXFwiXjIuNDguN1xcXCIsXFxcIkB0eXBlcy93c1xcXCI6XFxcIl44LjIuMFxcXCIsXFxcIkB0eXBlc2NyaXB0LWVzbGludC9lc2xpbnQtcGx1Z2luXFxcIjpcXFwiXjUuMTQuMFxcXCIsXFxcIkB0eXBlc2NyaXB0LWVzbGludC9wYXJzZXJcXFwiOlxcXCJeNS4xNC4wXFxcIixcXFwiYXN5bmNcXFwiOlxcXCJhYmx5LWZvcmtzL2FzeW5jI3JlcXVpcmVqc1xcXCIsXFxcImF3cy1zZGtcXFwiOlxcXCJeMi4xNDEzLjBcXFwiLFxcXCJjaGFpXFxcIjpcXFwiXjQuMi4wXFxcIixcXFwiY29weS13ZWJwYWNrLXBsdWdpblxcXCI6XFxcIl42LjQuMVxcXCIsXFxcImNvcnNcXFwiOlxcXCJeMi44LjVcXFwiLFxcXCJjcnlwdG8tanNcXFwiOlxcXCJhYmx5LWZvcmtzL2NyeXB0by1qcyNjcnlwdG8tbGl0ZVxcXCIsXFxcImVzbGludFxcXCI6XFxcIl43LjEzLjBcXFwiLFxcXCJlc2xpbnQtcGx1Z2luLWpzZG9jXFxcIjpcXFwiXjQwLjAuMFxcXCIsXFxcImVzbGludC1wbHVnaW4tc2VjdXJpdHlcXFwiOlxcXCJeMS40LjBcXFwiLFxcXCJleHByZXNzXFxcIjpcXFwiXjQuMTcuMVxcXCIsXFxcImdsb2JcXFwiOlxcXCJ+NC40XFxcIixcXFwiZ29vZ2xlLWNsb3N1cmUtY29tcGlsZXJcXFwiOlxcXCJeMjAxODA2MTAuMC4xXFxcIixcXFwiZ3J1bnRcXFwiOlxcXCJeMS42LjFcXFwiLFxcXCJncnVudC1idW1wXFxcIjpcXFwiXjAuMy4xXFxcIixcXFwiZ3J1bnQtY2xpXFxcIjpcXFwifjEuMi4wXFxcIixcXFwiZ3J1bnQtY2xvc3VyZS10b29sc1xcXCI6XFxcIl4xLjAuMFxcXCIsXFxcImdydW50LWNvbnRyaWItY29uY2F0XFxcIjpcXFwifjAuNVxcXCIsXFxcImdydW50LXNoZWxsXFxcIjpcXFwifjEuMVxcXCIsXFxcImdydW50LXdlYnBhY2tcXFwiOlxcXCJeNC4wLjJcXFwiLFxcXCJoZXh5XFxcIjpcXFwifjAuMlxcXCIsXFxcImtleGVjXFxcIjpcXFwiYWJseS1mb3Jrcy9ub2RlLWtleGVjI3VwZGF0ZS1mb3Itbm9kZS0xMlxcXCIsXFxcIm1pbmltaXN0XFxcIjpcXFwiXjEuMi41XFxcIixcXFwibW9jaGFcXFwiOlxcXCJeOC4xLjNcXFwiLFxcXCJudWxsLWxvYWRlclxcXCI6XFxcIl40LjAuMVxcXCIsXFxcInBsYXl3cmlnaHRcXFwiOlxcXCJeMS4xMC4wXFxcIixcXFwicHJldHRpZXJcXFwiOlxcXCJeMi41LjFcXFwiLFxcXCJyZXF1aXJlanNcXFwiOlxcXCJ+Mi4xXFxcIixcXFwic2hlbGxqc1xcXCI6XFxcIn4wLjhcXFwiLFxcXCJzb3VyY2UtbWFwLWV4cGxvcmVyXFxcIjpcXFwiXjIuNS4yXFxcIixcXFwidHMtbG9hZGVyXFxcIjpcXFwiXjguMi4wXFxcIixcXFwidHNjb25maWctcGF0aHMtd2VicGFjay1wbHVnaW5cXFwiOlxcXCJeNC4wLjFcXFwiLFxcXCJ0c2xpYlxcXCI6XFxcIl4yLjMuMVxcXCIsXFxcInR5cGVkb2NcXFwiOlxcXCJeMC4yMy44XFxcIixcXFwidHlwZXNjcmlwdFxcXCI6XFxcIl40LjYuNFxcXCIsXFxcIndlYnBhY2tcXFwiOlxcXCJeNC40NC4yXFxcIixcXFwid2VicGFjay1jbGlcXFwiOlxcXCJeNC4yLjBcXFwifSxcXFwiZW5naW5lc1xcXCI6e1xcXCJub2RlXFxcIjpcXFwiPj01LjEwLnhcXFwifSxcXFwicmVwb3NpdG9yeVxcXCI6XFxcImFibHkvYWJseS1qc1xcXCIsXFxcImpzcG1cXFwiOntcXFwicmVnaXN0cnlcXFwiOlxcXCJucG1cXFwiLFxcXCJkaXJlY3Rvcmllc1xcXCI6e1xcXCJsaWJcXFwiOlxcXCJidWlsZFxcXCJ9LFxcXCJtYWluXFxcIjpcXFwiYWJseVxcXCJ9LFxcXCJzY3JpcHRzXFxcIjp7XFxcImdydW50XFxcIjpcXFwiZ3J1bnRcXFwiLFxcXCJ0ZXN0XFxcIjpcXFwiZ3J1bnQgdGVzdFxcXCIsXFxcInRlc3Q6bm9kZVxcXCI6XFxcImdydW50IHRlc3Q6bm9kZVxcXCIsXFxcInRlc3Q6bm9kZTpza2lwLWJ1aWxkXFxcIjpcXFwiZ3J1bnQgbW9jaGFcXFwiLFxcXCJ0ZXN0OndlYnNlcnZlclxcXCI6XFxcImdydW50IHRlc3Q6d2Vic2VydmVyXFxcIixcXFwidGVzdDpwbGF5d3JpZ2h0XFxcIjpcXFwibm9kZSB0ZXN0L3N1cHBvcnQvcnVuUGxheXdyaWdodFRlc3RzLmpzXFxcIixcXFwiY29uY2F0XFxcIjpcXFwiZ3J1bnQgY29uY2F0XFxcIixcXFwiYnVpbGRcXFwiOlxcXCJncnVudCBidWlsZDphbGxcXFwiLFxcXCJidWlsZDpub2RlXFxcIjpcXFwiZ3J1bnQgYnVpbGQ6bm9kZVxcXCIsXFxcImJ1aWxkOmJyb3dzZXJcXFwiOlxcXCJncnVudCBidWlsZDpicm93c2VyXFxcIixcXFwicmVxdWlyZWpzXFxcIjpcXFwiZ3J1bnQgcmVxdWlyZWpzXFxcIixcXFwibGludFxcXCI6XFxcImVzbGludCAuXFxcIixcXFwibGludDpmaXhcXFwiOlxcXCJlc2xpbnQgLS1maXggLlxcXCIsXFxcImNoZWNrLWNsb3N1cmUtY29tcGlsZXJcXFwiOlxcXCJncnVudCBjaGVjay1jbG9zdXJlLWNvbXBpbGVyXFxcIixcXFwicHJlcGFyZVxcXCI6XFxcIm5wbSBydW4gYnVpbGRcXFwiLFxcXCJmb3JtYXRcXFwiOlxcXCJwcmV0dGllciAtLXdyaXRlIC0taWdub3JlLXBhdGggLmdpdGlnbm9yZSAtLWlnbm9yZS1wYXRoIC5wcmV0dGllcmlnbm9yZSBzcmMgdGVzdCBhYmx5LmQudHMgd2VicGFjay5jb25maWcuanMgR3J1bnRmaWxlLmpzIHNjcmlwdHMvY2RuX2RlcGxveS5qcyBkb2NzL2Nocm9tZS1tdjMubWRcXFwiLFxcXCJmb3JtYXQ6Y2hlY2tcXFwiOlxcXCJwcmV0dGllciAtLWNoZWNrIC0taWdub3JlLXBhdGggLmdpdGlnbm9yZSAtLWlnbm9yZS1wYXRoIC5wcmV0dGllcmlnbm9yZSBzcmMgdGVzdCBhYmx5LmQudHMgd2VicGFjay5jb25maWcuanMgR3J1bnRmaWxlLmpzIHNjcmlwdHMvY2RuX2RlcGxveS5qc1xcXCIsXFxcInNvdXJjZW1hcFxcXCI6XFxcInNvdXJjZS1tYXAtZXhwbG9yZXIgYnVpbGQvYWJseS5taW4uanNcXFwiLFxcXCJzb3VyY2VtYXA6bm9lbmNyeXB0aW9uXFxcIjpcXFwic291cmNlLW1hcC1leHBsb3JlciBidWlsZC9hYmx5Lm5vZW5jcnlwdGlvbi5taW4uanNcXFwiLFxcXCJkb2NzXFxcIjpcXFwidHlwZWRvYyAtLWVudHJ5UG9pbnRzIGFibHkuZC50cyAtLW91dCBkb2NzL2dlbmVyYXRlZC9kZWZhdWx0IC0tcmVhZG1lIGRvY3MvbGFuZGluZy1wYWdlcy9kZWZhdWx0Lm1kICYmIHR5cGVkb2MgLS1lbnRyeVBvaW50cyBwcm9taXNlcy5kLnRzIC0tb3V0IGRvY3MvZ2VuZXJhdGVkL3Byb21pc2VzIC0tbmFtZSBcXFxcXFxcImFibHkgKFByb21pc2UtYmFzZWQpXFxcXFxcXCIgLS1yZWFkbWUgZG9jcy9sYW5kaW5nLXBhZ2VzL3Byb21pc2VzLm1kICYmIGNwIGRvY3MvbGFuZGluZy1wYWdlcy9jaG9vc2UtbGlicmFyeS5odG1sIGRvY3MvZ2VuZXJhdGVkL2luZGV4Lmh0bWxcXFwifX1cIik7XG5cbi8qKiovIH0pLFxuLyogNDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXG5cbi8qKiovIH0pLFxuLyogNDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKSwgX193ZWJwYWNrX3JlcXVpcmVfXygyNCkpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0cmV0dXJuIENyeXB0b0pTLkhtYWNTSEEyNTY7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiA0NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgZGV2aWNlZGV0YWlsc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0NykpO1xudmFyIHJlc291cmNlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSk7XG52YXIgcGFnaW5hdGVkcmVzb3VyY2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTkpKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KSk7XG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcbnZhciBQdXNoID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFB1c2gocmVzdCkge1xuICAgICAgICB0aGlzLnJlc3QgPSByZXN0O1xuICAgICAgICB0aGlzLmFkbWluID0gbmV3IEFkbWluKHJlc3QpO1xuICAgIH1cbiAgICByZXR1cm4gUHVzaDtcbn0oKSk7XG52YXIgQWRtaW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWRtaW4ocmVzdCkge1xuICAgICAgICB0aGlzLnJlc3QgPSByZXN0O1xuICAgICAgICB0aGlzLmRldmljZVJlZ2lzdHJhdGlvbnMgPSBuZXcgRGV2aWNlUmVnaXN0cmF0aW9ucyhyZXN0KTtcbiAgICAgICAgdGhpcy5jaGFubmVsU3Vic2NyaXB0aW9ucyA9IG5ldyBDaGFubmVsU3Vic2NyaXB0aW9ucyhyZXN0KTtcbiAgICB9XG4gICAgQWRtaW4ucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbiAocmVjaXBpZW50LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucmVzdDtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0UG9zdEhlYWRlcnMocmVzdC5vcHRpb25zLCBmb3JtYXQpLCBwYXJhbXMgPSB7fTtcbiAgICAgICAgdmFyIGJvZHkgPSBVdGlscy5taXhpbih7IHJlY2lwaWVudDogcmVjaXBpZW50IH0sIHBheWxvYWQpO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdwdWJsaXNoJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgICAgICAgVXRpbHMubWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiAndHJ1ZScgfSk7XG4gICAgICAgIHZhciByZXF1ZXN0Qm9keSA9IFV0aWxzLmVuY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LnBvc3QocmVzdCwgJy9wdXNoL3B1Ymxpc2gnLCByZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zLCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBBZG1pbjtcbn0oKSk7XG52YXIgRGV2aWNlUmVnaXN0cmF0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXZpY2VSZWdpc3RyYXRpb25zKHJlc3QpIHtcbiAgICAgICAgdGhpcy5yZXN0ID0gcmVzdDtcbiAgICB9XG4gICAgRGV2aWNlUmVnaXN0cmF0aW9ucy5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIChkZXZpY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5yZXN0O1xuICAgICAgICB2YXIgYm9keSA9IGRldmljZWRldGFpbHNfMS5kZWZhdWx0LmZyb21WYWx1ZXMoZGV2aWNlKTtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0UG9zdEhlYWRlcnMocmVzdC5vcHRpb25zLCBmb3JtYXQpLCBwYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnc2F2ZScsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBpZiAocmVzdC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgICAgICAgIFV0aWxzLm1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogJ3RydWUnIH0pO1xuICAgICAgICB2YXIgcmVxdWVzdEJvZHkgPSBVdGlscy5lbmNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdC5wdXQocmVzdCwgJy9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMvJyArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2UuaWQpLCByZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zLCBudWxsLCBmdW5jdGlvbiAoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCAhZXJyXG4gICAgICAgICAgICAgICAgPyBkZXZpY2VkZXRhaWxzXzEuZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIHVucGFja2VkID8gdW5kZWZpbmVkIDogZm9ybWF0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEZXZpY2VSZWdpc3RyYXRpb25zLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoZGV2aWNlSWRPckRldGFpbHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5yZXN0LCBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdEdldEhlYWRlcnMocmVzdC5vcHRpb25zLCBmb3JtYXQpLCBkZXZpY2VJZCA9IGRldmljZUlkT3JEZXRhaWxzLmlkIHx8IGRldmljZUlkT3JEZXRhaWxzO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdnZXQnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGV2aWNlSWQgIT09ICdzdHJpbmcnIHx8ICFkZXZpY2VJZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdGaXJzdCBhcmd1bWVudCB0byBEZXZpY2VSZWdpc3RyYXRpb25zI2dldCBtdXN0IGJlIGEgZGV2aWNlSWQgc3RyaW5nIG9yIERldmljZURldGFpbHMnLCA0MDAwMCwgNDAwKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQuZ2V0KHJlc3QsICcvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zLycgKyBlbmNvZGVVUklDb21wb25lbnQoZGV2aWNlSWQpLCBoZWFkZXJzLCB7fSwgbnVsbCwgZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgIWVyclxuICAgICAgICAgICAgICAgID8gZGV2aWNlZGV0YWlsc18xLmRlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShib2R5LCB1bnBhY2tlZCA/IHVuZGVmaW5lZCA6IGZvcm1hdClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGV2aWNlUmVnaXN0cmF0aW9ucy5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5yZXN0LCBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBlbnZlbG9wZSA9IHRoaXMucmVzdC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQsIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0R2V0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2xpc3QnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgbmV3IHBhZ2luYXRlZHJlc291cmNlXzEuZGVmYXVsdChyZXN0LCAnL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucycsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbiAoYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXZpY2VkZXRhaWxzXzEuZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIHVucGFja2VkID8gdW5kZWZpbmVkIDogZm9ybWF0KTtcbiAgICAgICAgfSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgRGV2aWNlUmVnaXN0cmF0aW9ucy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGRldmljZUlkT3JEZXRhaWxzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucmVzdCwgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzKHJlc3Qub3B0aW9ucywgZm9ybWF0KSwgcGFyYW1zID0ge30sIGRldmljZUlkID0gZGV2aWNlSWRPckRldGFpbHMuaWQgfHwgZGV2aWNlSWRPckRldGFpbHM7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3JlbW92ZScsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkZXZpY2VJZCAhPT0gJ3N0cmluZycgfHwgIWRldmljZUlkLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0ZpcnN0IGFyZ3VtZW50IHRvIERldmljZVJlZ2lzdHJhdGlvbnMjcmVtb3ZlIG11c3QgYmUgYSBkZXZpY2VJZCBzdHJpbmcgb3IgRGV2aWNlRGV0YWlscycsIDQwMDAwLCA0MDApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgICAgICAgVXRpbHMubWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiAndHJ1ZScgfSk7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdFsnZGVsZXRlJ10ocmVzdCwgJy9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMvJyArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2VJZCksIGhlYWRlcnMsIHBhcmFtcywgbnVsbCwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKTsgfSk7XG4gICAgfTtcbiAgICBEZXZpY2VSZWdpc3RyYXRpb25zLnByb3RvdHlwZS5yZW1vdmVXaGVyZSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5yZXN0LCBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdEdldEhlYWRlcnMocmVzdC5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdyZW1vdmVXaGVyZScsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBpZiAocmVzdC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgICAgICAgIFV0aWxzLm1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogJ3RydWUnIH0pO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHRbJ2RlbGV0ZSddKHJlc3QsICcvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zJywgaGVhZGVycywgcGFyYW1zLCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBEZXZpY2VSZWdpc3RyYXRpb25zO1xufSgpKTtcbnZhciBDaGFubmVsU3Vic2NyaXB0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDaGFubmVsU3Vic2NyaXB0aW9ucyhyZXN0KSB7XG4gICAgICAgIC8qIENoYW5uZWxTdWJzY3JpcHRpb25zIGhhdmUgbm8gdW5pcXVlIGlkOyByZW1vdmluZyBvbmUgaXMgZXF1aXZhbGVudCB0byByZW1vdmVXaGVyZSBieSBpdHMgcHJvcGVydGllcyAqL1xuICAgICAgICB0aGlzLnJlbW92ZSA9IENoYW5uZWxTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5yZW1vdmVXaGVyZTtcbiAgICAgICAgdGhpcy5yZXN0ID0gcmVzdDtcbiAgICB9XG4gICAgQ2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucmVzdDtcbiAgICAgICAgdmFyIGJvZHkgPSBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbl8xLmRlZmF1bHQuZnJvbVZhbHVlcyhzdWJzY3JpcHRpb24pO1xuICAgICAgICB2YXIgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRQb3N0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCksIHBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdzYXZlJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgICAgICAgVXRpbHMubWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiAndHJ1ZScgfSk7XG4gICAgICAgIHZhciByZXF1ZXN0Qm9keSA9IFV0aWxzLmVuY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LnBvc3QocmVzdCwgJy9wdXNoL2NoYW5uZWxTdWJzY3JpcHRpb25zJywgcmVxdWVzdEJvZHksIGhlYWRlcnMsIHBhcmFtcywgbnVsbCwgZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgIWVyciAmJiBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbl8xLmRlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShib2R5LCB1bnBhY2tlZCA/IHVuZGVmaW5lZCA6IGZvcm1hdCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoYW5uZWxTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnJlc3QsIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGVudmVsb3BlID0gdGhpcy5yZXN0Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzKHJlc3Qub3B0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnbGlzdCcsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfMS5kZWZhdWx0KHJlc3QsICcvcHVzaC9jaGFubmVsU3Vic2NyaXB0aW9ucycsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbiAoYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbl8xLmRlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShib2R5LCB1bnBhY2tlZCA/IHVuZGVmaW5lZCA6IGZvcm1hdCk7XG4gICAgICAgIH0pLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIENoYW5uZWxTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5yZW1vdmVXaGVyZSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5yZXN0LCBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdEdldEhlYWRlcnMocmVzdC5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdyZW1vdmVXaGVyZScsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBpZiAocmVzdC5vcHRpb25zLnB1c2hGdWxsV2FpdClcbiAgICAgICAgICAgIFV0aWxzLm1peGluKHBhcmFtcywgeyBmdWxsV2FpdDogJ3RydWUnIH0pO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHRbJ2RlbGV0ZSddKHJlc3QsICcvcHVzaC9jaGFubmVsU3Vic2NyaXB0aW9ucycsIGhlYWRlcnMsIHBhcmFtcywgbnVsbCwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKTsgfSk7XG4gICAgfTtcbiAgICBDaGFubmVsU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUubGlzdENoYW5uZWxzID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnJlc3QsIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGVudmVsb3BlID0gdGhpcy5yZXN0Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzKHJlc3Qub3B0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnbGlzdENoYW5uZWxzJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgICAgICAgVXRpbHMubWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiAndHJ1ZScgfSk7XG4gICAgICAgIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV8xLmRlZmF1bHQocmVzdCwgJy9wdXNoL2NoYW5uZWxzJywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uIChib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgdmFyIHBhcnNlZEJvZHkgPSAoIXVucGFja2VkICYmIGZvcm1hdCA/IFV0aWxzLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KSA6IGJvZHkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJzZWRCb2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkQm9keVtpXSA9IFN0cmluZyhwYXJzZWRCb2R5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRCb2R5O1xuICAgICAgICB9KS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhbm5lbFN1YnNjcmlwdGlvbnM7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUHVzaDtcblxuXG4vKioqLyB9KSxcbi8qIDQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIERldmljZUZvcm1GYWN0b3I7XG4oZnVuY3Rpb24gKERldmljZUZvcm1GYWN0b3IpIHtcbiAgICBEZXZpY2VGb3JtRmFjdG9yW1wiUGhvbmVcIl0gPSBcInBob25lXCI7XG4gICAgRGV2aWNlRm9ybUZhY3RvcltcIlRhYmxldFwiXSA9IFwidGFibGV0XCI7XG4gICAgRGV2aWNlRm9ybUZhY3RvcltcIkRlc2t0b3BcIl0gPSBcImRlc2t0b3BcIjtcbiAgICBEZXZpY2VGb3JtRmFjdG9yW1wiVFZcIl0gPSBcInR2XCI7XG4gICAgRGV2aWNlRm9ybUZhY3RvcltcIldhdGNoXCJdID0gXCJ3YXRjaFwiO1xuICAgIERldmljZUZvcm1GYWN0b3JbXCJDYXJcIl0gPSBcImNhclwiO1xuICAgIERldmljZUZvcm1GYWN0b3JbXCJFbWJlZGRlZFwiXSA9IFwiZW1iZWRkZWRcIjtcbiAgICBEZXZpY2VGb3JtRmFjdG9yW1wiT3RoZXJcIl0gPSBcIm90aGVyXCI7XG59KShEZXZpY2VGb3JtRmFjdG9yIHx8IChEZXZpY2VGb3JtRmFjdG9yID0ge30pKTtcbnZhciBEZXZpY2VQbGF0Zm9ybTtcbihmdW5jdGlvbiAoRGV2aWNlUGxhdGZvcm0pIHtcbiAgICBEZXZpY2VQbGF0Zm9ybVtcIkFuZHJvaWRcIl0gPSBcImFuZHJvaWRcIjtcbiAgICBEZXZpY2VQbGF0Zm9ybVtcIklPU1wiXSA9IFwiaW9zXCI7XG4gICAgRGV2aWNlUGxhdGZvcm1bXCJCcm93c2VyXCJdID0gXCJicm93c2VyXCI7XG59KShEZXZpY2VQbGF0Zm9ybSB8fCAoRGV2aWNlUGxhdGZvcm0gPSB7fSkpO1xudmFyIERldmljZURldGFpbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGV2aWNlRGV0YWlscygpIHtcbiAgICB9XG4gICAgRGV2aWNlRGV0YWlscy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgZGV2aWNlU2VjcmV0OiB0aGlzLmRldmljZVNlY3JldCxcbiAgICAgICAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgICAgICAgZm9ybUZhY3RvcjogdGhpcy5mb3JtRmFjdG9yLFxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgICAgICBtZXRhZGF0YTogdGhpcy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGRldmljZUlkZW50aXR5VG9rZW46IHRoaXMuZGV2aWNlSWRlbnRpdHlUb2tlbixcbiAgICAgICAgICAgIHB1c2g6IHtcbiAgICAgICAgICAgICAgICByZWNpcGllbnQ6IChfYSA9IHRoaXMucHVzaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlY2lwaWVudCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogKF9iID0gdGhpcy5wdXNoKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhdGUsXG4gICAgICAgICAgICAgICAgZXJyb3I6IChfYyA9IHRoaXMucHVzaCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmVycm9yLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIERldmljZURldGFpbHMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSAnW0RldmljZURldGFpbHMnO1xuICAgICAgICBpZiAodGhpcy5pZClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBpZD0nICsgdGhpcy5pZDtcbiAgICAgICAgaWYgKHRoaXMucGxhdGZvcm0pXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgcGxhdGZvcm09JyArIHRoaXMucGxhdGZvcm07XG4gICAgICAgIGlmICh0aGlzLmZvcm1GYWN0b3IpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgZm9ybUZhY3Rvcj0nICsgdGhpcy5mb3JtRmFjdG9yO1xuICAgICAgICBpZiAodGhpcy5jbGllbnRJZClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBjbGllbnRJZD0nICsgdGhpcy5jbGllbnRJZDtcbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgbWV0YWRhdGE9JyArIHRoaXMubWV0YWRhdGE7XG4gICAgICAgIGlmICh0aGlzLmRldmljZUlkZW50aXR5VG9rZW4pXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgZGV2aWNlSWRlbnRpdHlUb2tlbj0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5kZXZpY2VJZGVudGl0eVRva2VuKTtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMucHVzaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlY2lwaWVudClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBwdXNoLnJlY2lwaWVudD0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5wdXNoLnJlY2lwaWVudCk7XG4gICAgICAgIGlmICgoX2IgPSB0aGlzLnB1c2gpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGF0ZSlcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBwdXNoLnN0YXRlPScgKyB0aGlzLnB1c2guc3RhdGU7XG4gICAgICAgIGlmICgoX2MgPSB0aGlzLnB1c2gpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5lcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBwdXNoLmVycm9yPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnB1c2guZXJyb3IpO1xuICAgICAgICBpZiAoKF9kID0gdGhpcy5wdXNoKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubWV0YWRhdGEpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgcHVzaC5tZXRhZGF0YT0nICsgdGhpcy5wdXNoLm1ldGFkYXRhO1xuICAgICAgICByZXN1bHQgKz0gJ10nO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgRGV2aWNlRGV0YWlscy5mcm9tUmVzcG9uc2VCb2R5ID0gZnVuY3Rpb24gKGJvZHksIGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBib2R5ID0gVXRpbHMuZGVjb2RlQm9keShib2R5LCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChVdGlscy5pc0FycmF5KGJvZHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gRGV2aWNlRGV0YWlscy5mcm9tVmFsdWVzQXJyYXkoYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRGV2aWNlRGV0YWlscy5mcm9tVmFsdWVzKGJvZHkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcy5lcnJvciA9IHZhbHVlcy5lcnJvciAmJiBlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXModmFsdWVzLmVycm9yKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IERldmljZURldGFpbHMoKSwgdmFsdWVzKTtcbiAgICB9O1xuICAgIERldmljZURldGFpbHMuZnJvbVZhbHVlc0FycmF5ID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICB2YXIgY291bnQgPSB2YWx1ZXMubGVuZ3RoLCByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspXG4gICAgICAgICAgICByZXN1bHRbaV0gPSBEZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXModmFsdWVzW2ldKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIERldmljZURldGFpbHMudG9SZXF1ZXN0Qm9keSA9IFV0aWxzLmVuY29kZUJvZHk7XG4gICAgcmV0dXJuIERldmljZURldGFpbHM7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRGV2aWNlRGV0YWlscztcblxuXG4vKioqLyB9KSxcbi8qIDQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcmxvYWQgdG9KU09OKCkgdG8gaW50ZXJjZXB0IEpTT04uc3RyaW5naWZ5KClcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuICAgIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzLmNoYW5uZWwsXG4gICAgICAgICAgICBkZXZpY2VJZDogdGhpcy5kZXZpY2VJZCxcbiAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgUHVzaENoYW5uZWxTdWJzY3JpcHRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJ1tQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbic7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWwpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgY2hhbm5lbD0nICsgdGhpcy5jaGFubmVsO1xuICAgICAgICBpZiAodGhpcy5kZXZpY2VJZClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBkZXZpY2VJZD0nICsgdGhpcy5kZXZpY2VJZDtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50SWQpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgY2xpZW50SWQ9JyArIHRoaXMuY2xpZW50SWQ7XG4gICAgICAgIHJlc3VsdCArPSAnXSc7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tUmVzcG9uc2VCb2R5ID0gZnVuY3Rpb24gKGJvZHksIGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBib2R5ID0gVXRpbHMuZGVjb2RlQm9keShib2R5LCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChVdGlscy5pc0FycmF5KGJvZHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlc0FycmF5KGJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXMoYm9keSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbigpLCB2YWx1ZXMpO1xuICAgIH07XG4gICAgUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlc0FycmF5ID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICB2YXIgY291bnQgPSB2YWx1ZXMubGVuZ3RoLCByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspXG4gICAgICAgICAgICByZXN1bHRbaV0gPSBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzKHZhbHVlc1tpXSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi50b1JlcXVlc3RCb2R5ID0gVXRpbHMuZW5jb2RlQm9keTtcbiAgICByZXR1cm4gUHVzaENoYW5uZWxTdWJzY3JpcHRpb247XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUHVzaENoYW5uZWxTdWJzY3JpcHRpb247XG5cblxuLyoqKi8gfSksXG4vKiA0OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgTWVzc2FnZUNvdW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VDb3VudCh2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9ICh2YWx1ZXMgJiYgdmFsdWVzLmNvdW50KSB8fCAwO1xuICAgICAgICB0aGlzLmRhdGEgPSAodmFsdWVzICYmIHZhbHVlcy5kYXRhKSB8fCAwO1xuICAgICAgICB0aGlzLnVuY29tcHJlc3NlZERhdGEgPSAodmFsdWVzICYmIHZhbHVlcy51bmNvbXByZXNzZWREYXRhKSB8fCAwO1xuICAgICAgICB0aGlzLmZhaWxlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLmZhaWxlZCkgfHwgMDtcbiAgICAgICAgdGhpcy5yZWZ1c2VkID0gKHZhbHVlcyAmJiB2YWx1ZXMucmVmdXNlZCkgfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIE1lc3NhZ2VDb3VudDtcbn0oKSk7XG52YXIgTWVzc2FnZUNhdGVnb3J5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1lc3NhZ2VDYXRlZ29yeSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXNzYWdlQ2F0ZWdvcnkodmFsdWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHZhbHVlcykgfHwgdGhpcztcbiAgICAgICAgaWYgKHZhbHVlcyAmJiB2YWx1ZXMuY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgIF90aGlzLmNhdGVnb3J5ID0ge307XG4gICAgICAgICAgICBVdGlscy5mb3JJbk93bk5vbk51bGxQcm9wZXJ0aWVzKHZhbHVlcy5jYXRlZ29yeSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jYXRlZ29yeVtwcm9wXSA9IG5ldyBNZXNzYWdlQ291bnQodmFsdWVzLmNhdGVnb3J5W3Byb3BdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1lc3NhZ2VDYXRlZ29yeTtcbn0oTWVzc2FnZUNvdW50KSk7XG52YXIgUmVzb3VyY2VDb3VudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNvdXJjZUNvdW50KHZhbHVlcykge1xuICAgICAgICB0aGlzLnBlYWsgPSAodmFsdWVzICYmIHZhbHVlcy5wZWFrKSB8fCAwO1xuICAgICAgICB0aGlzLm1pbiA9ICh2YWx1ZXMgJiYgdmFsdWVzLm1pbikgfHwgMDtcbiAgICAgICAgdGhpcy5tZWFuID0gKHZhbHVlcyAmJiB2YWx1ZXMubWVhbikgfHwgMDtcbiAgICAgICAgdGhpcy5vcGVuZWQgPSAodmFsdWVzICYmIHZhbHVlcy5vcGVuZWQpIHx8IDA7XG4gICAgICAgIHRoaXMucmVmdXNlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnJlZnVzZWQpIHx8IDA7XG4gICAgfVxuICAgIHJldHVybiBSZXNvdXJjZUNvdW50O1xufSgpKTtcbnZhciBSZXF1ZXN0Q291bnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVxdWVzdENvdW50KHZhbHVlcykge1xuICAgICAgICB0aGlzLnN1Y2NlZWRlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnN1Y2NlZWRlZCkgfHwgMDtcbiAgICAgICAgdGhpcy5mYWlsZWQgPSAodmFsdWVzICYmIHZhbHVlcy5mYWlsZWQpIHx8IDA7XG4gICAgICAgIHRoaXMucmVmdXNlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnJlZnVzZWQpIHx8IDA7XG4gICAgfVxuICAgIHJldHVybiBSZXF1ZXN0Q291bnQ7XG59KCkpO1xudmFyIENvbm5lY3Rpb25UeXBlcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25uZWN0aW9uVHlwZXModmFsdWVzKSB7XG4gICAgICAgIHRoaXMucGxhaW4gPSBuZXcgUmVzb3VyY2VDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLnBsYWluKTtcbiAgICAgICAgdGhpcy50bHMgPSBuZXcgUmVzb3VyY2VDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLnRscyk7XG4gICAgICAgIHRoaXMuYWxsID0gbmV3IFJlc291cmNlQ291bnQodmFsdWVzICYmIHZhbHVlcy5hbGwpO1xuICAgIH1cbiAgICByZXR1cm4gQ29ubmVjdGlvblR5cGVzO1xufSgpKTtcbnZhciBNZXNzYWdlVHlwZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVzc2FnZVR5cGVzKHZhbHVlcykge1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gbmV3IE1lc3NhZ2VDYXRlZ29yeSh2YWx1ZXMgJiYgdmFsdWVzLm1lc3NhZ2VzKTtcbiAgICAgICAgdGhpcy5wcmVzZW5jZSA9IG5ldyBNZXNzYWdlQ2F0ZWdvcnkodmFsdWVzICYmIHZhbHVlcy5wcmVzZW5jZSk7XG4gICAgICAgIHRoaXMuYWxsID0gbmV3IE1lc3NhZ2VDYXRlZ29yeSh2YWx1ZXMgJiYgdmFsdWVzLmFsbCk7XG4gICAgfVxuICAgIHJldHVybiBNZXNzYWdlVHlwZXM7XG59KCkpO1xudmFyIE1lc3NhZ2VUcmFmZmljID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VUcmFmZmljKHZhbHVlcykge1xuICAgICAgICB0aGlzLnJlYWx0aW1lID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLnJlYWx0aW1lKTtcbiAgICAgICAgdGhpcy5yZXN0ID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLnJlc3QpO1xuICAgICAgICB0aGlzLndlYmhvb2sgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMud2ViaG9vayk7XG4gICAgICAgIHRoaXMuc2hhcmVkUXVldWUgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuc2hhcmVkUXVldWUpO1xuICAgICAgICB0aGlzLmV4dGVybmFsUXVldWUgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuZXh0ZXJuYWxRdWV1ZSk7XG4gICAgICAgIHRoaXMuaHR0cEV2ZW50ID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmh0dHBFdmVudCk7XG4gICAgICAgIHRoaXMucHVzaCA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5wdXNoKTtcbiAgICAgICAgdGhpcy5hbGwgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuYWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIE1lc3NhZ2VUcmFmZmljO1xufSgpKTtcbnZhciBNZXNzYWdlRGlyZWN0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXNzYWdlRGlyZWN0aW9ucyh2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5hbGwgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuYWxsKTtcbiAgICAgICAgdGhpcy5pbmJvdW5kID0gbmV3IE1lc3NhZ2VUcmFmZmljKHZhbHVlcyAmJiB2YWx1ZXMuaW5ib3VuZCk7XG4gICAgICAgIHRoaXMub3V0Ym91bmQgPSBuZXcgTWVzc2FnZVRyYWZmaWModmFsdWVzICYmIHZhbHVlcy5vdXRib3VuZCk7XG4gICAgfVxuICAgIHJldHVybiBNZXNzYWdlRGlyZWN0aW9ucztcbn0oKSk7XG52YXIgWGNoZ01lc3NhZ2VzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhjaGdNZXNzYWdlcyh2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5hbGwgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuYWxsKTtcbiAgICAgICAgdGhpcy5wcm9kdWNlclBhaWQgPSBuZXcgTWVzc2FnZURpcmVjdGlvbnModmFsdWVzICYmIHZhbHVlcy5wcm9kdWNlclBhaWQpO1xuICAgICAgICB0aGlzLmNvbnN1bWVyUGFpZCA9IG5ldyBNZXNzYWdlRGlyZWN0aW9ucyh2YWx1ZXMgJiYgdmFsdWVzLmNvbnN1bWVyUGFpZCk7XG4gICAgfVxuICAgIHJldHVybiBYY2hnTWVzc2FnZXM7XG59KCkpO1xudmFyIFB1c2hTdGF0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQdXNoU3RhdHModmFsdWVzKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSAodmFsdWVzICYmIHZhbHVlcy5tZXNzYWdlcykgfHwgMDtcbiAgICAgICAgdmFyIG5vdGlmaWNhdGlvbnMgPSB2YWx1ZXMgJiYgdmFsdWVzLm5vdGlmaWNhdGlvbnM7XG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9ucyA9IHtcbiAgICAgICAgICAgIGludmFsaWQ6IChub3RpZmljYXRpb25zICYmIG5vdGlmaWNhdGlvbnMuaW52YWxpZCkgfHwgMCxcbiAgICAgICAgICAgIGF0dGVtcHRlZDogKG5vdGlmaWNhdGlvbnMgJiYgbm90aWZpY2F0aW9ucy5hdHRlbXB0ZWQpIHx8IDAsXG4gICAgICAgICAgICBzdWNjZXNzZnVsOiAobm90aWZpY2F0aW9ucyAmJiBub3RpZmljYXRpb25zLnN1Y2Nlc3NmdWwpIHx8IDAsXG4gICAgICAgICAgICBmYWlsZWQ6IChub3RpZmljYXRpb25zICYmIG5vdGlmaWNhdGlvbnMuZmFpbGVkKSB8fCAwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRpcmVjdFB1Ymxpc2hlcyA9ICh2YWx1ZXMgJiYgdmFsdWVzLmRpcmVjdFB1Ymxpc2hlcykgfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIFB1c2hTdGF0cztcbn0oKSk7XG52YXIgUHJvY2Vzc2VkQ291bnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvY2Vzc2VkQ291bnQodmFsdWVzKSB7XG4gICAgICAgIHRoaXMuc3VjY2VlZGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuc3VjY2VlZGVkKSB8fCAwO1xuICAgICAgICB0aGlzLnNraXBwZWQgPSAodmFsdWVzICYmIHZhbHVlcy5za2lwcGVkKSB8fCAwO1xuICAgICAgICB0aGlzLmZhaWxlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLmZhaWxlZCkgfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIFByb2Nlc3NlZENvdW50O1xufSgpKTtcbnZhciBQcm9jZXNzZWRNZXNzYWdlcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcm9jZXNzZWRNZXNzYWdlcyh2YWx1ZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5kZWx0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHZhbHVlcyAmJiB2YWx1ZXMuZGVsdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsdGEgPSB7fTtcbiAgICAgICAgICAgIFV0aWxzLmZvckluT3duTm9uTnVsbFByb3BlcnRpZXModmFsdWVzLmRlbHRhLCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRlbHRhW3Byb3BdID0gbmV3IFByb2Nlc3NlZENvdW50KHZhbHVlcy5kZWx0YVtwcm9wXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvY2Vzc2VkTWVzc2FnZXM7XG59KCkpO1xudmFyIFN0YXRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFN0YXRzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0YXRzKHZhbHVlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB2YWx1ZXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnBlcnNpc3RlZCA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5wZXJzaXN0ZWQpO1xuICAgICAgICBfdGhpcy5jb25uZWN0aW9ucyA9IG5ldyBDb25uZWN0aW9uVHlwZXModmFsdWVzICYmIHZhbHVlcy5jb25uZWN0aW9ucyk7XG4gICAgICAgIF90aGlzLmNoYW5uZWxzID0gbmV3IFJlc291cmNlQ291bnQodmFsdWVzICYmIHZhbHVlcy5jaGFubmVscyk7XG4gICAgICAgIF90aGlzLmFwaVJlcXVlc3RzID0gbmV3IFJlcXVlc3RDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLmFwaVJlcXVlc3RzKTtcbiAgICAgICAgX3RoaXMudG9rZW5SZXF1ZXN0cyA9IG5ldyBSZXF1ZXN0Q291bnQodmFsdWVzICYmIHZhbHVlcy50b2tlblJlcXVlc3RzKTtcbiAgICAgICAgX3RoaXMueGNoZ1Byb2R1Y2VyID0gbmV3IFhjaGdNZXNzYWdlcyh2YWx1ZXMgJiYgdmFsdWVzLnhjaGdQcm9kdWNlcik7XG4gICAgICAgIF90aGlzLnhjaGdDb25zdW1lciA9IG5ldyBYY2hnTWVzc2FnZXModmFsdWVzICYmIHZhbHVlcy54Y2hnQ29uc3VtZXIpO1xuICAgICAgICBfdGhpcy5wdXNoID0gbmV3IFB1c2hTdGF0cyh2YWx1ZXMgJiYgdmFsdWVzLnB1c2hTdGF0cyk7XG4gICAgICAgIF90aGlzLnByb2Nlc3NlZCA9IG5ldyBQcm9jZXNzZWRNZXNzYWdlcyh2YWx1ZXMgJiYgdmFsdWVzLnByb2Nlc3NlZCk7XG4gICAgICAgIF90aGlzLmluUHJvZ3Jlc3MgPSAodmFsdWVzICYmIHZhbHVlcy5pblByb2dyZXNzKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLnVuaXQgPSAodmFsdWVzICYmIHZhbHVlcy51bml0KSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLmludGVydmFsSWQgPSAodmFsdWVzICYmIHZhbHVlcy5pbnRlcnZhbElkKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3RhdHMuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0cyh2YWx1ZXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRzO1xufShNZXNzYWdlRGlyZWN0aW9ucykpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3RhdHM7XG5cblxuLyoqKi8gfSksXG4vKiA1MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgcmVzdF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzMCkpO1xudmFyIGV2ZW50ZW1pdHRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBjb25uZWN0aW9uXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKSk7XG52YXIgcmVhbHRpbWVjaGFubmVsXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KSk7XG52YXIgZGVmYXVsdHNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOCkpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgcHJvdG9jb2xtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSk7XG52YXIgY29ubmVjdGlvbm1hbmFnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzUpKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg5KSk7XG52YXIgUmVhbHRpbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUmVhbHRpbWUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVhbHRpbWUob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1JlYWx0aW1lKCknLCAnJyk7XG4gICAgICAgIF90aGlzLmNvbm5lY3Rpb24gPSBuZXcgY29ubmVjdGlvbl8xLmRlZmF1bHQoX3RoaXMsIF90aGlzLm9wdGlvbnMpO1xuICAgICAgICBfdGhpcy5jaGFubmVscyA9IG5ldyBDaGFubmVscyhfdGhpcyk7XG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9Db25uZWN0ICE9PSBmYWxzZSlcbiAgICAgICAgICAgIF90aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZWFsdGltZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdSZWFsdGltZS5jb25uZWN0KCknLCAnJyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5jb25uZWN0KCk7XG4gICAgfTtcbiAgICBSZWFsdGltZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUmVhbHRpbWUuY2xvc2UoKScsICcnKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgfTtcbiAgICBSZWFsdGltZS5Qcm9taXNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRzXzEuZGVmYXVsdC5vYmplY3RpZnlPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zLnByb21pc2VzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFsdGltZShvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lLkNhbGxiYWNrcyA9IFJlYWx0aW1lO1xuICAgIFJlYWx0aW1lLlV0aWxzID0gVXRpbHM7XG4gICAgUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIgPSBjb25uZWN0aW9ubWFuYWdlcl8xLmRlZmF1bHQ7XG4gICAgUmVhbHRpbWUuUGxhdGZvcm0gPSBwbGF0Zm9ybV8xLmRlZmF1bHQ7XG4gICAgUmVhbHRpbWUuUHJvdG9jb2xNZXNzYWdlID0gcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdDtcbiAgICBSZWFsdGltZS5NZXNzYWdlID0gbWVzc2FnZV8xLmRlZmF1bHQ7XG4gICAgcmV0dXJuIFJlYWx0aW1lO1xufShyZXN0XzEuZGVmYXVsdCkpO1xudmFyIENoYW5uZWxzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKENoYW5uZWxzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENoYW5uZWxzKHJlYWx0aW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlYWx0aW1lID0gcmVhbHRpbWU7XG4gICAgICAgIF90aGlzLmFsbCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHJlYWx0aW1lLmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIub24oJ3RyYW5zcG9ydC5hY3RpdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5vblRyYW5zcG9ydEFjdGl2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDaGFubmVscy5wcm90b3R5cGUuY2hhbm5lbFNlcmlhbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZXJpYWxzID0ge307XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBVdGlscy5rZXlzQXJyYXkodGhpcy5hbGwsIHRydWUpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIG5hbWVfMSA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV8xXTtcbiAgICAgICAgICAgIGlmIChjaGFubmVsLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCkge1xuICAgICAgICAgICAgICAgIHNlcmlhbHNbbmFtZV8xXSA9IGNoYW5uZWwucHJvcGVydGllcy5jaGFubmVsU2VyaWFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJpYWxzO1xuICAgIH07XG4gICAgLy8gcmVjb3ZlckNoYW5uZWxzIGdldHMgdGhlIGdpdmVuIGNoYW5uZWxzIGFuZCBzZXRzIHRoZWlyIGNoYW5uZWwgc2VyaWFscy5cbiAgICBDaGFubmVscy5wcm90b3R5cGUucmVjb3ZlckNoYW5uZWxzID0gZnVuY3Rpb24gKGNoYW5uZWxTZXJpYWxzKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBVdGlscy5rZXlzQXJyYXkoY2hhbm5lbFNlcmlhbHMsIHRydWUpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIG5hbWVfMiA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5nZXQobmFtZV8yKTtcbiAgICAgICAgICAgIGNoYW5uZWwucHJvcGVydGllcy5jaGFubmVsU2VyaWFsID0gY2hhbm5lbFNlcmlhbHNbbmFtZV8yXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2hhbm5lbHMucHJvdG90eXBlLm9uQ2hhbm5lbE1lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBjaGFubmVsTmFtZSA9IG1zZy5jaGFubmVsO1xuICAgICAgICBpZiAoY2hhbm5lbE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDaGFubmVscy5vbkNoYW5uZWxNZXNzYWdlKCknLCAncmVjZWl2ZWQgZXZlbnQgdW5zcGVjaWZpZWQgY2hhbm5lbCwgYWN0aW9uID0gJyArIG1zZy5hY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5hbGxbY2hhbm5lbE5hbWVdO1xuICAgICAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQ2hhbm5lbHMub25DaGFubmVsTWVzc2FnZSgpJywgJ3JlY2VpdmVkIGV2ZW50IGZvciBub24tZXhpc3RlbnQgY2hhbm5lbDogJyArIGNoYW5uZWxOYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjaGFubmVsLm9uTWVzc2FnZShtc2cpO1xuICAgIH07XG4gICAgLyogY2FsbGVkIHdoZW4gYSB0cmFuc3BvcnQgYmVjb21lcyBjb25uZWN0ZWQ7IHJlYXR0ZW1wdCBhdHRhY2gvZGV0YWNoXG4gICAgICogZm9yIGNoYW5uZWxzIHRoYXQgYXJlIGF0dGFjaGluZyBvciBkZXRhY2hpbmcuICovXG4gICAgQ2hhbm5lbHMucHJvdG90eXBlLm9uVHJhbnNwb3J0QWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBjaGFubmVsTmFtZSBpbiB0aGlzLmFsbCkge1xuICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsTmFtZV07XG4gICAgICAgICAgICBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gJ2F0dGFjaGluZycgfHwgY2hhbm5lbC5zdGF0ZSA9PT0gJ2RldGFjaGluZycpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFubmVsLnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuX2F0dGFjaChmYWxzZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFubmVsLnN0YXRlID09PSAnYXR0YWNoZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZSBleHBsaWNpdHkgcmVxdWVzdCB0aGUgc3RhdGUsIGNoYW5uZWwuYXR0YWNoKCkgd291bGQgZG8gbm90aGluZ1xuICAgICAgICAgICAgICAgIC8vIGFzIGl0cyBhbHJlYWR5IGF0dGFjaGVkLlxuICAgICAgICAgICAgICAgIGNoYW5uZWwucmVxdWVzdFN0YXRlKCdhdHRhY2hpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyogQ29ubmVjdGlvbiBpbnRlcnJ1cHRpb25zIChpZSB3aGVuIHRoZSBjb25uZWN0aW9uIHdpbGwgbm8gbG9uZ2VyIHF1ZXVlXG4gICAgICogZXZlbnRzKSBpbXBseSBjb25uZWN0aW9uIHN0YXRlIGNoYW5nZXMgZm9yIGFueSBjaGFubmVsIHdoaWNoIGlzIGVpdGhlclxuICAgICAqIGF0dGFjaGVkLCBwZW5kaW5nLCBvciB3aWxsIGF0dGVtcHQgdG8gYmVjb21lIGF0dGFjaGVkIGluIHRoZSBmdXR1cmUgKi9cbiAgICBDaGFubmVscy5wcm90b3R5cGUucHJvcG9nYXRlQ29ubmVjdGlvbkludGVycnVwdGlvbiA9IGZ1bmN0aW9uIChjb25uZWN0aW9uU3RhdGUsIHJlYXNvbikge1xuICAgICAgICB2YXIgY29ubmVjdGlvblN0YXRlVG9DaGFubmVsU3RhdGUgPSB7XG4gICAgICAgICAgICBjbG9zaW5nOiAnZGV0YWNoZWQnLFxuICAgICAgICAgICAgY2xvc2VkOiAnZGV0YWNoZWQnLFxuICAgICAgICAgICAgZmFpbGVkOiAnZmFpbGVkJyxcbiAgICAgICAgICAgIHN1c3BlbmRlZDogJ3N1c3BlbmRlZCcsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBmcm9tQ2hhbm5lbFN0YXRlcyA9IFsnYXR0YWNoaW5nJywgJ2F0dGFjaGVkJywgJ2RldGFjaGluZycsICdzdXNwZW5kZWQnXTtcbiAgICAgICAgdmFyIHRvQ2hhbm5lbFN0YXRlID0gY29ubmVjdGlvblN0YXRlVG9DaGFubmVsU3RhdGVbY29ubmVjdGlvblN0YXRlXTtcbiAgICAgICAgZm9yICh2YXIgY2hhbm5lbElkIGluIHRoaXMuYWxsKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxJZF07XG4gICAgICAgICAgICBpZiAoVXRpbHMuYXJySW4oZnJvbUNoYW5uZWxTdGF0ZXMsIGNoYW5uZWwuc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5ub3RpZnlTdGF0ZSh0b0NoYW5uZWxTdGF0ZSwgcmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2hhbm5lbHMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lLCBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdO1xuICAgICAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgICAgICAgIGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXSA9IG5ldyByZWFsdGltZWNoYW5uZWxfMS5kZWZhdWx0KHRoaXMucmVhbHRpbWUsIG5hbWUsIGNoYW5uZWxPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFubmVsT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGNoYW5uZWwuX3Nob3VsZFJlYXR0YWNoVG9TZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdDaGFubmVscy5nZXQoKSBjYW5ub3QgYmUgdXNlZCB0byBzZXQgY2hhbm5lbCBvcHRpb25zIHRoYXQgd291bGQgY2F1c2UgdGhlIGNoYW5uZWwgdG8gcmVhdHRhY2guIFBsZWFzZSwgdXNlIFJlYWx0aW1lQ2hhbm5lbC5zZXRPcHRpb25zKCkgaW5zdGVhZC4nLCA0MDAwMCwgNDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYW5uZWwuc2V0T3B0aW9ucyhjaGFubmVsT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgfTtcbiAgICBDaGFubmVscy5wcm90b3R5cGUuZ2V0RGVyaXZlZCA9IGZ1bmN0aW9uIChuYW1lLCBkZXJpdmVPcHRpb25zLCBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICBpZiAoZGVyaXZlT3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBVdGlscy50b0Jhc2U2NChkZXJpdmVPcHRpb25zLmZpbHRlcik7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBVdGlscy5tYXRjaERlcml2ZWRDaGFubmVsKG5hbWUpO1xuICAgICAgICAgICAgbmFtZSA9IFwiW2ZpbHRlcj1cIi5jb25jYXQoZmlsdGVyKS5jb25jYXQobWF0Y2gucXVhbGlmaWVyUGFyYW0sIFwiXVwiKS5jb25jYXQobWF0Y2guY2hhbm5lbE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldChuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKiBJbmNsdWRlZCB0byBzdXBwb3J0IGNlcnRhaW4gbmljaGUgdXNlLWNhc2VzOyBtb3N0IHVzZXJzIHNob3VsZCBpZ25vcmUgdGhpcy5cbiAgICAgKiBQbGVhc2UgZG8gbm90IHVzZSB0aGlzIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZyAqL1xuICAgIENoYW5uZWxzLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcbiAgICAgICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbGVhc2VFcnIgPSBjaGFubmVsLmdldFJlbGVhc2VFcnIoKTtcbiAgICAgICAgaWYgKHJlbGVhc2VFcnIpIHtcbiAgICAgICAgICAgIHRocm93IHJlbGVhc2VFcnI7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuYWxsW25hbWVdO1xuICAgIH07XG4gICAgcmV0dXJuIENoYW5uZWxzO1xufShldmVudGVtaXR0ZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBSZWFsdGltZTtcblxuXG4vKioqLyB9KSxcbi8qIDUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBldmVudGVtaXR0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNykpO1xudmFyIGNvbm5lY3Rpb25tYW5hZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzcpKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG5mdW5jdGlvbiBub29wKCkgeyB9XG52YXIgQ29ubmVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb25uZWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbm5lY3Rpb24oYWJseSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy53aGVuU3RhdGUgPSAoZnVuY3Rpb24gKHN0YXRlLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQucHJvdG90eXBlLndoZW5TdGF0ZS5jYWxsKF90aGlzLCBzdGF0ZSwgX3RoaXMuc3RhdGUsIGxpc3RlbmVyLCBuZXcgY29ubmVjdGlvbnN0YXRlY2hhbmdlXzEuZGVmYXVsdCh1bmRlZmluZWQsIHN0YXRlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5hYmx5ID0gYWJseTtcbiAgICAgICAgX3RoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgY29ubmVjdGlvbm1hbmFnZXJfMS5kZWZhdWx0KGFibHksIG9wdGlvbnMpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IF90aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnN0YXRlO1xuICAgICAgICBfdGhpcy5rZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLmlkID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5lcnJvclJlYXNvbiA9IG51bGw7XG4gICAgICAgIF90aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uKCdjb25uZWN0aW9uc3RhdGUnLCBmdW5jdGlvbiAoc3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IChfdGhpcy5zdGF0ZSA9IHN0YXRlQ2hhbmdlLmN1cnJlbnQpO1xuICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChzdGF0ZSwgc3RhdGVDaGFuZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbigndXBkYXRlJywgZnVuY3Rpb24gKHN0YXRlQ2hhbmdlKSB7XG4gICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCd1cGRhdGUnLCBzdGF0ZUNoYW5nZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uLmNvbm5lY3QoKScsICcnKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogJ2Nvbm5lY3RpbmcnIH0pO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb24ucGluZygpJywgJycpO1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hYmx5Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdwaW5nJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnBpbmcobnVsbCwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbi5jbG9zZSgpJywgJ2Nvbm5lY3Rpb25LZXkgPSAnICsgdGhpcy5rZXkpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiAnY2xvc2luZycgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGlvbi5wcm90b3R5cGUsIFwicmVjb3ZlcnlLZXlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJlY292ZXJ5S2V5KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVSZWNvdmVyeUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY3JlYXRlUmVjb3ZlcnlLZXkoKTtcbiAgICB9O1xuICAgIHJldHVybiBDb25uZWN0aW9uO1xufShldmVudGVtaXR0ZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uO1xuXG5cbi8qKiovIH0pLFxuLyogNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGVuZGluZ01lc3NhZ2UgPSB2b2lkIDA7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgcHJvdG9jb2xtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBldmVudGVtaXR0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNykpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgbWVzc2FnZXF1ZXVlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBhY3Rpb25zID0gcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5BY3Rpb247XG52YXIgUGVuZGluZ01lc3NhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGVuZGluZ01lc3NhZ2UobWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLm1lcmdlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgYWN0aW9uID0gbWVzc2FnZS5hY3Rpb247XG4gICAgICAgIHRoaXMuc2VuZEF0dGVtcHRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFja1JlcXVpcmVkID0gYWN0aW9uID09IGFjdGlvbnMuTUVTU0FHRSB8fCBhY3Rpb24gPT0gYWN0aW9ucy5QUkVTRU5DRTtcbiAgICB9XG4gICAgcmV0dXJuIFBlbmRpbmdNZXNzYWdlO1xufSgpKTtcbmV4cG9ydHMuUGVuZGluZ01lc3NhZ2UgPSBQZW5kaW5nTWVzc2FnZTtcbnZhciBQcm90b2NvbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhQcm90b2NvbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcm90b2NvbCh0cmFuc3BvcnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICBfdGhpcy5tZXNzYWdlUXVldWUgPSBuZXcgbWVzc2FnZXF1ZXVlXzEuZGVmYXVsdCgpO1xuICAgICAgICB0cmFuc3BvcnQub24oJ2FjaycsIGZ1bmN0aW9uIChzZXJpYWwsIGNvdW50KSB7XG4gICAgICAgICAgICBfdGhpcy5vbkFjayhzZXJpYWwsIGNvdW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyYW5zcG9ydC5vbignbmFjaycsIGZ1bmN0aW9uIChzZXJpYWwsIGNvdW50LCBlcnIpIHtcbiAgICAgICAgICAgIF90aGlzLm9uTmFjayhzZXJpYWwsIGNvdW50LCBlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQcm90b2NvbC5wcm90b3R5cGUub25BY2sgPSBmdW5jdGlvbiAoc2VyaWFsLCBjb3VudCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1Byb3RvY29sLm9uQWNrKCknLCAnc2VyaWFsID0gJyArIHNlcmlhbCArICc7IGNvdW50ID0gJyArIGNvdW50KTtcbiAgICAgICAgdGhpcy5tZXNzYWdlUXVldWUuY29tcGxldGVNZXNzYWdlcyhzZXJpYWwsIGNvdW50KTtcbiAgICB9O1xuICAgIFByb3RvY29sLnByb3RvdHlwZS5vbk5hY2sgPSBmdW5jdGlvbiAoc2VyaWFsLCBjb3VudCwgZXJyKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnUHJvdG9jb2wub25OYWNrKCknLCAnc2VyaWFsID0gJyArIHNlcmlhbCArICc7IGNvdW50ID0gJyArIGNvdW50ICsgJzsgZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgIGVyciA9IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdVbmFibGUgdG8gc2VuZCBtZXNzYWdlOyBjaGFubmVsIG5vdCByZXNwb25kaW5nJywgNTAwMDEsIDUwMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXNzYWdlUXVldWUuY29tcGxldGVNZXNzYWdlcyhzZXJpYWwsIGNvdW50LCBlcnIpO1xuICAgIH07XG4gICAgUHJvdG9jb2wucHJvdG90eXBlLm9uY2VJZGxlID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBtZXNzYWdlUXVldWUgPSB0aGlzLm1lc3NhZ2VRdWV1ZTtcbiAgICAgICAgaWYgKG1lc3NhZ2VRdWV1ZS5jb3VudCgpID09PSAwKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2VRdWV1ZS5vbmNlKCdpZGxlJywgbGlzdGVuZXIpO1xuICAgIH07XG4gICAgUHJvdG9jb2wucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAocGVuZGluZ01lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHBlbmRpbmdNZXNzYWdlLmFja1JlcXVpcmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5wdXNoKHBlbmRpbmdNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9nZ2VyXzEuZGVmYXVsdC5zaG91bGRMb2cobG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1Byb3RvY29sLnNlbmQoKScsICdzZW5kaW5nIG1zZzsgJyArIHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuc3RyaW5naWZ5KHBlbmRpbmdNZXNzYWdlLm1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgICAgICBwZW5kaW5nTWVzc2FnZS5zZW5kQXR0ZW1wdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZChwZW5kaW5nTWVzc2FnZS5tZXNzYWdlKTtcbiAgICB9O1xuICAgIFByb3RvY29sLnByb3RvdHlwZS5nZXRUcmFuc3BvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydDtcbiAgICB9O1xuICAgIFByb3RvY29sLnByb3RvdHlwZS5nZXRQZW5kaW5nTWVzc2FnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VRdWV1ZS5jb3B5QWxsKCk7XG4gICAgfTtcbiAgICBQcm90b2NvbC5wcm90b3R5cGUuY2xlYXJQZW5kaW5nTWVzc2FnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VRdWV1ZS5jbGVhcigpO1xuICAgIH07XG4gICAgUHJvdG9jb2wucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0O1xuICAgICAgICB0aGlzLm9uY2VJZGxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFByb3RvY29sO1xufShldmVudGVtaXR0ZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQcm90b2NvbDtcblxuXG4vKioqLyB9KSxcbi8qIDUzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgdHJhbnNwb3J0XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KSk7XG52YXIgZGVmYXVsdHNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOCkpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgcHJvdG9jb2xtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBzaG9ydE5hbWUgPSAnd2ViX3NvY2tldCc7XG5mdW5jdGlvbiBpc05vZGVXZWJTb2NrZXQod3MpIHtcbiAgICByZXR1cm4gISF3cy5vbjtcbn1cbnZhciBXZWJTb2NrZXRUcmFuc3BvcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoV2ViU29ja2V0VHJhbnNwb3J0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdlYlNvY2tldFRyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNob3J0TmFtZSA9IHNob3J0TmFtZTtcbiAgICAgICAgLyogSWYgaXMgYSBicm93c2VyLCBjYW4ndCBkZXRlY3QgcGluZ3MsIHNvIHJlcXVlc3QgcHJvdG9jb2wgaGVhcnRiZWF0cyAqL1xuICAgICAgICBwYXJhbXMuaGVhcnRiZWF0cyA9IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcudXNlUHJvdG9jb2xIZWFydGJlYXRzO1xuICAgICAgICBfdGhpcy53c0hvc3QgPSBkZWZhdWx0c18xLmRlZmF1bHQuZ2V0SG9zdChwYXJhbXMub3B0aW9ucywgcGFyYW1zLmhvc3QsIHRydWUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFdlYlNvY2tldFRyYW5zcG9ydC5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5XZWJTb2NrZXQ7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmNyZWF0ZVdlYlNvY2tldCA9IGZ1bmN0aW9uICh1cmksIGNvbm5lY3RQYXJhbXMpIHtcbiAgICAgICAgdGhpcy51cmkgPSB1cmkgKyBVdGlscy50b1F1ZXJ5U3RyaW5nKGNvbm5lY3RQYXJhbXMpO1xuICAgICAgICByZXR1cm4gbmV3IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuV2ViU29ja2V0KHRoaXMudXJpKTtcbiAgICB9O1xuICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnV2ViU29ja2V0VHJhbnNwb3J0OyB1cmk9JyArIHRoaXMudXJpO1xuICAgIH07XG4gICAgV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5jb25uZWN0KCknLCAnc3RhcnRpbmcnKTtcbiAgICAgICAgdHJhbnNwb3J0XzEuZGVmYXVsdC5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIHBhcmFtcyA9IHRoaXMucGFyYW1zLCBvcHRpb25zID0gcGFyYW1zLm9wdGlvbnM7XG4gICAgICAgIHZhciB3c1NjaGVtZSA9IG9wdGlvbnMudGxzID8gJ3dzczovLycgOiAnd3M6Ly8nO1xuICAgICAgICB2YXIgd3NVcmkgPSB3c1NjaGVtZSArIHRoaXMud3NIb3N0ICsgJzonICsgZGVmYXVsdHNfMS5kZWZhdWx0LmdldFBvcnQob3B0aW9ucykgKyAnLyc7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKScsICd1cmk6ICcgKyB3c1VyaSk7XG4gICAgICAgIHRoaXMuYXV0aC5nZXRBdXRoUGFyYW1zKGZ1bmN0aW9uIChlcnIsIGF1dGhQYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFyYW1TdHIgPSAnJztcbiAgICAgICAgICAgIGZvciAodmFyIHBhcmFtIGluIGF1dGhQYXJhbXMpXG4gICAgICAgICAgICAgICAgcGFyYW1TdHIgKz0gJyAnICsgcGFyYW0gKyAnOiAnICsgYXV0aFBhcmFtc1twYXJhbV0gKyAnOyc7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5jb25uZWN0KCknLCAnYXV0aFBhcmFtczonICsgcGFyYW1TdHIgKyAnIGVycjogJyArIGVycik7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kaXNjb25uZWN0KGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbm5lY3RQYXJhbXMgPSBwYXJhbXMuZ2V0Q29ubmVjdFBhcmFtcyhhdXRoUGFyYW1zKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHdzQ29ubmVjdGlvbiA9IChzZWxmLndzQ29ubmVjdGlvbiA9IHNlbGYuY3JlYXRlV2ViU29ja2V0KHdzVXJpLCBjb25uZWN0UGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgd3NDb25uZWN0aW9uLmJpbmFyeVR5cGUgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmJpbmFyeVR5cGU7XG4gICAgICAgICAgICAgICAgd3NDb25uZWN0aW9uLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vbldzT3BlbigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd3NDb25uZWN0aW9uLm9uY2xvc2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vbldzQ2xvc2UoZXYpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd3NDb25uZWN0aW9uLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9uV3NEYXRhKGV2LmRhdGEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd3NDb25uZWN0aW9uLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vbldzRXJyb3IoZXYpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGlzTm9kZVdlYlNvY2tldCh3c0Nvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIG5vZGU7IGJyb3dzZXJzIGN1cnJlbnRseSBkb24ndCBoYXZlIGEgZ2VuZXJhbCBldmVudGVtaXR0ZXIgYW5kIGNhbid0IGRldGVjdFxuICAgICAgICAgICAgICAgICAgICAgKiBwaW5ncy4gQWxzbywgbm8gbmVlZCB0byByZXBseSB3aXRoIGEgcG9uZyBleHBsaWNpdGx5LCB3cyBsaWIgaGFuZGxlcyB0aGF0ICovXG4gICAgICAgICAgICAgICAgICAgIHdzQ29ubmVjdGlvbi5vbigncGluZycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub25BY3Rpdml0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdVbmV4cGVjdGVkIGV4Y2VwdGlvbiBjcmVhdGluZyB3ZWJzb2NrZXQ6IGVyciA9ICcgKyAoZS5zdGFjayB8fCBlLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICBzZWxmLmRpc2Nvbm5lY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIHdzQ29ubmVjdGlvbiA9IHRoaXMud3NDb25uZWN0aW9uO1xuICAgICAgICBpZiAoIXdzQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuc2VuZCgpJywgJ05vIHNvY2tldCBjb25uZWN0aW9uJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdzQ29ubmVjdGlvbi5zZW5kKHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuc2VyaWFsaXplKG1lc3NhZ2UsIHRoaXMucGFyYW1zLmZvcm1hdCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ0V4Y2VwdGlvbiBmcm9tIHdzIGNvbm5lY3Rpb24gd2hlbiB0cnlpbmcgdG8gc2VuZDogJyArIFV0aWxzLmluc3BlY3RFcnJvcihlKTtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LnNlbmQoKScsIG1zZyk7XG4gICAgICAgICAgICAvKiBEb24ndCB0cnkgdG8gcmVxdWVzdCBhIGRpc2Nvbm5lY3QsIHRoYXQnbGwganVzdCBpbnZvbHZlIHNlbmRpbmcgZGF0YVxuICAgICAgICAgICAgICogZG93biB0aGUgd2Vic29ja2V0IGFnYWluLiBKdXN0IGZpbmlzaCB0aGUgdHJhbnNwb3J0LiAqL1xuICAgICAgICAgICAgdGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgNTAwMDAsIDUwMCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uV3NEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0RhdGEoKScsICdkYXRhIHJlY2VpdmVkOyBsZW5ndGggPSAnICsgZGF0YS5sZW5ndGggKyAnOyB0eXBlID0gJyArIHR5cGVvZiBkYXRhKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMub25Qcm90b2NvbE1lc3NhZ2UocHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5kZXNlcmlhbGl6ZShkYXRhLCB0aGlzLmZvcm1hdCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5vbldzRGF0YSgpJywgJ1VuZXhwZWN0ZWQgZXhjZXB0aW9uIGhhbmRpbmcgY2hhbm5lbCBtZXNzYWdlOiAnICsgZS5zdGFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUub25Xc09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NPcGVuKCknLCAnb3BlbmVkIFdlYlNvY2tldCcpO1xuICAgICAgICB0aGlzLmVtaXQoJ3ByZWNvbm5lY3QnKTtcbiAgICB9O1xuICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUub25Xc0Nsb3NlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciB3YXNDbGVhbiwgY29kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBldiA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLyogVzNDIHNwZWMtY29tcGF0aWJsZSAqL1xuICAgICAgICAgICAgY29kZSA9IGV2LmNvZGU7XG4gICAgICAgICAgICAvLyBldi53YXNDbGVhbiBpcyB1bmRlZmluZWQgaW4gcmVhY3RuYXRpdmVcbiAgICAgICAgICAgIHdhc0NsZWFuID0gZXYud2FzQ2xlYW4gfHwgY29kZSA9PT0gMTAwMDtcbiAgICAgICAgfSAvKmlmKHR5cGVvZihldikgPT0gJ251bWJlcicpKi9cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiB3cyBpbiBub2RlICovXG4gICAgICAgICAgICBjb2RlID0gZXY7XG4gICAgICAgICAgICB3YXNDbGVhbiA9IGNvZGUgPT0gMTAwMDtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy53c0Nvbm5lY3Rpb247XG4gICAgICAgIGlmICh3YXNDbGVhbikge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0Nsb3NlKCknLCAnQ2xlYW5seSBjbG9zZWQgV2ViU29ja2V0Jyk7XG4gICAgICAgICAgICB2YXIgZXJyID0gbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1dlYnNvY2tldCBjbG9zZWQnLCA4MDAwMywgNDAwKTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCdkaXNjb25uZWN0ZWQnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdVbmNsZWFuIGRpc2Nvbm5lY3Rpb24gb2YgV2ViU29ja2V0IDsgY29kZSA9ICcgKyBjb2RlLCBlcnIgPSBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDgwMDAzLCA0MDApO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0Nsb3NlKCknLCBtc2cpO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdkaXNwb3NlZCcpO1xuICAgIH07XG4gICAgV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5vbldzRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0Lm9uRXJyb3IoKScsICdFcnJvciBmcm9tIFdlYlNvY2tldDogJyArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgLyogV2FpdCBhIHRpY2sgYmVmb3JlIGFib3J0aW5nOiBpZiB0aGUgd2Vic29ja2V0IHdhcyBjb25uZWN0ZWQsIHRoaXMgZXZlbnRcbiAgICAgICAgICogd2lsbCBiZSBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbiBvbmNsb3NlIGV2ZW50IHdpdGggYSBjbG9zZSBjb2RlLiBBbGxvd1xuICAgICAgICAgKiB0aGF0IHRvIGNsb3NlIGl0IChzbyB3ZSBzZWUgdGhlIGNsb3NlIGNvZGUpIHJhdGhlciB0aGFuIGFudGljaXBhdGluZyBpdCAqL1xuICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmRpc2Nvbm5lY3QoRXJyb3IoZXJyLm1lc3NhZ2UpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmRpc3Bvc2UoKScsICcnKTtcbiAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHdzQ29ubmVjdGlvbiA9IHRoaXMud3NDb25uZWN0aW9uO1xuICAgICAgICBpZiAod3NDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAvKiBJZ25vcmUgYW55IG1lc3NhZ2VzIHRoYXQgY29tZSB0aHJvdWdoIGFmdGVyIGRpc3Bvc2UoKSBpcyBjYWxsZWQgYnV0IGJlZm9yZVxuICAgICAgICAgICAgICogd2Vic29ja2V0IGlzIGFjdHVhbGx5IGNsb3NlZC4gKG1vc3RseSB3b3VsZCBiZSBoYXJtbGVzcywgYnV0IGlmIGl0J3MgYVxuICAgICAgICAgICAgICogQ09OTkVDVEVELCBpdCdsbCByZS10aWNrIGlzQ29ubmVjdGVkIGFuZCBjYXVzZSBhbGwgc29ydHMgb2YgaGF2b2MpICovXG4gICAgICAgICAgICB3c0Nvbm5lY3Rpb24ub25tZXNzYWdlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMud3NDb25uZWN0aW9uO1xuICAgICAgICAgICAgLyogZGVmZXIgdW50aWwgdGhlIG5leHQgZXZlbnQgbG9vcCBjeWNsZSBiZWZvcmUgY2xvc2luZyB0aGUgc29ja2V0LFxuICAgICAgICAgICAgICogZ2l2aW5nIHNvbWUgaW1wbGVtZW50YXRpb25zIHRoZSBvcHBvcnR1bml0eSB0byBzZW5kIGFueSBvdXRzdGFuZGluZyBjbG9zZSBtZXNzYWdlICovXG4gICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1dlYlNvY2tldFRyYW5zcG9ydC5kaXNwb3NlKCknLCAnY2xvc2luZyB3ZWJzb2NrZXQnKTtcbiAgICAgICAgICAgICAgICBpZiAoIXdzQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldFRyYW5zcG9ydC5kaXNwb3NlKCk6IHdzQ29ubmVjdGlvbiBpcyBub3QgZGVmaW5lZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3c0Nvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gV2ViU29ja2V0VHJhbnNwb3J0O1xufSh0cmFuc3BvcnRfMS5kZWZhdWx0KSk7XG5mdW5jdGlvbiBpbml0aWFsaXNlVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyKSB7XG4gICAgaWYgKFdlYlNvY2tldFRyYW5zcG9ydC5pc0F2YWlsYWJsZSgpKVxuICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzW3Nob3J0TmFtZV0gPSBXZWJTb2NrZXRUcmFuc3BvcnQ7XG4gICAgcmV0dXJuIFdlYlNvY2tldFRyYW5zcG9ydDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGluaXRpYWxpc2VUcmFuc3BvcnQ7XG5cblxuLyoqKi8gfSksXG4vKiA1NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgcHJlc2VuY2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzQpKTtcbnZhciBldmVudGVtaXR0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNykpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgcHJlc2VuY2VtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciByZWFsdGltZWNoYW5uZWxfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzgpKTtcbnZhciBtdWx0aWNhc3Rlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyMykpO1xudmFyIGNoYW5uZWxzdGF0ZWNoYW5nZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzOSkpO1xudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG5mdW5jdGlvbiBnZXRDbGllbnRJZChyZWFsdGltZVByZXNlbmNlKSB7XG4gICAgcmV0dXJuIHJlYWx0aW1lUHJlc2VuY2UuY2hhbm5lbC5yZWFsdGltZS5hdXRoLmNsaWVudElkO1xufVxuZnVuY3Rpb24gaXNBbm9ueW1vdXNPcldpbGRjYXJkKHJlYWx0aW1lUHJlc2VuY2UpIHtcbiAgICB2YXIgcmVhbHRpbWUgPSByZWFsdGltZVByZXNlbmNlLmNoYW5uZWwucmVhbHRpbWU7XG4gICAgLyogSWYgbm90IGN1cnJlbnRseSBjb25uZWN0ZWQsIHdlIGNhbid0IGFzc3VtZSB0aGF0IHdlJ3JlIGFuIGFub255bW91c1xuICAgICAqIGNsaWVudCwgYXMgcmVhbHRpbWUgbWF5IGluZm9ybSB1cyBvZiBvdXIgY2xpZW50SWQgaW4gdGhlIENPTk5FQ1RFRFxuICAgICAqIG1lc3NhZ2UuIFNvIGFzc3VtZSB3ZSdyZSBub3QgYW5vbnltb3VzIGFuZCBsZWF2ZSBpdCB0byByZWFsdGltZSB0b1xuICAgICAqIHJldHVybiBhbiBlcnJvciBpZiB3ZSBhcmUgKi9cbiAgICB2YXIgY2xpZW50SWQgPSByZWFsdGltZS5hdXRoLmNsaWVudElkO1xuICAgIHJldHVybiAoIWNsaWVudElkIHx8IGNsaWVudElkID09PSAnKicpICYmIHJlYWx0aW1lLmNvbm5lY3Rpb24uc3RhdGUgPT09ICdjb25uZWN0ZWQnO1xufVxuLyogQ2FsbGJhY2sgaXMgY2FsbGVkIG9ubHkgaW4gdGhlIGV2ZW50IG9mIGFuIGVycm9yICovXG5mdW5jdGlvbiB3YWl0QXR0YWNoZWQoY2hhbm5lbCwgY2FsbGJhY2ssIGFjdGlvbikge1xuICAgIHN3aXRjaCAoY2hhbm5lbC5zdGF0ZSkge1xuICAgICAgICBjYXNlICdhdHRhY2hlZCc6XG4gICAgICAgIGNhc2UgJ3N1c3BlbmRlZCc6XG4gICAgICAgICAgICBhY3Rpb24oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbml0aWFsaXplZCc6XG4gICAgICAgIGNhc2UgJ2RldGFjaGVkJzpcbiAgICAgICAgY2FzZSAnZGV0YWNoaW5nJzpcbiAgICAgICAgY2FzZSAnYXR0YWNoaW5nJzpcbiAgICAgICAgICAgIGNoYW5uZWwuYXR0YWNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKGNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5ld2VyVGhhbihpdGVtLCBleGlzdGluZykge1xuICAgIC8qIFJUUDJiMTogaWYgZWl0aGVyIGlzIHN5bnRoZXNpc2VkLCBjb21wYXJlIGJ5IHRpbWVzdGFtcCAqL1xuICAgIGlmIChpdGVtLmlzU3ludGhlc2l6ZWQoKSB8fCBleGlzdGluZy5pc1N5bnRoZXNpemVkKCkpIHtcbiAgICAgICAgLy8gUlRQMmIxYTogaWYgZXF1YWwsIHByZWZlciB0aGUgbmV3bHktYXJyaXZlZCBvbmVcbiAgICAgICAgcmV0dXJuIGl0ZW0udGltZXN0YW1wID49IGV4aXN0aW5nLnRpbWVzdGFtcDtcbiAgICB9XG4gICAgLyogUlRQMmIyICovXG4gICAgdmFyIGl0ZW1PcmRlcmluZ3MgPSBpdGVtLnBhcnNlSWQoKSwgZXhpc3RpbmdPcmRlcmluZ3MgPSBleGlzdGluZy5wYXJzZUlkKCk7XG4gICAgaWYgKGl0ZW1PcmRlcmluZ3MubXNnU2VyaWFsID09PSBleGlzdGluZ09yZGVyaW5ncy5tc2dTZXJpYWwpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1PcmRlcmluZ3MuaW5kZXggPiBleGlzdGluZ09yZGVyaW5ncy5pbmRleDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBpdGVtT3JkZXJpbmdzLm1zZ1NlcmlhbCA+IGV4aXN0aW5nT3JkZXJpbmdzLm1zZ1NlcmlhbDtcbiAgICB9XG59XG52YXIgUmVhbHRpbWVQcmVzZW5jZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZWFsdGltZVByZXNlbmNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlYWx0aW1lUHJlc2VuY2UoY2hhbm5lbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjaGFubmVsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgX3RoaXMuc3luY0NvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIF90aGlzLm1lbWJlcnMgPSBuZXcgUHJlc2VuY2VNYXAoX3RoaXMsIGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLmNsaWVudElkICsgJzonICsgaXRlbS5jb25uZWN0aW9uSWQ7IH0pO1xuICAgICAgICAvLyBSVFAxN2g6IFN0b3JlIG93biBtZW1iZXJzIGJ5IGNsaWVudElkIG9ubHkuXG4gICAgICAgIF90aGlzLl9teU1lbWJlcnMgPSBuZXcgUHJlc2VuY2VNYXAoX3RoaXMsIGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLmNsaWVudElkOyB9KTtcbiAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBldmVudGVtaXR0ZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIF90aGlzLnBlbmRpbmdQcmVzZW5jZSA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChpc0Fub255bW91c09yV2lsZGNhcmQodGhpcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdjbGllbnRJZCBtdXN0IGJlIHNwZWNpZmllZCB0byBlbnRlciBhIHByZXNlbmNlIGNoYW5uZWwnLCA0MDAxMiwgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGF0YSwgJ2VudGVyJywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChpc0Fub255bW91c09yV2lsZGNhcmQodGhpcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdjbGllbnRJZCBtdXN0IGJlIHNwZWNpZmllZCB0byB1cGRhdGUgcHJlc2VuY2UgZGF0YScsIDQwMDEyLCA0MDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkYXRhLCAndXBkYXRlJywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuZW50ZXJDbGllbnQgPSBmdW5jdGlvbiAoY2xpZW50SWQsIGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KHVuZGVmaW5lZCwgY2xpZW50SWQsIGRhdGEsICdlbnRlcicsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLnVwZGF0ZUNsaWVudCA9IGZ1bmN0aW9uIChjbGllbnRJZCwgZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQodW5kZWZpbmVkLCBjbGllbnRJZCwgZGF0YSwgJ3VwZGF0ZScsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLl9lbnRlck9yVXBkYXRlQ2xpZW50ID0gZnVuY3Rpb24gKGlkLCBjbGllbnRJZCwgZGF0YSwgYWN0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnX2VudGVyT3JVcGRhdGVDbGllbnQnLCBbaWQsIGNsaWVudElkLCBkYXRhLCBhY3Rpb25dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsO1xuICAgICAgICBpZiAoIWNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgICAgICAgY2FsbGJhY2soY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2UuJyArIGFjdGlvbiArICdDbGllbnQoKScsICdjaGFubmVsID0gJyArIGNoYW5uZWwubmFtZSArICcsIGlkID0gJyArIGlkICsgJywgY2xpZW50ID0gJyArIChjbGllbnRJZCB8fCAnKGltcGxpY2l0KSAnICsgZ2V0Q2xpZW50SWQodGhpcykpKTtcbiAgICAgICAgdmFyIHByZXNlbmNlID0gcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5mcm9tRGF0YShkYXRhKTtcbiAgICAgICAgcHJlc2VuY2UuYWN0aW9uID0gYWN0aW9uO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHByZXNlbmNlLmlkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsaWVudElkKSB7XG4gICAgICAgICAgICBwcmVzZW5jZS5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgICB9XG4gICAgICAgIHByZXNlbmNlbWVzc2FnZV8xLmRlZmF1bHQuZW5jb2RlKHByZXNlbmNlLCBjaGFubmVsLmNoYW5uZWxPcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYW5uZWwuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdhdHRhY2hlZCc6XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuc2VuZFByZXNlbmNlKHByZXNlbmNlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2luaXRpYWxpemVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkZXRhY2hlZCc6XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuYXR0YWNoKCk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgY2FzZSAnYXR0YWNoaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGVuZGluZ1ByZXNlbmNlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2U6IHByZXNlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZXJyID0gbmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ1VuYWJsZSB0byAnICsgYWN0aW9uICsgJyBwcmVzZW5jZSBjaGFubmVsIHdoaWxlIGluICcgKyBjaGFubmVsLnN0YXRlICsgJyBzdGF0ZScsIDkwMDAxKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyLmNvZGUgPSA5MDAwMTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5sZWF2ZSA9IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoaXNBbm9ueW1vdXNPcldpbGRjYXJkKHRoaXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnY2xpZW50SWQgbXVzdCBoYXZlIGJlZW4gc3BlY2lmaWVkIHRvIGVudGVyIG9yIGxlYXZlIGEgcHJlc2VuY2UgY2hhbm5lbCcsIDQwMDEyLCA0MDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxlYXZlQ2xpZW50KHVuZGVmaW5lZCwgZGF0YSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUubGVhdmVDbGllbnQgPSBmdW5jdGlvbiAoY2xpZW50SWQsIGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZGF0YTtcbiAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWwucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdsZWF2ZUNsaWVudCcsIFtjbGllbnRJZCwgZGF0YV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG4gICAgICAgIGlmICghY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2UubGVhdmVDbGllbnQoKScsICdsZWF2aW5nOyBjaGFubmVsID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lICsgJywgY2xpZW50ID0gJyArIGNsaWVudElkKTtcbiAgICAgICAgdmFyIHByZXNlbmNlID0gcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgIGFjdGlvbjogJ2xlYXZlJyxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2xpZW50SWQpIHtcbiAgICAgICAgICAgIHByZXNlbmNlLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjaGFubmVsLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdhdHRhY2hlZCc6XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5zZW5kUHJlc2VuY2UocHJlc2VuY2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2F0dGFjaGluZyc6XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUHJlc2VuY2UucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHByZXNlbmNlOiBwcmVzZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5pdGlhbGl6ZWQnOlxuICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzoge1xuICAgICAgICAgICAgICAgIC8qIHdlJ3JlIG5vdCBhdHRhY2hlZDsgdGhlcmVmb3JlIHdlIGxldCBhbnkgZW50ZXJlZCBzdGF0dXNcbiAgICAgICAgICAgICAgICAgKiB0aW1lb3V0IGJ5IGl0c2VsZiBpbnN0ZWFkIG9mIGF0dGFjaGluZyBqdXN0IGluIG9yZGVyIHRvIGxlYXZlICovXG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdVbmFibGUgdG8gbGVhdmUgcHJlc2VuY2UgY2hhbm5lbCAoaW5jb21wYXRpYmxlIHN0YXRlKScsIDkwMDAxKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKGNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFJldHVybiB0eXBlIGlzIGFueSB0byBhdm9pZCBjb25mbGljdCB3aXRoIGJhc2UgUHJlc2VuY2UgY2xhc3NcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAxICYmIHR5cGVvZiBhcmdzWzBdID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQobnVsbCk7XG4gICAgICAgIHBhcmFtcyA9IGFyZ3NbMF07XG4gICAgICAgIGNhbGxiYWNrID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIHdhaXRGb3JTeW5jID0gIXBhcmFtcyB8fCAoJ3dhaXRGb3JTeW5jJyBpbiBwYXJhbXMgPyBwYXJhbXMud2FpdEZvclN5bmMgOiB0cnVlKTtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbC5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnZ2V0JywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmV0dXJuTWVtYmVycyhtZW1iZXJzKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBwYXJhbXMgPyBtZW1iZXJzLmxpc3QocGFyYW1zKSA6IG1lbWJlcnMudmFsdWVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8qIFNwZWNpYWwtY2FzZSB0aGUgc3VzcGVuZGVkIHN0YXRlOiBjYW4gc3RpbGwgZ2V0IChzdGFsZSkgcHJlc2VuY2Ugc2V0IGlmIHdhaXRGb3JTeW5jIGlzIGZhbHNlICovXG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWwuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgICAgICBpZiAod2FpdEZvclN5bmMpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IDkxMDA1LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUHJlc2VuY2Ugc3RhdGUgaXMgb3V0IG9mIHN5bmMgZHVlIHRvIGNoYW5uZWwgYmVpbmcgaW4gdGhlIFNVU1BFTkRFRCBzdGF0ZScsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuTWVtYmVycyh0aGlzLm1lbWJlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhaXRBdHRhY2hlZCh0aGlzLmNoYW5uZWwsIGNhbGxiYWNrLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IF90aGlzLm1lbWJlcnM7XG4gICAgICAgICAgICBpZiAod2FpdEZvclN5bmMpIHtcbiAgICAgICAgICAgICAgICBtZW1iZXJzLndhaXRTeW5jKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuTWVtYmVycyhtZW1iZXJzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybk1lbWJlcnMobWVtYmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuaGlzdG9yeSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS5oaXN0b3J5KCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLm5hbWUpO1xuICAgICAgICAvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbC5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2hpc3RvcnknLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMudW50aWxBdHRhY2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWwuc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW1zLnVudGlsQXR0YWNoO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5mcm9tX3NlcmlhbCA9IHRoaXMuY2hhbm5lbC5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdvcHRpb24gdW50aWxBdHRhY2ggcmVxdWlyZXMgdGhlIGNoYW5uZWwgdG8gYmUgYXR0YWNoZWQsIHdhczogJyArIHRoaXMuY2hhbm5lbC5zdGF0ZSwgNDAwMDAsIDQwMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZXNlbmNlXzEuZGVmYXVsdC5wcm90b3R5cGUuX2hpc3RvcnkuY2FsbCh0aGlzLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLnNldFByZXNlbmNlID0gZnVuY3Rpb24gKHByZXNlbmNlU2V0LCBpc1N5bmMsIHN5bmNDaGFubmVsU2VyaWFsKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS5zZXRQcmVzZW5jZSgpJywgJ3JlY2VpdmVkIHByZXNlbmNlIGZvciAnICsgcHJlc2VuY2VTZXQubGVuZ3RoICsgJyBwYXJ0aWNpcGFudHM7IHN5bmNDaGFubmVsU2VyaWFsID0gJyArIHN5bmNDaGFubmVsU2VyaWFsKTtcbiAgICAgICAgdmFyIHN5bmNDdXJzb3IsIG1hdGNoO1xuICAgICAgICB2YXIgbWVtYmVycyA9IHRoaXMubWVtYmVycywgbXlNZW1iZXJzID0gdGhpcy5fbXlNZW1iZXJzLCBicm9hZGNhc3RNZXNzYWdlcyA9IFtdLCBjb25uSWQgPSB0aGlzLmNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkO1xuICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICB0aGlzLm1lbWJlcnMuc3RhcnRTeW5jKCk7XG4gICAgICAgICAgICBpZiAoc3luY0NoYW5uZWxTZXJpYWwgJiYgKG1hdGNoID0gc3luY0NoYW5uZWxTZXJpYWwubWF0Y2goL15bXFx3LV0rOiguKikkLykpKSB7XG4gICAgICAgICAgICAgICAgc3luY0N1cnNvciA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlc2VuY2VTZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcmVzZW5jZSA9IHByZXNlbmNlbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyhwcmVzZW5jZVNldFtpXSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHByZXNlbmNlLmFjdGlvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlYXZlJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlcnMucmVtb3ZlKHByZXNlbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0TWVzc2FnZXMucHVzaChwcmVzZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXNlbmNlLmNvbm5lY3Rpb25JZCA9PT0gY29ubklkICYmICFwcmVzZW5jZS5pc1N5bnRoZXNpemVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG15TWVtYmVycy5yZW1vdmUocHJlc2VuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VudGVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdwcmVzZW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICd1cGRhdGUnOlxuICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVycy5wdXQocHJlc2VuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3RNZXNzYWdlcy5wdXNoKHByZXNlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJlc2VuY2UuY29ubmVjdGlvbklkID09PSBjb25uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG15TWVtYmVycy5wdXQocHJlc2VuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGlmIHRoaXMgaXMgdGhlIGxhc3QgKG9yIG9ubHkpIG1lc3NhZ2UgaW4gYSBzZXF1ZW5jZSBvZiBzeW5jIHVwZGF0ZXMsIGVuZCB0aGUgc3luYyAqL1xuICAgICAgICBpZiAoaXNTeW5jICYmICFzeW5jQ3Vyc29yKSB7XG4gICAgICAgICAgICBtZW1iZXJzLmVuZFN5bmMoKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5zeW5jQ2hhbm5lbFNlcmlhbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyogYnJvYWRjYXN0IHRvIGxpc3RlbmVycyAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJyb2FkY2FzdE1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJlc2VuY2UgPSBicm9hZGNhc3RNZXNzYWdlc1tpXTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5lbWl0KHByZXNlbmNlLmFjdGlvbiwgcHJlc2VuY2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5vbkF0dGFjaGVkID0gZnVuY3Rpb24gKGhhc1ByZXNlbmNlKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUmVhbHRpbWVQcmVzZW5jZS5vbkF0dGFjaGVkKCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLmNoYW5uZWwubmFtZSArICcsIGhhc1ByZXNlbmNlID0gJyArIGhhc1ByZXNlbmNlKTtcbiAgICAgICAgaWYgKGhhc1ByZXNlbmNlKSB7XG4gICAgICAgICAgICB0aGlzLm1lbWJlcnMuc3RhcnRTeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zeW50aGVzaXplTGVhdmVzKHRoaXMubWVtYmVycy52YWx1ZXMoKSk7XG4gICAgICAgICAgICB0aGlzLm1lbWJlcnMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSVFAxN2Y6IFJlLWVudGVyIG93biBtZW1iZXJzIHdoZW4gbW92aW5nIGludG8gdGhlIGF0dGFjaGVkIHN0YXRlLlxuICAgICAgICB0aGlzLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KCk7XG4gICAgICAgIC8qIE5CIHRoaXMgbXVzdCBiZSBhZnRlciB0aGUgX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQgY2FsbCwgd2hpY2ggbWF5IGFkZCBpdGVtcyB0byBwZW5kaW5nUHJlc2VuY2UgKi9cbiAgICAgICAgdmFyIHBlbmRpbmdQcmVzZW5jZSA9IHRoaXMucGVuZGluZ1ByZXNlbmNlLCBwZW5kaW5nUHJlc0NvdW50ID0gcGVuZGluZ1ByZXNlbmNlLmxlbmd0aDtcbiAgICAgICAgaWYgKHBlbmRpbmdQcmVzQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1ByZXNlbmNlID0gW107XG4gICAgICAgICAgICB2YXIgcHJlc2VuY2VBcnJheSA9IFtdO1xuICAgICAgICAgICAgdmFyIG11bHRpY2FzdGVyID0gbXVsdGljYXN0ZXJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZVByZXNlbmNlLm9uQXR0YWNoZWQnLCAnc2VuZGluZyAnICsgcGVuZGluZ1ByZXNDb3VudCArICcgcXVldWVkIHByZXNlbmNlIG1lc3NhZ2VzJyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBlbmRpbmdQcmVzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBldmVudF8xID0gcGVuZGluZ1ByZXNlbmNlW2ldO1xuICAgICAgICAgICAgICAgIHByZXNlbmNlQXJyYXkucHVzaChldmVudF8xLnByZXNlbmNlKTtcbiAgICAgICAgICAgICAgICBtdWx0aWNhc3Rlci5wdXNoKGV2ZW50XzEuY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGFubmVsLnNlbmRQcmVzZW5jZShwcmVzZW5jZUFycmF5LCBtdWx0aWNhc3Rlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmFjdE9uQ2hhbm5lbFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCBoYXNQcmVzZW5jZSwgZXJyKSB7XG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2F0dGFjaGVkJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uQXR0YWNoZWQoaGFzUHJlc2VuY2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGV0YWNoZWQnOlxuICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhck15TWVtYmVycygpO1xuICAgICAgICAgICAgICAgIHRoaXMubWVtYmVycy5jbGVhcigpO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnc3VzcGVuZGVkJzpcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWxQZW5kaW5nUHJlc2VuY2UoZXJyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuZmFpbFBlbmRpbmdQcmVzZW5jZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1ByZXNlbmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwuZmFpbFBlbmRpbmdQcmVzZW5jZScsICdjaGFubmVsOyBuYW1lID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lICsgJywgZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nUHJlc2VuY2UubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUHJlc2VuY2VbaV0uY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1ByZXNlbmNlID0gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLl9jbGVhck15TWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbXlNZW1iZXJzLmNsZWFyKCk7XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG15TWVtYmVycyA9IHRoaXMuX215TWVtYmVycywgcmVlbnRlckNiID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnUHJlc2VuY2UgYXV0by1yZS1lbnRlciBmYWlsZWQ6ICcgKyBlcnIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZEVyciA9IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgOTEwMDQsIDQwMCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdSZWFsdGltZVByZXNlbmNlLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KCknLCBtc2cpO1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBuZXcgY2hhbm5lbHN0YXRlY2hhbmdlXzEuZGVmYXVsdChfdGhpcy5jaGFubmVsLnN0YXRlLCBfdGhpcy5jaGFubmVsLnN0YXRlLCB0cnVlLCBmYWxzZSwgd3JhcHBlZEVycik7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2hhbm5lbC5lbWl0KCd1cGRhdGUnLCBjaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBtZW1iZXJLZXkgaW4gbXlNZW1iZXJzLm1hcCkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gbXlNZW1iZXJzLm1hcFttZW1iZXJLZXldO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZVByZXNlbmNlLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KCknLCAnQXV0by1yZWVudGVyaW5nIGNsaWVudElkIFwiJyArIGVudHJ5LmNsaWVudElkICsgJ1wiIGludG8gdGhlIHByZXNlbmNlIHNldCcpO1xuICAgICAgICAgICAgLy8gUlRQMTdnOiBTZW5kIEVOVEVSIGNvbnRhaW5pbmcgdGhlIG1lbWJlciBpZCwgY2xpZW50SWQgYW5kIGRhdGFcbiAgICAgICAgICAgIC8vIGF0dHJpYnV0ZXMuXG4gICAgICAgICAgICB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KGVudHJ5LmlkLCBlbnRyeS5jbGllbnRJZCwgZW50cnkuZGF0YSwgJ2VudGVyJywgcmVlbnRlckNiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuX3N5bnRoZXNpemVMZWF2ZXMgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnM7XG4gICAgICAgIFV0aWxzLmFyckZvckVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIgcHJlc2VuY2UgPSBwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogJ2xlYXZlJyxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQ6IGl0ZW0uY29ubmVjdGlvbklkLFxuICAgICAgICAgICAgICAgIGNsaWVudElkOiBpdGVtLmNsaWVudElkLFxuICAgICAgICAgICAgICAgIGRhdGE6IGl0ZW0uZGF0YSxcbiAgICAgICAgICAgICAgICBlbmNvZGluZzogaXRlbS5lbmNvZGluZyxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IFV0aWxzLm5vdygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zLmVtaXQoJ2xlYXZlJywgcHJlc2VuY2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qIERlcHJlY2F0ZWQgKi9cbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlcHJlY2F0ZWQoJ3ByZXNlbmNlLm9uJywgJ3ByZXNlbmNlLnN1YnNjcmliZScpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICAgIC8qIERlcHJlY2F0ZWQgKi9cbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZXByZWNhdGVkKCdwcmVzZW5jZS5vZmYnLCAncHJlc2VuY2UudW5zdWJzY3JpYmUnKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hcmdzID0gW107IC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovXG4gICAgICAgIGZvciAodmFyIF9pID0gMCAvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqLzsgX2kgPCBhcmd1bWVudHMubGVuZ3RoIC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovOyBfaSsrIC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovKSB7XG4gICAgICAgICAgICBfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldOyAvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqL1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcmdzID0gcmVhbHRpbWVjaGFubmVsXzEuZGVmYXVsdC5wcm9jZXNzTGlzdGVuZXJBcmdzKF9hcmdzKTtcbiAgICAgICAgdmFyIGV2ZW50ID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1syXTtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWwucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3N1YnNjcmliZScsIFtldmVudCwgbGlzdGVuZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyhjaGFubmVsLmludmFsaWRTdGF0ZUVycm9yKCkpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgY2hhbm5lbC5hdHRhY2goY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYXJncyA9IFtdOyAvKiBbZXZlbnRdLCBsaXN0ZW5lciAqL1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAgLyogW2V2ZW50XSwgbGlzdGVuZXIgKi87IF9pIDwgYXJndW1lbnRzLmxlbmd0aCAvKiBbZXZlbnRdLCBsaXN0ZW5lciAqLzsgX2krKyAvKiBbZXZlbnRdLCBsaXN0ZW5lciAqLykge1xuICAgICAgICAgICAgX2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTsgLyogW2V2ZW50XSwgbGlzdGVuZXIgKi9cbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJncyA9IHJlYWx0aW1lY2hhbm5lbF8xLmRlZmF1bHQucHJvY2Vzc0xpc3RlbmVyQXJncyhfYXJncyk7XG4gICAgICAgIHZhciBldmVudCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IGFyZ3NbMV07XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWFsdGltZVByZXNlbmNlO1xufShwcmVzZW5jZV8xLmRlZmF1bHQpKTtcbnZhciBQcmVzZW5jZU1hcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhQcmVzZW5jZU1hcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcmVzZW5jZU1hcChwcmVzZW5jZSwgbWVtYmVyS2V5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByZXNlbmNlID0gcHJlc2VuY2U7XG4gICAgICAgIF90aGlzLm1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIF90aGlzLnN5bmNJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG4gICAgICAgIF90aGlzLm1lbWJlcktleSA9IG1lbWJlcktleTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQcmVzZW5jZU1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBba2V5XTtcbiAgICB9O1xuICAgIFByZXNlbmNlTWFwLnByb3RvdHlwZS5nZXRDbGllbnQgPSBmdW5jdGlvbiAoY2xpZW50SWQpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwLCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG1hcCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBtYXBba2V5XTtcbiAgICAgICAgICAgIGlmIChpdGVtLmNsaWVudElkID09IGNsaWVudElkICYmIGl0ZW0uYWN0aW9uICE9ICdhYnNlbnQnKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1hcC5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwLCBjbGllbnRJZCA9IHBhcmFtcyAmJiBwYXJhbXMuY2xpZW50SWQsIGNvbm5lY3Rpb25JZCA9IHBhcmFtcyAmJiBwYXJhbXMuY29ubmVjdGlvbklkLCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG1hcCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBtYXBba2V5XTtcbiAgICAgICAgICAgIGlmIChpdGVtLmFjdGlvbiA9PT0gJ2Fic2VudCcpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoY2xpZW50SWQgJiYgY2xpZW50SWQgIT0gaXRlbS5jbGllbnRJZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uSWQgJiYgY29ubmVjdGlvbklkICE9IGl0ZW0uY29ubmVjdGlvbklkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFByZXNlbmNlTWFwLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5hY3Rpb24gPT09ICdlbnRlcicgfHwgaXRlbS5hY3Rpb24gPT09ICd1cGRhdGUnKSB7XG4gICAgICAgICAgICBpdGVtID0gcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKGl0ZW0pO1xuICAgICAgICAgICAgaXRlbS5hY3Rpb24gPSAncHJlc2VudCc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwLCBrZXkgPSB0aGlzLm1lbWJlcktleShpdGVtKTtcbiAgICAgICAgLyogd2UndmUgc2VlbiB0aGlzIG1lbWJlciwgc28gZG8gbm90IHJlbW92ZSBpdCBhdCB0aGUgZW5kIG9mIHN5bmMgKi9cbiAgICAgICAgaWYgKHRoaXMucmVzaWR1YWxNZW1iZXJzKVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVzaWR1YWxNZW1iZXJzW2tleV07XG4gICAgICAgIC8qIGNvbXBhcmUgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbmV3IGl0ZW0gd2l0aCBhbnkgZXhpc3RpbmcgbWVtYmVyIChvciBBQlNFTlQgd2l0bmVzcykgKi9cbiAgICAgICAgdmFyIGV4aXN0aW5nSXRlbSA9IG1hcFtrZXldO1xuICAgICAgICBpZiAoZXhpc3RpbmdJdGVtICYmICFuZXdlclRoYW4oaXRlbSwgZXhpc3RpbmdJdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG1hcFtrZXldID0gaXRlbTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1hcC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5tYXAsIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbWFwKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IG1hcFtrZXldO1xuICAgICAgICAgICAgaWYgKGl0ZW0uYWN0aW9uICE9ICdhYnNlbnQnKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1hcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwLCBrZXkgPSB0aGlzLm1lbWJlcktleShpdGVtKTtcbiAgICAgICAgdmFyIGV4aXN0aW5nSXRlbSA9IG1hcFtrZXldO1xuICAgICAgICBpZiAoZXhpc3RpbmdJdGVtICYmICFuZXdlclRoYW4oaXRlbSwgZXhpc3RpbmdJdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qIFJUUDJmICovXG4gICAgICAgIGlmICh0aGlzLnN5bmNJblByb2dyZXNzKSB7XG4gICAgICAgICAgICBpdGVtID0gcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKGl0ZW0pO1xuICAgICAgICAgICAgaXRlbS5hY3Rpb24gPSAnYWJzZW50JztcbiAgICAgICAgICAgIG1hcFtrZXldID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBtYXBba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFByZXNlbmNlTWFwLnByb3RvdHlwZS5zdGFydFN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLm1hcCwgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1ByZXNlbmNlTWFwLnN0YXJ0U3luYygpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5wcmVzZW5jZS5jaGFubmVsLm5hbWUgKyAnOyBzeW5jSW5Qcm9ncmVzcyA9ICcgKyBzeW5jSW5Qcm9ncmVzcyk7XG4gICAgICAgIC8qIHdlIG1pZ2h0IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB3aGlsZSBhIHN5bmMgaXMgaW4gcHJvZ3Jlc3MgKi9cbiAgICAgICAgaWYgKCF0aGlzLnN5bmNJblByb2dyZXNzKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2lkdWFsTWVtYmVycyA9IFV0aWxzLmNvcHkobWFwKTtcbiAgICAgICAgICAgIHRoaXMuc2V0SW5Qcm9ncmVzcyh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHJlc2VuY2VNYXAucHJvdG90eXBlLmVuZFN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLm1hcCwgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1ByZXNlbmNlTWFwLmVuZFN5bmMoKScsICdjaGFubmVsID0gJyArIHRoaXMucHJlc2VuY2UuY2hhbm5lbC5uYW1lICsgJzsgc3luY0luUHJvZ3Jlc3MgPSAnICsgc3luY0luUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAoc3luY0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIC8qIHdlIGNhbiBub3cgc3RyaXAgb3V0IHRoZSBBQlNFTlQgbWVtYmVycywgYXMgd2UgaGF2ZVxuICAgICAgICAgICAgICogcmVjZWl2ZWQgYWxsIG9mIHRoZSBvdXQtb2Ytb3JkZXIgc3luYyBtZXNzYWdlcyAqL1xuICAgICAgICAgICAgZm9yICh2YXIgbWVtYmVyS2V5IGluIG1hcCkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IG1hcFttZW1iZXJLZXldO1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5hY3Rpb24gPT09ICdhYnNlbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtYXBbbWVtYmVyS2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBhbnkgbWVtYmVycyB0aGF0IHdlcmUgcHJlc2VudCBhdCB0aGUgc3RhcnQgb2YgdGhlIHN5bmMsXG4gICAgICAgICAgICAgKiBhbmQgaGF2ZSBub3QgYmVlbiBzZWVuIGluIHN5bmMsIGNhbiBiZSByZW1vdmVkLCBhbmQgbGVhdmUgZXZlbnRzIGVtaXR0ZWQgKi9cbiAgICAgICAgICAgIHRoaXMucHJlc2VuY2UuX3N5bnRoZXNpemVMZWF2ZXMoVXRpbHMudmFsdWVzQXJyYXkodGhpcy5yZXNpZHVhbE1lbWJlcnMpKTtcbiAgICAgICAgICAgIGZvciAodmFyIG1lbWJlcktleSBpbiB0aGlzLnJlc2lkdWFsTWVtYmVycykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYXBbbWVtYmVyS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzaWR1YWxNZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICAgIC8qIGZpbmlzaCwgbm90aWZ5aW5nIGFueSB3YWl0ZXJzICovXG4gICAgICAgICAgICB0aGlzLnNldEluUHJvZ3Jlc3MoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnc3luYycpO1xuICAgIH07XG4gICAgUHJlc2VuY2VNYXAucHJvdG90eXBlLndhaXRTeW5jID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzeW5jSW5Qcm9ncmVzcyA9IHRoaXMuc3luY0luUHJvZ3Jlc3M7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUHJlc2VuY2VNYXAud2FpdFN5bmMoKScsICdjaGFubmVsID0gJyArIHRoaXMucHJlc2VuY2UuY2hhbm5lbC5uYW1lICsgJzsgc3luY0luUHJvZ3Jlc3MgPSAnICsgc3luY0luUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAoIXN5bmNJblByb2dyZXNzKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25jZSgnc3luYycsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFByZXNlbmNlTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tYXAgPSB7fTtcbiAgICAgICAgdGhpcy5zZXRJblByb2dyZXNzKGZhbHNlKTtcbiAgICAgICAgdGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBudWxsO1xuICAgIH07XG4gICAgUHJlc2VuY2VNYXAucHJvdG90eXBlLnNldEluUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoaW5Qcm9ncmVzcykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1ByZXNlbmNlTWFwLnNldEluUHJvZ3Jlc3MoKScsICdpblByb2dyZXNzID0gJyArIGluUHJvZ3Jlc3MpO1xuICAgICAgICB0aGlzLnN5bmNJblByb2dyZXNzID0gaW5Qcm9ncmVzcztcbiAgICAgICAgdGhpcy5wcmVzZW5jZS5zeW5jQ29tcGxldGUgPSAhaW5Qcm9ncmVzcztcbiAgICB9O1xuICAgIHJldHVybiBQcmVzZW5jZU1hcDtcbn0oZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUmVhbHRpbWVQcmVzZW5jZTtcblxuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgZW5jX2hleF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XG52YXIgZW5jX3V0ZjhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xudmFyIGVuY19iYXNlNjRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xudmFyIGxpYl90eXBlZGFycmF5c18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg1KSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIEJ1ZmZlclV0aWxzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1ZmZlclV0aWxzKCkge1xuICAgICAgICB0aGlzLmJhc2U2NENoYXJTZXQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4gICAgICAgIHRoaXMuaGV4Q2hhclNldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcbiAgICB9XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLmlzV29yZEFycmF5ID0gZnVuY3Rpb24gKG9iKSB7XG4gICAgICAgIHJldHVybiBvYiAhPT0gbnVsbCAmJiBvYiAhPT0gdW5kZWZpbmVkICYmIG9iLnNpZ0J5dGVzICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUuaXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIChvYikge1xuICAgICAgICByZXR1cm4gb2IgIT09IG51bGwgJiYgb2IgIT09IHVuZGVmaW5lZCAmJiBvYi5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXI7XG4gICAgfTtcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUuaXNUeXBlZEFycmF5ID0gZnVuY3Rpb24gKG9iKSB7XG4gICAgICAgIHJldHVybiAhIUFycmF5QnVmZmVyICYmIEFycmF5QnVmZmVyLmlzVmlldyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcob2IpO1xuICAgIH07XG4gICAgLy8gLy8gaHR0cHM6Ly9naXN0LmdpdGh1YnVzZXJjb250ZW50LmNvbS9qb25sZWlnaHRvbi85NTg4NDEvcmF3L2YyMDBlMzBkZmU5NTIxMmMwMTY1Y2NmMWFlMDAwY2E1MWU5ZGU4MDMvZ2lzdGZpbGUxLmpzXG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLnVpbnQ4Vmlld1RvQmFzZTY0ID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgIHZhciBiYXNlNjQgPSAnJztcbiAgICAgICAgdmFyIGVuY29kaW5ncyA9IHRoaXMuYmFzZTY0Q2hhclNldDtcbiAgICAgICAgdmFyIGJ5dGVMZW5ndGggPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgICAgICB2YXIgYnl0ZVJlbWFpbmRlciA9IGJ5dGVMZW5ndGggJSAzO1xuICAgICAgICB2YXIgbWFpbkxlbmd0aCA9IGJ5dGVMZW5ndGggLSBieXRlUmVtYWluZGVyO1xuICAgICAgICB2YXIgYSwgYiwgYywgZDtcbiAgICAgICAgdmFyIGNodW5rO1xuICAgICAgICAvLyBNYWluIGxvb3AgZGVhbHMgd2l0aCBieXRlcyBpbiBjaHVua3Mgb2YgM1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1haW5MZW5ndGg7IGkgPSBpICsgMykge1xuICAgICAgICAgICAgLy8gQ29tYmluZSB0aGUgdGhyZWUgYnl0ZXMgaW50byBhIHNpbmdsZSBpbnRlZ2VyXG4gICAgICAgICAgICBjaHVuayA9IChieXRlc1tpXSA8PCAxNikgfCAoYnl0ZXNbaSArIDFdIDw8IDgpIHwgYnl0ZXNbaSArIDJdO1xuICAgICAgICAgICAgLy8gVXNlIGJpdG1hc2tzIHRvIGV4dHJhY3QgNi1iaXQgc2VnbWVudHMgZnJvbSB0aGUgdHJpcGxldFxuICAgICAgICAgICAgYSA9IChjaHVuayAmIDE2NTE1MDcyKSA+PiAxODsgLy8gMTY1MTUwNzIgPSAoMl42IC0gMSkgPDwgMThcbiAgICAgICAgICAgIGIgPSAoY2h1bmsgJiAyNTgwNDgpID4+IDEyOyAvLyAyNTgwNDggICA9ICgyXjYgLSAxKSA8PCAxMlxuICAgICAgICAgICAgYyA9IChjaHVuayAmIDQwMzIpID4+IDY7IC8vIDQwMzIgICAgID0gKDJeNiAtIDEpIDw8IDZcbiAgICAgICAgICAgIGQgPSBjaHVuayAmIDYzOyAvLyA2MyAgICAgICA9IDJeNiAtIDFcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHJhdyBiaW5hcnkgc2VnbWVudHMgdG8gdGhlIGFwcHJvcHJpYXRlIEFTQ0lJIGVuY29kaW5nXG4gICAgICAgICAgICBiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgZW5jb2RpbmdzW2NdICsgZW5jb2RpbmdzW2RdO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlYWwgd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzIGFuZCBwYWRkaW5nXG4gICAgICAgIGlmIChieXRlUmVtYWluZGVyID09IDEpIHtcbiAgICAgICAgICAgIGNodW5rID0gYnl0ZXNbbWFpbkxlbmd0aF07XG4gICAgICAgICAgICBhID0gKGNodW5rICYgMjUyKSA+PiAyOyAvLyAyNTIgPSAoMl42IC0gMSkgPDwgMlxuICAgICAgICAgICAgLy8gU2V0IHRoZSA0IGxlYXN0IHNpZ25pZmljYW50IGJpdHMgdG8gemVyb1xuICAgICAgICAgICAgYiA9IChjaHVuayAmIDMpIDw8IDQ7IC8vIDMgICA9IDJeMiAtIDFcbiAgICAgICAgICAgIGJhc2U2NCArPSBlbmNvZGluZ3NbYV0gKyBlbmNvZGluZ3NbYl0gKyAnPT0nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ5dGVSZW1haW5kZXIgPT0gMikge1xuICAgICAgICAgICAgY2h1bmsgPSAoYnl0ZXNbbWFpbkxlbmd0aF0gPDwgOCkgfCBieXRlc1ttYWluTGVuZ3RoICsgMV07XG4gICAgICAgICAgICBhID0gKGNodW5rICYgNjQ1MTIpID4+IDEwOyAvLyA2NDUxMiA9ICgyXjYgLSAxKSA8PCAxMFxuICAgICAgICAgICAgYiA9IChjaHVuayAmIDEwMDgpID4+IDQ7IC8vIDEwMDggID0gKDJeNiAtIDEpIDw8IDRcbiAgICAgICAgICAgIC8vIFNldCB0aGUgMiBsZWFzdCBzaWduaWZpY2FudCBiaXRzIHRvIHplcm9cbiAgICAgICAgICAgIGMgPSAoY2h1bmsgJiAxNSkgPDwgMjsgLy8gMTUgICAgPSAyXjQgLSAxXG4gICAgICAgICAgICBiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgZW5jb2RpbmdzW2NdICsgJz0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfTtcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUuYmFzZTY0VG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIChiYXNlNjQpIHtcbiAgICAgICAgdmFyIGJpbmFyeV9zdHJpbmcgPSBhdG9iID09PSBudWxsIHx8IGF0b2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF0b2IoYmFzZTY0KTsgLy8gdGhpcyB3aWxsIGFsd2F5cyBiZSBkZWZpbmVkIGluIGJyb3dzZXIgc28gaXQncyBzYWZlIHRvIGNhc3RcbiAgICAgICAgdmFyIGxlbiA9IGJpbmFyeV9zdHJpbmcubGVuZ3RoO1xuICAgICAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXNjaWkgPSBiaW5hcnlfc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBieXRlc1tpXSA9IGFzY2lpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlcy5idWZmZXI7XG4gICAgfTtcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQXJyYXlCdWZmZXIoYnVmZmVyKSB8fCB0aGlzLmlzV29yZEFycmF5KGJ1ZmZlcikgfHwgdGhpcy5pc1R5cGVkQXJyYXkoYnVmZmVyKTtcbiAgICB9O1xuICAgIC8qIEluIGJyb3dzZXJzLCByZXR1cm5zIGEgVWludDhBcnJheSAqL1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgaWYgKCFBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29udmVydCB0byBCdWZmZXI6IGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgbmVjZXNzYXJ5IHR5cGVzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXlCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNUeXBlZEFycmF5KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIuYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1dvcmRBcnJheShidWZmZXIpKSB7XG4gICAgICAgICAgICAvKiBCYWNrcG9ydGVkIGZyb20gdW5yZWxlYXNlZCBDcnlwdG9KU1xuICAgICAgICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvc291cmNlL2Jyb3dzZS9icmFuY2hlcy8zLngvc3JjL2xpYi10eXBlZGFycmF5cy5qcz9yPTY2MSAqL1xuICAgICAgICAgICAgdmFyIGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlci5zaWdCeXRlcyk7XG4gICAgICAgICAgICB2YXIgdWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIuc2lnQnl0ZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIHVpbnQ4Vmlld1tpXSA9IChidWZmZXIud29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVpbnQ4VmlldztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlclV0aWxzLnRvQnVmZmVyIGV4cGVjdGVkIGFuIGFycmF5YnVmZmVyLCB0eXBlZCBhcnJheSwgb3IgQ3J5cHRvSlMgd29yZGFycmF5Jyk7XG4gICAgfTtcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheUJ1ZmZlcihidWZmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRvQnVmZmVyKGJ1ZmZlcikuYnVmZmVyO1xuICAgIH07XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLnRvV29yZEFycmF5ID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICBpZiAodGhpcy5pc1R5cGVkQXJyYXkoYnVmZmVyKSkge1xuICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pc1dvcmRBcnJheShidWZmZXIpID8gYnVmZmVyIDogbGliX3R5cGVkYXJyYXlzXzEuZGVmYXVsdC5jcmVhdGUoYnVmZmVyKTtcbiAgICB9O1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS5iYXNlNjRFbmNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmlzV29yZEFycmF5KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZW5jX2Jhc2U2NF8xLnN0cmluZ2lmeSkoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy51aW50OFZpZXdUb0Jhc2U2NCh0aGlzLnRvQnVmZmVyKGJ1ZmZlcikpO1xuICAgIH07XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLmJhc2U2NERlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKEFycmF5QnVmZmVyICYmIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuYXRvYikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0VG9BcnJheUJ1ZmZlcihzdHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgZW5jX2Jhc2U2NF8xLnBhcnNlKShzdHIpO1xuICAgIH07XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLmhleEVuY29kZSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuICgwLCBlbmNfaGV4XzEuc3RyaW5naWZ5KSh0aGlzLnRvV29yZEFycmF5KGJ1ZmZlcikpO1xuICAgIH07XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLmhleERlY29kZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgdmFyIHdvcmRBcnJheSA9ICgwLCBlbmNfaGV4XzEucGFyc2UpKHN0cmluZyk7XG4gICAgICAgIHJldHVybiBBcnJheUJ1ZmZlciA/IHRoaXMudG9BcnJheUJ1ZmZlcih3b3JkQXJyYXkpIDogd29yZEFycmF5O1xuICAgIH07XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLnV0ZjhFbmNvZGUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIGlmIChwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLlRleHRFbmNvZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyaW5nKS5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBlbmNfdXRmOF8xLnBhcnNlKShzdHJpbmcpO1xuICAgIH07XG4gICAgLyogRm9yIHV0ZjggZGVjb2Rpbmcgd2UgYXBwbHkgc2xpZ2h0bHkgc3RyaWN0ZXIgaW5wdXQgdmFsaWRhdGlvbiB0aGFuIHRvXG4gICAgICogaGV4RW5jb2RlL2Jhc2U2NEVuY29kZS9ldGM6IGluIHRob3NlIHdlIGFjY2VwdCBhbnl0aGluZyB0aGF0IEJ1ZmZlci5mcm9tXG4gICAgICogY2FuIHRha2UgKGluIHBhcnRpY3VsYXIgYWxsb3dpbmcgc3RyaW5ncywgd2hpY2ggYXJlIGp1c3QgaW50ZXJwcmV0ZWQgYXNcbiAgICAgKiBiaW5hcnkpOyBoZXJlIHdlIGVuc3VyZSB0aGF0IHRoZSBpbnB1dCBpcyBhY3R1YWxseSBhIGJ1ZmZlciBzaW5jZSB0cnlpbmdcbiAgICAgKiB0byB1dGY4LWRlY29kZSBhIHN0cmluZyB0byBhbm90aGVyIHN0cmluZyBpcyBhbG1vc3QgY2VydGFpbmx5IGEgbWlzdGFrZSAqL1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS51dGY4RGVjb2RlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICBpZiAoIXRoaXMuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnB1dCBvZiB1dGY4ZGVjb2RlIHRvIGJlIGFuIGFycmF5YnVmZmVyLCB0eXBlZCBhcnJheSwgb3IgQ3J5cHRvSlMgd29yZGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFRleHREZWNvZGVyICYmICF0aGlzLmlzV29yZEFycmF5KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIgPSB0aGlzLnRvV29yZEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiAoMCwgZW5jX3V0ZjhfMS5zdHJpbmdpZnkpKGJ1ZmZlcik7XG4gICAgfTtcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUuYnVmZmVyQ29tcGFyZSA9IGZ1bmN0aW9uIChidWZmZXIxLCBidWZmZXIyKSB7XG4gICAgICAgIGlmICghYnVmZmVyMSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKCFidWZmZXIyKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIHZhciB3b3JkQXJyYXkxID0gdGhpcy50b1dvcmRBcnJheShidWZmZXIxKTtcbiAgICAgICAgdmFyIHdvcmRBcnJheTIgPSB0aGlzLnRvV29yZEFycmF5KGJ1ZmZlcjIpO1xuICAgICAgICB3b3JkQXJyYXkxLmNsYW1wKCk7XG4gICAgICAgIHdvcmRBcnJheTIuY2xhbXAoKTtcbiAgICAgICAgdmFyIGNtcCA9IHdvcmRBcnJheTEuc2lnQnl0ZXMgLSB3b3JkQXJyYXkyLnNpZ0J5dGVzO1xuICAgICAgICBpZiAoY21wICE9IDApXG4gICAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB2YXIgd29yZHMxID0gd29yZEFycmF5MS53b3JkcztcbiAgICAgICAgdmFyIHdvcmRzMiA9IHdvcmRBcnJheTIud29yZHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjbXAgPSB3b3JkczFbaV0gLSB3b3JkczJbaV07XG4gICAgICAgICAgICBpZiAoY21wICE9IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICBpZiAodGhpcy5pc0FycmF5QnVmZmVyKGJ1ZmZlcikgfHwgdGhpcy5pc1R5cGVkQXJyYXkoYnVmZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNXb3JkQXJyYXkoYnVmZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5zaWdCeXRlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICAvKiBSZXR1cm5zIEFycmF5QnVmZmVyIG9uIGJyb3dzZXIgYW5kIEJ1ZmZlciBvbiBOb2RlLmpzICovXG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLnR5cGVkQXJyYXlUb0J1ZmZlciA9IGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG4gICAgICAgIHJldHVybiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJVdGlscztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgQnVmZmVyVXRpbHMoKTtcblxuXG4vKioqLyB9KSxcbi8qIDU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLkhleDtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjcnlwdG9fanNfYnVpbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18pO1xuXG5cblxuXG5cblxudmFyIENyeXB0b0ZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlnLCBidWZmZXJVdGlscykge1xuICB2YXIgREVGQVVMVF9BTEdPUklUSE0gPSAnYWVzJztcbiAgdmFyIERFRkFVTFRfS0VZTEVOR1RIID0gMjU2OyAvLyBiaXRzXG4gIHZhciBERUZBVUxUX01PREUgPSAnY2JjJztcbiAgdmFyIERFRkFVTFRfQkxPQ0tMRU5HVEggPSAxNjsgLy8gYnl0ZXNcbiAgdmFyIERFRkFVTFRfQkxPQ0tMRU5HVEhfV09SRFMgPSA0OyAvLyAzMi1iaXQgd29yZHNcbiAgdmFyIFVJTlQzMl9TVVAgPSAweDEwMDAwMDAwMDtcbiAgdmFyIElOVDMyX1NVUCA9IDB4ODAwMDAwMDA7XG5cbiAgLyoqXG4gICAqIEludGVybmFsOiBnZW5lcmF0ZSBhbiBhcnJheSBvZiBzZWN1cmUgcmFuZG9tIHdvcmRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxlbmd0aCBvZiBieXRlc1xuICAgKiBAcGFyYW0gYnl0ZXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICB2YXIgZ2VuZXJhdGVSYW5kb207XG4gIGlmIChjb25maWcuZ2V0UmFuZG9tV29yZEFycmF5KSB7XG4gICAgZ2VuZXJhdGVSYW5kb20gPSBjb25maWcuZ2V0UmFuZG9tV29yZEFycmF5O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBVaW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uZmlnLmdldFJhbmRvbVZhbHVlcykge1xuICAgIHZhciBibG9ja1JhbmRvbUFycmF5ID0gbmV3IFVpbnQzMkFycmF5KERFRkFVTFRfQkxPQ0tMRU5HVEhfV09SRFMpO1xuICAgIGdlbmVyYXRlUmFuZG9tID0gZnVuY3Rpb24gKGJ5dGVzLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHdvcmRzID0gYnl0ZXMgLyA0LFxuICAgICAgICBuYXRpdmVBcnJheSA9IHdvcmRzID09IERFRkFVTFRfQkxPQ0tMRU5HVEhfV09SRFMgPyBibG9ja1JhbmRvbUFycmF5IDogbmV3IFVpbnQzMkFycmF5KHdvcmRzKTtcbiAgICAgIGNvbmZpZy5nZXRSYW5kb21WYWx1ZXMobmF0aXZlQXJyYXksIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIsIGJ1ZmZlclV0aWxzLnRvV29yZEFycmF5KG5hdGl2ZUFycmF5KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZ2VuZXJhdGVSYW5kb20gPSBmdW5jdGlvbiAoYnl0ZXMsIGNhbGxiYWNrKSB7XG4gICAgICBfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQuYS5sb2dBY3Rpb24oXG4gICAgICAgIF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdC5hLkxPR19NQUpPUixcbiAgICAgICAgJ0FibHkuQ3J5cHRvLmdlbmVyYXRlUmFuZG9tKCknLFxuICAgICAgICAnV2FybmluZzogdGhlIGJyb3dzZXIgeW91IGFyZSB1c2luZyBkb2VzIG5vdCBzdXBwb3J0IHNlY3VyZSBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcmFuZG9tbmVzcyBnZW5lcmF0aW9uOyBmYWxsaW5nIGJhY2sgdG8gaW5zZWN1cmUgTWF0aC5yYW5kb20oKSdcbiAgICAgICk7XG4gICAgICB2YXIgd29yZHMgPSBieXRlcyAvIDQsXG4gICAgICAgIGFycmF5ID0gbmV3IEFycmF5KHdvcmRzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHM7IGkrKykge1xuICAgICAgICAvKiBjcnlwdG9qcyB3b3JkYXJyYXlzIHVzZSBzaWduZWQgaW50cy4gV2hlbiBXb3JkQXJyYXkuY3JlYXRlIGlzIGZlZCBhXG4gICAgICAgICAqIFVpbnQzMkFycmF5IHVuc2lnbmVkIGFyZSBjb252ZXJ0ZWQgdG8gc2lnbmVkIGF1dG9tYXRpY2FsbHksIGJ1dCB3aGVuXG4gICAgICAgICAqIGZlZCBhIG5vcm1hbCBhcnJheSB0aGV5IGFyZW4ndCwgc28gbmVlZCB0byBkbyBzbyBvdXJzZWx2ZXMgYnlcbiAgICAgICAgICogc3VidHJhY3RpbmcgSU5UMzJfU1VQICovXG4gICAgICAgIGFycmF5W2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogVUlOVDMyX1NVUCkgLSBJTlQzMl9TVVA7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKGFycmF5KSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbDogY2FsY3VsYXRlIHRoZSBwYWRkZWQgbGVuZ3RoIG9mIGEgZ2l2ZW4gcGxhaW50ZXh0XG4gICAqIHVzaW5nIFBLQ1M1LlxuICAgKiBAcGFyYW0gcGxhaW50ZXh0TGVuZ3RoXG4gICAqIEByZXR1cm5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFBhZGRlZExlbmd0aChwbGFpbnRleHRMZW5ndGgpIHtcbiAgICByZXR1cm4gKHBsYWludGV4dExlbmd0aCArIERFRkFVTFRfQkxPQ0tMRU5HVEgpICYgLURFRkFVTFRfQkxPQ0tMRU5HVEg7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWw6IGNoZWNrcyB0aGF0IHRoZSBjaXBoZXJQYXJhbXMgYXJlIGEgdmFsaWQgY29tYmluYXRpb24uIEN1cnJlbnRseVxuICAgKiBqdXN0IGNoZWNrcyB0aGF0IHRoZSBjYWxjdWxhdGVkIGtleUxlbmd0aCBpcyBhIHZhbGlkIG9uZSBmb3IgYWVzLWNiY1xuICAgKi9cbiAgZnVuY3Rpb24gdmFsaWRhdGVDaXBoZXJQYXJhbXMocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy5hbGdvcml0aG0gPT09ICdhZXMnICYmIHBhcmFtcy5tb2RlID09PSAnY2JjJykge1xuICAgICAgaWYgKHBhcmFtcy5rZXlMZW5ndGggPT09IDEyOCB8fCBwYXJhbXMua2V5TGVuZ3RoID09PSAyNTYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVW5zdXBwb3J0ZWQga2V5IGxlbmd0aCAnICtcbiAgICAgICAgICBwYXJhbXMua2V5TGVuZ3RoICtcbiAgICAgICAgICAnIGZvciBhZXMtY2JjIGVuY3J5cHRpb24uIEVuY3J5cHRpb24ga2V5IG11c3QgYmUgMTI4IG9yIDI1NiBiaXRzICgxNiBvciAzMiBBU0NJSSBjaGFyYWN0ZXJzKSdcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXNlQmFzZTY0KHN0cmluZykge1xuICAgIC8qIHVybC1zYWZlIGJhc2U2NCBzdHJpbmdzIHVzZSBfIGFuZCAtIGluc3RyZWFkIG9mIC8gYW5kICsgKi9cbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoJ18nLCAnLycpLnJlcGxhY2UoJy0nLCAnKycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsOiBvYnRhaW4gdGhlIHBrY3M1IHBhZGRpbmcgc3RyaW5nIGZvciBhIGdpdmVuIHBhZGRlZCBsZW5ndGg7XG4gICAqL1xuICB2YXIgcGtjczVQYWRkaW5nID0gW1xuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDEwMTAxMDEwLCAweDEwMTAxMDEwLCAweDEwMTAxMDEwLCAweDEwMTAxMDEwXSwgMTYpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDAxMDAwMDAwXSwgMSksXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDIwMjAwMDBdLCAyKSxcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwMzAzMDMwMF0sIDMpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDA0MDQwNDA0XSwgNCksXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDUwNTA1MDUsIDB4MDUwMDAwMDBdLCA1KSxcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwNjA2MDYwNiwgMHgwNjA2MDAwMF0sIDYpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDA3MDcwNzA3LCAweDA3MDcwNzAwXSwgNyksXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDgwODA4MDgsIDB4MDgwODA4MDhdLCA4KSxcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwOTA5MDkwOSwgMHgwOTA5MDkwOSwgMHgwOTAwMDAwMF0sIDkpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBhMGEwYTBhLCAweDBhMGEwYTBhLCAweDBhMGEwMDAwXSwgMTApLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBiMGIwYjBiLCAweDBiMGIwYjBiLCAweDBiMGIwYjAwXSwgMTEpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBjMGMwYzBjLCAweDBjMGMwYzBjLCAweDBjMGMwYzBjXSwgMTIpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBkMGQwZDBkLCAweDBkMGQwZDBkLCAweDBkMGQwZDBkLCAweDBkMDAwMDAwXSwgMTMpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBlMGUwZTBlLCAweDBlMGUwZTBlLCAweDBlMGUwZTBlLCAweDBlMGUwMDAwXSwgMTQpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBmMGYwZjBmLCAweDBmMGYwZjBmLCAweDBmMGYwZjBmLCAweDBmMGYwZjBmXSwgMTUpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDEwMTAxMDEwLCAweDEwMTAxMDEwLCAweDEwMTAxMDEwLCAweDEwMTAxMDEwXSwgMTYpLFxuICBdO1xuXG4gIC8qKlxuICAgKiBVdGlsaXR5IGNsYXNzZXMgYW5kIGludGVyZmFjZXMgZm9yIG1lc3NhZ2UgcGF5bG9hZCBlbmNyeXB0aW9uLlxuICAgKlxuICAgKiBUaGlzIGNsYXNzIHN1cHBvcnRzIEFFUy9DQkMvUEtDUzUgd2l0aCBhIGRlZmF1bHQga2V5bGVuZ3RoIG9mIDEyOCBiaXRzXG4gICAqIGJ1dCBzdXBwb3J0aW5nIG90aGVyIGtleWxlbmd0aHMuIE90aGVyIGFsZ29yaXRobXMgYW5kIGNoYWluaW5nIG1vZGVzIGFyZVxuICAgKiBub3Qgc3VwcG9ydGVkIGRpcmVjdGx5LCBidXQgc3VwcG9ydGFibGUgYnkgZXh0ZW5kaW5nL2ltcGxlbWVudGluZyB0aGUgYmFzZVxuICAgKiBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIGhlcmUuXG4gICAqLVxuICAgKiBTZWN1cmUgcmFuZG9tIGRhdGEgZm9yIGNyZWF0aW9uIG9mIEluaXRpYWxpemF0aW9uIFZlY3RvcnMgKElWcykgYW5kIGtleXNcbiAgICogaXMgb2J0YWluZWQgZnJvbSB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBpZiBhdmFpbGFibGUsIG9yIGZyb21cbiAgICogTWF0aC5yYW5kb20oKSBpZiBub3QuIENsaWVudHMgd2hvIGRvIG5vdCB3YW50IHRvIGRlcGVuZCBvbiBNYXRoLnJhbmRvbSgpXG4gICAqIHNob3VsZCBwb2x5ZmlsbCB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB3aXRoIGEgbGlicmFyeSB0aGF0IHNlZWRzXG4gICAqIGEgUFJORyB3aXRoIHJlYWwgZW50cm9weS5cbiAgICpcbiAgICogRWFjaCBtZXNzYWdlIHBheWxvYWQgaXMgZW5jcnlwdGVkIHdpdGggYW4gSVYgaW4gQ0JDIG1vZGUsIGFuZCB0aGUgSVYgaXNcbiAgICogY29uY2F0ZW5hdGVkIHdpdGggdGhlIHJlc3VsdGluZyByYXcgY2lwaGVydGV4dCB0byBjb25zdHJ1Y3QgdGhlIFwiY2lwaGVydGV4dFwiXG4gICAqIGRhdGEgcGFzc2VkIHRvIHRoZSByZWNpcGllbnQuXG4gICAqL1xuICBmdW5jdGlvbiBDcnlwdG8oKSB7fVxuXG4gIC8qKlxuICAgKiBBIGNsYXNzIGVuY2Fwc3VsYXRpbmcgdGhlIGNsaWVudC1zcGVjaWZpYWJsZSBwYXJhbWV0ZXJzIGZvclxuICAgKiB0aGUgY2lwaGVyLlxuICAgKlxuICAgKiBhbGdvcml0aG0gaXMgdGhlIG5hbWUgb2YgdGhlIGFsZ29yaXRobSBpbiB0aGUgZGVmYXVsdCBzeXN0ZW0gcHJvdmlkZXIsXG4gICAqIG9yIHRoZSBsb3dlci1jYXNlZCB2ZXJzaW9uIG9mIGl0OyBlZyBcImFlc1wiIG9yIFwiQUVTXCIuXG4gICAqXG4gICAqIENsaWVudHMgYXJlIHJlY29tbWVuZGVkIHRvIG5vdCBjYWxsIHRoaXMgZGlyZWN0bHksIGJ1dCBpbnN0ZWFkIHRvIHVzZSB0aGVcbiAgICogQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMgaGVscGVyLCB3aGljaCB3aWxsIGZpbGwgaW4gYW55IGZpZWxkcyBub3Qgc3VwcGxpZWRcbiAgICogd2l0aCBkZWZhdWx0IHZhbHVlcyBhbmQgdmFsaWRhdGlvbiB0aGUgcmVzdWx0LlxuICAgKi9cbiAgZnVuY3Rpb24gQ2lwaGVyUGFyYW1zKCkge1xuICAgIHRoaXMuYWxnb3JpdGhtID0gbnVsbDtcbiAgICB0aGlzLmtleUxlbmd0aCA9IG51bGw7XG4gICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IG51bGw7XG4gIH1cbiAgQ3J5cHRvLkNpcGhlclBhcmFtcyA9IENpcGhlclBhcmFtcztcblxuICAvKipcbiAgICogT2J0YWluIGEgY29tcGxldGUgQ2lwaGVyUGFyYW1zIGluc3RhbmNlIGZyb20gdGhlIHByb3ZpZGVkIHBhcmFtcywgZmlsbGluZ1xuICAgKiBpbiBhbnkgbm90IHByb3ZpZGVkIHdpdGggZGVmYXVsdCB2YWx1ZXMsIGNhbGN1bGF0aW5nIGEga2V5TGVuZ3RoIGZyb21cbiAgICogdGhlIHN1cHBsaWVkIGtleSwgYW5kIHZhbGlkYXRpbmcgdGhlIHJlc3VsdC5cbiAgICogQHBhcmFtIHBhcmFtcyBhbiBvYmplY3QgY29udGFpbmluZyBhdCBhIG1pbmltdW0gYSBga2V5YCBrZXkgd2l0aCB2YWx1ZSB0aGVcbiAgICoga2V5LCBhcyBlaXRoZXIgYSBiaW5hcnkgKEFycmF5QnVmZmVyLCBBcnJheSwgV29yZEFycmF5KSBvciBhXG4gICAqIGJhc2U2NC1lbmNvZGVkIHN0cmluZy4gTWF5IG9wdGlvbmFsbHkgYWxzbyBjb250YWluOiBhbGdvcml0aG0gKGRlZmF1bHRzIHRvXG4gICAqIEFFUyksIG1vZGUgKGRlZmF1bHRzIHRvICdjYmMnKVxuICAgKi9cbiAgQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdmFyIGtleTtcbiAgICAvKiBCYWNrd2FyZCBjb21wYXRpYmlsaXR5ICovXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHBhcmFtcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdC5hLmRlcHJlY2F0ZWQoJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zKGtleSwgY2FsbGJhY2spJywgJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zKHtrZXk6IGtleX0pJyk7XG4gICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBDcnlwdG8uZ2VuZXJhdGVSYW5kb21LZXkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHBhcmFtcyhudWxsLCBDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyh7IGtleToga2V5IH0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYXJndW1lbnRzWzFdKG51bGwsIENyeXB0by5nZXREZWZhdWx0UGFyYW1zKHsga2V5OiBwYXJhbXMgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBmb3IgQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5rZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ3J5cHRvLmdldERlZmF1bHRQYXJhbXM6IGEga2V5IGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMua2V5ID09PSAnc3RyaW5nJykge1xuICAgICAga2V5ID0gT2JqZWN0KGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJwYXJzZVwiXSkobm9ybWFsaXNlQmFzZTY0KHBhcmFtcy5rZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gYnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkocGFyYW1zLmtleSk7IC8vIEV4cGVjdCBrZXkgdG8gYmUgYW4gQXJyYXksIEFycmF5QnVmZmVyLCBvciBXb3JkQXJyYXkgYXQgdGhpcyBwb2ludFxuICAgIH1cblxuICAgIHZhciBjaXBoZXJQYXJhbXMgPSBuZXcgQ2lwaGVyUGFyYW1zKCk7XG4gICAgY2lwaGVyUGFyYW1zLmtleSA9IGtleTtcbiAgICBjaXBoZXJQYXJhbXMuYWxnb3JpdGhtID0gcGFyYW1zLmFsZ29yaXRobSB8fCBERUZBVUxUX0FMR09SSVRITTtcbiAgICBjaXBoZXJQYXJhbXMua2V5TGVuZ3RoID0ga2V5LndvcmRzLmxlbmd0aCAqICg0ICogOCk7XG4gICAgY2lwaGVyUGFyYW1zLm1vZGUgPSBwYXJhbXMubW9kZSB8fCBERUZBVUxUX01PREU7XG5cbiAgICBpZiAocGFyYW1zLmtleUxlbmd0aCAmJiBwYXJhbXMua2V5TGVuZ3RoICE9PSBjaXBoZXJQYXJhbXMua2V5TGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtczogYSBrZXlMZW5ndGggb2YgJyArXG4gICAgICAgICAgcGFyYW1zLmtleUxlbmd0aCArXG4gICAgICAgICAgJyB3YXMgc3BlY2lmaWVkLCBidXQgdGhlIGtleSBhY3R1YWxseSBoYXMgbGVuZ3RoICcgK1xuICAgICAgICAgIGNpcGhlclBhcmFtcy5rZXlMZW5ndGhcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFsaWRhdGVDaXBoZXJQYXJhbXMoY2lwaGVyUGFyYW1zKTtcbiAgICByZXR1cm4gY2lwaGVyUGFyYW1zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHJhbmRvbSBlbmNyeXB0aW9uIGtleSBmcm9tIHRoZSBzdXBwbGllZCBrZXlsZW5ndGggKG9yIHRoZVxuICAgKiBkZWZhdWx0IGtleUxlbmd0aCBpZiBub25lIHN1cHBsaWVkKSBhcyBhIENyeXB0b0pTIFdvcmRBcnJheVxuICAgKiBAcGFyYW0ga2V5TGVuZ3RoIChvcHRpb25hbCkgdGhlIHJlcXVpcmVkIGtleUxlbmd0aCBpbiBiaXRzXG4gICAqIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIChlcnIsIGtleSlcbiAgICovXG4gIENyeXB0by5nZW5lcmF0ZVJhbmRvbUtleSA9IGZ1bmN0aW9uIChrZXlMZW5ndGgsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiB0eXBlb2Yga2V5TGVuZ3RoID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0ga2V5TGVuZ3RoO1xuICAgICAga2V5TGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGdlbmVyYXRlUmFuZG9tKChrZXlMZW5ndGggfHwgREVGQVVMVF9LRVlMRU5HVEgpIC8gOCwgZnVuY3Rpb24gKGVyciwgYnVmKSB7XG4gICAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayhlcnIgPyBjb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQuYS5mcm9tVmFsdWVzKGVycikgOiBudWxsLCBidWYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnRlcm5hbDsgZ2V0IGEgQ2hhbm5lbENpcGhlciBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gY2lwaGVyUGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMgZWl0aGVyIGEgQ2lwaGVyUGFyYW1zIGluc3RhbmNlIG9yIHNvbWUgc3Vic2V0IG9mIGl0c1xuICAgKiBmaWVsZHMgdGhhdCBpbmNsdWRlcyBhIGtleVxuICAgKi9cbiAgQ3J5cHRvLmdldENpcGhlciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICB2YXIgY2lwaGVyUGFyYW1zID0gcGFyYW1zIGluc3RhbmNlb2YgQ2lwaGVyUGFyYW1zID8gcGFyYW1zIDogQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMocGFyYW1zKTtcblxuICAgIHJldHVybiB7IGNpcGhlclBhcmFtczogY2lwaGVyUGFyYW1zLCBjaXBoZXI6IG5ldyBDQkNDaXBoZXIoY2lwaGVyUGFyYW1zLCBERUZBVUxUX0JMT0NLTEVOR1RIX1dPUkRTLCBwYXJhbXMuaXYpIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQ0JDQ2lwaGVyKHBhcmFtcywgYmxvY2tMZW5ndGhXb3JkcywgaXYpIHtcbiAgICB0aGlzLmFsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0gKyAnLScgKyBTdHJpbmcocGFyYW1zLmtleUxlbmd0aCkgKyAnLScgKyBwYXJhbXMubW9kZTtcbiAgICB0aGlzLmNqc0FsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0udG9VcHBlckNhc2UoKS5yZXBsYWNlKC8tXFxkKyQvLCAnJyk7XG4gICAgdGhpcy5rZXkgPSBidWZmZXJVdGlscy50b1dvcmRBcnJheShwYXJhbXMua2V5KTtcbiAgICBpZiAoaXYpIHtcbiAgICAgIHRoaXMuaXYgPSBidWZmZXJVdGlscy50b1dvcmRBcnJheShpdikuY2xvbmUoKTtcbiAgICB9XG4gICAgdGhpcy5ibG9ja0xlbmd0aFdvcmRzID0gYmxvY2tMZW5ndGhXb3JkcztcbiAgfVxuXG4gIENCQ0NpcGhlci5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uIChwbGFpbnRleHQsIGNhbGxiYWNrKSB7XG4gICAgX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0LmEubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdC5hLkxPR19NSUNSTywgJ0NCQ0NpcGhlci5lbmNyeXB0KCknLCAnJyk7XG4gICAgcGxhaW50ZXh0ID0gYnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkocGxhaW50ZXh0KTtcbiAgICB2YXIgcGxhaW50ZXh0TGVuZ3RoID0gcGxhaW50ZXh0LnNpZ0J5dGVzLFxuICAgICAgcGFkZGVkTGVuZ3RoID0gZ2V0UGFkZGVkTGVuZ3RoKHBsYWludGV4dExlbmd0aCksXG4gICAgICBzZWxmID0gdGhpcztcblxuICAgIHZhciB0aGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5nZXRJdihmdW5jdGlvbiAoZXJyLCBpdikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNpcGhlck91dCA9IHNlbGYuZW5jcnlwdENpcGhlci5wcm9jZXNzKHBsYWludGV4dC5jb25jYXQocGtjczVQYWRkaW5nW3BhZGRlZExlbmd0aCAtIHBsYWludGV4dExlbmd0aF0pKTtcbiAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBpdi5jb25jYXQoY2lwaGVyT3V0KTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgY2lwaGVydGV4dCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLmVuY3J5cHRDaXBoZXIpIHtcbiAgICAgIGlmICh0aGlzLml2KSB7XG4gICAgICAgIHRoaXMuZW5jcnlwdENpcGhlciA9IGNyeXB0b19qc19idWlsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQuYS5hbGdvW3RoaXMuY2pzQWxnb3JpdGhtXS5jcmVhdGVFbmNyeXB0b3IodGhpcy5rZXksIHsgaXY6IHRoaXMuaXYgfSk7XG4gICAgICAgIHRoZW4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbmVyYXRlUmFuZG9tKERFRkFVTFRfQkxPQ0tMRU5HVEgsIGZ1bmN0aW9uIChlcnIsIGl2KSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5lbmNyeXB0Q2lwaGVyID0gY3J5cHRvX2pzX2J1aWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdC5hLmFsZ29bc2VsZi5janNBbGdvcml0aG1dLmNyZWF0ZUVuY3J5cHRvcihzZWxmLmtleSwgeyBpdjogaXYgfSk7XG4gICAgICAgICAgc2VsZi5pdiA9IGl2O1xuICAgICAgICAgIHRoZW4oKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoZW4oKTtcbiAgICB9XG4gIH07XG5cbiAgQ0JDQ2lwaGVyLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24gKGNpcGhlcnRleHQpIHtcbiAgICBfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQuYS5sb2dBY3Rpb24oX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0LmEuTE9HX01JQ1JPLCAnQ0JDQ2lwaGVyLmRlY3J5cHQoKScsICcnKTtcbiAgICBjaXBoZXJ0ZXh0ID0gYnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkoY2lwaGVydGV4dCk7XG4gICAgdmFyIGJsb2NrTGVuZ3RoV29yZHMgPSB0aGlzLmJsb2NrTGVuZ3RoV29yZHMsXG4gICAgICBjaXBoZXJ0ZXh0V29yZHMgPSBjaXBoZXJ0ZXh0LndvcmRzLFxuICAgICAgaXYgPSBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoMCwgYmxvY2tMZW5ndGhXb3JkcykpLFxuICAgICAgY2lwaGVydGV4dEJvZHkgPSBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoYmxvY2tMZW5ndGhXb3JkcykpO1xuXG4gICAgdmFyIGRlY3J5cHRDaXBoZXIgPSBjcnlwdG9fanNfYnVpbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0LmEuYWxnb1t0aGlzLmNqc0FsZ29yaXRobV0uY3JlYXRlRGVjcnlwdG9yKHRoaXMua2V5LCB7IGl2OiBpdiB9KTtcbiAgICB2YXIgcGxhaW50ZXh0ID0gZGVjcnlwdENpcGhlci5wcm9jZXNzKGNpcGhlcnRleHRCb2R5KTtcbiAgICB2YXIgZXBpbG9ndWUgPSBkZWNyeXB0Q2lwaGVyLmZpbmFsaXplKCk7XG4gICAgZGVjcnlwdENpcGhlci5yZXNldCgpO1xuICAgIGlmIChlcGlsb2d1ZSAmJiBlcGlsb2d1ZS5zaWdCeXRlcykgcGxhaW50ZXh0LmNvbmNhdChlcGlsb2d1ZSk7XG4gICAgcmV0dXJuIHBsYWludGV4dDtcbiAgfTtcblxuICBDQkNDaXBoZXIucHJvdG90eXBlLmdldEl2ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuaXYpIHtcbiAgICAgIHZhciBpdiA9IHRoaXMuaXY7XG4gICAgICB0aGlzLml2ID0gbnVsbDtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGl2KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKiBTaW5jZSB0aGUgaXYgZm9yIGEgbmV3IGJsb2NrIGlzIHRoZSBjaXBoZXJ0ZXh0IG9mIHRoZSBsYXN0LCB0aGlzXG4gICAgICogc2V0cyBhIG5ldyBpdiAoPSBhZXMocmFuZG9tQmxvY2sgWE9SIGxhc3RDaXBoZXJUZXh0KSkgYXMgd2VsbCBhc1xuICAgICAqIHJldHVybmluZyBpdCAqL1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBnZW5lcmF0ZVJhbmRvbShERUZBVUxUX0JMT0NLTEVOR1RILCBmdW5jdGlvbiAoZXJyLCByYW5kb21CbG9jaykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBzZWxmLmVuY3J5cHRDaXBoZXIucHJvY2VzcyhyYW5kb21CbG9jaykpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBDcnlwdG87XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENyeXB0b0ZhY3RvcnkpO1xuXG5cbi8qKiovIH0pLFxuLyogNTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDYpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVVEYtMTYgQkUgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBVdGYxNkJFID0gQ19lbmMuVXRmMTYgPSBDX2VuYy5VdGYxNkJFID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi0xNiBCRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTE2IEJFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjE2U3RyaW5nID0gQ3J5cHRvSlMuZW5jLlV0ZjE2LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgxNiAtIChpICUgNCkgKiA4KSkgJiAweGZmZmY7XG5cdCAgICAgICAgICAgICAgICB1dGYxNkNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB1dGYxNkNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi0xNiBCRSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjE2U3RyIFRoZSBVVEYtMTYgQkUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGYxNi5wYXJzZSh1dGYxNlN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGYxNlN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZTdHJMZW5ndGggPSB1dGYxNlN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1dGYxNlN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAxXSB8PSB1dGYxNlN0ci5jaGFyQ29kZUF0KGkpIDw8ICgxNiAtIChpICUgMikgKiAxNik7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgdXRmMTZTdHJMZW5ndGggKiAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVURi0xNiBMRSBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgQ19lbmMuVXRmMTZMRSA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtMTYgTEUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi0xNiBMRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB1dGYxNlN0ciA9IENyeXB0b0pTLmVuYy5VdGYxNkxFLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBzd2FwRW5kaWFuKCh3b3Jkc1tpID4+PiAyXSA+Pj4gKDE2IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmZmZik7XG5cdCAgICAgICAgICAgICAgICB1dGYxNkNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB1dGYxNkNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi0xNiBMRSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjE2U3RyIFRoZSBVVEYtMTYgTEUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGYxNkxFLnBhcnNlKHV0ZjE2U3RyKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjE2U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciB1dGYxNlN0ckxlbmd0aCA9IHV0ZjE2U3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHV0ZjE2U3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDFdIHw9IHN3YXBFbmRpYW4odXRmMTZTdHIuY2hhckNvZGVBdChpKSA8PCAoMTYgLSAoaSAlIDIpICogMTYpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCB1dGYxNlN0ckxlbmd0aCAqIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIHN3YXBFbmRpYW4od29yZCkge1xuXHQgICAgICAgIHJldHVybiAoKHdvcmQgPDwgOCkgJiAweGZmMDBmZjAwKSB8ICgod29yZCA+Pj4gOCkgJiAweDAwZmYwMGZmKTtcblx0ICAgIH1cblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuVXRmMTY7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiA1OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNiksIF9fd2VicGFja19yZXF1aXJlX18oMjgpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBDaXBoZXJQYXJhbXMgPSBDX2xpYi5DaXBoZXJQYXJhbXM7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblx0ICAgIHZhciBIZXggPSBDX2VuYy5IZXg7XG5cdCAgICB2YXIgQ19mb3JtYXQgPSBDLmZvcm1hdDtcblxuXHQgICAgdmFyIEhleEZvcm1hdHRlciA9IENfZm9ybWF0LkhleCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGUgY2lwaGVydGV4dCBvZiBhIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgaGV4YWRlY2ltYWxseSBlbmNvZGVkIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfSBjaXBoZXJQYXJhbXMgVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4YWRlY2ltYWxseSBlbmNvZGVkIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhleFN0cmluZyA9IENyeXB0b0pTLmZvcm1hdC5IZXguc3RyaW5naWZ5KGNpcGhlclBhcmFtcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dC50b1N0cmluZyhIZXgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBjaXBoZXJ0ZXh0IHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IFRoZSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5mb3JtYXQuSGV4LnBhcnNlKGhleFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IEhleC5wYXJzZShpbnB1dCk7XG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsgY2lwaGVydGV4dDogY2lwaGVydGV4dCB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmZvcm1hdC5IZXg7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiA2MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNiksIF9fd2VicGFja19yZXF1aXJlX18oMTEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKSwgX193ZWJwYWNrX3JlcXVpcmVfXygyNyksIF9fd2VicGFja19yZXF1aXJlX18oMjgpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gTG9va3VwIHRhYmxlc1xuXHQgICAgdmFyIFNCT1ggPSBbXTtcblx0ICAgIHZhciBJTlZfU0JPWCA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMCA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMSA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMiA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMyA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzAgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8xID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMiA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzMgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBsb29rdXAgdGFibGVzXG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vIENvbXB1dGUgZG91YmxlIHRhYmxlXG5cdCAgICAgICAgdmFyIGQgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmIChpIDwgMTI4KSB7XG5cdCAgICAgICAgICAgICAgICBkW2ldID0gaSA8PCAxO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZFtpXSA9IChpIDw8IDEpIF4gMHgxMWI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBXYWxrIEdGKDJeOClcblx0ICAgICAgICB2YXIgeCA9IDA7XG5cdCAgICAgICAgdmFyIHhpID0gMDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgc2JveFxuXHQgICAgICAgICAgICB2YXIgc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KTtcblx0ICAgICAgICAgICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzO1xuXHQgICAgICAgICAgICBTQk9YW3hdID0gc3g7XG5cdCAgICAgICAgICAgIElOVl9TQk9YW3N4XSA9IHg7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuXHQgICAgICAgICAgICB2YXIgeDIgPSBkW3hdO1xuXHQgICAgICAgICAgICB2YXIgeDQgPSBkW3gyXTtcblx0ICAgICAgICAgICAgdmFyIHg4ID0gZFt4NF07XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuXHQgICAgICAgICAgICB2YXIgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMCk7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfMFt4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8xW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8yW3hdID0gKHQgPDwgOCkgIHwgKHQgPj4+IDI0KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8zW3hdID0gdDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGludiBzdWIgYnl0ZXMsIGludiBtaXggY29sdW1ucyB0YWJsZXNcblx0ICAgICAgICAgICAgdmFyIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMCk7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzBbc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8xW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzJbc3hdID0gKHQgPDwgOCkgIHwgKHQgPj4+IDI0KTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfM1tzeF0gPSB0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG5cdCAgICAgICAgICAgIGlmICgheCkge1xuXHQgICAgICAgICAgICAgICAgeCA9IHhpID0gMTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG5cdCAgICAgICAgICAgICAgICB4aSBePSBkW2RbeGldXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8vIFByZWNvbXB1dGVkIFJjb24gbG9va3VwXG5cdCAgICB2YXIgUkNPTiA9IFsweDAwLCAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBRVMgYmxvY2sgY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEFFUyA9IENfYWxnby5BRVMgPSBCbG9ja0NpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciB0O1xuXG5cdCAgICAgICAgICAgIC8vIFNraXAgcmVzZXQgb2YgblJvdW5kcyBoYXMgYmVlbiBzZXQgYmVmb3JlIGFuZCBrZXkgZGlkIG5vdCBjaGFuZ2Vcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX25Sb3VuZHMgJiYgdGhpcy5fa2V5UHJpb3JSZXNldCA9PT0gdGhpcy5fa2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX2tleVByaW9yUmVzZXQgPSB0aGlzLl9rZXk7XG5cdCAgICAgICAgICAgIHZhciBrZXlXb3JkcyA9IGtleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGtleVNpemUgPSBrZXkuc2lnQnl0ZXMgLyA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbnVtYmVyIG9mIHJvdW5kc1xuXHQgICAgICAgICAgICB2YXIgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHMgPSBrZXlTaXplICsgNjtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG51bWJlciBvZiBrZXkgc2NoZWR1bGUgcm93c1xuXHQgICAgICAgICAgICB2YXIga3NSb3dzID0gKG5Sb3VuZHMgKyAxKSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBrZXkgc2NoZWR1bGVcblx0ICAgICAgICAgICAgdmFyIGtleVNjaGVkdWxlID0gdGhpcy5fa2V5U2NoZWR1bGUgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIga3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGtzUm93IDwga2V5U2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVdvcmRzW2tzUm93XTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gMV07XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIShrc1JvdyAlIGtleVNpemUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvdCB3b3JkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ViIHdvcmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9IChTQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3QgJiAweGZmXTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaXggUmNvblxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0IF49IFJDT05bKGtzUm93IC8ga2V5U2l6ZSkgfCAwXSA8PCAyNDtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAoU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFt0ICYgMHhmZl07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGludiBrZXkgc2NoZWR1bGVcblx0ICAgICAgICAgICAgdmFyIGludktleVNjaGVkdWxlID0gdGhpcy5faW52S2V5U2NoZWR1bGUgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3c7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChpbnZLc1JvdyAlIDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDRdO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSB0O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBJTlZfU1VCX01JWF8wW1NCT1hbdCA+Pj4gMjRdXSBeIElOVl9TVUJfTUlYXzFbU0JPWFsodCA+Pj4gMTYpICYgMHhmZl1dIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJTlZfU1VCX01JWF8yW1NCT1hbKHQgPj4+IDgpICYgMHhmZl1dIF4gSU5WX1NVQl9NSVhfM1tTQk9YW3QgJiAweGZmXV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZW5jcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2tleVNjaGVkdWxlLCBTVUJfTUlYXzAsIFNVQl9NSVhfMSwgU1VCX01JWF8yLCBTVUJfTUlYXzMsIFNCT1gpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBkZWNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU3dhcCAybmQgYW5kIDR0aCByb3dzXG5cdCAgICAgICAgICAgIHZhciB0ID0gTVtvZmZzZXQgKyAxXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0O1xuXG5cdCAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2ludktleVNjaGVkdWxlLCBJTlZfU1VCX01JWF8wLCBJTlZfU1VCX01JWF8xLCBJTlZfU1VCX01JWF8yLCBJTlZfU1VCX01JWF8zLCBJTlZfU0JPWCk7XG5cblx0ICAgICAgICAgICAgLy8gSW52IHN3YXAgMm5kIGFuZCA0dGggcm93c1xuXHQgICAgICAgICAgICB2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSBNW29mZnNldCArIDNdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvQ3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCwga2V5U2NoZWR1bGUsIFNVQl9NSVhfMCwgU1VCX01JWF8xLCBTVUJfTUlYXzIsIFNVQl9NSVhfMywgU0JPWCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHM7XG5cblx0ICAgICAgICAgICAgLy8gR2V0IGlucHV0LCBhZGQgcm91bmQga2V5XG5cdCAgICAgICAgICAgIHZhciBzMCA9IE1bb2Zmc2V0XSAgICAgXiBrZXlTY2hlZHVsZVswXTtcblx0ICAgICAgICAgICAgdmFyIHMxID0gTVtvZmZzZXQgKyAxXSBeIGtleVNjaGVkdWxlWzFdO1xuXHQgICAgICAgICAgICB2YXIgczIgPSBNW29mZnNldCArIDJdIF4ga2V5U2NoZWR1bGVbMl07XG5cdCAgICAgICAgICAgIHZhciBzMyA9IE1bb2Zmc2V0ICsgM10gXiBrZXlTY2hlZHVsZVszXTtcblxuXHQgICAgICAgICAgICAvLyBLZXkgc2NoZWR1bGUgcm93IGNvdW50ZXJcblx0ICAgICAgICAgICAgdmFyIGtzUm93ID0gNDtcblxuXHQgICAgICAgICAgICAvLyBSb3VuZHNcblx0ICAgICAgICAgICAgZm9yICh2YXIgcm91bmQgPSAxOyByb3VuZCA8IG5Sb3VuZHM7IHJvdW5kKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgbWl4IGNvbHVtbnMsIGFkZCByb3VuZCBrZXlcblx0ICAgICAgICAgICAgICAgIHZhciB0MCA9IFNVQl9NSVhfMFtzMCA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMSA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMyID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MzICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MSA9IFNVQl9NSVhfMFtzMSA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMiA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMzID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MwICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MiA9IFNVQl9NSVhfMFtzMiA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMyA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMwID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MxICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MyA9IFNVQl9NSVhfMFtzMyA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMCA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMxID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MyICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHN0YXRlXG5cdCAgICAgICAgICAgICAgICBzMCA9IHQwO1xuXHQgICAgICAgICAgICAgICAgczEgPSB0MTtcblx0ICAgICAgICAgICAgICAgIHMyID0gdDI7XG5cdCAgICAgICAgICAgICAgICBzMyA9IHQzO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XG5cdCAgICAgICAgICAgIHZhciB0MCA9ICgoU0JPWFtzMCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMSA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMyID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMyAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICB2YXIgdDEgPSAoKFNCT1hbczEgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczIgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMyA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczAgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgdmFyIHQyID0gKChTQk9YW3MyID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMzID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczAgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MxICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgIHZhciB0MyA9ICgoU0JPWFtzMyA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMxID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMiAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBvdXRwdXRcblx0ICAgICAgICAgICAgTVtvZmZzZXRdICAgICA9IHQwO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gdDE7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMl0gPSB0Mjtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBrZXlTaXplOiAyNTYvMzJcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLkFFUy5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLkFFUy5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAqL1xuXHQgICAgQy5BRVMgPSBCbG9ja0NpcGhlci5fY3JlYXRlSGVscGVyKEFFUyk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuQUVTO1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogNjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDYpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIENvbnN0YW50cyB0YWJsZVxuXHQgICAgdmFyIFQgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG5cdCAgICAgICAgICAgIFRbaV0gPSAoTWF0aC5hYnMoTWF0aC5zaW4oaSArIDEpKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNRDUgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBNRDUgPSBDX2FsZ28uTUQ1ID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LFxuXHQgICAgICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NlxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuXHQgICAgICAgICAgICAgICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXTtcblxuXHQgICAgICAgICAgICAgICAgTVtvZmZzZXRfaV0gPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSAgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8wICA9IE1bb2Zmc2V0ICsgMF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xICA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8yICA9IE1bb2Zmc2V0ICsgMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8zICA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF80ICA9IE1bb2Zmc2V0ICsgNF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF81ICA9IE1bb2Zmc2V0ICsgNV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF82ICA9IE1bb2Zmc2V0ICsgNl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF83ICA9IE1bb2Zmc2V0ICsgN107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF84ICA9IE1bb2Zmc2V0ICsgOF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF85ICA9IE1bb2Zmc2V0ICsgOV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMCA9IE1bb2Zmc2V0ICsgMTBdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTEgPSBNW29mZnNldCArIDExXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEyID0gTVtvZmZzZXQgKyAxMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMyA9IE1bb2Zmc2V0ICsgMTNdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTQgPSBNW29mZnNldCArIDE0XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE1ID0gTVtvZmZzZXQgKyAxNV07XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWxiZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNywgIFRbMF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMSwgIDEyLCBUWzFdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNywgVFsyXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8zLCAgMjIsIFRbM10pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDcsICBUWzRdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzUsICAxMiwgVFs1XSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTcsIFRbNl0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfNywgIDIyLCBUWzddKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA3LCAgVFs4XSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF85LCAgMTIsIFRbOV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE3LCBUWzEwXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xMSwgMjIsIFRbMTFdKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA3LCAgVFsxMl0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTMsIDEyLCBUWzEzXSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTcsIFRbMTRdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzE1LCAyMiwgVFsxNV0pO1xuXG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNSwgIFRbMTZdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzYsICA5LCAgVFsxN10pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE0LCBUWzE4XSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8wLCAgMjAsIFRbMTldKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA1LCAgVFsyMF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTAsIDksICBUWzIxXSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTQsIFRbMjJdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzQsICAyMCwgVFsyM10pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDUsICBUWzI0XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xNCwgOSwgIFRbMjVdKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNCwgVFsyNl0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfOCwgIDIwLCBUWzI3XSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNSwgIFRbMjhdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzIsICA5LCAgVFsyOV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE0LCBUWzMwXSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8xMiwgMjAsIFRbMzFdKTtcblxuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDQsICBUWzMyXSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF84LCAgMTEsIFRbMzNdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNiwgVFszNF0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTQsIDIzLCBUWzM1XSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNCwgIFRbMzZdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzQsICAxMSwgVFszN10pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE2LCBUWzM4XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xMCwgMjMsIFRbMzldKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA0LCAgVFs0MF0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMCwgIDExLCBUWzQxXSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTYsIFRbNDJdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzYsICAyMywgVFs0M10pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDQsICBUWzQ0XSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8xMiwgMTEsIFRbNDVdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNiwgVFs0Nl0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMiwgIDIzLCBUWzQ3XSk7XG5cblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsICA2LCAgVFs0OF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfNywgIDEwLCBUWzQ5XSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTUsIFRbNTBdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzUsICAyMSwgVFs1MV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDYsICBUWzUyXSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8zLCAgMTAsIFRbNTNdKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNSwgVFs1NF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMSwgIDIxLCBUWzU1XSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNiwgIFRbNTZdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE1LCAxMCwgVFs1N10pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE1LCBUWzU4XSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xMywgMjEsIFRbNTldKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsICA2LCAgVFs2MF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTEsIDEwLCBUWzYxXSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTUsIFRbNjJdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzksICAyMSwgVFs2M10pO1xuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsSCA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxMID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSAoXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCA4KSAgfCAobkJpdHNUb3RhbEggPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCAyNCkgfCAobkJpdHNUb3RhbEggPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IChcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDgpICB8IChuQml0c1RvdGFsTCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDI0KSB8IChuQml0c1RvdGFsTCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICk7XG5cblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IChkYXRhV29yZHMubGVuZ3RoICsgMSkgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoO1xuXHQgICAgICAgICAgICB2YXIgSCA9IGhhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgICAgICB2YXIgSF9pID0gSFtpXTtcblxuXHQgICAgICAgICAgICAgICAgSFtpXSA9ICgoKEhfaSA8PCA4KSAgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gRkYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGMpIHwgKH5iICYgZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gR0coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGQpIHwgKGMgJiB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSEgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChiIF4gYyBeIGQpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSUkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChjIF4gKGIgfCB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuTUQ1ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoTUQ1KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNNRDUobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjTUQ1ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKE1ENSk7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLk1ENTtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDYyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgZGVmYXVsdHNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOCkpO1xudmFyIGVycm9yaW5mb18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBIdHRwTWV0aG9kc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxOCkpO1xudmFyIHhocnJlcXVlc3RfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTYpKTtcbnZhciBYSFJTdGF0ZXNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjEpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIGpzb25wdHJhbnNwb3J0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcbnZhciBmZXRjaHJlcXVlc3RfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNjMpKTtcbnZhciBIdHRwU3RhdHVzQ29kZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuZnVuY3Rpb24gc2hvdWxkRmFsbGJhY2soZXJyb3JJbmZvKSB7XG4gICAgdmFyIHN0YXR1c0NvZGUgPSBlcnJvckluZm8uc3RhdHVzQ29kZTtcbiAgICAvKiA0MDAgKyBubyBjb2RlID0gYSBnZW5lcmljIHhociBvbmVycm9yLiBCcm93c2VyIGRvZXNuJ3QgZ2l2ZSB1cyBlbm91Z2hcbiAgICAgKiBkZXRhaWwgdG8ga25vdyB3aGV0aGVyIGl0J3MgZmFsbGJhY2stZml4YWJsZSwgYnV0IGl0IG1heSBiZSAoZWcgaWYgYVxuICAgICAqIG5ldHdvcmsgaXNzdWUpLCBzbyB0cnkganVzdCBpbiBjYXNlICovXG4gICAgcmV0dXJuICgoc3RhdHVzQ29kZSA9PT0gNDA4ICYmICFlcnJvckluZm8uY29kZSkgfHxcbiAgICAgICAgKHN0YXR1c0NvZGUgPT09IDQwMCAmJiAhZXJyb3JJbmZvLmNvZGUpIHx8XG4gICAgICAgIChzdGF0dXNDb2RlID49IDUwMCAmJiBzdGF0dXNDb2RlIDw9IDUwNCkpO1xufVxuZnVuY3Rpb24gZ2V0SG9zdHMoY2xpZW50KSB7XG4gICAgLyogSWYgd2UncmUgYSBjb25uZWN0ZWQgcmVhbHRpbWUgY2xpZW50LCB0cnkgdGhlIGVuZHBvaW50IHdlJ3JlIGNvbm5lY3RlZFxuICAgICAqIHRvIGZpcnN0IC0tIGJ1dCBzdGlsbCBoYXZlIGZhbGxiYWNrcywgYmVpbmcgY29ubmVjdGVkIGlzIG5vdCBhbiBhYnNvbHV0ZVxuICAgICAqIGd1YXJhbnRlZSB0aGF0IGEgZGF0YWNlbnRlciBoYXMgZnJlZSBjYXBhY2l0eSB0byBzZXJ2aWNlIFJFU1QgcmVxdWVzdHMuICovXG4gICAgdmFyIGNvbm5lY3Rpb24gPSBjbGllbnQuY29ubmVjdGlvbiwgY29ubmVjdGlvbkhvc3QgPSBjb25uZWN0aW9uICYmIGNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIuaG9zdDtcbiAgICBpZiAoY29ubmVjdGlvbkhvc3QpIHtcbiAgICAgICAgcmV0dXJuIFtjb25uZWN0aW9uSG9zdF0uY29uY2F0KGRlZmF1bHRzXzEuZGVmYXVsdC5nZXRGYWxsYmFja0hvc3RzKGNsaWVudC5vcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0c18xLmRlZmF1bHQuZ2V0SG9zdHMoY2xpZW50Lm9wdGlvbnMpO1xufVxudmFyIEh0dHAgPSAoX2EgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5jaGVja3NJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aXZpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnN1cHBvcnRzQXV0aEhlYWRlcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc3VwcG9ydHNMaW5rSGVhZGVycyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZ2V0SG9zdHMgPSBnZXRIb3N0cztcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICB2YXIgY29ubmVjdGl2aXR5Q2hlY2tVcmwgPSB0aGlzLm9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmwgfHwgZGVmYXVsdHNfMS5kZWZhdWx0LmNvbm5lY3Rpdml0eUNoZWNrVXJsO1xuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zID0gdGhpcy5vcHRpb25zLmNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zO1xuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpdml0eVVybElzRGVmYXVsdCA9ICF0aGlzLm9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmw7XG4gICAgICAgICAgICBpZiAocGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy54aHJTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1cHBvcnRzQXV0aEhlYWRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuUmVxdWVzdCA9IGZ1bmN0aW9uIChtZXRob2QsIHJlc3QsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0geGhycmVxdWVzdF8xLmRlZmF1bHQuY3JlYXRlUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgWEhSU3RhdGVzXzEuZGVmYXVsdC5SRVFfU0VORCwgcmVzdCAmJiByZXN0Lm9wdGlvbnMudGltZW91dHMsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmNlKCdjb21wbGV0ZScsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLmV4ZWMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZUNvbm5lY3Rpdml0eUNoZWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aXZpdHkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpdml0eSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICcoWEhSUmVxdWVzdClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCknLCAnU2VuZGluZzsgJyArIGNvbm5lY3Rpdml0eUNoZWNrVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9VcmkoSHR0cE1ldGhvZHNfMS5kZWZhdWx0LkdldCwgbnVsbCwgY29ubmVjdGl2aXR5Q2hlY2tVcmwsIG51bGwsIG51bGwsIGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZVRleHQsIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29ubmVjdGl2aXR5VXJsSXNEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICFlcnIgJiYgKDAsIEh0dHBTdGF0dXNDb2Rlc18xLmlzU3VjY2Vzc0NvZGUpKHN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gIWVyciAmJiAocmVzcG9uc2VUZXh0ID09PSBudWxsIHx8IHJlc3BvbnNlVGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2VUZXh0LnJlcGxhY2UoL1xcbi8sICcnKSkgPT0gJ3llcyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnKFhIUlJlcXVlc3QpSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpJywgJ1Jlc3VsdDogJyArIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuanNvbnBTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLlJlcXVlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9ICgwLCBqc29ucHRyYW5zcG9ydF8xLmNyZWF0ZVJlcXVlc3QpKHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBYSFJTdGF0ZXNfMS5kZWZhdWx0LlJFUV9TRU5ELCByZXN0ICYmIHJlc3Qub3B0aW9ucy50aW1lb3V0cywgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uY2UoJ2NvbXBsZXRlJywgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5leGVjKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlQ29ubmVjdGl2aXR5Q2hlY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpdml0eSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGl2aXR5ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVwVXJsID0gZGVmYXVsdHNfMS5kZWZhdWx0Lmpzb25wSW50ZXJuZXRVcFVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrc0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrc0luUHJvZ3Jlc3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja3NJblByb2dyZXNzID0gW2NhbGxiYWNrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnKEpTT05QKUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKScsICdTZW5kaW5nOyAnICsgdXBVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IG5ldyBqc29ucHRyYW5zcG9ydF8xLlJlcXVlc3QoJ2lzVGhlSW50ZXJuZXRVcCcsIHVwVXJsLCBudWxsLCBudWxsLCBudWxsLCBYSFJTdGF0ZXNfMS5kZWZhdWx0LlJFUV9TRU5ELCBkZWZhdWx0c18xLmRlZmF1bHQuVElNRU9VVFMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uY2UoJ2NvbXBsZXRlJywgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gIWVyciAmJiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJyhKU09OUClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCknLCAnUmVzdWx0OiAnICsgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLmNoZWNrc0luUHJvZ3Jlc3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNoZWNrc0luUHJvZ3Jlc3NbaV0obnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jaGVja3NJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmV4ZWMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuZmV0Y2hTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1cHBvcnRzQXV0aEhlYWRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuUmVxdWVzdCA9IGZldGNocmVxdWVzdF8xLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpdml0eSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJyhGZXRjaClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCknLCAnU2VuZGluZzsgJyArIGNvbm5lY3Rpdml0eUNoZWNrVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1VyaShIdHRwTWV0aG9kc18xLmRlZmF1bHQuR2V0LCBudWxsLCBjb25uZWN0aXZpdHlDaGVja1VybCwgbnVsbCwgbnVsbCwgbnVsbCwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gIWVyciAmJiAocmVzcG9uc2VUZXh0ID09PSBudWxsIHx8IHJlc3BvbnNlVGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2VUZXh0LnJlcGxhY2UoL1xcbi8sICcnKSkgPT0gJ3llcyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJyhGZXRjaClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCknLCAnUmVzdWx0OiAnICsgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLlJlcXVlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ25vIHN1cHBvcnRlZCBIVFRQIHRyYW5zcG9ydHMgYXZhaWxhYmxlJywgbnVsbCwgNDAwKSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBVbmxpa2UgZm9yIGRvVXJpLCB0aGUgJ3Jlc3QnIHBhcmFtIGhlcmUgaXMgbWFuZGF0b3J5LCBhcyBpdCdzIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGhvc3RzICovXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmRvID0gZnVuY3Rpb24gKG1ldGhvZCwgcmVzdCwgcGF0aCwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciB1cmlGcm9tSG9zdCA9IHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IHBhdGhcbiAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uIChob3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN0LmJhc2VVcmkoaG9zdCkgKyBwYXRoO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY3VycmVudEZhbGxiYWNrID0gcmVzdC5fY3VycmVudEZhbGxiYWNrO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RmFsbGJhY2sudmFsaWRVbnRpbCA+IFV0aWxzLm5vdygpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFVzZSBzdG9yZWQgZmFsbGJhY2sgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLlJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygnUmVxdWVzdCBpbnZva2VkIGJlZm9yZSBhc3NpZ25lZCB0bycsIG51bGwsIDUwMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuUmVxdWVzdChtZXRob2QsIHJlc3QsIHVyaUZyb21Ib3N0KGN1cnJlbnRGYWxsYmFjay5ob3N0KSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB0eXBlY2FzdCBpcyBzYWZlIGJlY2F1c2UgRXJybm9FeGNlcHRpb25zIGFyZSBvbmx5IHRocm93biBpbiBOb2RlSlNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgc2hvdWxkRmFsbGJhY2soZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHVuc3RvcmUgdGhlIGZhbGxiYWNrIGFuZCBzdGFydCBmcm9tIHRoZSB0b3Agd2l0aCB0aGUgZGVmYXVsdCBzZXF1ZW5jZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3QuX2N1cnJlbnRGYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZG8obWV0aG9kLCByZXN0LCBwYXRoLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2suYXBwbHkodm9pZCAwLCB0c2xpYl8xLl9fc3ByZWFkQXJyYXkoW2Vycl0sIGFyZ3MsIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKiBGYWxsYmFjayBleHBpcmVkOyByZW1vdmUgaXQgYW5kIGZhbGx0aHJvdWdoIHRvIG5vcm1hbCBzZXF1ZW5jZSAqL1xuICAgICAgICAgICAgICAgICAgICByZXN0Ll9jdXJyZW50RmFsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBob3N0cyA9IGdldEhvc3RzKHJlc3QpO1xuICAgICAgICAgICAgLyogaWYgdGhlcmUgaXMgb25seSBvbmUgaG9zdCBkbyBpdCAqL1xuICAgICAgICAgICAgaWYgKGhvc3RzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9VcmkobWV0aG9kLCByZXN0LCB1cmlGcm9tSG9zdChob3N0c1swXSksIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGhvc3RzIGlzIGFuIGFycmF5IHdpdGggcHJlZmVycmVkIGhvc3QgcGx1cyBhdCBsZWFzdCBvbmUgZmFsbGJhY2sgKi9cbiAgICAgICAgICAgIHZhciB0cnlBSG9zdCA9IGZ1bmN0aW9uIChjYW5kaWRhdGVIb3N0cywgcGVyc2lzdE9uU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHZhciBob3N0ID0gY2FuZGlkYXRlSG9zdHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5kb1VyaShtZXRob2QsIHJlc3QsIHVyaUZyb21Ib3N0KGhvc3QpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB0eXBlY2FzdCBpcyBzYWZlIGJlY2F1c2UgRXJybm9FeGNlcHRpb25zIGFyZSBvbmx5IHRocm93biBpbiBOb2RlSlNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBzaG91bGRGYWxsYmFjayhlcnIpICYmIGNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5QUhvc3QoY2FuZGlkYXRlSG9zdHMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXJzaXN0T25TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBSU0MxNWYgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3QuX2N1cnJlbnRGYWxsYmFjayA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBob3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkVW50aWw6IFV0aWxzLm5vdygpICsgcmVzdC5vcHRpb25zLnRpbWVvdXRzLmZhbGxiYWNrUmV0cnlUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2suYXBwbHkodm9pZCAwLCB0c2xpYl8xLl9fc3ByZWFkQXJyYXkoW2Vycl0sIGFyZ3MsIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5QUhvc3QoaG9zdHMpO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5kb1VyaSA9IGZ1bmN0aW9uIChtZXRob2QsIHJlc3QsIHVyaSwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLlJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygnUmVxdWVzdCBpbnZva2VkIGJlZm9yZSBhc3NpZ25lZCB0bycsIG51bGwsIDUwMCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuUmVxdWVzdChtZXRob2QsIHJlc3QsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oKSksXG4gICAgX2EubWV0aG9kcyA9IFtIdHRwTWV0aG9kc18xLmRlZmF1bHQuR2V0LCBIdHRwTWV0aG9kc18xLmRlZmF1bHQuRGVsZXRlLCBIdHRwTWV0aG9kc18xLmRlZmF1bHQuUG9zdCwgSHR0cE1ldGhvZHNfMS5kZWZhdWx0LlB1dCwgSHR0cE1ldGhvZHNfMS5kZWZhdWx0LlBhdGNoXSxcbiAgICBfYS5tZXRob2RzV2l0aG91dEJvZHkgPSBbSHR0cE1ldGhvZHNfMS5kZWZhdWx0LkdldCwgSHR0cE1ldGhvZHNfMS5kZWZhdWx0LkRlbGV0ZV0sXG4gICAgX2EubWV0aG9kc1dpdGhCb2R5ID0gW0h0dHBNZXRob2RzXzEuZGVmYXVsdC5Qb3N0LCBIdHRwTWV0aG9kc18xLmRlZmF1bHQuUHV0LCBIdHRwTWV0aG9kc18xLmRlZmF1bHQuUGF0Y2hdLFxuICAgIF9hKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEh0dHA7XG5cblxuLyoqKi8gfSksXG4vKiA2MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIGRlZmF1bHRzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuZnVuY3Rpb24gaXNBYmx5RXJyb3IocmVzcG9uc2VCb2R5LCBoZWFkZXJzKSB7XG4gICAgcmV0dXJuICEhaGVhZGVycy5nZXQoJ3gtYWJseS1lcnJvcmNvZGUnKTtcbn1cbmZ1bmN0aW9uIGdldEFibHlFcnJvcihyZXNwb25zZUJvZHksIGhlYWRlcnMpIHtcbiAgICBpZiAoaXNBYmx5RXJyb3IocmVzcG9uc2VCb2R5LCBoZWFkZXJzKSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VCb2R5LmVycm9yICYmIGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyhyZXNwb25zZUJvZHkuZXJyb3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZldGNoUmVxdWVzdChtZXRob2QsIHJlc3QsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBjYWxsYmFjaykge1xuICAgIHZhciBmZXRjaEhlYWRlcnMgPSBuZXcgSGVhZGVycyhoZWFkZXJzIHx8IHt9KTtcbiAgICB2YXIgX21ldGhvZCA9IG1ldGhvZCA/IG1ldGhvZC50b1VwcGVyQ2FzZSgpIDogVXRpbHMuaXNFbXB0eUFyZyhib2R5KSA/ICdHRVQnIDogJ1BPU1QnO1xuICAgIHZhciBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ1JlcXVlc3QgdGltZWQgb3V0JywgbnVsbCwgNDA4KSk7XG4gICAgfSwgcmVzdCA/IHJlc3Qub3B0aW9ucy50aW1lb3V0cy5odHRwUmVxdWVzdFRpbWVvdXQgOiBkZWZhdWx0c18xLmRlZmF1bHQuVElNRU9VVFMuaHR0cFJlcXVlc3RUaW1lb3V0KTtcbiAgICB2YXIgcmVxdWVzdEluaXQgPSB7XG4gICAgICAgIG1ldGhvZDogX21ldGhvZCxcbiAgICAgICAgaGVhZGVyczogZmV0Y2hIZWFkZXJzLFxuICAgICAgICBib2R5OiBib2R5LFxuICAgIH07XG4gICAgaWYgKCFwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmlzV2Vid29ya2VyKSB7XG4gICAgICAgIHJlcXVlc3RJbml0LmNyZWRlbnRpYWxzID0gZmV0Y2hIZWFkZXJzLmhhcygnYXV0aG9yaXphdGlvbicpID8gJ2luY2x1ZGUnIDogJ3NhbWUtb3JpZ2luJztcbiAgICB9XG4gICAgKDAsIHV0aWxzXzEuZ2V0R2xvYmFsT2JqZWN0KSgpXG4gICAgICAgIC5mZXRjaCh1cmkgKyAnPycgKyBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcyB8fCB7fSksIHJlcXVlc3RJbml0KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gcmVzLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgdmFyIHByb207XG4gICAgICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi94LW1zZ3BhY2snKSA+IC0xKSB7XG4gICAgICAgICAgICBwcm9tID0gcmVzLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTEpIHtcbiAgICAgICAgICAgIHByb20gPSByZXMuanNvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvbSA9IHJlcy50ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvbS50aGVuKGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgICB2YXIgdW5wYWNrZWQgPSAhIWNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL3gtbXNncGFjaycpID09PSAtMTtcbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IGdldEFibHlFcnJvcihib2R5LCByZXMuaGVhZGVycykgfHxcbiAgICAgICAgICAgICAgICAgICAgbmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ0Vycm9yIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gc2VydmVyOiAnICsgcmVzLnN0YXR1cyArICcgYm9keSB3YXM6ICcgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QoYm9keSksIG51bGwsIHJlcy5zdGF0dXMpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgYm9keSwgcmVzLmhlYWRlcnMsIHVucGFja2VkLCByZXMuc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGJvZHksIHJlcy5oZWFkZXJzLCB1bnBhY2tlZCwgcmVzLnN0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGZldGNoUmVxdWVzdDtcblxuXG4vKioqLyB9KSxcbi8qIDY0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgbXNncGFja18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0MSkpO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG4vLyBXb3JrYXJvdW5kIGZvciBzYWxlc2ZvcmNlIGxpZ2h0bmluZyBsb2NrZXIgY29tcGF0XG52YXIgZ2xvYmFsT2JqZWN0ID0gVXRpbHMuZ2V0R2xvYmFsT2JqZWN0KCk7XG5pZiAodHlwZW9mIFdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUubG9nKFwiV2FybmluZzogdGhpcyBkaXN0cmlidXRpb24gb2YgQWJseSBpcyBpbnRlbmRlZCBmb3IgYnJvd3NlcnMuIE9uIG5vZGVqcywgcGxlYXNlIHVzZSB0aGUgJ2FibHknIHBhY2thZ2Ugb24gbnBtXCIpO1xufVxuZnVuY3Rpb24gYWxsb3dDb21ldCgpIHtcbiAgICAvKiB4aHIgcmVxdWVzdHMgZnJvbSBsb2NhbCBmaWxlcyBhcmUgdW5yZWxpYWJsZSBpbiBzb21lIGJyb3dzZXJzLCBzdWNoIGFzIENocm9tZSA2NSBhbmQgaGlnaGVyIC0tIHNlZSBlZ1xuICAgICAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5MjU2NDI5L2Nocm9tZS02NS11bmFibGUtdG8tbWFrZS1wb3N0LXJlcXVlc3RzLWZyb20tbG9jYWwtZmlsZXMtdG8tZmxhc2tcbiAgICAgKiBTbyBpZiB3ZWJzb2NrZXRzIGFyZSBzdXBwb3J0ZWQsIHRoZW4ganVzdCBmb3JnZXQgYWJvdXQgY29tZXQgdHJhbnNwb3J0cyBhbmQgdXNlIHRoYXQgKi9cbiAgICB2YXIgbG9jID0gZ2xvYmFsT2JqZWN0LmxvY2F0aW9uO1xuICAgIHJldHVybiAhZ2xvYmFsT2JqZWN0LldlYlNvY2tldCB8fCAhbG9jIHx8ICFsb2Mub3JpZ2luIHx8IGxvYy5vcmlnaW4uaW5kZXhPZignaHR0cCcpID4gLTE7XG59XG52YXIgdXNlckFnZW50ID0gZ2xvYmFsT2JqZWN0Lm5hdmlnYXRvciAmJiBnbG9iYWxPYmplY3QubmF2aWdhdG9yLnVzZXJBZ2VudC50b1N0cmluZygpO1xudmFyIGN1cnJlbnRVcmwgPSBnbG9iYWxPYmplY3QubG9jYXRpb24gJiYgZ2xvYmFsT2JqZWN0LmxvY2F0aW9uLmhyZWY7XG52YXIgQ29uZmlnID0ge1xuICAgIGFnZW50OiAnYnJvd3NlcicsXG4gICAgbG9nVGltZXN0YW1wczogdHJ1ZSxcbiAgICB1c2VyQWdlbnQ6IHVzZXJBZ2VudCxcbiAgICBjdXJyZW50VXJsOiBjdXJyZW50VXJsLFxuICAgIG5vVXBncmFkZTogdXNlckFnZW50ICYmICEhdXNlckFnZW50Lm1hdGNoKC9NU0lFXFxzOFxcLjAvKSxcbiAgICBiaW5hcnlUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgIFdlYlNvY2tldDogZ2xvYmFsT2JqZWN0LldlYlNvY2tldCxcbiAgICBmZXRjaFN1cHBvcnRlZDogISFnbG9iYWxPYmplY3QuZmV0Y2gsXG4gICAgeGhyU3VwcG9ydGVkOiBnbG9iYWxPYmplY3QuWE1MSHR0cFJlcXVlc3QgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCksXG4gICAganNvbnBTdXBwb3J0ZWQ6IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgYWxsb3dDb21ldDogYWxsb3dDb21ldCgpLFxuICAgIHN0cmVhbWluZ1N1cHBvcnRlZDogdHJ1ZSxcbiAgICB1c2VQcm90b2NvbEhlYXJ0YmVhdHM6IHRydWUsXG4gICAgY3JlYXRlSG1hYzogbnVsbCxcbiAgICBtc2dwYWNrOiBtc2dwYWNrXzEuZGVmYXVsdCxcbiAgICBzdXBwb3J0c0JpbmFyeTogISFnbG9iYWxPYmplY3QuVGV4dERlY29kZXIsXG4gICAgcHJlZmVyQmluYXJ5OiBmYWxzZSxcbiAgICBBcnJheUJ1ZmZlcjogZ2xvYmFsT2JqZWN0LkFycmF5QnVmZmVyLFxuICAgIGF0b2I6IGdsb2JhbE9iamVjdC5hdG9iLFxuICAgIG5leHRUaWNrOiB0eXBlb2YgZ2xvYmFsT2JqZWN0LnNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBnbG9iYWxPYmplY3Quc2V0SW1tZWRpYXRlLmJpbmQoZ2xvYmFsT2JqZWN0KVxuICAgICAgICA6IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGYsIDApO1xuICAgICAgICB9LFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGdsb2JhbE9iamVjdC5hZGRFdmVudExpc3RlbmVyLFxuICAgIGluc3BlY3Q6IEpTT04uc3RyaW5naWZ5LFxuICAgIHN0cmluZ0J5dGVTaXplOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIC8qIHN0ci5sZW5ndGggd2lsbCBiZSBhbiB1bmRlcmVzdGltYXRlIGZvciBub24tYXNjaWkgc3RyaW5ncy4gQnV0IGlmIHdlJ3JlXG4gICAgICAgICAqIGluIGEgYnJvd3NlciB0b28gb2xkIHRvIHN1cHBvcnQgVGV4dERlY29kZXIsIG5vdCBtdWNoIHdlIGNhbiBkby4gQmV0dGVyXG4gICAgICAgICAqIHRvIHVuZGVyZXN0aW1hdGUsIHNvIGlmIHdlIGRvIGdvIG92ZXItc2l6ZSwgdGhlIHNlcnZlciB3aWxsIHJlamVjdCB0aGVcbiAgICAgICAgICogbWVzc2FnZSAqL1xuICAgICAgICByZXR1cm4gKGdsb2JhbE9iamVjdC5UZXh0RGVjb2RlciAmJiBuZXcgZ2xvYmFsT2JqZWN0LlRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikubGVuZ3RoKSB8fCBzdHIubGVuZ3RoO1xuICAgIH0sXG4gICAgVGV4dEVuY29kZXI6IGdsb2JhbE9iamVjdC5UZXh0RW5jb2RlcixcbiAgICBUZXh0RGVjb2RlcjogZ2xvYmFsT2JqZWN0LlRleHREZWNvZGVyLFxuICAgIFByb21pc2U6IGdsb2JhbE9iamVjdC5Qcm9taXNlLFxuICAgIGdldFJhbmRvbVZhbHVlczogKGZ1bmN0aW9uIChjcnlwdG8pIHtcbiAgICAgICAgaWYgKGNyeXB0byA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJyLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSkoZ2xvYmFsT2JqZWN0LmNyeXB0byB8fCBtc0NyeXB0byksXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29uZmlnO1xuXG5cbi8qKiovIH0pLFxuLyogNjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciB0ZXN0ID0gJ2FibHlqcy1zdG9yYWdlLXRlc3QnO1xudmFyIFdlYnN0b3JhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2Vic3RvcmFnZSgpIHtcbiAgICAgICAgLyogRXZlbiBqdXN0IGFjY2Vzc2luZyB0aGUgc2Vzc2lvbi9sb2NhbFN0b3JhZ2Ugb2JqZWN0IGNhbiB0aHJvdyBhXG4gICAgICAgICAqIHNlY3VyaXR5IGV4Y2VwdGlvbiBpbiBzb21lIGNpcmN1bXN0YW5jZXMgd2l0aCBzb21lIGJyb3dzZXJzLiBJblxuICAgICAgICAgKiBvdGhlcnMsIGNhbGxpbmcgc2V0SXRlbSB3aWxsIHRocm93LiBTbyBoYXZlIHRvIGNoZWNrIGluIHRoaXNcbiAgICAgICAgICogc29tZXdoYXQgcm91bmRhYm91dCB3YXkuIChJZiB1bnN1cHBvcnRlZCBvciBubyBnbG9iYWwgb2JqZWN0LFxuICAgICAgICAgKiB3aWxsIHRocm93IG9uIGFjY2Vzc2luZyBhIHByb3BlcnR5IG9mIHVuZGVmaW5lZCkgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGdsb2JhbC5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHRlc3QsIHRlc3QpO1xuICAgICAgICAgICAgZ2xvYmFsLnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odGVzdCk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb25TdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb25TdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5zZXRJdGVtKHRlc3QsIHRlc3QpO1xuICAgICAgICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRlc3QpO1xuICAgICAgICAgICAgdGhpcy5sb2NhbFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBXZWJzdG9yYWdlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KG5hbWUsIGZhbHNlKTtcbiAgICB9O1xuICAgIFdlYnN0b3JhZ2UucHJvdG90eXBlLmdldFNlc3Npb24gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KG5hbWUsIHRydWUpO1xuICAgIH07XG4gICAgV2Vic3RvcmFnZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZShuYW1lLCBmYWxzZSk7XG4gICAgfTtcbiAgICBXZWJzdG9yYWdlLnByb3RvdHlwZS5yZW1vdmVTZXNzaW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZShuYW1lLCB0cnVlKTtcbiAgICB9O1xuICAgIFdlYnN0b3JhZ2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgdHRsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXQobmFtZSwgdmFsdWUsIHR0bCwgZmFsc2UpO1xuICAgIH07XG4gICAgV2Vic3RvcmFnZS5wcm90b3R5cGUuc2V0U2Vzc2lvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgdHRsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXQobmFtZSwgdmFsdWUsIHR0bCwgdHJ1ZSk7XG4gICAgfTtcbiAgICBXZWJzdG9yYWdlLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCB0dGwsIHNlc3Npb24pIHtcbiAgICAgICAgdmFyIHdyYXBwZWRWYWx1ZSA9IHsgdmFsdWU6IHZhbHVlIH07XG4gICAgICAgIGlmICh0dGwpIHtcbiAgICAgICAgICAgIHdyYXBwZWRWYWx1ZS5leHBpcmVzID0gVXRpbHMubm93KCkgKyB0dGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZUludGVyZmFjZShzZXNzaW9uKS5zZXRJdGVtKG5hbWUsIEpTT04uc3RyaW5naWZ5KHdyYXBwZWRWYWx1ZSkpO1xuICAgIH07XG4gICAgV2Vic3RvcmFnZS5wcm90b3R5cGUuX2dldCA9IGZ1bmN0aW9uIChuYW1lLCBzZXNzaW9uKSB7XG4gICAgICAgIGlmIChzZXNzaW9uICYmICF0aGlzLnNlc3Npb25TdXBwb3J0ZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nlc3Npb24gU3RvcmFnZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIGlmICghc2Vzc2lvbiAmJiAhdGhpcy5sb2NhbFN1cHBvcnRlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTG9jYWwgU3RvcmFnZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIHZhciByYXdJdGVtID0gdGhpcy5zdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLmdldEl0ZW0obmFtZSk7XG4gICAgICAgIGlmICghcmF3SXRlbSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgd3JhcHBlZFZhbHVlID0gSlNPTi5wYXJzZShyYXdJdGVtKTtcbiAgICAgICAgaWYgKHdyYXBwZWRWYWx1ZS5leHBpcmVzICYmIHdyYXBwZWRWYWx1ZS5leHBpcmVzIDwgVXRpbHMubm93KCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZUludGVyZmFjZShzZXNzaW9uKS5yZW1vdmVJdGVtKG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyYXBwZWRWYWx1ZS52YWx1ZTtcbiAgICB9O1xuICAgIFdlYnN0b3JhZ2UucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbiAobmFtZSwgc2Vzc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLnJlbW92ZUl0ZW0obmFtZSk7XG4gICAgfTtcbiAgICBXZWJzdG9yYWdlLnByb3RvdHlwZS5zdG9yYWdlSW50ZXJmYWNlID0gZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHNlc3Npb24gPyBnbG9iYWwuc2Vzc2lvblN0b3JhZ2UgOiBnbG9iYWwubG9jYWxTdG9yYWdlO1xuICAgIH07XG4gICAgcmV0dXJuIFdlYnN0b3JhZ2U7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFdlYnN0b3JhZ2UoKTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTMpKSlcblxuLyoqKi8gfSksXG4vKiA2NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFRyYW5zcG9ydE5hbWVzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KSk7XG52YXIgRGVmYXVsdHMgPSB7XG4gICAgY29ubmVjdGl2aXR5Q2hlY2tVcmw6ICdodHRwczovL2ludGVybmV0LXVwLmFibHktcmVhbHRpbWUuY29tL2lzLXRoZS1pbnRlcm5ldC11cC50eHQnLFxuICAgIGpzb25wSW50ZXJuZXRVcFVybDogJ2h0dHBzOi8vaW50ZXJuZXQtdXAuYWJseS1yZWFsdGltZS5jb20vaXMtdGhlLWludGVybmV0LXVwLTAtOS5qcycsXG4gICAgLyogT3JkZXIgbWF0dGVycyBoZXJlOiB0aGUgYmFzZSB0cmFuc3BvcnQgaXMgdGhlIGxlZnRtb3N0IG9uZSBpbiB0aGVcbiAgICAgKiBpbnRlcnNlY3Rpb24gb2YgYmFzZVRyYW5zcG9ydE9yZGVyIGFuZCB0aGUgdHJhbnNwb3J0cyBjbGllbnRPcHRpb24gdGhhdCdzXG4gICAgICogc3VwcG9ydGVkLiAgVGhpcyBpcyBub3QgcXVpdGUgdGhlIHNhbWUgYXMgdGhlIHByZWZlcmVuY2Ugb3JkZXIgLS0gZS5nLlxuICAgICAqIHhocl9wb2xsaW5nIGlzIHByZWZlcnJlZCB0byBqc29ucCwgYnV0IGZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQgd2Ugd2FudFxuICAgICAqIHRoZSBiYXNlIHRyYW5zcG9ydCB0byBiZSB4aHJfcG9sbGluZywgbm90IGpzb25wICovXG4gICAgZGVmYXVsdFRyYW5zcG9ydHM6IFtcbiAgICAgICAgVHJhbnNwb3J0TmFtZXNfMS5kZWZhdWx0LlhoclBvbGxpbmcsXG4gICAgICAgIFRyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5YaHJTdHJlYW1pbmcsXG4gICAgICAgIFRyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5Kc29uUCxcbiAgICAgICAgVHJhbnNwb3J0TmFtZXNfMS5kZWZhdWx0LldlYlNvY2tldCxcbiAgICBdLFxuICAgIGJhc2VUcmFuc3BvcnRPcmRlcjogW1xuICAgICAgICBUcmFuc3BvcnROYW1lc18xLmRlZmF1bHQuWGhyUG9sbGluZyxcbiAgICAgICAgVHJhbnNwb3J0TmFtZXNfMS5kZWZhdWx0LlhoclN0cmVhbWluZyxcbiAgICAgICAgVHJhbnNwb3J0TmFtZXNfMS5kZWZhdWx0Lkpzb25QLFxuICAgICAgICBUcmFuc3BvcnROYW1lc18xLmRlZmF1bHQuV2ViU29ja2V0LFxuICAgIF0sXG4gICAgdHJhbnNwb3J0UHJlZmVyZW5jZU9yZGVyOiBbXG4gICAgICAgIFRyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5Kc29uUCxcbiAgICAgICAgVHJhbnNwb3J0TmFtZXNfMS5kZWZhdWx0LlhoclBvbGxpbmcsXG4gICAgICAgIFRyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5YaHJTdHJlYW1pbmcsXG4gICAgICAgIFRyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5XZWJTb2NrZXQsXG4gICAgXSxcbiAgICB1cGdyYWRlVHJhbnNwb3J0czogW1RyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5YaHJTdHJlYW1pbmcsIFRyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5XZWJTb2NrZXRdLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IERlZmF1bHRzO1xuXG5cbi8qKiovIH0pLFxuLyogNjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBUcmFuc3BvcnROYW1lcztcbihmdW5jdGlvbiAoVHJhbnNwb3J0TmFtZXMpIHtcbiAgICBUcmFuc3BvcnROYW1lc1tcIldlYlNvY2tldFwiXSA9IFwid2ViX3NvY2tldFwiO1xuICAgIFRyYW5zcG9ydE5hbWVzW1wiQ29tZXRcIl0gPSBcImNvbWV0XCI7XG4gICAgVHJhbnNwb3J0TmFtZXNbXCJYaHJTdHJlYW1pbmdcIl0gPSBcInhocl9zdHJlYW1pbmdcIjtcbiAgICBUcmFuc3BvcnROYW1lc1tcIlhoclBvbGxpbmdcIl0gPSBcInhocl9wb2xsaW5nXCI7XG4gICAgVHJhbnNwb3J0TmFtZXNbXCJKc29uUFwiXSA9IFwianNvbnBcIjtcbn0pKFRyYW5zcG9ydE5hbWVzIHx8IChUcmFuc3BvcnROYW1lcyA9IHt9KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBUcmFuc3BvcnROYW1lcztcblxuXG4vKioqLyB9KSxcbi8qIDY4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gRVNNIENPTVBBVCBGTEFHXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvcGxhdGZvcm0vd2ViL2xpYi90cmFuc3BvcnQvanNvbnB0cmFuc3BvcnQudHNcbnZhciBqc29ucHRyYW5zcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xudmFyIGpzb25wdHJhbnNwb3J0X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpzb25wdHJhbnNwb3J0KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21tb24vbGliL3V0aWwvdXRpbHMudHNcbnZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tbW9uL3BsYXRmb3JtLnRzXG52YXIgcGxhdGZvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIHBsYXRmb3JtX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHBsYXRmb3JtKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21tb24vbGliL3RyYW5zcG9ydC9jb21ldHRyYW5zcG9ydC50c1xudmFyIGNvbWV0dHJhbnNwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG52YXIgY29tZXR0cmFuc3BvcnRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29tZXR0cmFuc3BvcnQpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3BsYXRmb3JtL3dlYi9saWIvdHJhbnNwb3J0L3hocnJlcXVlc3QudHNcbnZhciB4aHJyZXF1ZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG52YXIgeGhycmVxdWVzdF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih4aHJyZXF1ZXN0KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcGxhdGZvcm0vd2ViL2xpYi90cmFuc3BvcnQveGhycG9sbGluZ3RyYW5zcG9ydC5qc1xuXG5cblxuXG5cbnZhciB4aHJwb2xsaW5ndHJhbnNwb3J0X1hIUlBvbGxpbmdUcmFuc3BvcnQgPSBmdW5jdGlvbiAoY29ubmVjdGlvbk1hbmFnZXIpIHtcbiAgdmFyIHNob3J0TmFtZSA9ICd4aHJfcG9sbGluZyc7XG5cbiAgZnVuY3Rpb24gWEhSUG9sbGluZ1RyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG4gICAgcGFyYW1zLnN0cmVhbSA9IGZhbHNlO1xuICAgIGNvbWV0dHJhbnNwb3J0X2RlZmF1bHQuYS5jYWxsKHRoaXMsIGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuICAgIHRoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lO1xuICB9XG4gIHV0aWxzW1wiaW5oZXJpdHNcIl0oWEhSUG9sbGluZ1RyYW5zcG9ydCwgY29tZXR0cmFuc3BvcnRfZGVmYXVsdC5hKTtcblxuICBYSFJQb2xsaW5nVHJhbnNwb3J0LmlzQXZhaWxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwbGF0Zm9ybV9kZWZhdWx0LmEuQ29uZmlnLnhoclN1cHBvcnRlZCAmJiBwbGF0Zm9ybV9kZWZhdWx0LmEuQ29uZmlnLmFsbG93Q29tZXQ7XG4gIH07XG5cbiAgWEhSUG9sbGluZ1RyYW5zcG9ydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdYSFJQb2xsaW5nVHJhbnNwb3J0OyB1cmk9JyArIHRoaXMuYmFzZVVyaSArICc7IGlzQ29ubmVjdGVkPScgKyB0aGlzLmlzQ29ubmVjdGVkO1xuICB9O1xuXG4gIFhIUlBvbGxpbmdUcmFuc3BvcnQucHJvdG90eXBlLmNyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbiAodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlKSB7XG4gICAgcmV0dXJuIHhocnJlcXVlc3RfZGVmYXVsdC5hLmNyZWF0ZVJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aGlzLnRpbWVvdXRzKTtcbiAgfTtcblxuICBpZiAodHlwZW9mIGNvbm5lY3Rpb25NYW5hZ2VyICE9PSAndW5kZWZpbmVkJyAmJiBYSFJQb2xsaW5nVHJhbnNwb3J0LmlzQXZhaWxhYmxlKCkpIHtcbiAgICBjb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzW3Nob3J0TmFtZV0gPSBYSFJQb2xsaW5nVHJhbnNwb3J0O1xuICB9XG5cbiAgcmV0dXJuIFhIUlBvbGxpbmdUcmFuc3BvcnQ7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB4aHJwb2xsaW5ndHJhbnNwb3J0ID0gKHhocnBvbGxpbmd0cmFuc3BvcnRfWEhSUG9sbGluZ1RyYW5zcG9ydCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3BsYXRmb3JtL3dlYi9saWIvdHJhbnNwb3J0L3hocnN0cmVhbWluZ3RyYW5zcG9ydC5qc1xuXG5cblxuXG5cbnZhciB4aHJzdHJlYW1pbmd0cmFuc3BvcnRfWEhSU3RyZWFtaW5nVHJhbnNwb3J0ID0gZnVuY3Rpb24gKGNvbm5lY3Rpb25NYW5hZ2VyKSB7XG4gIHZhciBzaG9ydE5hbWUgPSAneGhyX3N0cmVhbWluZyc7XG5cbiAgLyogcHVibGljIGNvbnN0cnVjdG9yICovXG4gIGZ1bmN0aW9uIFhIUlN0cmVhbWluZ1RyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG4gICAgY29tZXR0cmFuc3BvcnRfZGVmYXVsdC5hLmNhbGwodGhpcywgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG4gICAgdGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWU7XG4gIH1cbiAgdXRpbHNbXCJpbmhlcml0c1wiXShYSFJTdHJlYW1pbmdUcmFuc3BvcnQsIGNvbWV0dHJhbnNwb3J0X2RlZmF1bHQuYSk7XG5cbiAgWEhSU3RyZWFtaW5nVHJhbnNwb3J0LmlzQXZhaWxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwbGF0Zm9ybV9kZWZhdWx0LmEuQ29uZmlnLnhoclN1cHBvcnRlZCAmJiBwbGF0Zm9ybV9kZWZhdWx0LmEuQ29uZmlnLnN0cmVhbWluZ1N1cHBvcnRlZCAmJiBwbGF0Zm9ybV9kZWZhdWx0LmEuQ29uZmlnLmFsbG93Q29tZXQ7XG4gIH07XG5cbiAgWEhSU3RyZWFtaW5nVHJhbnNwb3J0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ1hIUlN0cmVhbWluZ1RyYW5zcG9ydDsgdXJpPScgKyB0aGlzLmJhc2VVcmkgKyAnOyBpc0Nvbm5lY3RlZD0nICsgdGhpcy5pc0Nvbm5lY3RlZDtcbiAgfTtcblxuICBYSFJTdHJlYW1pbmdUcmFuc3BvcnQucHJvdG90eXBlLmNyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbiAodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlKSB7XG4gICAgcmV0dXJuIHhocnJlcXVlc3RfZGVmYXVsdC5hLmNyZWF0ZVJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aGlzLnRpbWVvdXRzKTtcbiAgfTtcblxuICBpZiAodHlwZW9mIGNvbm5lY3Rpb25NYW5hZ2VyICE9PSAndW5kZWZpbmVkJyAmJiBYSFJTdHJlYW1pbmdUcmFuc3BvcnQuaXNBdmFpbGFibGUoKSkge1xuICAgIGNvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHNbc2hvcnROYW1lXSA9IFhIUlN0cmVhbWluZ1RyYW5zcG9ydDtcbiAgfVxuXG4gIHJldHVybiBYSFJTdHJlYW1pbmdUcmFuc3BvcnQ7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB4aHJzdHJlYW1pbmd0cmFuc3BvcnQgPSAoeGhyc3RyZWFtaW5ndHJhbnNwb3J0X1hIUlN0cmVhbWluZ1RyYW5zcG9ydCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3BsYXRmb3JtL3dlYi9saWIvdHJhbnNwb3J0L2luZGV4LmpzXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcG9ydCA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKFtqc29ucHRyYW5zcG9ydF9kZWZhdWx0LmEsIHhocnBvbGxpbmd0cmFuc3BvcnQsIHhocnN0cmVhbWluZ3RyYW5zcG9ydF0pO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKVtcImRlZmF1bHRcIl07XG59KTsiLCIndXNlIHN0cmljdCc7XG5mdW5jdGlvbiBwcm9taXNpZnlPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMuaW5kZXhPZignOicpID09IC0xID8geyB0b2tlbjogb3B0aW9ucyB9IDogeyBrZXk6IG9wdGlvbnMgfTtcbiAgfVxuICBvcHRpb25zLnByb21pc2VzID0gdHJ1ZTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qIFBsZWFzZSBub3RlIHRoYXQgdGhlIGZpbGUgaW1wb3J0ZWQgYmVsb3cgaXMgb25seSBnZW5lcmF0ZWQgYWZ0ZXIgcnVubmluZ1xuICogdGhlIGJ1aWxkIHRhc2suICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xudmFyIEFibHkgPSByZXF1aXJlKCcuL2J1aWxkL2FibHktbm9kZScpO1xuXG52YXIgUmVzdFByb21pc2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICByZXR1cm4gbmV3IEFibHkuUmVzdChwcm9taXNpZnlPcHRpb25zKG9wdGlvbnMpKTtcbn07XG5PYmplY3QuYXNzaWduKFJlc3RQcm9taXNlLCBBYmx5LlJlc3QpO1xuXG52YXIgUmVhbHRpbWVQcm9taXNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBBYmx5LlJlYWx0aW1lKHByb21pc2lmeU9wdGlvbnMob3B0aW9ucykpO1xufTtcbk9iamVjdC5hc3NpZ24oUmVhbHRpbWVQcm9taXNlLCBBYmx5LlJlYWx0aW1lKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFJlc3Q6IFJlc3RQcm9taXNlLFxuICBSZWFsdGltZTogUmVhbHRpbWVQcm9taXNlLFxufTtcbiIsImltcG9ydCB7IHNlcnZlciB9IGZyb20gXCIuL3NlcnZlclwiO1xyXG5pbXBvcnQgeyB2aWV3IH0gZnJvbSBcIi4vdmlld1wiO1xyXG5pbXBvcnQgeyBnZXRSYW5kb21JbnQgfSBmcm9tIFwiLi91bnRpbHMvcmFuZG9tXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgQ29udHJvbGxlciB7XHJcbiAgc3R5bGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInN0eWxlXCIpID8/IFwibGlnaHRcIjtcclxuICBzdGVwID0gZ2V0UmFuZG9tSW50KDEpID09PSAwID8gXCJ4XCIgOiBcIm9cIjtcclxuXHJcbiAgY2VsbHNEYXRhID0gW107XHJcblxyXG4gIGFzeW5jIGluaXQoKSB7XHJcbiAgICBhd2FpdCBzZXJ2ZXIuaW5pdCgpO1xyXG5cclxuICAgIHRoaXMucmVzZXRHYW1lKCk7XHJcbiAgICBjb25zb2xlLmxvZyh0aGlzLmNlbGxzRGF0YSk7XHJcblxyXG4gICAgc2VydmVyLm9uU2VydmVyTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB0aGlzLm9uU2VydmVyTWVzc2FnZShtZXNzYWdlKTtcclxuXHJcbiAgICB2aWV3LnNldFN0eWxlKHRoaXMuc3R5bGUpO1xyXG5cclxuICAgIHZpZXcuc2V0VHVybih0aGlzLnN0ZXApO1xyXG5cclxuICAgIHZpZXcuYnV0dG9uVG9waWMub25jbGljayA9ICgpID0+IHRoaXMudG9nZ2xlU3R5bGUoKTtcclxuXHJcbiAgICB2aWV3Lm9uQ2VsbFByZXNzID0gKGNlbGwpID0+IHRoaXMub25DZWxsUHJlc3MoY2VsbCk7XHJcbiAgfVxyXG5cclxuICB0b2dnbGVTdHlsZSgpIHtcclxuICAgIHRoaXMuc3R5bGUgPSB0aGlzLnN0eWxlID09PSBcImxpZ2h0XCIgPyBcImRhcmtcIiA6IFwibGlnaHRcIjtcclxuICAgIHZpZXcuc2V0U3R5bGUodGhpcy5zdHlsZSk7XHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInN0eWxlXCIsIHRoaXMuc3R5bGUpO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRHYW1lKCkge1xyXG4gICAgdGhpcy5jZWxsc0RhdGEgPSBuZXcgQXJyYXkoOSkuZmlsbChcImVtcHR5XCIpO1xyXG4gICAgdmlldy5jbGVhckNlbGxzKCk7XHJcbiAgICB2aWV3LnNldFR1cm4odGhpcy5zdGVwKTtcclxuICB9XHJcblxyXG4gIG9uU2VydmVyTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpO1xyXG5cclxuICAgIHRoaXMuc3RlcCA9IGRhdGEuc3RlcDtcclxuICAgIHRoaXMuY2VsbCA9IHZpZXcuY2VsbHNbZGF0YS5jZWxsXTtcclxuICAgIHRoaXMuY2VsbHNEYXRhW2RhdGEuY2VsbF0gPSB0aGlzLnN0ZXA7XHJcblxyXG4gICAgdmlldy51cGRhdGVDZWxsKHZpZXcuY2VsbHNbZGF0YS5jZWxsXSwgdGhpcy5zdGVwKTtcclxuICAgIHZpZXcuc2V0VHVybih0aGlzLnN0ZXApO1xyXG5cclxuICAgIHRoaXMuc3dpdGNoU3RlcCgpO1xyXG4gICAgdmlldy5zZXRUdXJuKHRoaXMuc3RlcCk7XHJcblxyXG4gICAgdGhpcy5jaGVja0RyYXcoKTtcclxuICAgIHRoaXMuY2hlY2tXaW4oKTtcclxuICB9XHJcblxyXG4gIHN3aXRjaFN0ZXAoKSB7XHJcbiAgICB0aGlzLnN0ZXAgPSB0aGlzLnN0ZXAgPT09IFwieFwiID8gXCJvXCIgOiBcInhcIjtcclxuICAgIGNvbnNvbGUubG9nKFwic3dpdGNoU3RlcFwiLCB0aGlzLnN0ZXApO1xyXG4gIH1cclxuXHJcbiAgb25DZWxsUHJlc3MoY2VsbCkge1xyXG4gICAgY29uc29sZS5sb2coXCJvbkNlbGxQcmVzc1wiLCB0aGlzLnN0ZXApO1xyXG5cclxuICAgIGlmICh0aGlzLmNlbGxzRGF0YVt2aWV3LmNlbGxzLmluZGV4T2YoY2VsbCldICE9PSBcImVtcHR5XCIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHNlcnZlci5tYWtlTW92ZSh7XHJcbiAgICAgIGNlbGw6IHZpZXcuY2VsbHMuaW5kZXhPZihjZWxsKSxcclxuICAgICAgc3RlcDogdGhpcy5zdGVwLFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBjaGVja1dpbigpIHtcclxuICAgIGNvbnN0IHdpbm5lciA9IHRoaXMuZ2V0V2lubmVyKCk7XHJcblxyXG4gICAgaWYgKCF3aW5uZXIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZpZXcuc2V0V2luKCk7XHJcbiAgICB2aWV3LnNldENvbW1lbnQodGhpcy5zdGVwKTtcclxuICAgIHZpZXcuc2V0V2luVGV4dCh3aW5uZXIpO1xyXG4gICAgdGhpcy5jZWxsc0RhdGEuZmlsbChcImZ1bGxcIik7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVzZXRHYW1lKCksIDUwMDApO1xyXG4gICAgY29uc29sZS5sb2coYHdpbm5lcjogJHt3aW5uZXJ9YCk7XHJcbiAgfVxyXG5cclxuICBnZXRXaW5uZXIoKSB7XHJcbiAgICBpZiAodGhpcy5jaGVja1dpbm5pbmdQb3NpdGlvbnMoXCJ4XCIpKSB7XHJcbiAgICAgIHJldHVybiBcInhcIjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5jaGVja1dpbm5pbmdQb3NpdGlvbnMoXCJvXCIpKSB7XHJcbiAgICAgIHJldHVybiBcIm9cIjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGNoZWNrV2lubmluZ1Bvc2l0aW9ucyh3aW5uaW5nTWFyaykge1xyXG4gICAgbGV0IHdpbm5pbmdQb3NpdGlvbnMgPSBbXHJcbiAgICAgIFswLCAxLCAyXSxcclxuICAgICAgWzMsIDQsIDVdLFxyXG4gICAgICBbNiwgNywgOF0sXHJcbiAgICAgIFswLCAzLCA2XSxcclxuICAgICAgWzEsIDQsIDddLFxyXG4gICAgICBbMiwgNSwgOF0sXHJcbiAgICAgIFswLCA0LCA4XSxcclxuICAgICAgWzIsIDQsIDZdLFxyXG4gICAgXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpbm5pbmdQb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgW3BvczEsIHBvczIsIHBvczNdID0gd2lubmluZ1Bvc2l0aW9uc1tpXTtcclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICB0aGlzLmNlbGxzRGF0YVtwb3MxXSA9PT0gd2lubmluZ01hcmsgJiZcclxuICAgICAgICB0aGlzLmNlbGxzRGF0YVtwb3MyXSA9PT0gd2lubmluZ01hcmsgJiZcclxuICAgICAgICB0aGlzLmNlbGxzRGF0YVtwb3MzXSA9PT0gd2lubmluZ01hcmtcclxuICAgICAgKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBjaGVja0RyYXcoKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2VsbHNEYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICh0aGlzLmNlbGxzRGF0YVtpXSAhPT0gXCJ4XCIgJiYgdGhpcy5jZWxsc0RhdGFbaV0gIT09IFwib1wiKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmxvZyhcIkRSQVdcIik7XHJcblxyXG4gICAgdmlldy5zZXREcmF3KCk7XHJcbiAgICB2aWV3LnNldENvbW1lbnQodGhpcy5zdGVwKTtcclxuXHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVzZXRHYW1lKCksIDUwMDApO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgYWJseSBmcm9tIFwiYWJseS9wcm9taXNlc1wiO1xyXG5cclxuY29uc3QgQVBJX0tFWSA9IFwiWjlvcS13LlNlQzBzQTpSV2NoUVZvZTVPVzZIQ3hfb2drLXBSdF9nMnFvQmt6RTNodWh4ZHNTSV9BXCI7XHJcblxyXG5jb25zdCBtZXNzYWdlcyA9IHtcclxuICBtb3ZlOiBcIm1vdmVcIixcclxuICBtZXNzYWdlOiBcIm1lc3NhZ2VcIixcclxufTtcclxuXHJcbmNsYXNzIFNlcnZlciB7XHJcbiAgYXN5bmMgaW5pdCgpIHtcclxuICAgIHRoaXMuc2VydmVyID0gYXdhaXQgdGhpcy5jb25uZWN0KCk7XHJcbiAgICBhd2FpdCB0aGlzLmNyZWF0ZUNoYW5uZWwoXCJnYW1lXCIpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgY29ubmVjdCgpIHtcclxuICAgIC8vIEZvciB0aGUgZnVsbCBjb2RlIHNhbXBsZSBzZWUgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL2FibHkvcXVpY2tzdGFydC1qc1xyXG4gICAgY29uc3Qgc2VydmVyID0gbmV3IGFibHkuUmVhbHRpbWUuUHJvbWlzZShBUElfS0VZKTtcclxuXHJcbiAgICBhd2FpdCBzZXJ2ZXIuY29ubmVjdGlvbi5vbmNlKFwiY29ubmVjdGVkXCIpO1xyXG4gICAgY29uc29sZS5sb2coXCJDb25uZWN0ZWQgdG8gQWJseSFcIik7XHJcblxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgKCkgPT4gYWJseS5jbG9zZSgpKTtcclxuXHJcbiAgICByZXR1cm4gc2VydmVyO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgY3JlYXRlQ2hhbm5lbChjaGFubmVsTmFtZSkge1xyXG4gICAgdGhpcy5jaGFubmVsID0gdGhpcy5zZXJ2ZXIuY2hhbm5lbHMuZ2V0KGNoYW5uZWxOYW1lKTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLmNoYW5uZWwuc3Vic2NyaWJlKG1lc3NhZ2VzLm1vdmUsIChtZXNzYWdlKSA9PlxyXG4gICAgICB0aGlzLm9uU2VydmVyTWVzc2FnZShtZXNzYWdlKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIG1ha2VNb3ZlKGRhdGEpIHtcclxuICAgIGF3YWl0IHRoaXMuY2hhbm5lbC5wdWJsaXNoKG1lc3NhZ2VzLm1vdmUsIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBzZXJ2ZXIgPSBuZXcgU2VydmVyKCk7XHJcbiIsImV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kb21JbnQobWF4KSB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KTtcclxufSIsImV4cG9ydCBjbGFzcyBWaWV3IHtcclxuICBjZWxscyA9IFtdO1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMucGFyZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwYXJlbnRcIik7XHJcblxyXG4gICAgY29uc3QgdGljVGFjVG9lRGl2ID0gdGhpcy5jcmVhdGVEaXYoXCJ0aWN0YWN0b2VEaXZcIik7XHJcbiAgICB0aGlzLnBhcmVudC5hcHBlbmRDaGlsZCh0aWNUYWNUb2VEaXYpO1xyXG4gICAgdGljVGFjVG9lRGl2LmNsYXNzTGlzdC5hZGQoXCJkaXNwbGF5Tm9uZVwiKTtcclxuXHJcbiAgICB0aGlzLmJ1dHRvblRvcGljID0gdGhpcy5jcmVhdGVCdXR0b24oXCJidXR0b25Ub3BpY1wiKTtcclxuICAgIHRpY1RhY1RvZURpdi5hcHBlbmRDaGlsZCh0aGlzLmJ1dHRvblRvcGljKTtcclxuXHJcbiAgICBjb25zdCBwbGF5ZXJEaXYgPSB0aGlzLmNyZWF0ZURpdihcInBsYXllckRpdlwiKTtcclxuICAgIHRpY1RhY1RvZURpdi5hcHBlbmRDaGlsZChwbGF5ZXJEaXYpO1xyXG5cclxuICAgIHRoaXMudHVyblBvaW50ZXIgPSB0aGlzLmNyZWF0ZURpdihcInBsYXllclwiKTtcclxuICAgIHBsYXllckRpdi5hcHBlbmRDaGlsZCh0aGlzLnR1cm5Qb2ludGVyKTtcclxuXHJcbiAgICB0aGlzLmNvbW1lbnRzID0gdGhpcy5jcmVhdGVEaXYoXCJwbGF5ZXJQXCIpO1xyXG4gICAgcGxheWVyRGl2LmFwcGVuZENoaWxkKHRoaXMuY29tbWVudHMpO1xyXG5cclxuICAgIGNvbnN0IGNlbGxEaXYgPSB0aGlzLmNyZWF0ZURpdihcImNlbGxEaXZcIik7XHJcbiAgICB0aWNUYWNUb2VEaXYuYXBwZW5kQ2hpbGQoY2VsbERpdik7XHJcblxyXG4gICAgdGhpcy5jcmVhdGVDZWxscyhjZWxsRGl2KTtcclxuXHJcblxyXG5cclxuICAgIC8vIHRoaXMuYnV0dG9uUGxheUFnYWluID0gdGhpcy5jcmVhdGVCdXR0b24oXCJidXR0b25cIik7XHJcbiAgICAvLyB0aWNUYWNUb2VEaXYuYXBwZW5kQ2hpbGQodGhpcy5idXR0b25QbGF5QWdhaW4pO1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlRGl2KGNsYXNzTmFtZSkge1xyXG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgIGRpdi5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIGRpdjtcclxuICB9XHJcblxyXG4gIGNyZWF0ZUNlbGxzKGNlbGxzRGl2KSB7XHJcbiAgICBmb3IgKGxldCBjZWxsTnVtID0gMDsgY2VsbE51bSA8IDk7IGNlbGxOdW0rKykge1xyXG4gICAgICBjb25zdCBjZWxsID0gdGhpcy5jcmVhdGVCdXR0b24oXCJjZWxsIGZ1bGxcIik7XHJcblxyXG4gICAgICBjZWxsLm9uY2xpY2sgPSAoKSA9PiB0aGlzLm9uQ2VsbFByZXNzKGNlbGwpO1xyXG5cclxuICAgICAgY2VsbHNEaXYuYXBwZW5kQ2hpbGQoY2VsbCk7XHJcblxyXG4gICAgICB0aGlzLmNlbGxzLnB1c2goY2VsbCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjcmVhdGVCdXR0b24oY2xhc3NOYW1lKSB7XHJcbiAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xyXG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuXHJcbiAgICByZXR1cm4gYnV0dG9uO1xyXG4gIH1cclxuXHJcbiAgc2V0VHVybih0dXJuKSB7XHJcbiAgICBpZiAodHVybiA9PT0gXCJ4XCIpIHtcclxuICAgICAgdGhpcy50dXJuUG9pbnRlci5pbm5lckhUTUwgPSBcIlggVHVyblwiO1xyXG4gICAgfSBlbHNlIGlmICh0dXJuID09PSBcIm9cIikge1xyXG4gICAgICB0aGlzLnR1cm5Qb2ludGVyLmlubmVySFRNTCA9IFwiTyBUdXJuXCI7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXRDb21tZW50KHR1cm4pIHtcclxuICAgIGlmICh0dXJuID09PSBcInhcIikge1xyXG4gICAgICB0aGlzLmNvbW1lbnRzLmlubmVySFRNTCA9IFwiTmV4dCB0dXJuIFhcIjtcclxuICAgIH0gZWxzZSBpZiAodHVybiA9PT0gXCJvXCIpIHtcclxuICAgICAgdGhpcy5jb21tZW50cy5pbm5lckhUTUwgPSBcIk5leHQgdHVybiBPXCI7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXRXaW5UZXh0KHdpblN5bWJvbCkge1xyXG4gICAgaWYgKHdpblN5bWJvbCA9PT0gXCJ4XCIpIHtcclxuICAgICAgdGhpcy50dXJuUG9pbnRlci5pbm5lckhUTUwgPSBcIlggV29uIVwiO1xyXG4gICAgfSBlbHNlIGlmICh3aW5TeW1ib2wgPT09IFwib1wiKSB7XHJcbiAgICAgIHRoaXMudHVyblBvaW50ZXIuaW5uZXJIVE1MID0gXCJPIFdvbiFcIjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldFN0eWxlKHN0eWxlKSB7XHJcbiAgICBpZiAoc3R5bGUgPT09IFwiZGFya1wiKSB7XHJcbiAgICAgIHRoaXMucGFyZW50LmNsYXNzTGlzdC5hZGQoXCJkYXJrXCIpO1xyXG4gICAgfSBlbHNlIGlmIChzdHlsZSA9PT0gXCJsaWdodFwiKSB7XHJcbiAgICAgIHRoaXMucGFyZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJkYXJrXCIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdXBkYXRlQ2VsbChjZWxsLCBzdGVwKSB7XHJcbiAgICBpZiAoc3RlcCA9PT0gXCJ4XCIpIHtcclxuICAgICAgY2VsbC5jbGFzc0xpc3QuYWRkKFwieFwiLCBcImVtcHR5XCIsIFwic3RlcFhcIik7XHJcbiAgICAgIGNlbGwuY2xhc3NMaXN0LnJlbW92ZShcImZ1bGxcIik7XHJcbiAgICB9IGVsc2UgaWYgKHN0ZXAgPT09IFwib1wiKSB7XHJcbiAgICAgIGNlbGwuY2xhc3NMaXN0LmFkZChcIm9cIiwgXCJlbXB0eVwiLCBcInN0ZXBPXCIpO1xyXG4gICAgICBjZWxsLmNsYXNzTGlzdC5yZW1vdmUoXCJjZWxsV2FpdFwiLCBcImZ1bGxcIik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXRXaW4oKSB7XHJcbiAgICB0aGlzLnBhcmVudC5jbGFzc0xpc3QuYWRkKFwid2luXCIpO1xyXG4gIH1cclxuXHJcbiAgc2V0RHJhdygpIHtcclxuICAgIHRoaXMudHVyblBvaW50ZXIuaW5uZXJIVE1MID0gXCJEcmF3IVwiO1xyXG4gICAgdGhpcy5wYXJlbnQuY2xhc3NMaXN0LmFkZChcImRyYXdcIik7XHJcbiAgfVxyXG5cclxuICBjbGVhckNlbGxzKCkge1xyXG4gICAgZm9yIChjb25zdCBjZWxsIG9mIHRoaXMuY2VsbHMpIHtcclxuICAgICAgY2VsbC5jbGFzc0xpc3QuYWRkKFwiZnVsbFwiKTtcclxuICAgICAgY2VsbC5jbGFzc0xpc3QucmVtb3ZlKFwib1wiLCBcInhcIiwgXCJzdGVwWFwiLCBcInN0ZXBPXCIsIFwiZW1wdHlcIik7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5wYXJlbnQuY2xhc3NMaXN0LnJlbW92ZShcIndpblwiLCBcImRyYXdcIik7XHJcbiAgICB0aGlzLmNvbW1lbnRzLmlubmVySFRNTCA9IFwiXCI7XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJjbGVhclwiKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB2aWV3ID0gbmV3IFZpZXcoKTtcclxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImltcG9ydCB7IENvbnRyb2xsZXIgfSBmcm9tIFwiLi9jb250cm9sbGVyXCI7XHJcblxyXG5uZXcgQ29udHJvbGxlcigpLmluaXQoKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9