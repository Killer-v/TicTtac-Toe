/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/ably/build/ably-commonjs.js":
/*!**************************************************!*\
  !*** ./node_modules/ably/build/ably-commonjs.js ***!
  \**************************************************/
/***/ ((module) => {

/*!
 * @license Copyright 2015-2022 Ably Real-time Ltd (ably.com)
 * 
 * Ably JavaScript Library v1.2.43
 * https://github.com/ably/ably-js
 * 
 * Released under the Apache Licence v2.0
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_723__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_723__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_723__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_723__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_723__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_723__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_723__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__nested_webpack_require_723__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __nested_webpack_require_723__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__nested_webpack_require_723__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_723__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_723__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_723__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_723__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_723__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_723__(__nested_webpack_require_723__.s = 42);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_4200__) {

"use strict";
__nested_webpack_require_4200__.r(__nested_webpack_exports__);
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__spreadArray", function() { return __spreadArray; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __nested_webpack_require_4200__.d(__nested_webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}


/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_19043__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.allToUpperCase = exports.allToLowerCase = exports.encodeBody = exports.decodeBody = exports.Format = exports.promisify = exports.trim = exports.arrChooseN = exports.randomHexString = exports.randomString = exports.cheapRandStr = exports.dataSizeBytes = exports.inspectBody = exports.inspectError = exports.isErrorInfoOrPartialErrorInfo = exports.now = exports.parseQueryString = exports.toQueryString = exports.arrPopRandomElement = exports.defaultPostHeaders = exports.defaultGetHeaders = exports.allSame = exports.arrEvery = exports.arrFilter = exports.arrMap = exports.safeArrForEach = exports.arrForEach = exports.forInOwnNonNullProperties = exports.valuesArray = exports.keysArray = exports.arrWithoutValue = exports.arrDeleteValue = exports.arrIn = exports.arrIndexOf = exports.arrSubtract = exports.arrIntersectOb = exports.arrIntersect = exports.intersect = exports.containsValue = exports.inherits = exports.prototypicalClone = exports.shallowClone = exports.isEmptyArg = exports.isOnlyPropIn = exports.isEmpty = exports.isObject = exports.ensureArray = exports.isArray = exports.copy = exports.mixin = void 0;
exports.toBase64 = exports.matchDerivedChannel = exports.shallowEquals = exports.getGlobalObject = exports.getRetryTime = exports.getJitterCoefficient = exports.getBackoffCoefficient = void 0;
var tslib_1 = __nested_webpack_require_19043__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_19043__(3));
var defaults_1 = tslib_1.__importStar(__nested_webpack_require_19043__(8));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_19043__(4));
var enc_base64_1 = __nested_webpack_require_19043__(11);
var enc_utf8_1 = __nested_webpack_require_19043__(31);
function randomPosn(arrOrStr) {
    return Math.floor(Math.random() * arrOrStr.length);
}
/*
 * Add a set of properties to a target object
 * target: the target object
 * props:  an object whose enumerable properties are
 *         added, by reference only
 */
function mixin(target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < args.length; i++) {
        var source = args[i];
        if (!source) {
            break;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        for (var key in source) {
            if (!hasOwnProperty || hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }
    return target;
}
exports.mixin = mixin;
/*
 * Add a set of properties to a target object
 * target: the target object
 * props:  an object whose enumerable properties are
 *         added, by reference only
 */
function copy(src) {
    return mixin({}, src);
}
exports.copy = copy;
/*
 * Determine whether or not a given object is
 * an array.
 */
exports.isArray = Array.isArray ||
    function (value) {
        return Object.prototype.toString.call(value) == '[object Array]';
    };
/*
 * Ensures that an Array object is always returned
 * returning the original Array of obj is an Array
 * else wrapping the obj in a single element Array
 */
function ensureArray(obj) {
    if (isEmptyArg(obj)) {
        return [];
    }
    if ((0, exports.isArray)(obj)) {
        return obj;
    }
    return [obj];
}
exports.ensureArray = ensureArray;
function isObject(ob) {
    return Object.prototype.toString.call(ob) == '[object Object]';
}
exports.isObject = isObject;
/*
 * Determine whether or not an object contains
 * any enumerable properties.
 * ob: the object
 */
function isEmpty(ob) {
    for (var prop in ob)
        return false;
    return true;
}
exports.isEmpty = isEmpty;
function isOnlyPropIn(ob, property) {
    for (var prop in ob) {
        if (prop !== property) {
            return false;
        }
    }
    return true;
}
exports.isOnlyPropIn = isOnlyPropIn;
/*
 * Determine whether or not an argument to an overloaded function is
 * undefined (missing) or null.
 * This method is useful when constructing functions such as (WebIDL terminology):
 *   off([TreatUndefinedAs=Null] DOMString? event)
 * as you can then confirm the argument using:
 *   Utils.isEmptyArg(event)
 */
function isEmptyArg(arg) {
    return arg === null || arg === undefined;
}
exports.isEmptyArg = isEmptyArg;
/*
 * Perform a simple shallow clone of an object.
 * Result is an object irrespective of whether
 * the input is an object or array. All
 * enumerable properties are copied.
 * ob: the object
 */
function shallowClone(ob) {
    var result = new Object();
    for (var prop in ob)
        result[prop] = ob[prop];
    return result;
}
exports.shallowClone = shallowClone;
/*
 * Clone an object by creating a new object with the
 * given object as its prototype. Optionally
 * a set of additional own properties can be
 * supplied to be added to the newly created clone.
 * ob:            the object to be cloned
 * ownProperties: optional object with additional
 *                properties to add
 */
function prototypicalClone(ob, ownProperties) {
    var F = /** @class */ (function () {
        function F() {
        }
        return F;
    }());
    F.prototype = ob;
    var result = new F();
    if (ownProperties)
        mixin(result, ownProperties);
    return result;
}
exports.prototypicalClone = prototypicalClone;
/*
 * Declare a constructor to represent a subclass
 * of another constructor
 * If platform has a built-in version we use that from Platform, else we
 * define here (so can make use of other Utils fns)
 * See node.js util.inherits
 */
var inherits = function (ctor, superCtor) {
    if (platform_1.default.Config.inherits) {
        platform_1.default.Config.inherits(ctor, superCtor);
        return;
    }
    ctor.super_ = superCtor;
    ctor.prototype = prototypicalClone(superCtor.prototype, { constructor: ctor });
};
exports.inherits = inherits;
/*
 * Determine whether or not an object has an enumerable
 * property whose value equals a given value.
 * ob:  the object
 * val: the value to find
 */
function containsValue(ob, val) {
    for (var i in ob) {
        if (ob[i] == val)
            return true;
    }
    return false;
}
exports.containsValue = containsValue;
function intersect(arr, ob) {
    return (0, exports.isArray)(ob) ? arrIntersect(arr, ob) : arrIntersectOb(arr, ob);
}
exports.intersect = intersect;
function arrIntersect(arr1, arr2) {
    var result = [];
    for (var i = 0; i < arr1.length; i++) {
        var member = arr1[i];
        if ((0, exports.arrIndexOf)(arr2, member) != -1)
            result.push(member);
    }
    return result;
}
exports.arrIntersect = arrIntersect;
function arrIntersectOb(arr, ob) {
    var result = [];
    for (var i = 0; i < arr.length; i++) {
        var member = arr[i];
        if (member in ob)
            result.push(member);
    }
    return result;
}
exports.arrIntersectOb = arrIntersectOb;
function arrSubtract(arr1, arr2) {
    var result = [];
    for (var i = 0; i < arr1.length; i++) {
        var element = arr1[i];
        if ((0, exports.arrIndexOf)(arr2, element) == -1)
            result.push(element);
    }
    return result;
}
exports.arrSubtract = arrSubtract;
exports.arrIndexOf = Array.prototype.indexOf
    ? function (arr, elem, fromIndex) {
        return arr.indexOf(elem, fromIndex);
    }
    : function (arr, elem, fromIndex) {
        fromIndex = fromIndex || 0;
        var len = arr.length;
        for (; fromIndex < len; fromIndex++) {
            if (arr[fromIndex] === elem) {
                return fromIndex;
            }
        }
        return -1;
    };
function arrIn(arr, val) {
    return (0, exports.arrIndexOf)(arr, val) !== -1;
}
exports.arrIn = arrIn;
function arrDeleteValue(arr, val) {
    var idx = (0, exports.arrIndexOf)(arr, val);
    var res = idx != -1;
    if (res)
        arr.splice(idx, 1);
    return res;
}
exports.arrDeleteValue = arrDeleteValue;
function arrWithoutValue(arr, val) {
    var newArr = arr.slice();
    arrDeleteValue(newArr, val);
    return newArr;
}
exports.arrWithoutValue = arrWithoutValue;
/*
 * Construct an array of the keys of the enumerable
 * properties of a given object, optionally limited
 * to only the own properties.
 * ob:      the object
 * ownOnly: boolean, get own properties only
 */
function keysArray(ob, ownOnly) {
    var result = [];
    for (var prop in ob) {
        if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))
            continue;
        result.push(prop);
    }
    return result;
}
exports.keysArray = keysArray;
/*
 * Construct an array of the values of the enumerable
 * properties of a given object, optionally limited
 * to only the own properties.
 * ob:      the object
 * ownOnly: boolean, get own properties only
 */
function valuesArray(ob, ownOnly) {
    var result = [];
    for (var prop in ob) {
        if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))
            continue;
        result.push(ob[prop]);
    }
    return result;
}
exports.valuesArray = valuesArray;
function forInOwnNonNullProperties(ob, fn) {
    for (var prop in ob) {
        if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {
            fn(prop);
        }
    }
}
exports.forInOwnNonNullProperties = forInOwnNonNullProperties;
exports.arrForEach = Array.prototype.forEach
    ? function (arr, fn) {
        arr.forEach(fn);
    }
    : function (arr, fn) {
        var len = arr.length;
        for (var i = 0; i < len; i++) {
            fn(arr[i], i, arr);
        }
    };
/* Useful when the function may mutate the array */
function safeArrForEach(arr, fn) {
    return (0, exports.arrForEach)(arr.slice(), fn);
}
exports.safeArrForEach = safeArrForEach;
exports.arrMap = Array.prototype.map
    ? function (arr, fn) {
        return arr.map(fn);
    }
    : function (arr, fn) {
        var result = [];
        var len = arr.length;
        for (var i = 0; i < len; i++) {
            result.push(fn(arr[i], i, arr));
        }
        return result;
    };
exports.arrFilter = Array.prototype.filter
    ? function (arr, fn) {
        return arr.filter(fn);
    }
    : function (arr, fn) {
        var result = [], len = arr.length;
        for (var i = 0; i < len; i++) {
            if (fn(arr[i])) {
                result.push(arr[i]);
            }
        }
        return result;
    };
exports.arrEvery = Array.prototype.every
    ? function (arr, fn) {
        return arr.every(fn);
    }
    : function (arr, fn) {
        var len = arr.length;
        for (var i = 0; i < len; i++) {
            if (!fn(arr[i], i, arr)) {
                return false;
            }
        }
        return true;
    };
function allSame(arr, prop) {
    if (arr.length === 0) {
        return true;
    }
    var first = arr[0][prop];
    return (0, exports.arrEvery)(arr, function (item) {
        return item[prop] === first;
    });
}
exports.allSame = allSame;
var contentTypes = {
    json: 'application/json',
    jsonp: 'application/javascript',
    xml: 'application/xml',
    html: 'text/html',
    msgpack: 'application/x-msgpack',
};
function defaultGetHeaders(options, format) {
    var accept = contentTypes[format || Format.json];
    return {
        accept: accept,
        'X-Ably-Version': defaults_1.default.protocolVersion.toString(),
        'Ably-Agent': (0, defaults_1.getAgentString)(options),
    };
}
exports.defaultGetHeaders = defaultGetHeaders;
function defaultPostHeaders(options, format) {
    var contentType;
    var accept = (contentType = contentTypes[format || Format.json]);
    return {
        accept: accept,
        'content-type': contentType,
        'X-Ably-Version': defaults_1.default.protocolVersion.toString(),
        'Ably-Agent': (0, defaults_1.getAgentString)(options),
    };
}
exports.defaultPostHeaders = defaultPostHeaders;
function arrPopRandomElement(arr) {
    return arr.splice(randomPosn(arr), 1)[0];
}
exports.arrPopRandomElement = arrPopRandomElement;
function toQueryString(params) {
    var parts = [];
    if (params) {
        for (var key in params)
            parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));
    }
    return parts.length ? '?' + parts.join('&') : '';
}
exports.toQueryString = toQueryString;
function parseQueryString(query) {
    var match;
    var search = /([^?&=]+)=?([^&]*)/g;
    var result = {};
    while ((match = search.exec(query)))
        result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);
    return result;
}
exports.parseQueryString = parseQueryString;
exports.now = Date.now ||
    function () {
        /* IE 8 */
        return new Date().getTime();
    };
function isErrorInfoOrPartialErrorInfo(err) {
    return (typeof err == 'object' &&
        err !== null &&
        (err.constructor.name == 'ErrorInfo' || err.constructor.name == 'PartialErrorInfo'));
}
exports.isErrorInfoOrPartialErrorInfo = isErrorInfoOrPartialErrorInfo;
function inspectError(err) {
    var _a, _b;
    if (err instanceof Error ||
        ((_a = err === null || err === void 0 ? void 0 : err.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'ErrorInfo' ||
        ((_b = err === null || err === void 0 ? void 0 : err.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'PartialErrorInfo')
        return err.toString();
    return platform_1.default.Config.inspect(err);
}
exports.inspectError = inspectError;
function inspectBody(body) {
    if (platform_1.default.BufferUtils.isBuffer(body)) {
        return body.toString();
    }
    else if (typeof body === 'string') {
        return body;
    }
    else {
        return platform_1.default.Config.inspect(body);
    }
}
exports.inspectBody = inspectBody;
/* Data is assumed to be either a string or a buffer. */
function dataSizeBytes(data) {
    if (platform_1.default.BufferUtils.isBuffer(data)) {
        return platform_1.default.BufferUtils.byteLength(data);
    }
    if (typeof data === 'string') {
        return platform_1.default.Config.stringByteSize(data);
    }
    throw new Error('Expected input of Utils.dataSizeBytes to be a buffer or string, but was: ' + typeof data);
}
exports.dataSizeBytes = dataSizeBytes;
function cheapRandStr() {
    return String(Math.random()).substr(2);
}
exports.cheapRandStr = cheapRandStr;
/* Takes param the minimum number of bytes of entropy the string must
 * include, not the length of the string. String length produced is not
 * guaranteed. */
var randomString = function (numBytes) {
    if (platform_1.default.Config.getRandomValues && typeof Uint8Array !== 'undefined') {
        var uIntArr = new Uint8Array(numBytes);
        platform_1.default.Config.getRandomValues(uIntArr);
        return platform_1.default.BufferUtils.base64Encode(uIntArr);
    }
    /* Old browser; fall back to Math.random. Could just use a
     * CryptoJS version of the above, but want this to still work in nocrypto
     * versions of the library */
    var charset = platform_1.default.BufferUtils.base64CharSet;
    /* base64 has 33% overhead; round length up */
    var length = Math.round((numBytes * 4) / 3);
    var result = '';
    for (var i = 0; i < length; i++) {
        result += charset[randomPosn(charset)];
    }
    return result;
};
exports.randomString = randomString;
var randomHexString = function (numBytes) {
    if (platform_1.default.Config.getRandomValues && typeof Uint8Array !== 'undefined') {
        var uIntArr = new Uint8Array(numBytes);
        platform_1.default.Config.getRandomValues(uIntArr);
        return platform_1.default.BufferUtils.hexEncode(uIntArr);
    }
    var charset = platform_1.default.BufferUtils.hexCharSet;
    var length = numBytes * 2;
    var result = '';
    for (var i = 0; i < length; i++) {
        result += charset[randomPosn(charset)];
    }
    return result;
};
exports.randomHexString = randomHexString;
/* Pick n elements at random without replacement from an array */
function arrChooseN(arr, n) {
    var numItems = Math.min(n, arr.length), mutableArr = arr.slice(), result = [];
    for (var i = 0; i < numItems; i++) {
        result.push(arrPopRandomElement(mutableArr));
    }
    return result;
}
exports.arrChooseN = arrChooseN;
exports.trim = String.prototype.trim
    ? function (str) {
        return str.trim();
    }
    : function (str) {
        return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
    };
function promisify(ob, fnName, args) {
    return new Promise(function (resolve, reject) {
        ob[fnName].apply(ob, tslib_1.__spreadArray(tslib_1.__spreadArray([], args, false), [function (err, res) {
                err ? reject(err) : resolve(res);
            }], false));
    });
}
exports.promisify = promisify;
var Format;
(function (Format) {
    Format["msgpack"] = "msgpack";
    Format["json"] = "json";
})(Format = exports.Format || (exports.Format = {}));
function decodeBody(body, format) {
    return format == 'msgpack' ? platform_1.default.Config.msgpack.decode(body) : JSON.parse(String(body));
}
exports.decodeBody = decodeBody;
function encodeBody(body, format) {
    return format == 'msgpack' ? platform_1.default.Config.msgpack.encode(body, true) : JSON.stringify(body);
}
exports.encodeBody = encodeBody;
function allToLowerCase(arr) {
    return arr.map(function (element) {
        return element && element.toLowerCase();
    });
}
exports.allToLowerCase = allToLowerCase;
function allToUpperCase(arr) {
    return arr.map(function (element) {
        return element && element.toUpperCase();
    });
}
exports.allToUpperCase = allToUpperCase;
function getBackoffCoefficient(count) {
    return Math.min((count + 2) / 3, 2);
}
exports.getBackoffCoefficient = getBackoffCoefficient;
function getJitterCoefficient() {
    return 1 - Math.random() * 0.2;
}
exports.getJitterCoefficient = getJitterCoefficient;
/**
 *
 * @param initialTimeout initial timeout value
 * @param retryAttempt integer indicating retryAttempt
 * @returns RetryTimeout value for given timeout and retryAttempt.
 * If x is the value generated then,
 * Upper bound = min((retryAttempt + 2) / 3, 2) * initialTimeout,
 * Lower bound = 0.8 * Upper bound,
 * Lower bound < x < Upper bound
 */
function getRetryTime(initialTimeout, retryAttempt) {
    return initialTimeout * getBackoffCoefficient(retryAttempt) * getJitterCoefficient();
}
exports.getRetryTime = getRetryTime;
function getGlobalObject() {
    if (global) {
        return global;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    return self;
}
exports.getGlobalObject = getGlobalObject;
function shallowEquals(source, target) {
    return (Object.keys(source).every(function (key) { return source[key] === target[key]; }) &&
        Object.keys(target).every(function (key) { return target[key] === source[key]; }));
}
exports.shallowEquals = shallowEquals;
function matchDerivedChannel(name) {
    /**
     * This regex check is to retain existing channel params if any e.g [?rewind=1]foo to
     * [filter=xyz?rewind=1]foo. This is to keep channel compatibility around use of
     * channel params that work with derived channels.
     *
     * This eslint unsafe regex warning is triggered because the RegExp uses nested quantifiers,
     * but it does not create any situation where the regex engine has to
     * explore a large number of possible matches so itâ€™s safe to ignore
     */
    var regex = /^(\[([^?]*)(?:(.*))\])?(.+)$/; // eslint-disable-line
    var match = name.match(regex);
    if (!match || !match.length || match.length < 5) {
        throw new errorinfo_1.default('regex match failed', 400, 40010);
    }
    // Fail if there is already a channel qualifier, eg [meta]foo should fail instead of just overriding with [filter=xyz]foo
    if (match[2]) {
        throw new errorinfo_1.default("cannot use a derived option with a ".concat(match[2], " channel"), 400, 40010);
    }
    // Return match values to be added to derive channel quantifier.
    return {
        qualifierParam: match[3] || '',
        channelName: match[4],
    };
}
exports.matchDerivedChannel = matchDerivedChannel;
function toBase64(str) {
    if (platform_1.default.Config.createHmac) {
        return Buffer.from(str, 'ascii').toString('base64');
    }
    return (0, enc_base64_1.stringify)((0, enc_utf8_1.parse)(str));
}
exports.toBase64 = toBase64;

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_19043__(13)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __nested_webpack_require_39587__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_39587__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_39587__(3));
// Workaround for salesforce lightning locker compatibility
// This is a shorthand version of Utils.getGlobalObject (which we can't use here without creating a circular import)
var globalObject = global || (typeof window !== 'undefined' ? window : self);
var LogLevels;
(function (LogLevels) {
    LogLevels[LogLevels["None"] = 0] = "None";
    LogLevels[LogLevels["Error"] = 1] = "Error";
    LogLevels[LogLevels["Major"] = 2] = "Major";
    LogLevels[LogLevels["Minor"] = 3] = "Minor";
    LogLevels[LogLevels["Micro"] = 4] = "Micro";
})(LogLevels || (LogLevels = {}));
function pad(timeSegment, three) {
    return "".concat(timeSegment).padStart(three ? 3 : 2, '0');
}
function getHandler(logger) {
    return platform_1.default.Config.logTimestamps
        ? function (msg) {
            var time = new Date();
            logger(pad(time.getHours()) +
                ':' +
                pad(time.getMinutes()) +
                ':' +
                pad(time.getSeconds()) +
                '.' +
                pad(time.getMilliseconds(), 1) +
                ' ' +
                msg);
        }
        : logger;
}
var getDefaultLoggers = function () {
    var _a, _b;
    var consoleLogger;
    var errorLogger;
    /* Can't just check for console && console.log; fails in IE <=9 */
    if ((typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') /* node */ ||
        typeof ((_b = (_a = globalObject === null || globalObject === void 0 ? void 0 : globalObject.console) === null || _a === void 0 ? void 0 : _a.log) === null || _b === void 0 ? void 0 : _b.apply) === 'function' /* sensible browsers */) {
        consoleLogger = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            console.log.apply(console, args);
        };
        errorLogger = console.warn
            ? function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                console.warn.apply(console, args);
            }
            : consoleLogger;
    }
    else if (globalObject === null || globalObject === void 0 ? void 0 : globalObject.console.log) {
        /* IE <= 9 with the console open -- console.log does not
         * inherit from Function, so has no apply method */
        consoleLogger = errorLogger = function () {
            Function.prototype.apply.call(console.log, console, arguments);
        };
    }
    else {
        /* IE <= 9 when dev tools are closed - window.console not even defined */
        consoleLogger = errorLogger = function () { };
    }
    return [consoleLogger, errorLogger].map(getHandler);
};
var Logger = /** @class */ (function () {
    function Logger() {
        Logger.logLevel = Logger.LOG_DEFAULT;
    }
    Logger.initLogHandlers = function () {
        var _a = getDefaultLoggers(), logHandler = _a[0], logErrorHandler = _a[1];
        this.logHandler = logHandler;
        this.logErrorHandler = logErrorHandler;
    };
    Logger.logLevel = LogLevels.Error; // default logLevel
    // public constants
    Logger.LOG_NONE = LogLevels.None;
    Logger.LOG_ERROR = LogLevels.Error;
    Logger.LOG_MAJOR = LogLevels.Major;
    Logger.LOG_MINOR = LogLevels.Minor;
    Logger.LOG_MICRO = LogLevels.Micro;
    // aliases
    Logger.LOG_DEFAULT = LogLevels.Error;
    Logger.LOG_DEBUG = LogLevels.Micro;
    /* public static functions */
    Logger.logAction = function (level, action, message) {
        if (Logger.shouldLog(level)) {
            (level === LogLevels.Error ? Logger.logErrorHandler : Logger.logHandler)('Ably: ' + action + ': ' + message);
        }
    };
    Logger.deprecated = function (original, replacement) {
        Logger.deprecatedWithMsg(original, "Please use '" + replacement + "' instead.");
    };
    Logger.deprecatedWithMsg = function (funcName, msg) {
        if (Logger.shouldLog(LogLevels.Error)) {
            Logger.logErrorHandler("Ably: Deprecation warning - '" + funcName + "' is deprecated and will be removed from a future version. " + msg);
        }
    };
    /* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent
         the object being serialised if the log level will not output the message */
    Logger.shouldLog = function (level) {
        return level <= Logger.logLevel;
    };
    Logger.setLog = function (level, handler) {
        if (level !== undefined)
            Logger.logLevel = level;
        if (handler !== undefined)
            Logger.logHandler = Logger.logErrorHandler = handler;
    };
    return Logger;
}());
exports.default = Logger;

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_39587__(13)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Platform = /** @class */ (function () {
    function Platform() {
    }
    return Platform;
}());
exports.default = Platform;


/***/ }),
/* 4 */
/***/ (function(module, exports, __nested_webpack_require_45001__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PartialErrorInfo = void 0;
var tslib_1 = __nested_webpack_require_45001__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_45001__(3));
var Utils = tslib_1.__importStar(__nested_webpack_require_45001__(1));
function toString(err) {
    var result = '[' + err.constructor.name;
    if (err.message)
        result += ': ' + err.message;
    if (err.statusCode)
        result += '; statusCode=' + err.statusCode;
    if (err.code)
        result += '; code=' + err.code;
    if (err.cause)
        result += '; cause=' + Utils.inspectError(err.cause);
    if (err.href && !(err.message && err.message.indexOf('help.ably.io') > -1))
        result += '; see ' + err.href + ' ';
    result += ']';
    return result;
}
var ErrorInfo = /** @class */ (function (_super) {
    tslib_1.__extends(ErrorInfo, _super);
    function ErrorInfo(message, code, statusCode, cause) {
        var _this = _super.call(this, message) || this;
        if (typeof Object.setPrototypeOf !== 'undefined') {
            Object.setPrototypeOf(_this, ErrorInfo.prototype);
        }
        _this.code = code;
        _this.statusCode = statusCode;
        _this.cause = cause;
        return _this;
    }
    ErrorInfo.prototype.toString = function () {
        return toString(this);
    };
    ErrorInfo.fromValues = function (values) {
        var _a = values, message = _a.message, code = _a.code, statusCode = _a.statusCode;
        if (typeof message !== 'string' || typeof code !== 'number' || typeof statusCode !== 'number') {
            throw new Error('ErrorInfo.fromValues(): invalid values: ' + platform_1.default.Config.inspect(values));
        }
        var result = Object.assign(new ErrorInfo(message, code, statusCode), values);
        if (result.code && !result.href) {
            result.href = 'https://help.ably.io/error/' + result.code;
        }
        return result;
    };
    return ErrorInfo;
}(Error));
exports.default = ErrorInfo;
var PartialErrorInfo = /** @class */ (function (_super) {
    tslib_1.__extends(PartialErrorInfo, _super);
    function PartialErrorInfo(message, code, statusCode, cause) {
        var _this = _super.call(this, message) || this;
        if (typeof Object.setPrototypeOf !== 'undefined') {
            Object.setPrototypeOf(_this, PartialErrorInfo.prototype);
        }
        _this.code = code;
        _this.statusCode = statusCode;
        _this.cause = cause;
        return _this;
    }
    PartialErrorInfo.prototype.toString = function () {
        return toString(this);
    };
    return PartialErrorInfo;
}(Error));
exports.PartialErrorInfo = PartialErrorInfo;


/***/ }),
/* 5 */
/***/ (function(module, exports, __nested_webpack_require_47756__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_47756__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));

/***/ }),
/* 6 */
/***/ (function(module, exports, __nested_webpack_require_49894__) {

/* WEBPACK VAR INJECTION */(function(global) {;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof global !== 'undefined' && global.crypto) {
	        crypto = global.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __nested_webpack_require_49894__(44);
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_49894__(13)))

/***/ }),
/* 7 */
/***/ (function(module, exports, __nested_webpack_require_73260__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_73260__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_73260__(1));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_73260__(2));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_73260__(3));
/* Call the listener, catch any exceptions and log, but continue operation*/
function callListener(eventThis, listener, args) {
    try {
        listener.apply(eventThis, args);
    }
    catch (e) {
        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'EventEmitter.emit()', 'Unexpected listener exception: ' + e + '; stack = ' + (e && e.stack));
    }
}
/**
 * Remove listeners that match listener
 * @param targetListeners is an array of listener arrays or event objects with arrays of listeners
 * @param listener the listener callback to remove
 * @param eventFilter (optional) event name instructing the function to only remove listeners for the specified event
 */
function removeListener(targetListeners, listener, eventFilter) {
    var listeners;
    var index;
    var eventName;
    for (var targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {
        listeners = targetListeners[targetListenersIndex];
        if (eventFilter) {
            listeners = listeners[eventFilter];
        }
        if (Utils.isArray(listeners)) {
            while ((index = Utils.arrIndexOf(listeners, listener)) !== -1) {
                listeners.splice(index, 1);
            }
            /* If events object has an event name key with no listeners then
                          remove the key to stop the list growing indefinitely */
            if (eventFilter && listeners.length === 0) {
                delete targetListeners[targetListenersIndex][eventFilter];
            }
        }
        else if (Utils.isObject(listeners)) {
            /* events */
            for (eventName in listeners) {
                if (Object.prototype.hasOwnProperty.call(listeners, eventName) && Utils.isArray(listeners[eventName])) {
                    removeListener([listeners], listener, eventName);
                }
            }
        }
    }
}
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        this.any = [];
        this.events = Object.create(null);
        this.anyOnce = [];
        this.eventsOnce = Object.create(null);
    }
    EventEmitter.prototype.on = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            var listener = args[0];
            if (typeof listener === 'function') {
                this.any.push(listener);
            }
            else {
                throw new Error('EventListener.on(): Invalid arguments: ' + platform_1.default.Config.inspect(args));
            }
        }
        if (args.length === 2) {
            var event_1 = args[0], listener_1 = args[1];
            if (typeof listener_1 !== 'function') {
                throw new Error('EventListener.on(): Invalid arguments: ' + platform_1.default.Config.inspect(args));
            }
            if (Utils.isEmptyArg(event_1)) {
                this.any.push(listener_1);
            }
            else if (Utils.isArray(event_1)) {
                event_1.forEach(function (eventName) {
                    _this.on(eventName, listener_1);
                });
            }
            else {
                if (typeof event_1 !== 'string') {
                    throw new Error('EventListener.on(): Invalid arguments: ' + platform_1.default.Config.inspect(args));
                }
                var listeners = this.events[event_1] || (this.events[event_1] = []);
                listeners.push(listener_1);
            }
        }
    };
    EventEmitter.prototype.off = function () {
        var _a;
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length == 0 || (Utils.isEmptyArg(args[0]) && Utils.isEmptyArg(args[1]))) {
            this.any = [];
            this.events = Object.create(null);
            this.anyOnce = [];
            this.eventsOnce = Object.create(null);
            return;
        }
        var firstArg = args[0], secondArg = args[1];
        var listener = null;
        var event = null;
        if (args.length === 1 || !secondArg) {
            if (typeof firstArg === 'function') {
                /* we take this to be the listener and treat the event as "any" .. */
                listener = firstArg;
            }
            else {
                event = firstArg;
            }
            /* ... or we take event to be the actual event name and listener to be all */
        }
        else {
            if (typeof secondArg !== 'function') {
                throw new Error('EventEmitter.off(): invalid arguments:' + platform_1.default.Config.inspect(args));
            }
            _a = [firstArg, secondArg], event = _a[0], listener = _a[1];
        }
        if (listener && Utils.isEmptyArg(event)) {
            removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);
            return;
        }
        if (Utils.isArray(event)) {
            event.forEach(function (eventName) {
                _this.off(eventName, listener);
            });
            return;
        }
        /* "normal" case where event is an actual event */
        if (typeof event !== 'string') {
            throw new Error('EventEmitter.off(): invalid arguments:' + platform_1.default.Config.inspect(args));
        }
        if (listener) {
            removeListener([this.events, this.eventsOnce], listener, event);
        }
        else {
            delete this.events[event];
            delete this.eventsOnce[event];
        }
    };
    /**
     * Get the array of listeners for a given event; excludes once events
     * @param event (optional) the name of the event, or none for 'any'
     * @return array of events, or null if none
     */
    EventEmitter.prototype.listeners = function (event) {
        if (event) {
            var listeners = this.events[event] || [];
            if (this.eventsOnce[event])
                Array.prototype.push.apply(listeners, this.eventsOnce[event]);
            return listeners.length ? listeners : null;
        }
        return this.any.length ? this.any : null;
    };
    /**
     * Emit an event
     * @param event the event name
     * @param args the arguments to pass to the listener
     */
    EventEmitter.prototype.emit = function (event) {
        var args = []; /* , args... */
        for (var _i = 1 /* , args... */; _i < arguments.length /* , args... */; _i++ /* , args... */) {
            args[_i - 1] = arguments[_i]; /* , args... */
        }
        var eventThis = { event: event };
        var listeners = [];
        if (this.anyOnce.length) {
            Array.prototype.push.apply(listeners, this.anyOnce);
            this.anyOnce = [];
        }
        if (this.any.length) {
            Array.prototype.push.apply(listeners, this.any);
        }
        var eventsOnceListeners = this.eventsOnce[event];
        if (eventsOnceListeners) {
            Array.prototype.push.apply(listeners, eventsOnceListeners);
            delete this.eventsOnce[event];
        }
        var eventsListeners = this.events[event];
        if (eventsListeners) {
            Array.prototype.push.apply(listeners, eventsListeners);
        }
        Utils.arrForEach(listeners, function (listener) {
            callListener(eventThis, listener, args);
        });
    };
    EventEmitter.prototype.once = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var argCount = args.length;
        if ((argCount === 0 || (argCount === 1 && typeof args[0] !== 'function')) && platform_1.default.Config.Promise) {
            var event_2 = args[0];
            return new platform_1.default.Config.Promise(function (resolve) {
                _this.once(event_2, resolve);
            });
        }
        var firstArg = args[0], secondArg = args[1];
        if (args.length === 1 && typeof firstArg === 'function') {
            this.anyOnce.push(firstArg);
        }
        else if (Utils.isEmptyArg(firstArg)) {
            if (typeof secondArg !== 'function') {
                throw new Error('EventEmitter.once(): Invalid arguments:' + platform_1.default.Config.inspect(args));
            }
            this.anyOnce.push(secondArg);
        }
        else if (Utils.isArray(firstArg)) {
            var self_1 = this;
            var listenerWrapper_1 = function () {
                var innerArgs = Array.prototype.slice.call(arguments);
                Utils.arrForEach(firstArg, function (eventName) {
                    self_1.off(eventName, listenerWrapper_1);
                });
                if (typeof secondArg !== 'function') {
                    throw new Error('EventEmitter.once(): Invalid arguments:' + platform_1.default.Config.inspect(args));
                }
                secondArg.apply(this, innerArgs);
            };
            Utils.arrForEach(firstArg, function (eventName) {
                self_1.on(eventName, listenerWrapper_1);
            });
        }
        else {
            if (typeof firstArg !== 'string') {
                throw new Error('EventEmitter.once(): Invalid arguments:' + platform_1.default.Config.inspect(args));
            }
            var listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);
            if (secondArg) {
                if (typeof secondArg !== 'function') {
                    throw new Error('EventEmitter.once(): Invalid arguments:' + platform_1.default.Config.inspect(args));
                }
                listeners.push(secondArg);
            }
        }
    };
    /**
     * Private API
     *
     * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState
     * @param targetState the name of the state event to listen to
     * @param currentState the name of the current state of this object
     * @param listener the listener to be called
     * @param listenerArgs
     */
    EventEmitter.prototype.whenState = function (targetState, currentState, listener) {
        var _this = this;
        var listenerArgs = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            listenerArgs[_i - 3] = arguments[_i];
        }
        var eventThis = { event: targetState };
        if (typeof targetState !== 'string' || typeof currentState !== 'string') {
            throw 'whenState requires a valid event String argument';
        }
        if (typeof listener !== 'function' && platform_1.default.Config.Promise) {
            return new platform_1.default.Config.Promise(function (resolve) {
                EventEmitter.prototype.whenState.apply(_this, [targetState, currentState, resolve].concat(listenerArgs));
            });
        }
        if (targetState === currentState) {
            callListener(eventThis, listener, listenerArgs);
        }
        else {
            this.once(targetState, listener);
        }
    };
    return EventEmitter;
}());
exports.default = EventEmitter;


/***/ }),
/* 8 */
/***/ (function(module, exports, __nested_webpack_require_84856__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaults = exports.normaliseOptions = exports.objectifyOptions = exports.getAgentString = exports.getHosts = exports.getFallbackHosts = exports.environmentFallbackHosts = exports.getHttpScheme = exports.getPort = exports.getHost = void 0;
var tslib_1 = __nested_webpack_require_84856__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_84856__(3));
var Utils = tslib_1.__importStar(__nested_webpack_require_84856__(1));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_84856__(2));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_84856__(4));
var package_json_1 = __nested_webpack_require_84856__(43);
var agent = 'ably-js/' + package_json_1.version;
var Defaults = {
    ENVIRONMENT: '',
    REST_HOST: 'rest.ably.io',
    REALTIME_HOST: 'realtime.ably.io',
    FALLBACK_HOSTS: [
        'A.ably-realtime.com',
        'B.ably-realtime.com',
        'C.ably-realtime.com',
        'D.ably-realtime.com',
        'E.ably-realtime.com',
    ],
    PORT: 80,
    TLS_PORT: 443,
    TIMEOUTS: {
        /* Documented as options params: */
        disconnectedRetryTimeout: 15000,
        suspendedRetryTimeout: 30000,
        /* Undocumented, but part of the api and can be used by customers: */
        httpRequestTimeout: 15000,
        channelRetryTimeout: 15000,
        fallbackRetryTimeout: 600000,
        /* For internal / test use only: */
        connectionStateTtl: 120000,
        realtimeRequestTimeout: 10000,
        recvTimeout: 90000,
        preferenceConnectTimeout: 6000,
        parallelUpgradeDelay: 6000,
    },
    httpMaxRetryCount: 3,
    maxMessageSize: 65536,
    version: package_json_1.version,
    protocolVersion: 2,
    agent: agent,
    getHost: getHost,
    getPort: getPort,
    getHttpScheme: getHttpScheme,
    environmentFallbackHosts: environmentFallbackHosts,
    getFallbackHosts: getFallbackHosts,
    getHosts: getHosts,
    checkHost: checkHost,
    objectifyOptions: objectifyOptions,
    normaliseOptions: normaliseOptions,
};
function getHost(options, host, ws) {
    if (ws)
        host = (host == options.restHost && options.realtimeHost) || host || options.realtimeHost;
    else
        host = host || options.restHost;
    return host;
}
exports.getHost = getHost;
function getPort(options, tls) {
    return tls || options.tls ? options.tlsPort : options.port;
}
exports.getPort = getPort;
function getHttpScheme(options) {
    return options.tls ? 'https://' : 'http://';
}
exports.getHttpScheme = getHttpScheme;
// construct environment fallback hosts as per RSC15i
function environmentFallbackHosts(environment) {
    return [
        environment + '-a-fallback.ably-realtime.com',
        environment + '-b-fallback.ably-realtime.com',
        environment + '-c-fallback.ably-realtime.com',
        environment + '-d-fallback.ably-realtime.com',
        environment + '-e-fallback.ably-realtime.com',
    ];
}
exports.environmentFallbackHosts = environmentFallbackHosts;
function getFallbackHosts(options) {
    var fallbackHosts = options.fallbackHosts, httpMaxRetryCount = typeof options.httpMaxRetryCount !== 'undefined' ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;
    return fallbackHosts ? Utils.arrChooseN(fallbackHosts, httpMaxRetryCount) : [];
}
exports.getFallbackHosts = getFallbackHosts;
function getHosts(options) {
    return [options.restHost].concat(getFallbackHosts(options));
}
exports.getHosts = getHosts;
function checkHost(host) {
    if (typeof host !== 'string') {
        throw new errorinfo_1.default('host must be a string; was a ' + typeof host, 40000, 400);
    }
    if (!host.length) {
        throw new errorinfo_1.default('host must not be zero-length', 40000, 400);
    }
}
function getRealtimeHost(options, production, environment) {
    if (options.realtimeHost)
        return options.realtimeHost;
    /* prefer setting realtimeHost to restHost as a custom restHost typically indicates
     * a development environment is being used that can't be inferred by the library */
    if (options.restHost) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Defaults.normaliseOptions', 'restHost is set to "' +
            options.restHost +
            '" but realtimeHost is not set, so setting realtimeHost to "' +
            options.restHost +
            '" too. If this is not what you want, please set realtimeHost explicitly.');
        return options.restHost;
    }
    return production ? Defaults.REALTIME_HOST : environment + '-' + Defaults.REALTIME_HOST;
}
function getTimeouts(options) {
    /* Allow values passed in options to override default timeouts */
    var timeouts = {};
    for (var prop in Defaults.TIMEOUTS) {
        timeouts[prop] = options[prop] || Defaults.TIMEOUTS[prop];
    }
    return timeouts;
}
function getAgentString(options) {
    var agentStr = Defaults.agent;
    if (options.agents) {
        for (var agent in options.agents) {
            agentStr += ' ' + agent + '/' + options.agents[agent];
        }
    }
    return agentStr;
}
exports.getAgentString = getAgentString;
function objectifyOptions(options) {
    if (typeof options == 'string') {
        return options.indexOf(':') == -1 ? { token: options } : { key: options };
    }
    return options;
}
exports.objectifyOptions = objectifyOptions;
function normaliseOptions(options) {
    /* Deprecated options */
    if (options.host) {
        logger_1.default.deprecated('host', 'restHost');
        options.restHost = options.host;
    }
    if (options.wsHost) {
        logger_1.default.deprecated('wsHost', 'realtimeHost');
        options.realtimeHost = options.wsHost;
    }
    if (options.queueEvents) {
        logger_1.default.deprecated('queueEvents', 'queueMessages');
        options.queueMessages = options.queueEvents;
    }
    if (options.fallbackHostsUseDefault) {
        /* fallbackHostsUseDefault and fallbackHosts are mutually exclusive as per TO3k7 */
        if (options.fallbackHosts) {
            var msg = 'fallbackHosts and fallbackHostsUseDefault cannot both be set';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Defaults.normaliseOptions', msg);
            throw new errorinfo_1.default(msg, 40000, 400);
        }
        /* default fallbacks can't be used with custom ports */
        if (options.port || options.tlsPort) {
            var msg = 'fallbackHostsUseDefault cannot be set when port or tlsPort are set';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Defaults.normaliseOptions', msg);
            throw new errorinfo_1.default(msg, 40000, 400);
        }
        /* emit an appropriate deprecation warning */
        if (options.environment) {
            logger_1.default.deprecatedWithMsg('fallbackHostsUseDefault', 'There is no longer a need to set this when the environment option is also set since the library will now generate the correct fallback hosts using the environment option.');
        }
        else {
            logger_1.default.deprecated('fallbackHostsUseDefault', 'fallbackHosts: Ably.Defaults.FALLBACK_HOSTS');
        }
        /* use the default fallback hosts as requested */
        options.fallbackHosts = Defaults.FALLBACK_HOSTS;
    }
    /* options.recover as a boolean is deprecated, and therefore is not part of the public typing */
    if (options.recover === true) {
        logger_1.default.deprecated('{recover: true}', '{recover: function(lastConnectionDetails, cb) { cb(true); }}');
        options.recover = function (lastConnectionDetails, cb) {
            cb(true);
        };
    }
    if (typeof options.recover === 'function' && options.closeOnUnload === true) {
        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Defaults.normaliseOptions', 'closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter');
        options.recover = undefined;
    }
    if (!('closeOnUnload' in options)) {
        /* Have closeOnUnload default to true unless we have any indication that
         * the user may want to recover the connection */
        options.closeOnUnload = !options.recover;
    }
    if (options.transports && Utils.arrIn(options.transports, 'xhr')) {
        logger_1.default.deprecated('transports: ["xhr"]', 'transports: ["xhr_streaming"]');
        Utils.arrDeleteValue(options.transports, 'xhr');
        options.transports.push('xhr_streaming');
    }
    if (!('queueMessages' in options))
        options.queueMessages = true;
    /* infer hosts and fallbacks based on the configured environment */
    var environment = (options.environment && String(options.environment).toLowerCase()) || Defaults.ENVIRONMENT;
    var production = !environment || environment === 'production';
    if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {
        options.fallbackHosts = production ? Defaults.FALLBACK_HOSTS : environmentFallbackHosts(environment);
    }
    var restHost = options.restHost || (production ? Defaults.REST_HOST : environment + '-' + Defaults.REST_HOST);
    var realtimeHost = getRealtimeHost(options, production, environment);
    Utils.arrForEach((options.fallbackHosts || []).concat(restHost, realtimeHost), checkHost);
    options.port = options.port || Defaults.PORT;
    options.tlsPort = options.tlsPort || Defaults.TLS_PORT;
    if (!('tls' in options))
        options.tls = true;
    var timeouts = getTimeouts(options);
    if ('useBinaryProtocol' in options) {
        options.useBinaryProtocol = platform_1.default.Config.supportsBinary && options.useBinaryProtocol;
    }
    else {
        options.useBinaryProtocol = platform_1.default.Config.preferBinary;
    }
    if (options.clientId) {
        var headers = (options.headers = options.headers || {});
        headers['X-Ably-ClientId'] = platform_1.default.BufferUtils.base64Encode(platform_1.default.BufferUtils.utf8Encode(options.clientId));
    }
    if (!('idempotentRestPublishing' in options)) {
        options.idempotentRestPublishing = true;
    }
    if (options.promises && !platform_1.default.Config.Promise) {
        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Defaults.normaliseOptions', '{promises: true} was specified, but no Promise constructor found; disabling promises');
        options.promises = false;
    }
    var connectivityCheckParams = null;
    var connectivityCheckUrl = options.connectivityCheckUrl;
    if (options.connectivityCheckUrl) {
        var _a = options.connectivityCheckUrl.split('?'), uri = _a[0], qs = _a[1];
        connectivityCheckParams = qs ? Utils.parseQueryString(qs) : {};
        if (uri.indexOf('://') === -1) {
            uri = 'https://' + uri;
        }
        connectivityCheckUrl = uri;
    }
    return tslib_1.__assign(tslib_1.__assign({}, options), { useBinaryProtocol: 'useBinaryProtocol' in options
            ? platform_1.default.Config.supportsBinary && options.useBinaryProtocol
            : platform_1.default.Config.preferBinary, realtimeHost: realtimeHost, restHost: restHost, maxMessageSize: options.maxMessageSize || Defaults.maxMessageSize, timeouts: timeouts, connectivityCheckParams: connectivityCheckParams, connectivityCheckUrl: connectivityCheckUrl });
}
exports.normaliseOptions = normaliseOptions;
exports.default = Defaults;
function getDefaults(platformDefaults) {
    return Object.assign(Defaults, platformDefaults);
}
exports.getDefaults = getDefaults;


/***/ }),
/* 9 */
/***/ (function(module, exports, __nested_webpack_require_96442__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_96442__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_96442__(3));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_96442__(2));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_96442__(4));
var Utils = tslib_1.__importStar(__nested_webpack_require_96442__(1));
function normaliseContext(context) {
    if (!context || !context.channelOptions) {
        return {
            channelOptions: context,
            plugins: {},
            baseEncodedPreviousPayload: undefined,
        };
    }
    return context;
}
function normalizeCipherOptions(options) {
    if (options && options.cipher) {
        if (!platform_1.default.Crypto)
            throw new Error('Encryption not enabled; use ably.encryption.js instead');
        var cipher = platform_1.default.Crypto.getCipher(options.cipher);
        return {
            cipher: cipher.cipherParams,
            channelCipher: cipher.cipher,
        };
    }
    return options !== null && options !== void 0 ? options : {};
}
function getMessageSize(msg) {
    var size = 0;
    if (msg.name) {
        size += msg.name.length;
    }
    if (msg.clientId) {
        size += msg.clientId.length;
    }
    if (msg.extras) {
        size += JSON.stringify(msg.extras).length;
    }
    if (msg.data) {
        size += Utils.dataSizeBytes(msg.data);
    }
    return size;
}
var Message = /** @class */ (function () {
    function Message() {
    }
    /**
     * Overload toJSON() to intercept JSON.stringify()
     * @return {*}
     */
    Message.prototype.toJSON = function () {
        /* encode data to base64 if present and we're returning real JSON;
         * although msgpack calls toJSON(), we know it is a stringify()
         * call if it has a non-empty arguments list */
        var encoding = this.encoding;
        var data = this.data;
        if (data && platform_1.default.BufferUtils.isBuffer(data)) {
            if (arguments.length > 0) {
                /* stringify call */
                encoding = encoding ? encoding + '/base64' : 'base64';
                data = platform_1.default.BufferUtils.base64Encode(data);
            }
            else {
                /* Called by msgpack. toBuffer returns a datatype understandable by
                 * that platform's msgpack implementation (Buffer in node, Uint8Array
                 * in browsers) */
                data = platform_1.default.BufferUtils.toBuffer(data);
            }
        }
        return {
            name: this.name,
            id: this.id,
            clientId: this.clientId,
            connectionId: this.connectionId,
            connectionKey: this.connectionKey,
            extras: this.extras,
            encoding: encoding,
            data: data,
        };
    };
    Message.prototype.toString = function () {
        var result = '[Message';
        if (this.name)
            result += '; name=' + this.name;
        if (this.id)
            result += '; id=' + this.id;
        if (this.timestamp)
            result += '; timestamp=' + this.timestamp;
        if (this.clientId)
            result += '; clientId=' + this.clientId;
        if (this.connectionId)
            result += '; connectionId=' + this.connectionId;
        if (this.encoding)
            result += '; encoding=' + this.encoding;
        if (this.extras)
            result += '; extras =' + JSON.stringify(this.extras);
        if (this.data) {
            if (typeof this.data == 'string')
                result += '; data=' + this.data;
            else if (platform_1.default.BufferUtils.isBuffer(this.data))
                result += '; data (buffer)=' + platform_1.default.BufferUtils.base64Encode(this.data);
            else
                result += '; data (json)=' + JSON.stringify(this.data);
        }
        if (this.extras)
            result += '; extras=' + JSON.stringify(this.extras);
        result += ']';
        return result;
    };
    Message.encrypt = function (msg, options, callback) {
        var data = msg.data, encoding = msg.encoding, cipher = options.channelCipher;
        encoding = encoding ? encoding + '/' : '';
        if (!platform_1.default.BufferUtils.isBuffer(data)) {
            data = platform_1.default.BufferUtils.utf8Encode(String(data));
            encoding = encoding + 'utf-8/';
        }
        cipher.encrypt(data, function (err, data) {
            if (err) {
                callback(err);
                return;
            }
            msg.data = data;
            msg.encoding = encoding + 'cipher+' + cipher.algorithm;
            callback(null, msg);
        });
    };
    Message.encode = function (msg, options, callback) {
        var data = msg.data;
        var nativeDataType = typeof data == 'string' || platform_1.default.BufferUtils.isBuffer(data) || data === null || data === undefined;
        if (!nativeDataType) {
            if (Utils.isObject(data) || Utils.isArray(data)) {
                msg.data = JSON.stringify(data);
                msg.encoding = msg.encoding ? msg.encoding + '/json' : 'json';
            }
            else {
                throw new errorinfo_1.default('Data type is unsupported', 40013, 400);
            }
        }
        if (options != null && options.cipher) {
            Message.encrypt(msg, options, callback);
        }
        else {
            callback(null, msg);
        }
    };
    Message.encodeArray = function (messages, options, callback) {
        var processed = 0;
        for (var i = 0; i < messages.length; i++) {
            Message.encode(messages[i], options, function (err) {
                if (err) {
                    callback(err);
                    return;
                }
                processed++;
                if (processed == messages.length) {
                    callback(null, messages);
                }
            });
        }
    };
    Message.decode = function (message, inputContext) {
        var context = normaliseContext(inputContext);
        var lastPayload = message.data;
        var encoding = message.encoding;
        if (encoding) {
            var xforms = encoding.split('/');
            var lastProcessedEncodingIndex = void 0, encodingsToProcess = xforms.length, data = message.data;
            var xform = '';
            try {
                while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {
                    // eslint-disable-next-line security/detect-unsafe-regex
                    var match = xforms[--encodingsToProcess].match(/([-\w]+)(\+([\w-]+))?/);
                    if (!match)
                        break;
                    xform = match[1];
                    switch (xform) {
                        case 'base64':
                            data = platform_1.default.BufferUtils.base64Decode(String(data));
                            if (lastProcessedEncodingIndex == xforms.length) {
                                lastPayload = data;
                            }
                            continue;
                        case 'utf-8':
                            data = platform_1.default.BufferUtils.utf8Decode(data);
                            continue;
                        case 'json':
                            data = JSON.parse(data);
                            continue;
                        case 'cipher':
                            if (context.channelOptions != null &&
                                context.channelOptions.cipher &&
                                context.channelOptions.channelCipher) {
                                var xformAlgorithm = match[3], cipher = context.channelOptions.channelCipher;
                                /* don't attempt to decrypt unless the cipher params are compatible */
                                if (xformAlgorithm != cipher.algorithm) {
                                    throw new Error('Unable to decrypt message with given cipher; incompatible cipher params');
                                }
                                data = cipher.decrypt(data);
                                continue;
                            }
                            else {
                                throw new Error('Unable to decrypt message; not an encrypted channel');
                            }
                        case 'vcdiff':
                            if (!context.plugins || !context.plugins.vcdiff) {
                                throw new errorinfo_1.default('Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)', 40019, 400);
                            }
                            if (typeof Uint8Array === 'undefined') {
                                throw new errorinfo_1.default('Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)', 40020, 400);
                            }
                            try {
                                var deltaBase = context.baseEncodedPreviousPayload;
                                if (typeof deltaBase === 'string') {
                                    deltaBase = platform_1.default.BufferUtils.utf8Encode(deltaBase);
                                }
                                /* vcdiff expects Uint8Arrays, can't copy with ArrayBuffers. (also, if we
                                 * don't have a TextDecoder, deltaBase might be a WordArray here, so need
                                 * to process it into a buffer anyway) */
                                deltaBase = platform_1.default.BufferUtils.toBuffer(deltaBase);
                                data = platform_1.default.BufferUtils.toBuffer(data);
                                data = platform_1.default.BufferUtils.typedArrayToBuffer(context.plugins.vcdiff.decode(data, deltaBase));
                                lastPayload = data;
                            }
                            catch (e) {
                                throw new errorinfo_1.default('Vcdiff delta decode failed with ' + e, 40018, 400);
                            }
                            continue;
                        default:
                            throw new Error('Unknown encoding');
                    }
                }
            }
            catch (e) {
                var err = e;
                throw new errorinfo_1.default('Error processing the ' + xform + ' encoding, decoder returned â€˜' + err.message + 'â€™', err.code || 40013, 400);
            }
            finally {
                message.encoding =
                    lastProcessedEncodingIndex <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join('/');
                message.data = data;
            }
        }
        context.baseEncodedPreviousPayload = lastPayload;
    };
    Message.fromResponseBody = function (body, options, format) {
        if (format) {
            body = Utils.decodeBody(body, format);
        }
        for (var i = 0; i < body.length; i++) {
            var msg = (body[i] = Message.fromValues(body[i]));
            try {
                Message.decode(msg, options);
            }
            catch (e) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Message.fromResponseBody()', e.toString());
            }
        }
        return body;
    };
    Message.fromValues = function (values) {
        return Object.assign(new Message(), values);
    };
    Message.fromValuesArray = function (values) {
        var count = values.length, result = new Array(count);
        for (var i = 0; i < count; i++)
            result[i] = Message.fromValues(values[i]);
        return result;
    };
    Message.fromEncoded = function (encoded, inputOptions) {
        var msg = Message.fromValues(encoded);
        var options = normalizeCipherOptions(inputOptions !== null && inputOptions !== void 0 ? inputOptions : null);
        /* if decoding fails at any point, catch and return the message decoded to
         * the fullest extent possible */
        try {
            Message.decode(msg, options);
        }
        catch (e) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Message.fromEncoded()', e.toString());
        }
        return msg;
    };
    Message.fromEncodedArray = function (encodedArray, options) {
        return encodedArray.map(function (encoded) {
            return Message.fromEncoded(encoded, options);
        });
    };
    /* This should be called on encode()d (and encrypt()d) Messages (as it
     * assumes the data is a string or buffer) */
    Message.getMessagesSize = function (messages) {
        var msg, total = 0;
        for (var i = 0; i < messages.length; i++) {
            msg = messages[i];
            total += msg.size || (msg.size = getMessageSize(msg));
        }
        return total;
    };
    Message.serialize = Utils.encodeBody;
    return Message;
}());
exports.default = Message;


/***/ }),
/* 10 */
/***/ (function(module, exports, __nested_webpack_require_109505__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_109505__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_109505__(1));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_109505__(4));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_109505__(9));
var presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_109505__(15));
var actions = {
    HEARTBEAT: 0,
    ACK: 1,
    NACK: 2,
    CONNECT: 3,
    CONNECTED: 4,
    DISCONNECT: 5,
    DISCONNECTED: 6,
    CLOSE: 7,
    CLOSED: 8,
    ERROR: 9,
    ATTACH: 10,
    ATTACHED: 11,
    DETACH: 12,
    DETACHED: 13,
    PRESENCE: 14,
    MESSAGE: 15,
    SYNC: 16,
    AUTH: 17,
    ACTIVATE: 18,
};
var ActionName = [];
Object.keys(actions).forEach(function (name) {
    ActionName[actions[name]] = name;
});
var flags = {
    /* Channel attach state flags */
    HAS_PRESENCE: 1 << 0,
    HAS_BACKLOG: 1 << 1,
    RESUMED: 1 << 2,
    TRANSIENT: 1 << 4,
    ATTACH_RESUME: 1 << 5,
    /* Channel mode flags */
    PRESENCE: 1 << 16,
    PUBLISH: 1 << 17,
    SUBSCRIBE: 1 << 18,
    PRESENCE_SUBSCRIBE: 1 << 19,
};
var flagNames = Object.keys(flags);
flags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;
function toStringArray(array) {
    var result = [];
    if (array) {
        for (var i = 0; i < array.length; i++) {
            result.push(array[i].toString());
        }
    }
    return '[ ' + result.join(', ') + ' ]';
}
var simpleAttributes = 'id channel channelSerial connectionId count msgSerial timestamp'.split(' ');
var ProtocolMessage = /** @class */ (function () {
    function ProtocolMessage() {
        var _this = this;
        this.hasFlag = function (flag) {
            return (_this.flags & flags[flag]) > 0;
        };
    }
    ProtocolMessage.prototype.setFlag = function (flag) {
        return (this.flags = this.flags | flags[flag]);
    };
    ProtocolMessage.prototype.getMode = function () {
        return this.flags && this.flags & flags.MODE_ALL;
    };
    ProtocolMessage.prototype.encodeModesToFlags = function (modes) {
        var _this = this;
        modes.forEach(function (mode) { return _this.setFlag(mode); });
    };
    ProtocolMessage.prototype.decodeModesFromFlags = function () {
        var _this = this;
        var modes = [];
        ProtocolMessage.channelModes.forEach(function (mode) {
            if (_this.hasFlag(mode)) {
                modes.push(mode);
            }
        });
        return modes.length > 0 ? modes : undefined;
    };
    ProtocolMessage.fromValues = function (values) {
        return Object.assign(new ProtocolMessage(), values);
    };
    ProtocolMessage.Action = actions;
    ProtocolMessage.channelModes = ['PRESENCE', 'PUBLISH', 'SUBSCRIBE', 'PRESENCE_SUBSCRIBE'];
    ProtocolMessage.ActionName = ActionName;
    ProtocolMessage.serialize = Utils.encodeBody;
    ProtocolMessage.deserialize = function (serialized, format) {
        var deserialized = Utils.decodeBody(serialized, format);
        return ProtocolMessage.fromDeserialized(deserialized);
    };
    ProtocolMessage.fromDeserialized = function (deserialized) {
        var error = deserialized.error;
        if (error)
            deserialized.error = errorinfo_1.default.fromValues(error);
        var messages = deserialized.messages;
        if (messages)
            for (var i = 0; i < messages.length; i++)
                messages[i] = message_1.default.fromValues(messages[i]);
        var presence = deserialized.presence;
        if (presence)
            for (var i = 0; i < presence.length; i++)
                presence[i] = presencemessage_1.default.fromValues(presence[i], true);
        return Object.assign(new ProtocolMessage(), deserialized);
    };
    ProtocolMessage.stringify = function (msg) {
        var result = '[ProtocolMessage';
        if (msg.action !== undefined)
            result += '; action=' + ProtocolMessage.ActionName[msg.action] || 0;
        var attribute;
        for (var attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {
            attribute = simpleAttributes[attribIndex];
            if (msg[attribute] !== undefined)
                result += '; ' + attribute + '=' + msg[attribute];
        }
        if (msg.messages)
            result += '; messages=' + toStringArray(message_1.default.fromValuesArray(msg.messages));
        if (msg.presence)
            result += '; presence=' + toStringArray(presencemessage_1.default.fromValuesArray(msg.presence));
        if (msg.error)
            result += '; error=' + errorinfo_1.default.fromValues(msg.error).toString();
        if (msg.auth && msg.auth.accessToken)
            result += '; token=' + msg.auth.accessToken;
        if (msg.flags)
            result += '; flags=' + flagNames.filter(msg.hasFlag).join(',');
        if (msg.params) {
            var stringifiedParams_1 = '';
            Utils.forInOwnNonNullProperties(msg.params, function (prop) {
                if (stringifiedParams_1.length > 0) {
                    stringifiedParams_1 += '; ';
                }
                stringifiedParams_1 += prop + '=' + msg.params[prop];
            });
            if (stringifiedParams_1.length > 0) {
                result += '; params=[' + stringifiedParams_1 + ']';
            }
        }
        result += ']';
        return result;
    };
    return ProtocolMessage;
}());
exports.default = ProtocolMessage;


/***/ }),
/* 11 */
/***/ (function(module, exports, __nested_webpack_require_115059__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_115059__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        }
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              var bitsCombined = bits1 | bits2;
	              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),
/* 12 */
/***/ (function(module, exports, __nested_webpack_require_119082__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_119082__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_119082__(1));
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(10));
var transport_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(26));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(2));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(8));
var connectionerrors_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(20));
var auth_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(17));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(4));
var XHRStates_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(21));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_119082__(3));
/* TODO: can remove once realtime sends protocol message responses for comet errors */
function shouldBeErrorAction(err) {
    var UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];
    if (err.code) {
        if (auth_1.default.isTokenErr(err))
            return false;
        if (Utils.arrIn(UNRESOLVABLE_ERROR_CODES, err.code))
            return true;
        return err.code >= 40000 && err.code < 50000;
    }
    else {
        /* Likely a network or transport error of some kind. Certainly not fatal to the connection */
        return false;
    }
}
function protocolMessageFromRawError(err) {
    /* err will be either a legacy (non-protocolmessage) comet error response
     * (which will have an err.code), or a xhr/network error (which won't). */
    if (shouldBeErrorAction(err)) {
        return [protocolmessage_1.default.fromValues({ action: protocolmessage_1.default.Action.ERROR, error: err })];
    }
    else {
        return [protocolmessage_1.default.fromValues({ action: protocolmessage_1.default.Action.DISCONNECTED, error: err })];
    }
}
/*
 * A base comet transport class
 */
var CometTransport = /** @class */ (function (_super) {
    tslib_1.__extends(CometTransport, _super);
    function CometTransport(connectionManager, auth, params) {
        var _this = _super.call(this, connectionManager, auth, params, /* binary not supported for comet so force JSON protocol */ true) || this;
        /* For comet, we could do the auth update by aborting the current recv and
         * starting a new one with the new token, that'd be sufficient for realtime.
         * Problem is JSONP - you can't cancel truly abort a recv once started. So
         * we need to send an AUTH for jsonp. In which case it's simpler to keep all
         * comet transports the same and do it for all of them. So we send the AUTH
         * instead, and don't need to abort the recv */
        _this.onAuthUpdated = function (tokenDetails) {
            _this.authParams = { access_token: tokenDetails.token };
        };
        _this.stream = 'stream' in params ? params.stream : true;
        _this.sendRequest = null;
        _this.recvRequest = null;
        _this.pendingCallback = null;
        _this.pendingItems = null;
        return _this;
    }
    CometTransport.prototype.connect = function () {
        var _this = this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.connect()', 'starting');
        transport_1.default.prototype.connect.call(this);
        var params = this.params;
        var options = params.options;
        var host = defaults_1.default.getHost(options, params.host);
        var port = defaults_1.default.getPort(options);
        var cometScheme = options.tls ? 'https://' : 'http://';
        this.baseUri = cometScheme + host + ':' + port + '/comet/';
        var connectUri = this.baseUri + 'connect';
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.connect()', 'uri: ' + connectUri);
        this.auth.getAuthParams(function (err, authParams) {
            if (err) {
                _this.disconnect(err);
                return;
            }
            if (_this.isDisposed) {
                return;
            }
            _this.authParams = authParams;
            var connectParams = _this.params.getConnectParams(authParams);
            if ('stream' in connectParams)
                _this.stream = connectParams.stream;
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.connect()', 'connectParams:' + Utils.toQueryString(connectParams));
            /* this will be the 'recvRequest' so this connection can stream messages */
            var preconnected = false;
            var connectRequest = (_this.recvRequest = _this.createRequest(connectUri, null, connectParams, null, _this.stream ? XHRStates_1.default.REQ_RECV_STREAM : XHRStates_1.default.REQ_RECV));
            connectRequest.on('data', function (data) {
                if (!_this.recvRequest) {
                    /* the transport was disposed before we connected */
                    return;
                }
                if (!preconnected) {
                    preconnected = true;
                    _this.emit('preconnect');
                }
                _this.onData(data);
            });
            connectRequest.on('complete', function (err) {
                if (!_this.recvRequest) {
                    /* the transport was disposed before we connected */
                    err = err || new errorinfo_1.default('Request cancelled', 80003, 400);
                }
                _this.recvRequest = null;
                /* Connect request may complete without a emitting 'data' event since that is not
                 * emitted for e.g. a non-streamed error response. Still implies preconnect. */
                if (!preconnected && !err) {
                    preconnected = true;
                    _this.emit('preconnect');
                }
                _this.onActivity();
                if (err) {
                    if (err.code) {
                        /* A protocol error received from realtime. TODO: once realtime
                         * consistendly sends errors wrapped in protocol messages, should be
                         * able to remove this */
                        _this.onData(protocolMessageFromRawError(err));
                    }
                    else {
                        /* A network/xhr error. Don't bother wrapping in a protocol message,
                         * just disconnect the transport */
                        _this.disconnect(err);
                    }
                    return;
                }
                platform_1.default.Config.nextTick(function () {
                    _this.recv();
                });
            });
            connectRequest.exec();
        });
    };
    CometTransport.prototype.requestClose = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.requestClose()');
        this._requestCloseOrDisconnect(true);
    };
    CometTransport.prototype.requestDisconnect = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.requestDisconnect()');
        this._requestCloseOrDisconnect(false);
    };
    CometTransport.prototype._requestCloseOrDisconnect = function (closing) {
        var _this = this;
        var closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;
        if (closeOrDisconnectUri) {
            var request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, XHRStates_1.default.REQ_SEND);
            request.on('complete', function (err) {
                if (err) {
                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'CometTransport.request' + (closing ? 'Close()' : 'Disconnect()'), 'request returned err = ' + Utils.inspectError(err));
                    _this.finish('disconnected', err);
                }
            });
            request.exec();
        }
    };
    CometTransport.prototype.dispose = function () {
        var _this = this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.dispose()', '');
        if (!this.isDisposed) {
            this.isDisposed = true;
            if (this.recvRequest) {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.dispose()', 'aborting recv request');
                this.recvRequest.abort();
                this.recvRequest = null;
            }
            /* In almost all cases the transport will be finished before it's
             * disposed. Finish here just to make sure. */
            this.finish('disconnected', connectionerrors_1.default.disconnected());
            platform_1.default.Config.nextTick(function () {
                _this.emit('disposed');
            });
        }
    };
    CometTransport.prototype.onConnect = function (message) {
        var _a;
        /* if this transport has been disposed whilst awaiting connection, do nothing */
        if (this.isDisposed) {
            return;
        }
        /* the connectionKey in a comet connected response is really
         * <instId>-<connectionKey> */
        var connectionStr = (_a = message.connectionDetails) === null || _a === void 0 ? void 0 : _a.connectionKey;
        transport_1.default.prototype.onConnect.call(this, message);
        var baseConnectionUri = this.baseUri + connectionStr;
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'CometTransport.onConnect()', 'baseUri = ' + baseConnectionUri);
        this.sendUri = baseConnectionUri + '/send';
        this.recvUri = baseConnectionUri + '/recv';
        this.closeUri = baseConnectionUri + '/close';
        this.disconnectUri = baseConnectionUri + '/disconnect';
    };
    CometTransport.prototype.send = function (message) {
        if (this.sendRequest) {
            /* there is a pending send, so queue this message */
            this.pendingItems = this.pendingItems || [];
            this.pendingItems.push(message);
            return;
        }
        /* send this, plus any pending, now */
        var pendingItems = this.pendingItems || [];
        pendingItems.push(message);
        this.pendingItems = null;
        this.sendItems(pendingItems);
    };
    CometTransport.prototype.sendAnyPending = function () {
        var pendingItems = this.pendingItems;
        if (!pendingItems) {
            return;
        }
        this.pendingItems = null;
        this.sendItems(pendingItems);
    };
    CometTransport.prototype.sendItems = function (items) {
        var _this = this;
        var sendRequest = (this.sendRequest = this.createRequest(this.sendUri, null, this.authParams, this.encodeRequest(items), XHRStates_1.default.REQ_SEND));
        sendRequest.on('complete', function (err, data) {
            if (err)
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'CometTransport.sendItems()', 'on complete: err = ' + Utils.inspectError(err));
            _this.sendRequest = null;
            /* the result of the request, even if a nack, is usually a protocol response
             * contained in the data. An err is anomolous, and indicates some issue with the
             * network,transport, or connection */
            if (err) {
                if (err.code) {
                    /* A protocol error received from realtime. TODO: once realtime
                     * consistendly sends errors wrapped in protocol messages, should be
                     * able to remove this */
                    _this.onData(protocolMessageFromRawError(err));
                }
                else {
                    /* A network/xhr error. Don't bother wrapping in a protocol message,
                     * just disconnect the transport */
                    _this.disconnect(err);
                }
                return;
            }
            if (data) {
                _this.onData(data);
            }
            if (_this.pendingItems) {
                platform_1.default.Config.nextTick(function () {
                    /* If there's a new send request by now, any pending items will have
                     * been picked up by that; any new ones added since then will be
                     * picked up after that one completes */
                    if (!_this.sendRequest) {
                        _this.sendAnyPending();
                    }
                });
            }
        });
        sendRequest.exec();
    };
    CometTransport.prototype.recv = function () {
        var _this = this;
        /* do nothing if there is an active request, which might be streaming */
        if (this.recvRequest)
            return;
        /* If we're no longer connected, do nothing */
        if (!this.isConnected)
            return;
        var recvRequest = (this.recvRequest = this.createRequest(this.recvUri, null, this.authParams, null, this.stream ? XHRStates_1.default.REQ_RECV_STREAM : XHRStates_1.default.REQ_RECV_POLL));
        recvRequest.on('data', function (data) {
            _this.onData(data);
        });
        recvRequest.on('complete', function (err) {
            _this.recvRequest = null;
            /* A request completing must be considered activity, as realtime sends
             * heartbeats every 15s since a request began, not every 15s absolutely */
            _this.onActivity();
            if (err) {
                if (err.code) {
                    /* A protocol error received from realtime. TODO: once realtime
                     * consistently sends errors wrapped in protocol messages, should be
                     * able to remove this */
                    _this.onData(protocolMessageFromRawError(err));
                }
                else {
                    /* A network/xhr error. Don't bother wrapping in a protocol message,
                     * just disconnect the transport */
                    _this.disconnect(err);
                }
                return;
            }
            platform_1.default.Config.nextTick(function () {
                _this.recv();
            });
        });
        recvRequest.exec();
    };
    CometTransport.prototype.onData = function (responseData) {
        try {
            var items = this.decodeResponse(responseData);
            if (items && items.length)
                for (var i = 0; i < items.length; i++)
                    this.onProtocolMessage(protocolmessage_1.default.fromDeserialized(items[i]));
        }
        catch (e) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'CometTransport.onData()', 'Unexpected exception handing channel event: ' + e.stack);
        }
    };
    CometTransport.prototype.encodeRequest = function (requestItems) {
        return JSON.stringify(requestItems);
    };
    CometTransport.prototype.decodeResponse = function (responseData) {
        if (typeof responseData == 'string')
            return JSON.parse(responseData);
        return responseData;
    };
    return CometTransport;
}(transport_1.default));
exports.default = CometTransport;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 14 */
/***/ (function(module, exports, __nested_webpack_require_134706__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_134706__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_134706__(3));
var Utils = tslib_1.__importStar(__nested_webpack_require_134706__(1));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_134706__(2));
var auth_1 = tslib_1.__importDefault(__nested_webpack_require_134706__(17));
var HttpMethods_1 = tslib_1.__importDefault(__nested_webpack_require_134706__(18));
var errorinfo_1 = __nested_webpack_require_134706__(4);
function withAuthDetails(rest, headers, params, errCallback, opCallback) {
    if (rest.http.supportsAuthHeaders) {
        rest.auth.getAuthHeaders(function (err, authHeaders) {
            if (err)
                errCallback(err);
            else
                opCallback(Utils.mixin(authHeaders, headers), params);
        });
    }
    else {
        rest.auth.getAuthParams(function (err, authParams) {
            if (err)
                errCallback(err);
            else
                opCallback(headers, Utils.mixin(authParams, params));
        });
    }
}
function unenvelope(callback, format) {
    return function (err, body, outerHeaders, unpacked, outerStatusCode) {
        if (err && !body) {
            callback(err);
            return;
        }
        if (!unpacked) {
            try {
                body = Utils.decodeBody(body, format);
            }
            catch (e) {
                if (Utils.isErrorInfoOrPartialErrorInfo(e)) {
                    callback(e);
                }
                else {
                    callback(new errorinfo_1.PartialErrorInfo(Utils.inspectError(e), null));
                }
                return;
            }
        }
        if (!body) {
            callback(new errorinfo_1.PartialErrorInfo('unenvelope(): Response body is missing', null));
            return;
        }
        var _a = body, wrappedStatusCode = _a.statusCode, response = _a.response, wrappedHeaders = _a.headers;
        if (wrappedStatusCode === undefined) {
            /* Envelope already unwrapped by the transport */
            callback(err, body, outerHeaders, true, outerStatusCode);
            return;
        }
        if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {
            /* handle wrapped errors */
            var wrappedErr = (response && response.error) || err;
            if (!wrappedErr) {
                wrappedErr = new Error('Error in unenveloping ' + body);
                wrappedErr.statusCode = wrappedStatusCode;
            }
            callback(wrappedErr, response, wrappedHeaders, true, wrappedStatusCode);
            return;
        }
        callback(err, response, wrappedHeaders, true, wrappedStatusCode);
    };
}
function paramString(params) {
    var paramPairs = [];
    if (params) {
        for (var needle in params) {
            paramPairs.push(needle + '=' + params[needle]);
        }
    }
    return paramPairs.join('&');
}
function urlFromPathAndParams(path, params) {
    return path + (params ? '?' : '') + paramString(params);
}
function logResponseHandler(callback, method, path, params) {
    return function (err, body, headers, unpacked, statusCode) {
        if (err) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Received Error; ' + urlFromPathAndParams(path, params) + '; Error: ' + Utils.inspectError(err));
        }
        else {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Received; ' +
                urlFromPathAndParams(path, params) +
                '; Headers: ' +
                paramString(headers) +
                '; StatusCode: ' +
                statusCode +
                '; Body: ' +
                (platform_1.default.BufferUtils.isBuffer(body) ? body.toString() : body));
        }
        if (callback) {
            callback(err, body, headers, unpacked, statusCode);
        }
    };
}
var Resource = /** @class */ (function () {
    function Resource() {
    }
    Resource.get = function (rest, path, headers, params, envelope, callback) {
        Resource.do(HttpMethods_1.default.Get, rest, path, null, headers, params, envelope, callback);
    };
    Resource.delete = function (rest, path, headers, params, envelope, callback) {
        Resource.do(HttpMethods_1.default.Delete, rest, path, null, headers, params, envelope, callback);
    };
    Resource.post = function (rest, path, body, headers, params, envelope, callback) {
        Resource.do(HttpMethods_1.default.Post, rest, path, body, headers, params, envelope, callback);
    };
    Resource.patch = function (rest, path, body, headers, params, envelope, callback) {
        Resource.do(HttpMethods_1.default.Patch, rest, path, body, headers, params, envelope, callback);
    };
    Resource.put = function (rest, path, body, headers, params, envelope, callback) {
        Resource.do(HttpMethods_1.default.Put, rest, path, body, headers, params, envelope, callback);
    };
    Resource.do = function (method, rest, path, body, headers, params, envelope, callback) {
        if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {
            callback = logResponseHandler(callback, method, path, params);
        }
        if (envelope) {
            callback = callback && unenvelope(callback, envelope);
            (params = params || {})['envelope'] = envelope;
        }
        function doRequest(headers, params) {
            var _a;
            if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Sending; ' + urlFromPathAndParams(path, params));
            }
            if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {
                var decodedBody = body;
                if (((_a = headers['content-type']) === null || _a === void 0 ? void 0 : _a.indexOf('msgpack')) > 0) {
                    try {
                        decodedBody = platform_1.default.Config.msgpack.decode(body);
                    }
                    catch (decodeErr) {
                        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Sending MsgPack Decoding Error: ' + Utils.inspectError(decodeErr));
                    }
                }
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Sending; ' + urlFromPathAndParams(path, params) + '; Body: ' + decodedBody);
            }
            rest.http.do(method, rest, path, headers, body, params, function (err, res, headers, unpacked, statusCode) {
                if (err && auth_1.default.isTokenErr(err)) {
                    /* token has expired, so get a new one */
                    rest.auth.authorize(null, null, function (err) {
                        if (err) {
                            callback(err);
                            return;
                        }
                        /* retry ... */
                        withAuthDetails(rest, headers, params, callback, doRequest);
                    });
                    return;
                }
                callback(err, res, headers, unpacked, statusCode);
            });
        }
        withAuthDetails(rest, headers, params, callback, doRequest);
    };
    return Resource;
}());
exports.default = Resource;


/***/ }),
/* 15 */
/***/ (function(module, exports, __nested_webpack_require_142181__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_142181__(0);
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_142181__(2));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_142181__(3));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_142181__(9));
var Utils = tslib_1.__importStar(__nested_webpack_require_142181__(1));
function toActionValue(actionString) {
    return PresenceMessage.Actions.indexOf(actionString);
}
var PresenceMessage = /** @class */ (function () {
    function PresenceMessage() {
    }
    /* Returns whether this presenceMessage is synthesized, i.e. was not actually
     * sent by the connection (usually means a leave event sent 15s after a
     * disconnection). This is useful because synthesized messages cannot be
     * compared for newness by id lexicographically - RTP2b1
     */
    PresenceMessage.prototype.isSynthesized = function () {
        if (!this.id || !this.connectionId) {
            return true;
        }
        return this.id.substring(this.connectionId.length, 0) !== this.connectionId;
    };
    /* RTP2b2 */
    PresenceMessage.prototype.parseId = function () {
        if (!this.id)
            throw new Error('parseId(): Presence message does not contain an id');
        var parts = this.id.split(':');
        return {
            connectionId: parts[0],
            msgSerial: parseInt(parts[1], 10),
            index: parseInt(parts[2], 10),
        };
    };
    /**
     * Overload toJSON() to intercept JSON.stringify()
     * @return {*}
     */
    PresenceMessage.prototype.toJSON = function () {
        /* encode data to base64 if present and we're returning real JSON;
         * although msgpack calls toJSON(), we know it is a stringify()
         * call if it has a non-empty arguments list */
        var data = this.data;
        var encoding = this.encoding;
        if (data && platform_1.default.BufferUtils.isBuffer(data)) {
            if (arguments.length > 0) {
                /* stringify call */
                encoding = encoding ? encoding + '/base64' : 'base64';
                data = platform_1.default.BufferUtils.base64Encode(data);
            }
            else {
                /* Called by msgpack. toBuffer returns a datatype understandable by
                 * that platform's msgpack implementation (Buffer in node, Uint8Array
                 * in browsers) */
                data = platform_1.default.BufferUtils.toBuffer(data);
            }
        }
        return {
            id: this.id,
            clientId: this.clientId,
            /* Convert presence action back to an int for sending to Ably */
            action: toActionValue(this.action),
            data: data,
            encoding: encoding,
            extras: this.extras,
        };
    };
    PresenceMessage.prototype.toString = function () {
        var result = '[PresenceMessage';
        result += '; action=' + this.action;
        if (this.id)
            result += '; id=' + this.id;
        if (this.timestamp)
            result += '; timestamp=' + this.timestamp;
        if (this.clientId)
            result += '; clientId=' + this.clientId;
        if (this.connectionId)
            result += '; connectionId=' + this.connectionId;
        if (this.encoding)
            result += '; encoding=' + this.encoding;
        if (this.data) {
            if (typeof this.data == 'string')
                result += '; data=' + this.data;
            else if (platform_1.default.BufferUtils.isBuffer(this.data))
                result += '; data (buffer)=' + platform_1.default.BufferUtils.base64Encode(this.data);
            else
                result += '; data (json)=' + JSON.stringify(this.data);
        }
        if (this.extras) {
            result += '; extras=' + JSON.stringify(this.extras);
        }
        result += ']';
        return result;
    };
    PresenceMessage.fromResponseBody = function (body, options, format) {
        var messages = [];
        if (format) {
            body = Utils.decodeBody(body, format);
        }
        for (var i = 0; i < body.length; i++) {
            var msg = (messages[i] = PresenceMessage.fromValues(body[i], true));
            try {
                PresenceMessage.decode(msg, options);
            }
            catch (e) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'PresenceMessage.fromResponseBody()', e.toString());
            }
        }
        return messages;
    };
    PresenceMessage.fromValues = function (values, stringifyAction) {
        if (stringifyAction) {
            values.action = PresenceMessage.Actions[values.action];
        }
        return Object.assign(new PresenceMessage(), values);
    };
    PresenceMessage.fromValuesArray = function (values) {
        var count = values.length, result = new Array(count);
        for (var i = 0; i < count; i++)
            result[i] = PresenceMessage.fromValues(values[i]);
        return result;
    };
    PresenceMessage.fromEncoded = function (encoded, options) {
        var msg = PresenceMessage.fromValues(encoded, true);
        /* if decoding fails at any point, catch and return the message decoded to
         * the fullest extent possible */
        try {
            PresenceMessage.decode(msg, options !== null && options !== void 0 ? options : {});
        }
        catch (e) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'PresenceMessage.fromEncoded()', e.toString());
        }
        return msg;
    };
    PresenceMessage.fromEncodedArray = function (encodedArray, options) {
        return encodedArray.map(function (encoded) {
            return PresenceMessage.fromEncoded(encoded, options);
        });
    };
    PresenceMessage.fromData = function (data) {
        if (data instanceof PresenceMessage) {
            return data;
        }
        return PresenceMessage.fromValues({
            data: data,
        });
    };
    PresenceMessage.Actions = ['absent', 'present', 'enter', 'leave', 'update'];
    PresenceMessage.encode = message_1.default.encode;
    PresenceMessage.decode = message_1.default.decode;
    PresenceMessage.getMessagesSize = message_1.default.getMessagesSize;
    return PresenceMessage;
}());
exports.default = PresenceMessage;


/***/ }),
/* 16 */
/***/ (function(module, exports, __nested_webpack_require_148575__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_148575__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_148575__(1));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_148575__(7));
var errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_148575__(4));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_148575__(2));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_148575__(8));
var XHRStates_1 = tslib_1.__importDefault(__nested_webpack_require_148575__(21));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_148575__(3));
function isAblyError(responseBody, headers) {
    return Utils.arrIn(Utils.allToLowerCase(Utils.keysArray(headers)), 'x-ably-errorcode');
}
function getAblyError(responseBody, headers) {
    if (isAblyError(responseBody, headers)) {
        return responseBody.error && errorinfo_1.default.fromValues(responseBody.error);
    }
}
var noop = function () { };
var idCounter = 0;
var pendingRequests = {};
var isIE = typeof global !== 'undefined' && global.XDomainRequest;
function ieVersion() {
    var match = navigator.userAgent.toString().match(/MSIE\s([\d.]+)/);
    return match && Number(match[1]);
}
function needJsonEnvelope() {
    /* IE 10 xhr bug: http://stackoverflow.com/a/16320339 */
    var version;
    return isIE && (version = ieVersion()) && version === 10;
}
function getHeader(xhr, header) {
    return xhr.getResponseHeader && xhr.getResponseHeader(header);
}
/* Safari mysteriously returns 'Identity' for transfer-encoding when in fact
 * it is 'chunked'. So instead, decide that it is chunked when
 * transfer-encoding is present or content-length is absent.  ('or' because
 * when using http2 streaming, there's no transfer-encoding header, but can
 * still deduce streaming from lack of content-length) */
function isEncodingChunked(xhr) {
    return (xhr.getResponseHeader && (xhr.getResponseHeader('transfer-encoding') || !xhr.getResponseHeader('content-length')));
}
function getHeadersAsObject(xhr) {
    var headerPairs = Utils.trim(xhr.getAllResponseHeaders()).split('\r\n');
    var headers = {};
    for (var i = 0; i < headerPairs.length; i++) {
        var parts = headerPairs[i].split(':').map(Utils.trim);
        headers[parts[0].toLowerCase()] = parts[1];
    }
    return headers;
}
var XHRRequest = /** @class */ (function (_super) {
    tslib_1.__extends(XHRRequest, _super);
    function XHRRequest(uri, headers, params, body, requestMode, timeouts, method) {
        var _this = _super.call(this) || this;
        params = params || {};
        params.rnd = Utils.cheapRandStr();
        if (needJsonEnvelope() && !params.envelope)
            params.envelope = 'json';
        _this.uri = uri + Utils.toQueryString(params);
        _this.headers = headers || {};
        _this.body = body;
        _this.method = method ? method.toUpperCase() : Utils.isEmptyArg(body) ? 'GET' : 'POST';
        _this.requestMode = requestMode;
        _this.timeouts = timeouts;
        _this.timedOut = false;
        _this.requestComplete = false;
        _this.id = String(++idCounter);
        pendingRequests[_this.id] = _this;
        return _this;
    }
    XHRRequest.createRequest = function (uri, headers, params, body, requestMode, timeouts, method) {
        /* XHR requests are used either with the context being a realtime
         * transport, or with timeouts passed in (for when used by a rest client),
         * or completely standalone.  Use the appropriate timeouts in each case */
        var _timeouts = timeouts || defaults_1.default.TIMEOUTS;
        return new XHRRequest(uri, headers, Utils.copy(params), body, requestMode, _timeouts, method);
    };
    XHRRequest.prototype.complete = function (err, body, headers, unpacked, statusCode) {
        if (!this.requestComplete) {
            this.requestComplete = true;
            if (!err && body) {
                this.emit('data', body);
            }
            this.emit('complete', err, body, headers, unpacked, statusCode);
            this.dispose();
        }
    };
    XHRRequest.prototype.abort = function () {
        this.dispose();
    };
    XHRRequest.prototype.exec = function () {
        var _this = this;
        var headers = this.headers;
        var timeout = this.requestMode == XHRStates_1.default.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout, timer = (this.timer = setTimeout(function () {
            _this.timedOut = true;
            xhr.abort();
        }, timeout)), method = this.method, xhr = (this.xhr = new XMLHttpRequest()), accept = headers['accept'];
        var body = this.body;
        var responseType = 'text';
        if (!accept) {
            // Default to JSON
            headers['accept'] = 'application/json';
        }
        else if (accept.indexOf('application/x-msgpack') === 0) {
            // Msgpack responses will be typed as ArrayBuffer
            responseType = 'arraybuffer';
        }
        if (body) {
            var contentType = headers['content-type'] || (headers['content-type'] = 'application/json');
            if (contentType.indexOf('application/json') > -1 && typeof body != 'string')
                body = JSON.stringify(body);
        }
        // Can probably remove this directive if https://github.com/nodesecurity/eslint-plugin-security/issues/26 is resolved
        // eslint-disable-next-line security/detect-non-literal-fs-filename
        xhr.open(method, this.uri, true);
        xhr.responseType = responseType;
        if ('authorization' in headers) {
            xhr.withCredentials = true;
        }
        for (var h in headers)
            xhr.setRequestHeader(h, headers[h]);
        var errorHandler = function (errorEvent, message, code, statusCode) {
            var _a;
            var errorMessage = message + ' (event type: ' + errorEvent.type + ')';
            if ((_a = _this === null || _this === void 0 ? void 0 : _this.xhr) === null || _a === void 0 ? void 0 : _a.statusText)
                errorMessage += ', current statusText is ' + _this.xhr.statusText;
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Request.on' + errorEvent.type + '()', errorMessage);
            _this.complete(new errorinfo_1.PartialErrorInfo(errorMessage, code, statusCode));
        };
        xhr.onerror = function (errorEvent) {
            errorHandler(errorEvent, 'XHR error occurred', null, 400);
        };
        xhr.onabort = function (errorEvent) {
            if (_this.timedOut) {
                errorHandler(errorEvent, 'Request aborted due to request timeout expiring', null, 408);
            }
            else {
                errorHandler(errorEvent, 'Request cancelled', null, 400);
            }
        };
        xhr.ontimeout = function (errorEvent) {
            errorHandler(errorEvent, 'Request timed out', null, 408);
        };
        var streaming;
        var statusCode;
        var successResponse;
        var streamPos = 0;
        var unpacked = false;
        var onResponse = function () {
            clearTimeout(timer);
            successResponse = statusCode < 400;
            if (statusCode == 204) {
                _this.complete(null, null, null, null, statusCode);
                return;
            }
            streaming = _this.requestMode == XHRStates_1.default.REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr);
        };
        var onEnd = function () {
            var parsedResponse;
            try {
                var contentType = getHeader(xhr, 'content-type');
                /* Be liberal in what we accept; buggy auth servers may respond
                 * without the correct contenttype, but assume they're still
                 * responding with json */
                var json = contentType ? contentType.indexOf('application/json') >= 0 : xhr.responseType == 'text';
                if (json) {
                    /* If we requested msgpack but server responded with json, then since
                     * we set the responseType expecting msgpack, the response will be
                     * an ArrayBuffer containing json */
                    var jsonResponseBody = xhr.responseType === 'arraybuffer'
                        ? platform_1.default.BufferUtils.utf8Decode(xhr.response)
                        : String(xhr.responseText);
                    if (jsonResponseBody.length) {
                        parsedResponse = JSON.parse(jsonResponseBody);
                    }
                    else {
                        parsedResponse = jsonResponseBody;
                    }
                    unpacked = true;
                }
                else {
                    parsedResponse = xhr.response;
                }
                if (parsedResponse.response !== undefined) {
                    /* unwrap JSON envelope */
                    statusCode = parsedResponse.statusCode;
                    successResponse = statusCode < 400;
                    headers = parsedResponse.headers;
                    parsedResponse = parsedResponse.response;
                }
                else {
                    headers = getHeadersAsObject(xhr);
                }
            }
            catch (e) {
                _this.complete(new errorinfo_1.PartialErrorInfo('Malformed response body from server: ' + e.message, null, 400));
                return;
            }
            /* If response is an array, it's an array of protocol messages -- even if
             * is contains an error action (hence the nonsuccess statuscode), we can
             * consider the request to have succeeded, just pass it on to
             * onProtocolMessage to decide what to do */
            if (successResponse || Utils.isArray(parsedResponse)) {
                _this.complete(null, parsedResponse, headers, unpacked, statusCode);
                return;
            }
            var err = getAblyError(parsedResponse, headers);
            if (!err) {
                err = new errorinfo_1.PartialErrorInfo('Error response received from server: ' +
                    statusCode +
                    ' body was: ' +
                    platform_1.default.Config.inspect(parsedResponse), null, statusCode);
            }
            _this.complete(err, parsedResponse, headers, unpacked, statusCode);
        };
        function onProgress() {
            var responseText = xhr.responseText;
            var bodyEnd = responseText.length - 1;
            var idx, chunk;
            while (streamPos < bodyEnd && (idx = responseText.indexOf('\n', streamPos)) > -1) {
                chunk = responseText.slice(streamPos, idx);
                streamPos = idx + 1;
                onChunk(chunk);
            }
        }
        var onChunk = function (chunk) {
            try {
                chunk = JSON.parse(chunk);
            }
            catch (e) {
                _this.complete(new errorinfo_1.PartialErrorInfo('Malformed response body from server: ' + e.message, null, 400));
                return;
            }
            _this.emit('data', chunk);
        };
        var onStreamEnd = function () {
            onProgress();
            _this.streamComplete = true;
            platform_1.default.Config.nextTick(function () {
                _this.complete();
            });
        };
        xhr.onreadystatechange = function () {
            var readyState = xhr.readyState;
            if (readyState < 3)
                return;
            if (xhr.status !== 0) {
                if (statusCode === undefined) {
                    statusCode = xhr.status;
                    /* IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450 */
                    if (statusCode === 1223)
                        statusCode = 204;
                    onResponse();
                }
                if (readyState == 3 && streaming) {
                    onProgress();
                }
                else if (readyState == 4) {
                    if (streaming)
                        onStreamEnd();
                    else
                        onEnd();
                }
            }
        };
        xhr.send(body);
    };
    XHRRequest.prototype.dispose = function () {
        var xhr = this.xhr;
        if (xhr) {
            xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop;
            this.xhr = null;
            var timer = this.timer;
            if (timer) {
                clearTimeout(timer);
                this.timer = null;
            }
            if (!this.requestComplete)
                xhr.abort();
        }
        delete pendingRequests[this.id];
    };
    return XHRRequest;
}(eventemitter_1.default));
exports.default = XHRRequest;

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_148575__(13)))

/***/ }),
/* 17 */
/***/ (function(module, exports, __nested_webpack_require_161531__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_161531__(0);
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(2));
var Utils = tslib_1.__importStar(__nested_webpack_require_161531__(1));
var multicaster_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(23));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(4));
var hmac_sha256_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(45));
var enc_base64_1 = __nested_webpack_require_161531__(11);
var HttpMethods_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(18));
var HttpStatusCodes_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(25));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(3));
var resource_1 = tslib_1.__importDefault(__nested_webpack_require_161531__(14));
var MAX_TOKEN_LENGTH = Math.pow(2, 17);
function noop() { }
function random() {
    return ('000000' + Math.floor(Math.random() * 1e16)).slice(-16);
}
function isRealtime(client) {
    return !!client.connection;
}
/* A client auth callback may give errors in any number of formats; normalise to an ErrorInfo or PartialErrorInfo */
function normaliseAuthcallbackError(err) {
    if (!Utils.isErrorInfoOrPartialErrorInfo(err)) {
        return new errorinfo_1.default(Utils.inspectError(err), err.code || 40170, err.statusCode || 401);
    }
    /* network errors will not have an inherent error code */
    if (!err.code) {
        if (err.statusCode === 403) {
            err.code = 40300;
        }
        else {
            err.code = 40170;
            /* normalise statusCode to 401 per RSA4e */
            err.statusCode = 401;
        }
    }
    return err;
}
var hmac = function (text, key) {
    if (platform_1.default.Config.createHmac) {
        var inst = platform_1.default.Config.createHmac('SHA256', key);
        inst.update(text);
        return inst.digest('base64');
    }
    return (0, enc_base64_1.stringify)((0, hmac_sha256_1.default)(text, key));
};
function c14n(capability) {
    if (!capability)
        return '';
    if (typeof capability == 'string')
        capability = JSON.parse(capability);
    var c14nCapability = Object.create(null);
    var keys = Utils.keysArray(capability, true);
    if (!keys)
        return '';
    keys.sort();
    for (var i = 0; i < keys.length; i++) {
        c14nCapability[keys[i]] = capability[keys[i]].sort();
    }
    return JSON.stringify(c14nCapability);
}
function logAndValidateTokenAuthMethod(authOptions) {
    if (authOptions.authCallback) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'using token auth with authCallback');
    }
    else if (authOptions.authUrl) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'using token auth with authUrl');
    }
    else if (authOptions.key) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'using token auth with client-side signing');
    }
    else if (authOptions.tokenDetails) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'using token auth with supplied token only');
    }
    else {
        var msg = 'authOptions must include valid authentication parameters';
        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', msg);
        throw new Error(msg);
    }
}
function basicAuthForced(options) {
    return 'useTokenAuth' in options && !options.useTokenAuth;
}
/* RSA4 */
function useTokenAuth(options) {
    return (options.useTokenAuth ||
        (!basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails)));
}
/* RSA4a */
function noWayToRenew(options) {
    return !options.key && !options.authCallback && !options.authUrl;
}
var trId = 0;
function getTokenRequestId() {
    return trId++;
}
var Auth = /** @class */ (function () {
    function Auth(client, options) {
        // This initialization is always overwritten and only used to prevent a TypeScript compiler error
        this.authOptions = {};
        this.client = client;
        this.tokenParams = options.defaultTokenParams || {};
        /* The id of the current token request if one is in progress, else null */
        this.currentTokenRequestId = null;
        this.waitingForTokenRequest = null;
        if (useTokenAuth(options)) {
            /* Token auth */
            if (options.key && !hmac) {
                var msg = 'client-side token request signing not supported';
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', msg);
                throw new Error(msg);
            }
            if (noWayToRenew(options)) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', 'Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help');
            }
            this._saveTokenOptions(options.defaultTokenParams, options);
            logAndValidateTokenAuthMethod(this.authOptions);
        }
        else {
            /* Basic auth */
            if (!options.key) {
                var msg = 'No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)';
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', msg);
                throw new errorinfo_1.default(msg, 40160, 401);
            }
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'anonymous, using basic auth');
            this._saveBasicOptions(options);
        }
    }
    Auth.prototype.authorize = function (tokenParams, authOptions, callback) {
        var _this = this;
        var _authOptions;
        /* shuffle and normalise arguments as necessary */
        if (typeof tokenParams == 'function' && !callback) {
            callback = tokenParams;
            _authOptions = tokenParams = null;
        }
        else if (typeof authOptions == 'function' && !callback) {
            callback = authOptions;
            _authOptions = null;
        }
        else {
            _authOptions = authOptions;
        }
        if (!callback) {
            if (this.client.options.promises) {
                return Utils.promisify(this, 'authorize', arguments);
            }
        }
        /* RSA10a: authorize() call implies token auth. If a key is passed it, we
         * just check if it doesn't clash and assume we're generating a token from it */
        if (_authOptions && _authOptions.key && this.authOptions.key !== _authOptions.key) {
            throw new errorinfo_1.default('Unable to update auth options with incompatible key', 40102, 401);
        }
        if (_authOptions && 'force' in _authOptions) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.authorize', 'Deprecation warning: specifying {force: true} in authOptions is no longer necessary, authorize() now always gets a new token. Please remove this, as in version 1.0 and later, having a non-null authOptions will overwrite stored library authOptions, which may not be what you want');
            /* Emulate the old behaviour: if 'force' was the only member of authOptions,
             * set it to null so it doesn't overwrite stored. TODO: remove in version 1.0 */
            if (Utils.isOnlyPropIn(_authOptions, 'force')) {
                _authOptions = null;
            }
        }
        this._forceNewToken(tokenParams, _authOptions, function (err, tokenDetails) {
            if (err) {
                if (_this.client.connection && err.statusCode === HttpStatusCodes_1.default.Forbidden) {
                    /* Per RSA4d & RSA4d1, if the auth server explicitly repudiates our right to
                     * stay connecticed by returning a 403, we actively disconnect the connection
                     * even though we may well still have time left in the old token. */
                    _this.client.connection.connectionManager.actOnErrorFromAuthorize(err);
                }
                callback === null || callback === void 0 ? void 0 : callback(err);
                return;
            }
            /* RTC8
             * - When authorize called by an end user and have a realtime connection,
             * don't call back till new token has taken effect.
             * - Use this.client.connection as a proxy for (this.client instanceof Realtime),
             * which doesn't work in node as Realtime isn't part of the vm context for Rest clients */
            if (isRealtime(_this.client)) {
                _this.client.connection.connectionManager.onAuthUpdated(tokenDetails, callback || noop);
            }
            else {
                callback === null || callback === void 0 ? void 0 : callback(null, tokenDetails);
            }
        });
    };
    Auth.prototype.authorise = function (tokenParams, authOptions, callback) {
        logger_1.default.deprecated('Auth.authorise', 'Auth.authorize');
        this.authorize(tokenParams, authOptions, callback);
    };
    /* For internal use, eg by connectionManager - useful when want to call back
     * as soon as we have the new token, rather than waiting for it to take
     * effect on the connection as #authorize does */
    Auth.prototype._forceNewToken = function (tokenParams, authOptions, callback) {
        var _this = this;
        /* get rid of current token even if still valid */
        this.tokenDetails = null;
        /* _save normalises the tokenParams and authOptions and updates the auth
         * object. All subsequent operations should use the values on `this`,
         * not the passed in ones. */
        this._saveTokenOptions(tokenParams, authOptions);
        logAndValidateTokenAuthMethod(this.authOptions);
        this._ensureValidAuthCredentials(true, function (err, tokenDetails) {
            /* RSA10g */
            delete _this.tokenParams.timestamp;
            delete _this.authOptions.queryTime;
            callback(err, tokenDetails);
        });
    };
    Auth.prototype.requestToken = function (tokenParams, authOptions, callback) {
        var _this = this;
        /* shuffle and normalise arguments as necessary */
        if (typeof tokenParams == 'function' && !callback) {
            callback = tokenParams;
            authOptions = tokenParams = null;
        }
        else if (typeof authOptions == 'function' && !callback) {
            callback = authOptions;
            authOptions = null;
        }
        if (!callback && this.client.options.promises) {
            return Utils.promisify(this, 'requestToken', arguments);
        }
        /* RSA8e: if authOptions passed in, they're used instead of stored, don't merge them */
        authOptions = authOptions || this.authOptions;
        tokenParams = tokenParams || Utils.copy(this.tokenParams);
        var _callback = callback || noop;
        /* first set up whatever callback will be used to get signed
         * token requests */
        var tokenRequestCallback, client = this.client;
        if (authOptions.authCallback) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authCallback');
            tokenRequestCallback = authOptions.authCallback;
        }
        else if (authOptions.authUrl) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authUrl');
            tokenRequestCallback = function (params, cb) {
                var authHeaders = Utils.mixin({ accept: 'application/json, text/plain' }, authOptions.authHeaders);
                var usePost = authOptions.authMethod && authOptions.authMethod.toLowerCase() === 'post';
                var providedQsParams;
                /* Combine authParams with any qs params given in the authUrl */
                var queryIdx = authOptions.authUrl.indexOf('?');
                if (queryIdx > -1) {
                    providedQsParams = Utils.parseQueryString(authOptions.authUrl.slice(queryIdx));
                    authOptions.authUrl = authOptions.authUrl.slice(0, queryIdx);
                    if (!usePost) {
                        /* In case of conflict, authParams take precedence over qs params in the authUrl */
                        authOptions.authParams = Utils.mixin(providedQsParams, authOptions.authParams);
                    }
                }
                /* RSA8c2 */
                var authParams = Utils.mixin({}, authOptions.authParams || {}, params);
                var authUrlRequestCallback = function (err, body, headers, unpacked) {
                    var contentType;
                    if (err) {
                        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received Error: ' + Utils.inspectError(err));
                    }
                    else {
                        contentType = headers['content-type'];
                        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received; content-type: ' + contentType + '; body: ' + Utils.inspectBody(body));
                    }
                    if (err || unpacked)
                        return cb(err, body);
                    if (platform_1.default.BufferUtils.isBuffer(body))
                        body = body.toString();
                    if (!contentType) {
                        cb(new errorinfo_1.default('authUrl response is missing a content-type header', 40170, 401));
                        return;
                    }
                    var json = contentType.indexOf('application/json') > -1, text = contentType.indexOf('text/plain') > -1 || contentType.indexOf('application/jwt') > -1;
                    if (!json && !text) {
                        cb(new errorinfo_1.default('authUrl responded with unacceptable content-type ' +
                            contentType +
                            ', should be either text/plain, application/jwt or application/json', 40170, 401));
                        return;
                    }
                    if (json) {
                        if (body.length > MAX_TOKEN_LENGTH) {
                            cb(new errorinfo_1.default('authUrl response exceeded max permitted length', 40170, 401));
                            return;
                        }
                        try {
                            body = JSON.parse(body);
                        }
                        catch (e) {
                            cb(new errorinfo_1.default('Unexpected error processing authURL response; err = ' + e.message, 40170, 401));
                            return;
                        }
                    }
                    cb(null, body, contentType);
                };
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Requesting token from ' +
                    authOptions.authUrl +
                    '; Params: ' +
                    JSON.stringify(authParams) +
                    '; method: ' +
                    (usePost ? 'POST' : 'GET'));
                if (usePost) {
                    /* send body form-encoded */
                    var headers = authHeaders || {};
                    headers['content-type'] = 'application/x-www-form-urlencoded';
                    var body = Utils.toQueryString(authParams).slice(1); /* slice is to remove the initial '?' */
                    _this.client.http.doUri(HttpMethods_1.default.Post, client, authOptions.authUrl, headers, body, providedQsParams, authUrlRequestCallback);
                }
                else {
                    _this.client.http.doUri(HttpMethods_1.default.Get, client, authOptions.authUrl, authHeaders || {}, null, authParams, authUrlRequestCallback);
                }
            };
        }
        else if (authOptions.key) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.requestToken()', 'using token auth with client-side signing');
            tokenRequestCallback = function (params, cb) {
                _this.createTokenRequest(params, authOptions, cb);
            };
        }
        else {
            var msg = 'Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', 'library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help');
            _callback(new errorinfo_1.default(msg, 40171, 403));
            return;
        }
        /* normalise token params */
        if ('capability' in tokenParams)
            tokenParams.capability = c14n(tokenParams.capability);
        var tokenRequest = function (signedTokenParams, tokenCb) {
            var keyName = signedTokenParams.keyName, path = '/keys/' + keyName + '/requestToken', tokenUri = function (host) {
                return client.baseUri(host) + path;
            };
            var requestHeaders = Utils.defaultPostHeaders(_this.client.options);
            if (authOptions.requestHeaders)
                Utils.mixin(requestHeaders, authOptions.requestHeaders);
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Auth.requestToken().requestToken', 'Sending POST to ' + path + '; Token params: ' + JSON.stringify(signedTokenParams));
            _this.client.http.do(HttpMethods_1.default.Post, client, tokenUri, requestHeaders, JSON.stringify(signedTokenParams), null, tokenCb);
        };
        var tokenRequestCallbackTimeoutExpired = false, timeoutLength = this.client.options.timeouts.realtimeRequestTimeout, tokenRequestCallbackTimeout = setTimeout(function () {
            tokenRequestCallbackTimeoutExpired = true;
            var msg = 'Token request callback timed out after ' + timeoutLength / 1000 + ' seconds';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', msg);
            _callback(new errorinfo_1.default(msg, 40170, 401));
        }, timeoutLength);
        tokenRequestCallback(tokenParams, function (err, tokenRequestOrDetails, contentType) {
            if (tokenRequestCallbackTimeoutExpired)
                return;
            clearTimeout(tokenRequestCallbackTimeout);
            if (err) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', 'token request signing call returned error; err = ' + Utils.inspectError(err));
                _callback(normaliseAuthcallbackError(err));
                return;
            }
            /* the response from the callback might be a token string, a signed request or a token details */
            if (typeof tokenRequestOrDetails === 'string') {
                if (tokenRequestOrDetails.length === 0) {
                    _callback(new errorinfo_1.default('Token string is empty', 40170, 401));
                }
                else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {
                    _callback(new errorinfo_1.default('Token string exceeded max permitted length (was ' + tokenRequestOrDetails.length + ' bytes)', 40170, 401));
                }
                else if (tokenRequestOrDetails === 'undefined' || tokenRequestOrDetails === 'null') {
                    /* common failure mode with poorly-implemented authCallbacks */
                    _callback(new errorinfo_1.default('Token string was literal null/undefined', 40170, 401));
                }
                else if (tokenRequestOrDetails[0] === '{' && !(contentType && contentType.indexOf('application/jwt') > -1)) {
                    _callback(new errorinfo_1.default("Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details", 40170, 401));
                }
                else {
                    _callback(null, { token: tokenRequestOrDetails });
                }
                return;
            }
            if (typeof tokenRequestOrDetails !== 'object') {
                var msg = 'Expected token request callback to call back with a token string or token request/details object, but got a ' +
                    typeof tokenRequestOrDetails;
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', msg);
                _callback(new errorinfo_1.default(msg, 40170, 401));
                return;
            }
            var objectSize = JSON.stringify(tokenRequestOrDetails).length;
            if (objectSize > MAX_TOKEN_LENGTH && !authOptions.suppressMaxLengthCheck) {
                _callback(new errorinfo_1.default('Token request/details object exceeded max permitted stringified size (was ' + objectSize + ' bytes)', 40170, 401));
                return;
            }
            if ('issued' in tokenRequestOrDetails) {
                /* a tokenDetails object */
                _callback(null, tokenRequestOrDetails);
                return;
            }
            if (!('keyName' in tokenRequestOrDetails)) {
                var msg = 'Expected token request callback to call back with a token string, token request object, or token details object';
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', msg);
                _callback(new errorinfo_1.default(msg, 40170, 401));
                return;
            }
            /* it's a token request, so make the request */
            tokenRequest(tokenRequestOrDetails, function (err, tokenResponse, headers, unpacked) {
                if (err) {
                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', 'token request API call returned error; err = ' + Utils.inspectError(err));
                    _callback(normaliseAuthcallbackError(err));
                    return;
                }
                if (!unpacked)
                    tokenResponse = JSON.parse(tokenResponse);
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.getToken()', 'token received');
                _callback(null, tokenResponse);
            });
        });
    };
    /**
     * Create and sign a token request based on the given options.
     * NOTE this can only be used when the key value is available locally.
     * Otherwise, signed token requests must be obtained from the key
     * owner (either using the token request callback or url).
     *
     * @param authOptions
     * an object containing the request options:
     * - key:           the key to use. If not specified, a key passed in constructing
     *                  the Rest interface will be used
     *
     * - queryTime      (optional) boolean indicating that the ably system should be
     *                  queried for the current time when none is specified explicitly
     *
     * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
     *                  requestToken request
     *
     * @param tokenParams
     * an object containing the parameters for the requested token:
     * - ttl:       (optional) the requested life of the token in ms. If none is specified
     *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request
     *                  exceeding that lifetime will be rejected with an error.
     *
     * - capability:    (optional) the capability to associate with the access token.
     *                  If none is specified, a token will be requested with all of the
     *                  capabilities of the specified key.
     *
     * - clientId:      (optional) a client ID to associate with the token; if not
     *                  specified, a clientId passed in constructing the Rest interface will be used
     *
     * - timestamp:     (optional) the time in ms since the epoch. If none is specified,
     *                  the system will be queried for a time value to use.
     *
     * @param callback
     */
    Auth.prototype.createTokenRequest = function (tokenParams, authOptions, callback) {
        var _this = this;
        /* shuffle and normalise arguments as necessary */
        if (typeof tokenParams == 'function' && !callback) {
            callback = tokenParams;
            authOptions = tokenParams = null;
        }
        else if (typeof authOptions == 'function' && !callback) {
            callback = authOptions;
            authOptions = null;
        }
        if (!callback && this.client.options.promises) {
            return Utils.promisify(this, 'createTokenRequest', arguments);
        }
        /* RSA9h: if authOptions passed in, they're used instead of stored, don't merge them */
        authOptions = authOptions || this.authOptions;
        tokenParams = tokenParams || Utils.copy(this.tokenParams);
        var key = authOptions.key;
        if (!key) {
            callback(new errorinfo_1.default('No key specified', 40101, 403));
            return;
        }
        var keyParts = key.split(':'), keyName = keyParts[0], keySecret = keyParts[1];
        if (!keySecret) {
            callback(new errorinfo_1.default('Invalid key specified', 40101, 403));
            return;
        }
        if (tokenParams.clientId === '') {
            callback(new errorinfo_1.default('clientId canâ€™t be an empty string', 40012, 400));
            return;
        }
        if ('capability' in tokenParams) {
            tokenParams.capability = c14n(tokenParams.capability);
        }
        var request = Utils.mixin({ keyName: keyName }, tokenParams), clientId = tokenParams.clientId || '', ttl = tokenParams.ttl || '', capability = tokenParams.capability || '';
        (function (authoriseCb) {
            if (request.timestamp) {
                authoriseCb();
                return;
            }
            _this.getTimestamp(authOptions && authOptions.queryTime, function (err, time) {
                if (err) {
                    callback(err);
                    return;
                }
                request.timestamp = time;
                authoriseCb();
            });
        })(function () {
            /* nonce */
            /* NOTE: there is no expectation that the client
             * specifies the nonce; this is done by the library
             * However, this can be overridden by the client
             * simply for testing purposes. */
            var nonce = request.nonce || (request.nonce = random()), timestamp = request.timestamp;
            var signText = request.keyName + '\n' + ttl + '\n' + capability + '\n' + clientId + '\n' + timestamp + '\n' + nonce + '\n';
            /* mac */
            /* NOTE: there is no expectation that the client
             * specifies the mac; this is done by the library
             * However, this can be overridden by the client
             * simply for testing purposes. */
            request.mac = request.mac || hmac(signText, keySecret);
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.getTokenRequest()', 'generated signed request');
            callback(null, request);
        });
    };
    /**
     * Get the auth query params to use for a websocket connection,
     * based on the current auth parameters
     */
    Auth.prototype.getAuthParams = function (callback) {
        if (this.method == 'basic')
            callback(null, { key: this.key });
        else
            this._ensureValidAuthCredentials(false, function (err, tokenDetails) {
                if (err) {
                    callback(err);
                    return;
                }
                if (!tokenDetails) {
                    throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');
                }
                callback(null, { access_token: tokenDetails.token });
            });
    };
    /**
     * Get the authorization header to use for a REST or comet request,
     * based on the current auth parameters
     */
    Auth.prototype.getAuthHeaders = function (callback) {
        if (this.method == 'basic') {
            callback(null, { authorization: 'Basic ' + this.basicKey });
        }
        else {
            this._ensureValidAuthCredentials(false, function (err, tokenDetails) {
                if (err) {
                    callback(err);
                    return;
                }
                if (!tokenDetails) {
                    throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');
                }
                callback(null, { authorization: 'Bearer ' + Utils.toBase64(tokenDetails.token) });
            });
        }
    };
    /**
     * Get the current time based on the local clock,
     * or if the option queryTime is true, return the server time.
     * The server time offset from the local time is stored so that
     * only one request to the server to get the time is ever needed
     */
    Auth.prototype.getTimestamp = function (queryTime, callback) {
        if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {
            this.client.time(callback);
        }
        else {
            callback(null, this.getTimestampUsingOffset());
        }
    };
    Auth.prototype.getTimestampUsingOffset = function () {
        return Utils.now() + (this.client.serverTimeOffset || 0);
    };
    Auth.prototype.isTimeOffsetSet = function () {
        return this.client.serverTimeOffset !== null;
    };
    Auth.prototype._saveBasicOptions = function (authOptions) {
        this.method = 'basic';
        this.key = authOptions.key;
        this.basicKey = Utils.toBase64(authOptions.key);
        this.authOptions = authOptions || {};
        if ('clientId' in authOptions) {
            this._userSetClientId(authOptions.clientId);
        }
    };
    Auth.prototype._saveTokenOptions = function (tokenParams, authOptions) {
        this.method = 'token';
        if (tokenParams) {
            /* We temporarily persist tokenParams.timestamp in case a new token needs
             * to be requested, then null it out in the callback of
             * _ensureValidAuthCredentials for RSA10g compliance */
            this.tokenParams = tokenParams;
        }
        if (authOptions) {
            /* normalise */
            if (authOptions.token) {
                /* options.token may contain a token string or, for convenience, a TokenDetails */
                authOptions.tokenDetails =
                    typeof authOptions.token === 'string'
                        ? { token: authOptions.token }
                        : authOptions.token;
            }
            if (authOptions.tokenDetails) {
                this.tokenDetails = authOptions.tokenDetails;
            }
            if ('clientId' in authOptions) {
                this._userSetClientId(authOptions.clientId);
            }
            this.authOptions = authOptions;
        }
    };
    /* @param forceSupersede: force a new token request even if there's one in
     * progress, making all pending callbacks wait for the new one */
    Auth.prototype._ensureValidAuthCredentials = function (forceSupersede, callback) {
        var _this = this;
        var token = this.tokenDetails;
        if (token) {
            if (this._tokenClientIdMismatch(token.clientId)) {
                /* 403 to trigger a permanently failed client - RSA15c */
                callback(new errorinfo_1.default('Mismatch between clientId in token (' + token.clientId + ') and current clientId (' + this.clientId + ')', 40102, 403));
                return;
            }
            /* RSA4b1 -- if we have a server time offset set already, we can
             * automatically remove expired tokens. Else just use the cached token. If it is
             * expired Ably will tell us and we'll discard it then. */
            if (!this.isTimeOffsetSet() || !token.expires || token.expires >= this.getTimestampUsingOffset()) {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.getToken()', 'using cached token; expires = ' + token.expires);
                callback(null, token);
                return;
            }
            /* expired, so remove and fallthrough to getting a new one */
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.getToken()', 'deleting expired token');
            this.tokenDetails = null;
        }
        (this.waitingForTokenRequest || (this.waitingForTokenRequest = multicaster_1.default.create())).push(callback);
        if (this.currentTokenRequestId !== null && !forceSupersede) {
            return;
        }
        /* Request a new token */
        var tokenRequestId = (this.currentTokenRequestId = getTokenRequestId());
        this.requestToken(this.tokenParams, this.authOptions, function (err, tokenResponse) {
            if (_this.currentTokenRequestId > tokenRequestId) {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth._ensureValidAuthCredentials()', 'Discarding token request response; overtaken by newer one');
                return;
            }
            _this.currentTokenRequestId = null;
            var callbacks = _this.waitingForTokenRequest || noop;
            _this.waitingForTokenRequest = null;
            if (err) {
                callbacks(err);
                return;
            }
            callbacks(null, (_this.tokenDetails = tokenResponse));
        });
    };
    /* User-set: check types, '*' is disallowed, throw any errors */
    Auth.prototype._userSetClientId = function (clientId) {
        if (!(typeof clientId === 'string' || clientId === null)) {
            throw new errorinfo_1.default('clientId must be either a string or null', 40012, 400);
        }
        else if (clientId === '*') {
            throw new errorinfo_1.default('Canâ€™t use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: "*"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: "*"}, authOptions)', 40012, 400);
        }
        else {
            var err = this._uncheckedSetClientId(clientId);
            if (err)
                throw err;
        }
    };
    /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */
    Auth.prototype._uncheckedSetClientId = function (clientId) {
        if (this._tokenClientIdMismatch(clientId)) {
            /* Should never happen in normal circumstances as realtime should
             * recognise mismatch and return an error */
            var msg = 'Unexpected clientId mismatch: client has ' + this.clientId + ', requested ' + clientId;
            var err = new errorinfo_1.default(msg, 40102, 401);
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth._uncheckedSetClientId()', msg);
            return err;
        }
        else {
            /* RSA7a4: if options.clientId is provided and is not
             * null, it overrides defaultTokenParams.clientId */
            this.clientId = this.tokenParams.clientId = clientId;
            return null;
        }
    };
    Auth.prototype._tokenClientIdMismatch = function (tokenClientId) {
        return !!(this.clientId &&
            this.clientId !== '*' &&
            tokenClientId &&
            tokenClientId !== '*' &&
            this.clientId !== tokenClientId);
    };
    Auth.isTokenErr = function (error) {
        return error.code && error.code >= 40140 && error.code < 40150;
    };
    Auth.prototype.revokeTokens = function (specifiers, optionsOrCallbackArg, callbackArg) {
        if (useTokenAuth(this.client.options)) {
            throw new errorinfo_1.default('Cannot revoke tokens when using token auth', 40162, 401);
        }
        var keyName = this.client.options.keyName;
        var resolvedOptions;
        if (typeof optionsOrCallbackArg === 'function') {
            callbackArg = optionsOrCallbackArg;
            resolvedOptions = {};
        }
        else {
            resolvedOptions = optionsOrCallbackArg !== null && optionsOrCallbackArg !== void 0 ? optionsOrCallbackArg : {};
        }
        if (callbackArg === undefined) {
            if (this.client.options.promises) {
                return Utils.promisify(this, 'revokeTokens', [specifiers, resolvedOptions]);
            }
            callbackArg = noop;
        }
        var callback = callbackArg;
        var requestBodyDTO = tslib_1.__assign({ targets: specifiers.map(function (specifier) { return "".concat(specifier.type, ":").concat(specifier.value); }) }, resolvedOptions);
        var format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(this.client.options, format);
        if (this.client.options.headers)
            Utils.mixin(headers, this.client.options.headers);
        var requestBody = Utils.encodeBody(requestBodyDTO, format);
        resource_1.default.post(this.client, "/keys/".concat(keyName, "/revokeTokens"), requestBody, headers, { newBatchResponse: 'true' }, null, function (err, body, headers, unpacked) {
            if (err) {
                // TODO remove this type assertion after fixing https://github.com/ably/ably-js/issues/1405
                callback(err);
                return;
            }
            var batchResult = (unpacked ? body : Utils.decodeBody(body, format));
            callback(null, batchResult);
        });
    };
    return Auth;
}());
exports.default = Auth;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var HttpMethods;
(function (HttpMethods) {
    HttpMethods["Get"] = "get";
    HttpMethods["Delete"] = "delete";
    HttpMethods["Post"] = "post";
    HttpMethods["Put"] = "put";
    HttpMethods["Patch"] = "patch";
})(HttpMethods || (HttpMethods = {}));
exports.default = HttpMethods;


/***/ }),
/* 19 */
/***/ (function(module, exports, __nested_webpack_require_199902__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpPaginatedResponse = exports.PaginatedResult = void 0;
var tslib_1 = __nested_webpack_require_199902__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_199902__(1));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_199902__(2));
var resource_1 = tslib_1.__importDefault(__nested_webpack_require_199902__(14));
function getRelParams(linkUrl) {
    var urlMatch = linkUrl.match(/^\.\/(\w+)\?(.*)$/);
    return urlMatch && urlMatch[2] && Utils.parseQueryString(urlMatch[2]);
}
function parseRelLinks(linkHeader) {
    if (typeof linkHeader == 'string')
        linkHeader = linkHeader.split(',');
    var relParams = {};
    for (var i = 0; i < linkHeader.length; i++) {
        var linkMatch = linkHeader[i].match(/^\s*<(.+)>;\s*rel="(\w+)"$/);
        if (linkMatch) {
            var params = getRelParams(linkMatch[1]);
            if (params)
                relParams[linkMatch[2]] = params;
        }
    }
    return relParams;
}
function returnErrOnly(err, body, useHPR) {
    /* If using httpPaginatedResponse, errors from Ably are returned as part of
     * the HPR, only do callback(err) for network errors etc. which don't
     * return a body and/or have no ably-originated error code (non-numeric
     * error codes originate from node) */
    return !(useHPR && (body || typeof err.code === 'number'));
}
var PaginatedResource = /** @class */ (function () {
    function PaginatedResource(rest, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {
        this.rest = rest;
        this.path = path;
        this.headers = headers;
        this.envelope = envelope !== null && envelope !== void 0 ? envelope : null;
        this.bodyHandler = bodyHandler;
        this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;
    }
    PaginatedResource.prototype.get = function (params, callback) {
        var _this = this;
        resource_1.default.get(this.rest, this.path, this.headers, params, this.envelope, function (err, body, headers, unpacked, statusCode) {
            _this.handlePage(err, body, headers, unpacked, statusCode, callback);
        });
    };
    PaginatedResource.prototype.delete = function (params, callback) {
        var _this = this;
        resource_1.default.delete(this.rest, this.path, this.headers, params, this.envelope, function (err, body, headers, unpacked, statusCode) {
            _this.handlePage(err, body, headers, unpacked, statusCode, callback);
        });
    };
    PaginatedResource.prototype.post = function (params, body, callback) {
        var _this = this;
        resource_1.default.post(this.rest, this.path, body, this.headers, params, this.envelope, function (err, responseBody, headers, unpacked, statusCode) {
            if (callback) {
                _this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);
            }
        });
    };
    PaginatedResource.prototype.put = function (params, body, callback) {
        var _this = this;
        resource_1.default.put(this.rest, this.path, body, this.headers, params, this.envelope, function (err, responseBody, headers, unpacked, statusCode) {
            if (callback) {
                _this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);
            }
        });
    };
    PaginatedResource.prototype.patch = function (params, body, callback) {
        var _this = this;
        resource_1.default.patch(this.rest, this.path, body, this.headers, params, this.envelope, function (err, responseBody, headers, unpacked, statusCode) {
            if (callback) {
                _this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);
            }
        });
    };
    PaginatedResource.prototype.handlePage = function (err, body, headers, unpacked, statusCode, callback) {
        if (err && returnErrOnly(err, body, this.useHttpPaginatedResponse)) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'PaginatedResource.handlePage()', 'Unexpected error getting resource: err = ' + Utils.inspectError(err));
            callback === null || callback === void 0 ? void 0 : callback(err);
            return;
        }
        var items, linkHeader, relParams;
        try {
            items = this.bodyHandler(body, headers || {}, unpacked);
        }
        catch (e) {
            /* If we got an error, the failure to parse the body is almost certainly
             * due to that, so callback with that in preference over the parse error */
            callback === null || callback === void 0 ? void 0 : callback(err || e);
            return;
        }
        if (headers && (linkHeader = headers['Link'] || headers['link'])) {
            relParams = parseRelLinks(linkHeader);
        }
        if (this.useHttpPaginatedResponse) {
            callback(null, new HttpPaginatedResponse(this, items, headers || {}, statusCode, relParams, err));
        }
        else {
            callback(null, new PaginatedResult(this, items, relParams));
        }
    };
    return PaginatedResource;
}());
var PaginatedResult = /** @class */ (function () {
    function PaginatedResult(resource, items, relParams) {
        var _this = this;
        this.resource = resource;
        this.items = items;
        var self = this;
        if (relParams) {
            if ('first' in relParams) {
                this.first = function (callback) {
                    if (!callback && self.resource.rest.options.promises) {
                        return Utils.promisify(self, 'first', []);
                    }
                    self.get(relParams.first, callback);
                };
            }
            if ('current' in relParams) {
                this.current = function (callback) {
                    if (!callback && self.resource.rest.options.promises) {
                        return Utils.promisify(self, 'current', []);
                    }
                    self.get(relParams.current, callback);
                };
            }
            this.next = function (callback) {
                if (!callback && self.resource.rest.options.promises) {
                    return Utils.promisify(self, 'next', []);
                }
                if ('next' in relParams) {
                    self.get(relParams.next, callback);
                }
                else {
                    callback(null);
                }
            };
            this.hasNext = function () {
                return 'next' in relParams;
            };
            this.isLast = function () {
                var _a;
                return !((_a = _this.hasNext) === null || _a === void 0 ? void 0 : _a.call(_this));
            };
        }
    }
    /* We assume that only the initial request can be a POST, and that accessing
     * the rest of a multipage set of results can always be done with GET */
    PaginatedResult.prototype.get = function (params, callback) {
        var res = this.resource;
        resource_1.default.get(res.rest, res.path, res.headers, params, res.envelope, function (err, body, headers, unpacked, statusCode) {
            res.handlePage(err, body, headers, unpacked, statusCode, callback);
        });
    };
    return PaginatedResult;
}());
exports.PaginatedResult = PaginatedResult;
var HttpPaginatedResponse = /** @class */ (function (_super) {
    tslib_1.__extends(HttpPaginatedResponse, _super);
    function HttpPaginatedResponse(resource, items, headers, statusCode, relParams, err) {
        var _this = _super.call(this, resource, items, relParams) || this;
        _this.statusCode = statusCode;
        _this.success = statusCode < 300 && statusCode >= 200;
        _this.headers = headers;
        _this.errorCode = err && err.code;
        _this.errorMessage = err && err.message;
        return _this;
    }
    HttpPaginatedResponse.prototype.toJSON = function () {
        return {
            items: this.items,
            statusCode: this.statusCode,
            success: this.success,
            headers: this.headers,
            errorCode: this.errorCode,
            errorMessage: this.errorMessage,
        };
    };
    return HttpPaginatedResponse;
}(PaginatedResult));
exports.HttpPaginatedResponse = HttpPaginatedResponse;
exports.default = PaginatedResource;


/***/ }),
/* 20 */
/***/ (function(module, exports, __nested_webpack_require_208317__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isRetriable = void 0;
var tslib_1 = __nested_webpack_require_208317__(0);
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_208317__(4));
var ConnectionErrorCodes = {
    DISCONNECTED: 80003,
    SUSPENDED: 80002,
    FAILED: 80000,
    CLOSING: 80017,
    CLOSED: 80017,
    UNKNOWN_CONNECTION_ERR: 50002,
    UNKNOWN_CHANNEL_ERR: 50001,
};
var ConnectionErrors = {
    disconnected: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 400,
            code: ConnectionErrorCodes.DISCONNECTED,
            message: 'Connection to server temporarily unavailable',
        });
    },
    suspended: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 400,
            code: ConnectionErrorCodes.SUSPENDED,
            message: 'Connection to server unavailable',
        });
    },
    failed: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 400,
            code: ConnectionErrorCodes.FAILED,
            message: 'Connection failed or disconnected by server',
        });
    },
    closing: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 400,
            code: ConnectionErrorCodes.CLOSING,
            message: 'Connection closing',
        });
    },
    closed: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 400,
            code: ConnectionErrorCodes.CLOSED,
            message: 'Connection closed',
        });
    },
    unknownConnectionErr: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 500,
            code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,
            message: 'Internal connection error',
        });
    },
    unknownChannelErr: function () {
        return errorinfo_1.default.fromValues({
            statusCode: 500,
            code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,
            message: 'Internal channel error',
        });
    },
};
function isRetriable(err) {
    if (!err.statusCode || !err.code || err.statusCode >= 500) {
        return true;
    }
    return Object.values(ConnectionErrorCodes).includes(err.code);
}
exports.isRetriable = isRetriable;
exports.default = ConnectionErrors;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var XHRStates;
(function (XHRStates) {
    XHRStates[XHRStates["REQ_SEND"] = 0] = "REQ_SEND";
    XHRStates[XHRStates["REQ_RECV"] = 1] = "REQ_RECV";
    XHRStates[XHRStates["REQ_RECV_POLL"] = 2] = "REQ_RECV_POLL";
    XHRStates[XHRStates["REQ_RECV_STREAM"] = 3] = "REQ_RECV_STREAM";
})(XHRStates || (XHRStates = {}));
exports.default = XHRStates;


/***/ }),
/* 22 */
/***/ (function(module, exports, __nested_webpack_require_211239__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_211239__(6), __nested_webpack_require_211239__(5), __nested_webpack_require_211239__(58), __nested_webpack_require_211239__(11), __nested_webpack_require_211239__(40), __nested_webpack_require_211239__(32), __nested_webpack_require_211239__(24), __nested_webpack_require_211239__(27), __nested_webpack_require_211239__(28), __nested_webpack_require_211239__(59), __nested_webpack_require_211239__(60));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS;

}));

/***/ }),
/* 23 */
/***/ (function(module, exports, __nested_webpack_require_211750__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_211750__(0);
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_211750__(2));
var Multicaster = /** @class */ (function () {
    // Private constructor; use static Multicaster.create instead
    function Multicaster(members) {
        this.members = members || [];
    }
    Multicaster.prototype.call = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        for (var _a = 0, _b = this.members; _a < _b.length; _a++) {
            var member = _b[_a];
            if (member) {
                try {
                    member.apply(void 0, args);
                }
                catch (e) {
                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Multicaster multiple callback handler', 'Unexpected exception: ' + e + '; stack = ' + e.stack);
                }
            }
        }
    };
    Multicaster.prototype.push = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        (_a = this.members).push.apply(_a, args);
    };
    Multicaster.create = function (members) {
        var instance = new Multicaster(members);
        return Object.assign(function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return instance.call.apply(instance, args);
        }, {
            push: function (fn) { return instance.push(fn); },
        });
    };
    return Multicaster;
}());
exports.default = Multicaster;


/***/ }),
/* 24 */
/***/ (function(module, exports, __nested_webpack_require_213579__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_213579__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isSuccessCode = void 0;
var HttpStatusCodes;
(function (HttpStatusCodes) {
    HttpStatusCodes[HttpStatusCodes["Success"] = 200] = "Success";
    HttpStatusCodes[HttpStatusCodes["NoContent"] = 204] = "NoContent";
    HttpStatusCodes[HttpStatusCodes["BadRequest"] = 400] = "BadRequest";
    HttpStatusCodes[HttpStatusCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpStatusCodes[HttpStatusCodes["Forbidden"] = 403] = "Forbidden";
    HttpStatusCodes[HttpStatusCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpStatusCodes[HttpStatusCodes["InternalServerError"] = 500] = "InternalServerError";
})(HttpStatusCodes || (HttpStatusCodes = {}));
function isSuccessCode(statusCode) {
    return statusCode >= HttpStatusCodes.Success && statusCode < HttpStatusCodes.BadRequest;
}
exports.isSuccessCode = isSuccessCode;
exports.default = HttpStatusCodes;


/***/ }),
/* 26 */
/***/ (function(module, exports, __nested_webpack_require_218497__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_218497__(0);
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_218497__(10));
var Utils = tslib_1.__importStar(__nested_webpack_require_218497__(1));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_218497__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_218497__(2));
var connectionerrors_1 = tslib_1.__importDefault(__nested_webpack_require_218497__(20));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_218497__(4));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_218497__(3));
var actions = protocolmessage_1.default.Action;
var closeMessage = protocolmessage_1.default.fromValues({ action: actions.CLOSE });
var disconnectMessage = protocolmessage_1.default.fromValues({ action: actions.DISCONNECT });
/*
 * Transport instances inherit from EventEmitter and emit the following events:
 *
 * event name       data
 * closed           error
 * failed           error
 * disposed
 * connected        null error, connectionSerial, connectionId, connectionDetails
 * event            channel message object
 */
var Transport = /** @class */ (function (_super) {
    tslib_1.__extends(Transport, _super);
    function Transport(connectionManager, auth, params, forceJsonProtocol) {
        var _this = _super.call(this) || this;
        if (forceJsonProtocol) {
            params.format = undefined;
            params.heartbeats = true;
        }
        _this.connectionManager = connectionManager;
        connectionManager.registerProposedTransport(_this);
        _this.auth = auth;
        _this.params = params;
        _this.timeouts = params.options.timeouts;
        _this.format = params.format;
        _this.isConnected = false;
        _this.isFinished = false;
        _this.isDisposed = false;
        _this.maxIdleInterval = null;
        _this.idleTimer = null;
        _this.lastActivity = null;
        return _this;
    }
    Transport.prototype.connect = function () { };
    Transport.prototype.close = function () {
        if (this.isConnected) {
            this.requestClose();
        }
        this.finish('closed', connectionerrors_1.default.closed());
    };
    Transport.prototype.disconnect = function (err) {
        /* Used for network/transport issues that need to result in the transport
         * being disconnected, but should not transition the connection to 'failed' */
        if (this.isConnected) {
            this.requestDisconnect();
        }
        this.finish('disconnected', err || connectionerrors_1.default.disconnected());
    };
    Transport.prototype.fail = function (err) {
        /* Used for client-side-detected fatal connection issues */
        if (this.isConnected) {
            this.requestDisconnect();
        }
        this.finish('failed', err || connectionerrors_1.default.failed());
    };
    Transport.prototype.finish = function (event, err) {
        var _a;
        if (this.isFinished) {
            return;
        }
        this.isFinished = true;
        this.isConnected = false;
        this.maxIdleInterval = null;
        clearTimeout((_a = this.idleTimer) !== null && _a !== void 0 ? _a : undefined);
        this.idleTimer = null;
        this.emit(event, err);
        this.dispose();
    };
    Transport.prototype.onProtocolMessage = function (message) {
        if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Transport.onProtocolMessage()', 'received on ' +
                this.shortName +
                ': ' +
                protocolmessage_1.default.stringify(message) +
                '; connectionId = ' +
                this.connectionManager.connectionId);
        }
        this.onActivity();
        switch (message.action) {
            case actions.HEARTBEAT:
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Transport.onProtocolMessage()', this.shortName + ' heartbeat; connectionId = ' + this.connectionManager.connectionId);
                this.emit('heartbeat', message.id);
                break;
            case actions.CONNECTED:
                this.onConnect(message);
                this.emit('connected', message.error, message.connectionId, message.connectionDetails, message);
                break;
            case actions.CLOSED:
                this.onClose(message);
                break;
            case actions.DISCONNECTED:
                this.onDisconnect(message);
                break;
            case actions.ACK:
                this.emit('ack', message.msgSerial, message.count);
                break;
            case actions.NACK:
                this.emit('nack', message.msgSerial, message.count, message.error);
                break;
            case actions.SYNC:
                this.connectionManager.onChannelMessage(message, this);
                break;
            case actions.ACTIVATE:
                // Ignored.
                break;
            case actions.AUTH:
                this.auth.authorize(function (err) {
                    if (err) {
                        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Transport.onProtocolMessage()', 'Ably requested re-authentication, but unable to obtain a new token: ' + Utils.inspectError(err));
                    }
                });
                break;
            case actions.ERROR:
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.onProtocolMessage()', 'received error action; connectionId = ' +
                    this.connectionManager.connectionId +
                    '; err = ' +
                    platform_1.default.Config.inspect(message.error) +
                    (message.channel ? ', channel: ' + message.channel : ''));
                if (message.channel === undefined) {
                    this.onFatalError(message);
                    break;
                }
                /* otherwise it's a channel-specific error, so handle it in the channel */
                this.connectionManager.onChannelMessage(message, this);
                break;
            default:
                /* all other actions are channel-specific */
                this.connectionManager.onChannelMessage(message, this);
        }
    };
    Transport.prototype.onConnect = function (message) {
        this.isConnected = true;
        if (!message.connectionDetails) {
            throw new Error('Transport.onConnect(): Connect message recieved without connectionDetails');
        }
        var maxPromisedIdle = message.connectionDetails.maxIdleInterval;
        if (maxPromisedIdle) {
            this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;
            this.onActivity();
        }
        /* else Realtime declines to guarantee any maximum idle interval - CD2h */
    };
    Transport.prototype.onDisconnect = function (message) {
        /* Used for when the server has disconnected the client (usually with a
         * DISCONNECTED action) */
        var err = message && message.error;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.onDisconnect()', 'err = ' + Utils.inspectError(err));
        this.finish('disconnected', err);
    };
    Transport.prototype.onFatalError = function (message) {
        /* On receipt of a fatal connection error, we can assume that the server
         * will close the connection and the transport, and do not need to request
         * a disconnection - RTN15i */
        var err = message && message.error;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.onFatalError()', 'err = ' + Utils.inspectError(err));
        this.finish('failed', err);
    };
    Transport.prototype.onClose = function (message) {
        var err = message && message.error;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.onClose()', 'err = ' + Utils.inspectError(err));
        this.finish('closed', err);
    };
    Transport.prototype.requestClose = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.requestClose()', '');
        this.send(closeMessage);
    };
    Transport.prototype.requestDisconnect = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.requestDisconnect()', '');
        this.send(disconnectMessage);
    };
    Transport.prototype.ping = function (id) {
        var msg = { action: protocolmessage_1.default.Action.HEARTBEAT };
        if (id)
            msg.id = id;
        this.send(protocolmessage_1.default.fromValues(msg));
    };
    Transport.prototype.dispose = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.dispose()', '');
        this.isDisposed = true;
        this.off();
    };
    Transport.prototype.onActivity = function () {
        if (!this.maxIdleInterval) {
            return;
        }
        this.lastActivity = this.connectionManager.lastActivity = Utils.now();
        this.setIdleTimer(this.maxIdleInterval + 100);
    };
    Transport.prototype.setIdleTimer = function (timeout) {
        var _this = this;
        if (!this.idleTimer) {
            this.idleTimer = setTimeout(function () {
                _this.onIdleTimerExpire();
            }, timeout);
        }
    };
    Transport.prototype.onIdleTimerExpire = function () {
        if (!this.lastActivity || !this.maxIdleInterval) {
            throw new Error('Transport.onIdleTimerExpire(): lastActivity/maxIdleInterval not set');
        }
        this.idleTimer = null;
        var sinceLast = Utils.now() - this.lastActivity;
        var timeRemaining = this.maxIdleInterval - sinceLast;
        if (timeRemaining <= 0) {
            var msg = 'No activity seen from realtime in ' + sinceLast + 'ms; assuming connection has dropped';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Transport.onIdleTimerExpire()', msg);
            this.disconnect(new errorinfo_1.default(msg, 80003, 408));
        }
        else {
            this.setIdleTimer(timeRemaining + 100);
        }
    };
    Transport.tryConnect = function (transportCtor, connectionManager, auth, transportParams, callback) {
        var transport = new transportCtor(connectionManager, auth, transportParams);
        var transportAttemptTimer;
        var errorCb = function (err) {
            clearTimeout(transportAttemptTimer);
            callback({ event: this.event, error: err });
        };
        var realtimeRequestTimeout = connectionManager.options.timeouts.realtimeRequestTimeout;
        transportAttemptTimer = setTimeout(function () {
            transport.off(['preconnect', 'disconnected', 'failed']);
            transport.dispose();
            errorCb.call({ event: 'disconnected' }, new errorinfo_1.default('Timeout waiting for transport to indicate itself viable', 50000, 500));
        }, realtimeRequestTimeout);
        transport.on(['failed', 'disconnected'], errorCb);
        transport.on('preconnect', function () {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.tryConnect()', 'viable transport ' + transport);
            clearTimeout(transportAttemptTimer);
            transport.off(['failed', 'disconnected'], errorCb);
            callback(null, transport);
        });
        transport.connect();
    };
    return Transport;
}(eventemitter_1.default));
exports.default = Transport;


/***/ }),
/* 27 */
/***/ (function(module, exports, __nested_webpack_require_230082__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_230082__(6), __nested_webpack_require_230082__(40), __nested_webpack_require_230082__(24));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            var block;

	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));

/***/ }),
/* 28 */
/***/ (function(module, exports, __nested_webpack_require_233971__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_233971__(6), __nested_webpack_require_233971__(27));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            var block;

	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            var modeCreator;

	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            var finalProcessedBlocks;

	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            var wordArray;

	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            var salt;

	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));

/***/ }),
/* 29 */
/***/ (function(module, exports, __nested_webpack_require_263517__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Request = exports.createRequest = void 0;
var tslib_1 = __nested_webpack_require_263517__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_263517__(1));
var comettransport_1 = tslib_1.__importDefault(__nested_webpack_require_263517__(12));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_263517__(3));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_263517__(7));
var errorinfo_1 = __nested_webpack_require_263517__(4);
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_263517__(8));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_263517__(2));
var XHRStates_1 = tslib_1.__importDefault(__nested_webpack_require_263517__(21));
// Workaround for salesforce lightning locker compatibility
var globalObject = Utils.getGlobalObject();
var noop = function () { };
/* Can't just use window.Ably, as that won't exist if using the commonjs version. */
var _ = (globalObject._ablyjs_jsonp = {});
/* express strips out parantheses from the callback!
 * Kludge to still alow its responses to work, while not keeping the
 * function form for normal use and not cluttering window.Ably
 * https://github.com/expressjs/express/blob/5b4d4b4ab1324743534fbcd4709f4e75bb4b4e9d/lib/response.js#L305
 */
_._ = function (id) {
    return _['_' + id] || noop;
};
var idCounter = 1;
var shortName = 'jsonp';
function createRequest(uri, headers, params, body, requestMode, timeouts, method) {
    /* JSONP requests are used either with the context being a realtime
     * transport, or with timeouts passed in (for when used by a rest client),
     * or completely standalone.  Use the appropriate timeouts in each case */
    timeouts = timeouts || defaults_1.default.TIMEOUTS;
    return new Request(undefined, uri, headers, Utils.copy(params), body, requestMode, timeouts, method);
}
exports.createRequest = createRequest;
var JSONPTransport = /** @class */ (function (_super) {
    tslib_1.__extends(JSONPTransport, _super);
    function JSONPTransport(connectionManager, auth, params) {
        var _this = _super.call(this, connectionManager, auth, params) || this;
        _this.shortName = shortName;
        params.stream = false;
        return _this;
    }
    JSONPTransport.isAvailable = function () {
        return platform_1.default.Config.jsonpSupported && platform_1.default.Config.allowComet;
    };
    JSONPTransport.prototype.toString = function () {
        return 'JSONPTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
    };
    JSONPTransport.prototype.createRequest = function (uri, headers, params, body, requestMode, timeouts, method) {
        /* JSONP requests are used either with the context being a realtime
         * transport, or with timeouts passed in (for when used by a rest client),
         * or completely standalone.  Use the appropriate timeouts in each case */
        timeouts = (this === null || this === void 0 ? void 0 : this.timeouts) || timeouts || defaults_1.default.TIMEOUTS;
        return createRequest(uri, headers, params, body, requestMode, timeouts, method);
    };
    return JSONPTransport;
}(comettransport_1.default));
var Request = /** @class */ (function (_super) {
    tslib_1.__extends(Request, _super);
    function Request(id, uri, headers, params, body, requestMode, timeouts, method) {
        var _this = _super.call(this) || this;
        if (id === undefined)
            id = idCounter++;
        _this.id = id;
        _this.uri = uri;
        _this.params = params || {};
        _this.params.rnd = Utils.cheapRandStr();
        if (headers) {
            /* JSONP doesn't allow headers. Cherry-pick a couple to turn into qs params */
            if (headers['X-Ably-Version'])
                _this.params.v = headers['X-Ably-Version'];
            if (headers['X-Ably-Lib'])
                _this.params.lib = headers['X-Ably-Lib'];
        }
        _this.body = body;
        _this.method = method;
        _this.requestMode = requestMode;
        _this.timeouts = timeouts;
        _this.requestComplete = false;
        return _this;
    }
    Request.prototype.exec = function () {
        var _this = this;
        var id = this.id, body = this.body, method = this.method, uri = this.uri, params = this.params;
        params.callback = '_ablyjs_jsonp._(' + id + ')';
        params.envelope = 'jsonp';
        if (body) {
            params.body = body;
        }
        if (method && method !== 'get') {
            params.method = method;
        }
        var script = (this.script = document.createElement('script'));
        var src = uri + Utils.toQueryString(params);
        script.src = src;
        if (script.src.split('/').slice(-1)[0] !== src.split('/').slice(-1)[0]) {
            /* The src has been truncated. Can't abort, but can at least emit an
             * error so the user knows what's gone wrong. (Can't compare strings
             * directly as src may have a port, script.src won't) */
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'JSONP Request.exec()', 'Warning: the browser appears to have truncated the script URI. This will likely result in the request failing due to an unparseable body param');
        }
        script.async = true;
        script.type = 'text/javascript';
        script.charset = 'UTF-8';
        script.onerror = function (err) {
            _this.complete(new errorinfo_1.PartialErrorInfo('JSONP script error (event: ' + platform_1.default.Config.inspect(err) + ')', null, 400));
        };
        _['_' + id] = function (message) {
            if (message.statusCode) {
                /* Handle as enveloped jsonp, as all jsonp transport uses should be */
                var response = message.response;
                if (message.statusCode == 204) {
                    _this.complete(null, null, null, message.statusCode);
                }
                else if (!response) {
                    _this.complete(new errorinfo_1.PartialErrorInfo('Invalid server response: no envelope detected', null, 500));
                }
                else if (message.statusCode < 400 || Utils.isArray(response)) {
                    /* If response is an array, it's an array of protocol messages -- even if
                     * it contains an error action (hence the nonsuccess statuscode), we can
                     * consider the request to have succeeded, just pass it on to
                     * onProtocolMessage to decide what to do */
                    _this.complete(null, response, message.headers, message.statusCode);
                }
                else {
                    var err = response.error || new errorinfo_1.PartialErrorInfo('Error response received from server', null, message.statusCode);
                    _this.complete(err);
                }
            }
            else {
                /* Handle as non-enveloped -- as will be eg from a customer's authUrl server */
                _this.complete(null, message);
            }
        };
        var timeout = this.requestMode == XHRStates_1.default.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout;
        this.timer = setTimeout(this.abort.bind(this), timeout);
        var head = document.getElementsByTagName('head')[0];
        head.insertBefore(script, head.firstChild);
    };
    Request.prototype.complete = function (err, body, headers, statusCode) {
        headers = headers || {};
        if (!this.requestComplete) {
            this.requestComplete = true;
            var contentType = void 0;
            if (body) {
                contentType = typeof body == 'string' ? 'text/plain' : 'application/json';
                headers['content-type'] = contentType;
                this.emit('data', body);
            }
            this.emit('complete', err, body, headers, /* unpacked: */ true, statusCode);
            this.dispose();
        }
    };
    Request.prototype.abort = function () {
        this.dispose();
    };
    Request.prototype.dispose = function () {
        var timer = this.timer;
        if (timer) {
            clearTimeout(timer);
            this.timer = null;
        }
        var script = this.script;
        if (script.parentNode)
            script.parentNode.removeChild(script);
        delete _[this.id];
        this.emit('disposed');
    };
    return Request;
}(eventemitter_1.default));
exports.Request = Request;
function default_1(connectionManager) {
    globalObject.JSONPTransport = JSONPTransport;
    if (JSONPTransport.isAvailable()) {
        connectionManager.supportedTransports[shortName] = JSONPTransport;
    }
    return JSONPTransport;
}
exports.default = default_1;


/***/ }),
/* 30 */
/***/ (function(module, exports, __nested_webpack_require_272270__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_272270__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_272270__(1));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(2));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(8));
var auth_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(17));
var push_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(46));
var paginatedresource_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(19));
var channel_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(33));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(4));
var stats_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(49));
var HttpMethods_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(18));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(3));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(9));
var presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(15));
var resource_1 = tslib_1.__importDefault(__nested_webpack_require_272270__(14));
var noop = function () { };
var Rest = /** @class */ (function () {
    function Rest(options) {
        if (!options) {
            var msg = 'no options provided';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Rest()', msg);
            throw new Error(msg);
        }
        var optionsObj = defaults_1.default.objectifyOptions(options);
        if (optionsObj.log) {
            logger_1.default.setLog(optionsObj.log.level, optionsObj.log.handler);
        }
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Rest()', 'initialized with clientOptions ' + platform_1.default.Config.inspect(options));
        var normalOptions = (this.options = defaults_1.default.normaliseOptions(optionsObj));
        /* process options */
        if (normalOptions.key) {
            var keyMatch = normalOptions.key.match(/^([^:\s]+):([^:.\s]+)$/);
            if (!keyMatch) {
                var msg = 'invalid key parameter';
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Rest()', msg);
                throw new errorinfo_1.default(msg, 40400, 404);
            }
            normalOptions.keyName = keyMatch[1];
            normalOptions.keySecret = keyMatch[2];
        }
        if ('clientId' in normalOptions) {
            if (!(typeof normalOptions.clientId === 'string' || normalOptions.clientId === null))
                throw new errorinfo_1.default('clientId must be either a string or null', 40012, 400);
            else if (normalOptions.clientId === '*')
                throw new errorinfo_1.default('Canâ€™t use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: "*"}})', 40012, 400);
        }
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Rest()', 'started; version = ' + defaults_1.default.version);
        this.baseUri = this.authority = function (host) {
            return defaults_1.default.getHttpScheme(normalOptions) + host + ':' + defaults_1.default.getPort(normalOptions, false);
        };
        this._currentFallback = null;
        this.serverTimeOffset = null;
        this.http = new platform_1.default.Http(normalOptions);
        this.auth = new auth_1.default(this, normalOptions);
        this.channels = new Channels(this);
        this.push = new push_1.default(this);
    }
    Rest.prototype.stats = function (params, callback) {
        /* params and callback are optional; see if params contains the callback */
        if (callback === undefined) {
            if (typeof params == 'function') {
                callback = params;
                params = null;
            }
            else {
                if (this.options.promises) {
                    return Utils.promisify(this, 'stats', [params]);
                }
                callback = noop;
            }
        }
        var headers = Utils.defaultGetHeaders(this.options), format = this.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.http.supportsLinkHeaders ? undefined : format;
        if (this.options.headers)
            Utils.mixin(headers, this.options.headers);
        new paginatedresource_1.default(this, '/stats', headers, envelope, function (body, headers, unpacked) {
            var statsValues = unpacked ? body : JSON.parse(body);
            for (var i = 0; i < statsValues.length; i++)
                statsValues[i] = stats_1.default.fromValues(statsValues[i]);
            return statsValues;
        }).get(params, callback);
    };
    Rest.prototype.time = function (params, callback) {
        var _this = this;
        /* params and callback are optional; see if params contains the callback */
        if (callback === undefined) {
            if (typeof params == 'function') {
                callback = params;
                params = null;
            }
            else {
                if (this.options.promises) {
                    return Utils.promisify(this, 'time', [params]);
                }
            }
        }
        var _callback = callback || noop;
        var headers = Utils.defaultGetHeaders(this.options);
        if (this.options.headers)
            Utils.mixin(headers, this.options.headers);
        var timeUri = function (host) {
            return _this.authority(host) + '/time';
        };
        this.http.do(HttpMethods_1.default.Get, this, timeUri, headers, null, params, function (err, res, headers, unpacked) {
            if (err) {
                _callback(err);
                return;
            }
            if (!unpacked)
                res = JSON.parse(res);
            var time = res[0];
            if (!time) {
                _callback(new errorinfo_1.default('Internal error (unexpected result type from GET /time)', 50000, 500));
                return;
            }
            /* calculate time offset only once for this device by adding to the prototype */
            _this.serverTimeOffset = time - Utils.now();
            _callback(null, time);
        });
    };
    Rest.prototype.request = function (method, path, params, body, customHeaders, callback) {
        var useBinary = this.options.useBinaryProtocol, encoder = useBinary ? platform_1.default.Config.msgpack.encode : JSON.stringify, decoder = useBinary ? platform_1.default.Config.msgpack.decode : JSON.parse, format = useBinary ? Utils.Format.msgpack : Utils.Format.json, envelope = this.http.supportsLinkHeaders ? undefined : format;
        params = params || {};
        var _method = method.toLowerCase();
        var headers = _method == 'get' ? Utils.defaultGetHeaders(this.options, format) : Utils.defaultPostHeaders(this.options, format);
        if (callback === undefined) {
            if (this.options.promises) {
                return Utils.promisify(this, 'request', [method, path, params, body, customHeaders]);
            }
            callback = noop;
        }
        if (typeof body !== 'string') {
            body = encoder(body);
        }
        if (this.options.headers) {
            Utils.mixin(headers, this.options.headers);
        }
        if (customHeaders) {
            Utils.mixin(headers, customHeaders);
        }
        var paginatedResource = new paginatedresource_1.default(this, path, headers, envelope, function (resbody, headers, unpacked) {
            return Utils.ensureArray(unpacked ? resbody : decoder(resbody));
        }, 
        /* useHttpPaginatedResponse: */ true);
        if (!Utils.arrIn(platform_1.default.Http.methods, _method)) {
            throw new errorinfo_1.default('Unsupported method ' + _method, 40500, 405);
        }
        if (Utils.arrIn(platform_1.default.Http.methodsWithBody, _method)) {
            paginatedResource[_method](params, body, callback);
        }
        else {
            paginatedResource[_method](params, callback);
        }
    };
    Rest.prototype.batchPublish = function (specOrSpecs, callbackArg) {
        if (callbackArg === undefined) {
            if (this.options.promises) {
                return Utils.promisify(this, 'batchPublish', [specOrSpecs]);
            }
            callbackArg = noop;
        }
        var callback = callbackArg;
        var requestBodyDTO;
        var singleSpecMode;
        if (Utils.isArray(specOrSpecs)) {
            requestBodyDTO = specOrSpecs;
            singleSpecMode = false;
        }
        else {
            requestBodyDTO = [specOrSpecs];
            singleSpecMode = true;
        }
        var format = this.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(this.options, format);
        if (this.options.headers)
            Utils.mixin(headers, this.options.headers);
        var requestBody = Utils.encodeBody(requestBodyDTO, format);
        resource_1.default.post(this, '/messages', requestBody, headers, { newBatchResponse: 'true' }, null, function (err, body, headers, unpacked) {
            if (err) {
                // TODO remove this type assertion after fixing https://github.com/ably/ably-js/issues/1405
                callback(err);
                return;
            }
            var batchResults = (unpacked ? body : Utils.decodeBody(body, format));
            // I don't love the below type assertions for `callback` but not sure how to avoid them
            if (singleSpecMode) {
                callback(null, batchResults[0]);
            }
            else {
                callback(null, batchResults);
            }
        });
    };
    Rest.prototype.batchPresence = function (channels, callbackArg) {
        if (callbackArg === undefined) {
            if (this.options.promises) {
                return Utils.promisify(this, 'batchPresence', [channels]);
            }
            callbackArg = noop;
        }
        var callback = callbackArg;
        var format = this.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(this.options, format);
        if (this.options.headers)
            Utils.mixin(headers, this.options.headers);
        var channelsParam = channels.join(',');
        resource_1.default.get(this, '/presence', headers, { newBatchResponse: 'true', channels: channelsParam }, null, function (err, body, headers, unpacked) {
            if (err) {
                // TODO remove this type assertion after fixing https://github.com/ably/ably-js/issues/1405
                callback(err);
                return;
            }
            var batchResult = (unpacked ? body : Utils.decodeBody(body, format));
            callback(null, batchResult);
        });
    };
    Rest.prototype.setLog = function (logOptions) {
        logger_1.default.setLog(logOptions.level, logOptions.handler);
    };
    Rest.Promise = function (options) {
        options = defaults_1.default.objectifyOptions(options);
        options.promises = true;
        return new Rest(options);
    };
    Rest.Callbacks = Rest;
    Rest.Platform = platform_1.default;
    Rest.Message = message_1.default;
    Rest.PresenceMessage = presencemessage_1.default;
    return Rest;
}());
var Channels = /** @class */ (function () {
    function Channels(rest) {
        this.rest = rest;
        this.all = Object.create(null);
    }
    Channels.prototype.get = function (name, channelOptions) {
        name = String(name);
        var channel = this.all[name];
        if (!channel) {
            this.all[name] = channel = new channel_1.default(this.rest, name, channelOptions);
        }
        else if (channelOptions) {
            channel.setOptions(channelOptions);
        }
        return channel;
    };
    /* Included to support certain niche use-cases; most users should ignore this.
     * Please do not use this unless you know what you're doing */
    Channels.prototype.release = function (name) {
        delete this.all[String(name)];
    };
    return Channels;
}());
exports.default = Rest;


/***/ }),
/* 31 */
/***/ (function(module, exports, __nested_webpack_require_284415__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_284415__(6));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Utf8;

}));

/***/ }),
/* 32 */
/***/ (function(module, exports, __nested_webpack_require_284686__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_284686__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));

/***/ }),
/* 33 */
/***/ (function(module, exports, __nested_webpack_require_290135__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_290135__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_290135__(1));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(2));
var presence_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(34));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(9));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(4));
var paginatedresource_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(19));
var resource_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(14));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_290135__(3));
function noop() { }
var MSG_ID_ENTROPY_BYTES = 9;
function allEmptyIds(messages) {
    return Utils.arrEvery(messages, function (message) {
        return !message.id;
    });
}
function normaliseChannelOptions(options) {
    var channelOptions = options || {};
    if (channelOptions.cipher) {
        if (!platform_1.default.Crypto)
            throw new Error('Encryption not enabled; use ably.encryption.js instead');
        var cipher = platform_1.default.Crypto.getCipher(channelOptions.cipher);
        channelOptions.cipher = cipher.cipherParams;
        channelOptions.channelCipher = cipher.cipher;
    }
    else if ('cipher' in channelOptions) {
        /* Don't deactivate an existing cipher unless options
         * has a 'cipher' key that's falsey */
        channelOptions.cipher = undefined;
        channelOptions.channelCipher = null;
    }
    return channelOptions;
}
var Channel = /** @class */ (function (_super) {
    tslib_1.__extends(Channel, _super);
    function Channel(rest, name, channelOptions) {
        var _this = _super.call(this) || this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Channel()', 'started; name = ' + name);
        _this.rest = rest;
        _this.name = name;
        _this.basePath = '/channels/' + encodeURIComponent(name);
        _this.presence = new presence_1.default(_this);
        _this.channelOptions = normaliseChannelOptions(channelOptions);
        return _this;
    }
    Channel.prototype.setOptions = function (options) {
        this.channelOptions = normaliseChannelOptions(options);
    };
    Channel.prototype.history = function (params, callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Channel.history()', 'channel = ' + this.name);
        /* params and callback are optional; see if params contains the callback */
        if (callback === undefined) {
            if (typeof params == 'function') {
                callback = params;
                params = null;
            }
            else {
                if (this.rest.options.promises) {
                    return Utils.promisify(this, 'history', arguments);
                }
                callback = noop;
            }
        }
        this._history(params, callback);
    };
    Channel.prototype._history = function (params, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        var options = this.channelOptions;
        new paginatedresource_1.default(rest, this.basePath + '/messages', headers, envelope, function (body, headers, unpacked) {
            return message_1.default.fromResponseBody(body, options, unpacked ? undefined : format);
        }).get(params, callback);
    };
    Channel.prototype.publish = function () {
        var _this = this;
        var argCount = arguments.length, first = arguments[0], second = arguments[1];
        var callback = arguments[argCount - 1];
        var messages;
        var params;
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'publish', arguments);
            }
            callback = noop;
        }
        if (typeof first === 'string' || first === null) {
            /* (name, data, ...) */
            messages = [message_1.default.fromValues({ name: first, data: second })];
            params = arguments[2];
        }
        else if (Utils.isObject(first)) {
            messages = [message_1.default.fromValues(first)];
            params = arguments[1];
        }
        else if (Utils.isArray(first)) {
            messages = message_1.default.fromValuesArray(first);
            params = arguments[1];
        }
        else {
            throw new errorinfo_1.default('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);
        }
        if (typeof params !== 'object' || !params) {
            /* No params supplied (so after-message argument is just the callback or undefined) */
            params = {};
        }
        var rest = this.rest, options = rest.options, format = options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, idempotentRestPublishing = rest.options.idempotentRestPublishing, headers = Utils.defaultPostHeaders(rest.options, format);
        if (options.headers)
            Utils.mixin(headers, options.headers);
        if (idempotentRestPublishing && allEmptyIds(messages)) {
            var msgIdBase_1 = Utils.randomString(MSG_ID_ENTROPY_BYTES);
            Utils.arrForEach(messages, function (message, index) {
                message.id = msgIdBase_1 + ':' + index.toString();
            });
        }
        message_1.default.encodeArray(messages, this.channelOptions, function (err) {
            if (err) {
                callback(err);
                return;
            }
            /* RSL1i */
            var size = message_1.default.getMessagesSize(messages), maxMessageSize = options.maxMessageSize;
            if (size > maxMessageSize) {
                callback(new errorinfo_1.default('Maximum size of messages that can be published at once exceeded ( was ' +
                    size +
                    ' bytes; limit is ' +
                    maxMessageSize +
                    ' bytes)', 40009, 400));
                return;
            }
            _this._publish(message_1.default.serialize(messages, format), headers, params, callback);
        });
    };
    Channel.prototype._publish = function (requestBody, headers, params, callback) {
        resource_1.default.post(this.rest, this.basePath + '/messages', requestBody, headers, params, null, callback);
    };
    Channel.prototype.status = function (callback) {
        if (typeof callback !== 'function' && this.rest.options.promises) {
            return Utils.promisify(this, 'status', []);
        }
        var format = this.rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json;
        var headers = Utils.defaultPostHeaders(this.rest.options, format);
        resource_1.default.get(this.rest, this.basePath, headers, {}, format, callback || noop);
    };
    return Channel;
}(eventemitter_1.default));
exports.default = Channel;


/***/ }),
/* 34 */
/***/ (function(module, exports, __nested_webpack_require_297440__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_297440__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_297440__(1));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_297440__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_297440__(2));
var paginatedresource_1 = tslib_1.__importDefault(__nested_webpack_require_297440__(19));
var presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_297440__(15));
function noop() { }
var Presence = /** @class */ (function (_super) {
    tslib_1.__extends(Presence, _super);
    function Presence(channel) {
        var _this = _super.call(this) || this;
        _this.channel = channel;
        _this.basePath = channel.basePath + '/presence';
        return _this;
    }
    Presence.prototype.get = function (params, callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Presence.get()', 'channel = ' + this.channel.name);
        /* params and callback are optional; see if params contains the callback */
        if (callback === undefined) {
            if (typeof params == 'function') {
                callback = params;
                params = null;
            }
            else {
                if (this.channel.rest.options.promises) {
                    return Utils.promisify(this, 'get', arguments);
                }
                callback = noop;
            }
        }
        var rest = this.channel.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.channel.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        var options = this.channel.channelOptions;
        new paginatedresource_1.default(rest, this.basePath, headers, envelope, function (body, headers, unpacked) {
            return presencemessage_1.default.fromResponseBody(body, options, unpacked ? undefined : format);
        }).get(params, callback);
    };
    Presence.prototype.history = function (params, callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Presence.history()', 'channel = ' + this.channel.name);
        return this._history(params, callback);
    };
    Presence.prototype._history = function (params, callback) {
        /* params and callback are optional; see if params contains the callback */
        if (callback === undefined) {
            if (typeof params == 'function') {
                callback = params;
                params = null;
            }
            else {
                if (this.channel.rest.options.promises) {
                    return Utils.promisify(this, '_history', [params]);
                }
                callback = noop;
            }
        }
        var rest = this.channel.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.channel.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        var options = this.channel.channelOptions;
        new paginatedresource_1.default(rest, this.basePath + '/history', headers, envelope, function (body, headers, unpacked) {
            return presencemessage_1.default.fromResponseBody(body, options, unpacked ? undefined : format);
        }).get(params, callback);
    };
    return Presence;
}(eventemitter_1.default));
exports.default = Presence;


/***/ }),
/* 35 */
/***/ (function(module, exports, __nested_webpack_require_301120__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransportParams = void 0;
var tslib_1 = __nested_webpack_require_301120__(0);
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(10));
var Utils = tslib_1.__importStar(__nested_webpack_require_301120__(1));
var protocol_1 = tslib_1.__importStar(__nested_webpack_require_301120__(52));
var defaults_1 = tslib_1.__importStar(__nested_webpack_require_301120__(8));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(3));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(7));
var messagequeue_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(36));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(2));
var connectionstatechange_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(37));
var connectionerrors_1 = tslib_1.__importStar(__nested_webpack_require_301120__(20));
var errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_301120__(4));
var auth_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(17));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(9));
var multicaster_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(23));
var websockettransport_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(53));
var transport_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(26));
var HttpStatusCodes_1 = tslib_1.__importDefault(__nested_webpack_require_301120__(25));
var haveWebStorage = function () { var _a; return typeof platform_1.default.WebStorage !== 'undefined' && ((_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.localSupported); };
var haveSessionStorage = function () { var _a; return typeof platform_1.default.WebStorage !== 'undefined' && ((_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.sessionSupported); };
var actions = protocolmessage_1.default.Action;
var noop = function () { };
var transportPreferenceName = 'ably-transport-preference';
var sessionRecoveryName = 'ably-connection-recovery';
function getSessionRecoverData() {
    var _a, _b;
    return haveSessionStorage() && ((_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.getSession) === null || _b === void 0 ? void 0 : _b.call(_a, sessionRecoveryName));
}
function setSessionRecoverData(value) {
    var _a, _b;
    return haveSessionStorage() && ((_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.setSession) === null || _b === void 0 ? void 0 : _b.call(_a, sessionRecoveryName, value));
}
function clearSessionRecoverData() {
    var _a, _b;
    return haveSessionStorage() && ((_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.removeSession) === null || _b === void 0 ? void 0 : _b.call(_a, sessionRecoveryName));
}
function betterTransportThan(a, b) {
    return (Utils.arrIndexOf(platform_1.default.Defaults.transportPreferenceOrder, a.shortName) >
        Utils.arrIndexOf(platform_1.default.Defaults.transportPreferenceOrder, b.shortName));
}
function bundleWith(dest, src, maxSize) {
    var action;
    if (dest.channel !== src.channel) {
        /* RTL6d3 */
        return false;
    }
    if ((action = dest.action) !== actions.PRESENCE && action !== actions.MESSAGE) {
        /* RTL6d - can only bundle messages or presence */
        return false;
    }
    if (action !== src.action) {
        /* RTL6d4 */
        return false;
    }
    var kind = action === actions.PRESENCE ? 'presence' : 'messages', proposed = dest[kind].concat(src[kind]), size = message_1.default.getMessagesSize(proposed);
    if (size > maxSize) {
        /* RTL6d1 */
        return false;
    }
    if (!Utils.allSame(proposed, 'clientId')) {
        /* RTL6d2 */
        return false;
    }
    if (!Utils.arrEvery(proposed, function (msg) {
        return !msg.id;
    })) {
        /* RTL6d7 */
        return false;
    }
    /* we're good to go! */
    dest[kind] = proposed;
    return true;
}
function decodeRecoveryKey(recoveryKey) {
    try {
        return JSON.parse(recoveryKey);
    }
    catch (e) {
        return null;
    }
}
var TransportParams = /** @class */ (function () {
    function TransportParams(options, host, mode, connectionKey) {
        this.options = options;
        this.host = host;
        this.mode = mode;
        this.connectionKey = connectionKey;
        this.format = options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json;
    }
    TransportParams.prototype.getConnectParams = function (authParams) {
        var params = authParams ? Utils.copy(authParams) : {};
        var options = this.options;
        switch (this.mode) {
            case 'upgrade':
                params.upgrade = this.connectionKey;
                break;
            case 'resume':
                params.resume = this.connectionKey;
                break;
            case 'recover': {
                var recoveryContext = decodeRecoveryKey(options.recover);
                if (recoveryContext) {
                    params.recover = recoveryContext.connectionKey;
                }
                break;
            }
            default:
        }
        if (options.clientId !== undefined) {
            params.clientId = options.clientId;
        }
        if (options.echoMessages === false) {
            params.echo = 'false';
        }
        if (this.format !== undefined) {
            params.format = this.format;
        }
        if (this.stream !== undefined) {
            params.stream = this.stream;
        }
        if (this.heartbeats !== undefined) {
            params.heartbeats = this.heartbeats;
        }
        params.v = defaults_1.default.protocolVersion;
        params.agent = encodeURIComponent((0, defaults_1.getAgentString)(this.options));
        if (options.transportParams !== undefined) {
            Utils.mixin(params, options.transportParams);
        }
        return params;
    };
    TransportParams.prototype.toString = function () {
        var result = '[mode=' + this.mode;
        if (this.host) {
            result += ',host=' + this.host;
        }
        if (this.connectionKey) {
            result += ',connectionKey=' + this.connectionKey;
        }
        if (this.format) {
            result += ',format=' + this.format;
        }
        result += ']';
        return result;
    };
    return TransportParams;
}());
exports.TransportParams = TransportParams;
var ConnectionManager = /** @class */ (function (_super) {
    tslib_1.__extends(ConnectionManager, _super);
    function ConnectionManager(realtime, options) {
        var _this = _super.call(this) || this;
        _this.disconnectedRetryCount = 0;
        ConnectionManager.initTransports();
        _this.realtime = realtime;
        _this.options = options;
        var timeouts = options.timeouts;
        /* connectingTimeout: leave preferenceConnectTimeout (~6s) to try the
         * preference transport, then realtimeRequestTimeout (~10s) to establish
         * the base transport in case that fails */
        var connectingTimeout = timeouts.preferenceConnectTimeout + timeouts.realtimeRequestTimeout;
        _this.states = {
            initialized: {
                state: 'initialized',
                terminal: false,
                queueEvents: true,
                sendEvents: false,
                failState: 'disconnected',
            },
            connecting: {
                state: 'connecting',
                terminal: false,
                queueEvents: true,
                sendEvents: false,
                retryDelay: connectingTimeout,
                failState: 'disconnected',
            },
            connected: {
                state: 'connected',
                terminal: false,
                queueEvents: false,
                sendEvents: true,
                failState: 'disconnected',
            },
            synchronizing: {
                state: 'connected',
                terminal: false,
                queueEvents: true,
                sendEvents: false,
                forceQueueEvents: true,
                failState: 'disconnected',
            },
            disconnected: {
                state: 'disconnected',
                terminal: false,
                queueEvents: true,
                sendEvents: false,
                retryDelay: timeouts.disconnectedRetryTimeout,
                failState: 'disconnected',
            },
            suspended: {
                state: 'suspended',
                terminal: false,
                queueEvents: false,
                sendEvents: false,
                retryDelay: timeouts.suspendedRetryTimeout,
                failState: 'suspended',
            },
            closing: {
                state: 'closing',
                terminal: false,
                queueEvents: false,
                sendEvents: false,
                retryDelay: timeouts.realtimeRequestTimeout,
                failState: 'closed',
            },
            closed: { state: 'closed', terminal: true, queueEvents: false, sendEvents: false, failState: 'closed' },
            failed: { state: 'failed', terminal: true, queueEvents: false, sendEvents: false, failState: 'failed' },
        };
        _this.state = _this.states.initialized;
        _this.errorReason = null;
        _this.queuedMessages = new messagequeue_1.default();
        _this.msgSerial = 0;
        _this.connectionDetails = undefined;
        _this.connectionId = undefined;
        _this.connectionKey = undefined;
        _this.connectionStateTtl = timeouts.connectionStateTtl;
        _this.maxIdleInterval = null;
        _this.transports = Utils.intersect(options.transports || defaults_1.default.defaultTransports, ConnectionManager.supportedTransports);
        /* baseTransports selects the leftmost transport in the Defaults.baseTransportOrder list
         * that's both requested and supported. Normally this will be xhr_polling;
         * if xhr isn't supported it will be jsonp. If the user has forced a
         * transport, it'll just be that one. */
        _this.baseTransport = Utils.intersect(defaults_1.default.baseTransportOrder, _this.transports)[0];
        _this.upgradeTransports = Utils.intersect(_this.transports, defaults_1.default.upgradeTransports);
        _this.transportPreference = null;
        _this.httpHosts = defaults_1.default.getHosts(options);
        _this.activeProtocol = null;
        _this.proposedTransports = [];
        _this.pendingTransports = [];
        _this.host = null;
        _this.lastAutoReconnectAttempt = null;
        _this.lastActivity = null;
        _this.forceFallbackHost = false;
        _this.connectCounter = 0;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Realtime.ConnectionManager()', 'started');
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Realtime.ConnectionManager()', 'requested transports = [' + (options.transports || defaults_1.default.defaultTransports) + ']');
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Realtime.ConnectionManager()', 'available transports = [' + _this.transports + ']');
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Realtime.ConnectionManager()', 'http hosts = [' + _this.httpHosts + ']');
        if (!_this.transports.length) {
            var msg = 'no requested transports available';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'realtime.ConnectionManager()', msg);
            throw new Error(msg);
        }
        var addEventListener = platform_1.default.Config.addEventListener;
        if (addEventListener) {
            /* intercept close event in browser to persist connection id if requested */
            if (haveSessionStorage() && typeof options.recover === 'function') {
                /* Usually can't use bind as not supported in IE8, but IE doesn't support sessionStorage, so... */
                addEventListener('beforeunload', _this.persistConnection.bind(_this));
            }
            if (options.closeOnUnload === true) {
                addEventListener('beforeunload', function () {
                    logger_1.default.logAction(logger_1.default.LOG_MAJOR, 'Realtime.ConnectionManager()', 'beforeunload event has triggered the connection to close as closeOnUnload is true');
                    _this.requestState({ state: 'closing' });
                });
            }
            /* Listen for online and offline events */
            addEventListener('online', function () {
                if (_this.state == _this.states.disconnected || _this.state == _this.states.suspended) {
                    logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager caught browser â€˜onlineâ€™ event', 'reattempting connection');
                    _this.requestState({ state: 'connecting' });
                }
                else if (_this.state == _this.states.connecting) {
                    // RTN20c: if 'online' event recieved while CONNECTING, abandon connection attempt and retry
                    _this.pendingTransports.forEach(function (transport) {
                        // Detach transport listeners to avoid connection state side effects from calling dispose
                        transport.off();
                    });
                    _this.disconnectAllTransports();
                    _this.startConnect();
                }
            });
            addEventListener('offline', function () {
                if (_this.state == _this.states.connected) {
                    logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager caught browser â€˜offlineâ€™ event', 'disconnecting active transport');
                    // Not sufficient to just go to the 'disconnected' state, want to
                    // force all transports to reattempt the connection. Will immediately
                    // retry.
                    _this.disconnectAllTransports();
                }
            });
        }
        return _this;
    }
    ConnectionManager.initTransports = function () {
        (0, websockettransport_1.default)(ConnectionManager);
        Utils.arrForEach(platform_1.default.Transports, function (initFn) {
            initFn(ConnectionManager);
        });
    };
    ConnectionManager.prototype.createTransportParams = function (host, mode) {
        return new TransportParams(this.options, host, mode, this.connectionKey);
    };
    ConnectionManager.prototype.getTransportParams = function (callback) {
        var _this = this;
        var decideMode = function (modeCb) {
            if (_this.connectionKey) {
                modeCb('resume');
                return;
            }
            if (typeof _this.options.recover === 'string') {
                modeCb('recover');
                return;
            }
            var recoverFn = _this.options.recover, lastSessionData = getSessionRecoverData();
            if (lastSessionData && typeof recoverFn === 'function') {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Calling clientOptions-provided recover function with last session data');
                recoverFn(lastSessionData, function (shouldRecover) {
                    if (shouldRecover) {
                        _this.options.recover = lastSessionData.recoveryKey;
                        modeCb('recover');
                    }
                    else {
                        modeCb('clean');
                    }
                });
                return;
            }
            modeCb('clean');
        };
        decideMode(function (mode) {
            var transportParams = _this.createTransportParams(null, mode);
            if (mode === 'recover') {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Transport recovery mode = recover; recoveryKey = ' + _this.options.recover);
                var recoveryContext = decodeRecoveryKey(_this.options.recover);
                if (recoveryContext) {
                    _this.msgSerial = recoveryContext.msgSerial;
                }
            }
            else {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Transport params = ' + transportParams.toString());
            }
            callback(transportParams);
        });
    };
    /**
     * Attempt to connect using a given transport
     * @param transportParams
     * @param candidate, the transport to try
     * @param callback
     */
    ConnectionManager.prototype.tryATransport = function (transportParams, candidate, callback) {
        var _this = this;
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.tryATransport()', 'trying ' + candidate);
        transport_1.default.tryConnect(ConnectionManager.supportedTransports[candidate], this, this.realtime.auth, transportParams, function (wrappedErr, transport) {
            var state = _this.state;
            if (state == _this.states.closing || state == _this.states.closed || state == _this.states.failed) {
                if (transport) {
                    logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.tryATransport()', 'connection ' + state.state + ' while we were attempting the transport; closing ' + transport);
                    transport.close();
                }
                callback(true);
                return;
            }
            if (wrappedErr) {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.tryATransport()', 'transport ' + candidate + ' ' + wrappedErr.event + ', err: ' + wrappedErr.error.toString());
                /* Comet transport onconnect token errors can be dealt with here.
                 * Websocket ones only happen after the transport claims to be viable,
                 * so are dealt with as non-onconnect token errors */
                if (auth_1.default.isTokenErr(wrappedErr.error) &&
                    !(_this.errorReason && auth_1.default.isTokenErr(_this.errorReason))) {
                    _this.errorReason = wrappedErr.error;
                    /* re-get a token and try again */
                    _this.realtime.auth._forceNewToken(null, null, function (err) {
                        if (err) {
                            _this.actOnErrorFromAuthorize(err);
                            return;
                        }
                        _this.tryATransport(transportParams, candidate, callback);
                    });
                }
                else if (wrappedErr.event === 'failed') {
                    /* Error that's fatal to the connection */
                    _this.notifyState({ state: 'failed', error: wrappedErr.error });
                    callback(true);
                }
                else if (wrappedErr.event === 'disconnected') {
                    if (!(0, connectionerrors_1.isRetriable)(wrappedErr.error)) {
                        /* Error received from the server that does not call for trying a fallback host, eg a rate limit */
                        _this.notifyState({ state: _this.states.connecting.failState, error: wrappedErr.error });
                        callback(true);
                    }
                    else {
                        /* Error with that transport only; continue trying other fallback hosts */
                        callback(false);
                    }
                }
                return;
            }
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.tryATransport()', 'viable transport ' + candidate + '; setting pending');
            _this.setTransportPending(transport, transportParams);
            callback(null, transport);
        });
    };
    /**
     * Called when a transport is indicated to be viable, and the ConnectionManager
     * expects to activate this transport as soon as it is connected.
     * @param transport
     * @param transportParams
     */
    ConnectionManager.prototype.setTransportPending = function (transport, transportParams) {
        var _this = this;
        var mode = transportParams.mode;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.setTransportPending()', 'transport = ' + transport + '; mode = ' + mode);
        Utils.arrDeleteValue(this.proposedTransports, transport);
        this.pendingTransports.push(transport);
        var optimalTransport = platform_1.default.Defaults.transportPreferenceOrder[platform_1.default.Defaults.transportPreferenceOrder.length - 1];
        transport.once('connected', function (error, connectionId, connectionDetails) {
            if (mode == 'upgrade' && _this.activeProtocol) {
                /*  if ws and xhrs are connecting in parallel, delay xhrs activation to let ws go ahead */
                if (transport.shortName !== optimalTransport &&
                    Utils.arrIn(_this.getUpgradePossibilities(), optimalTransport) &&
                    _this.activeProtocol) {
                    setTimeout(function () {
                        _this.scheduleTransportActivation(error, transport, connectionId, connectionDetails);
                    }, _this.options.timeouts.parallelUpgradeDelay);
                }
                else {
                    _this.scheduleTransportActivation(error, transport, connectionId, connectionDetails);
                }
            }
            else {
                _this.activateTransport(error, transport, connectionId, connectionDetails);
                /* allow connectImpl to start the upgrade process if needed, but allow
                 * other event handlers, including activating the transport, to run first */
                platform_1.default.Config.nextTick(function () {
                    _this.connectImpl(transportParams);
                });
            }
            if (mode === 'recover' && _this.options.recover) {
                /* After a successful recovery, we unpersist, as a recovery key cannot
                 * be used more than once */
                _this.options.recover = null;
                _this.unpersistConnection();
            }
        });
        var self = this;
        transport.on(['disconnected', 'closed', 'failed'], function (error) {
            self.deactivateTransport(transport, this.event, error);
        });
        this.emit('transport.pending', transport);
    };
    /**
     * Called when an upgrade transport is connected,
     * to schedule the activation of that transport.
     * @param error
     * @param transport
     * @param connectionId
     * @param connectionDetails
     */
    ConnectionManager.prototype.scheduleTransportActivation = function (error, transport, connectionId, connectionDetails) {
        var _this = this;
        var currentTransport = this.activeProtocol && this.activeProtocol.getTransport(), abandon = function () {
            transport.disconnect();
            Utils.arrDeleteValue(_this.pendingTransports, transport);
        };
        if (this.state !== this.states.connected && this.state !== this.states.connecting) {
            /* This is most likely to happen for the delayed XHRs, when XHRs and ws are scheduled in parallel*/
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' +
                this.state.state +
                (this.state === this.states.synchronizing ? ', but with an upgrade already in progress' : '') +
                ') is not valid to upgrade in; abandoning upgrade to ' +
                transport.shortName);
            abandon();
            return;
        }
        if (currentTransport && !betterTransportThan(transport, currentTransport)) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' +
                transport.shortName +
                ' is no better than current active transport ' +
                currentTransport.shortName +
                ' - abandoning upgrade');
            abandon();
            return;
        }
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Scheduling transport upgrade; transport = ' + transport);
        var oldProtocol = null;
        if (!transport.isConnected) {
            /* This is only possible if the xhr streaming transport was disconnected during the parallelUpgradeDelay */
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' + transport.shortName + 'is no longer connected; abandoning upgrade');
            abandon();
            return;
        }
        if (this.state === this.states.connected) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Currently connected, so temporarily pausing events until the upgrade is complete');
            this.state = this.states.synchronizing;
            oldProtocol = this.activeProtocol;
        }
        else if (this.state !== this.states.connecting) {
            /* Note: upgrading from the connecting state is valid if the old active
             * transport was deactivated after the upgrade transport first connected;
             * see logic in deactivateTransport */
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' +
                this.state.state +
                (this.state === this.states.synchronizing ? ', but with an upgrade already in progress' : '') +
                ') is not valid to upgrade in; abandoning upgrade to ' +
                transport.shortName);
            abandon();
            return;
        }
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Syncing transport; transport = ' + transport);
        var finishUpgrade = function () {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Activating transport; transport = ' + transport);
            // Send ACTIVATE to tell the server to make this transport the
            // active transport, which suspends channels until we re-attach.
            transport.send(protocolmessage_1.default.fromValues({
                action: actions.ACTIVATE,
            }));
            _this.activateTransport(error, transport, connectionId, connectionDetails);
            /* Restore pre-sync state. If state has changed in the meantime,
             * don't touch it -- since the websocket transport waits a tick before
             * disposing itself, it's possible for it to have happily synced
             * without err while, unknown to it, the connection has closed in the
             * meantime and the ws transport is scheduled for death */
            if (_this.state === _this.states.synchronizing) {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, sending queued messages on upgraded transport; transport = ' + transport);
                _this.state = _this.states.connected;
            }
            else {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, but state is now ' + _this.state.state + ', so leaving unchanged');
            }
            if (_this.state.sendEvents) {
                _this.sendQueuedMessages();
            }
        };
        /* Wait until sync is done and old transport is idle before activating new transport. This
         * guarantees that messages arrive at realtime in the same order they are sent.
         *
         * If a message times out on the old transport, since it's still the active transport the
         * message will be requeued. deactivateTransport will see the pending transport and notify
         * the `connecting` state without starting a new connection, so the new transport can take
         * over once deactivateTransport clears the old protocol's queue.
         *
         * If there is no old protocol, that meant that we weren't in the connected state at the
         * beginning of the sync - likely the base transport died just before the sync. So can just
         * finish the upgrade. If we're actually in closing/failed rather than connecting, that's
         * fine, activatetransport will deal with that. */
        if (oldProtocol) {
            /* Most of the time this will be already true: the new-transport sync will have given
             * enough time for in-flight messages on the old transport to complete. */
            oldProtocol.onceIdle(finishUpgrade);
        }
        else {
            finishUpgrade();
        }
    };
    /**
     * Called when a transport is connected, and the connectionmanager decides that
     * it will now be the active transport. Returns whether or not it activated
     * the transport (if the connection is closing/closed it will choose not to).
     * @param transport the transport instance
     * @param connectionId the id of the new active connection
     * @param connectionDetails the details of the new active connection
     */
    ConnectionManager.prototype.activateTransport = function (error, transport, connectionId, connectionDetails) {
        var _this = this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.activateTransport()', 'transport = ' + transport);
        if (error) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', 'error = ' + error);
        }
        if (connectionId) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionId =  ' + connectionId);
        }
        if (connectionDetails) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionDetails =  ' + JSON.stringify(connectionDetails));
        }
        this.persistTransportPreference(transport);
        /* if the connectionmanager moved to the closing/closed state before this
         * connection event, then we won't activate this transport */
        var existingState = this.state, connectedState = this.states.connected.state;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.activateTransport()', 'current state = ' + existingState.state);
        if (existingState.state == this.states.closing.state ||
            existingState.state == this.states.closed.state ||
            existingState.state == this.states.failed.state) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.activateTransport()', 'Disconnecting transport and abandoning');
            transport.disconnect();
            return false;
        }
        /* remove this transport from pending transports */
        Utils.arrDeleteValue(this.pendingTransports, transport);
        /* if the transport is not connected then don't activate it */
        if (!transport.isConnected) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.activateTransport()', 'Declining to activate transport ' + transport + ' since it appears to no longer be connected');
            return false;
        }
        /* the given transport is connected; this will immediately
         * take over as the active transport */
        var existingActiveProtocol = this.activeProtocol;
        this.activeProtocol = new protocol_1.default(transport);
        this.host = transport.params.host;
        var connectionKey = connectionDetails.connectionKey;
        if (connectionKey && this.connectionKey != connectionKey) {
            this.setConnection(connectionId, connectionDetails, !!error);
        }
        /* Rebroadcast any new connectionDetails from the active transport, which
         * can come at any time (eg following a reauth), and emit an RTN24 UPDATE
         * event. (Listener added on nextTick because we're in a transport.on('connected')
         * callback at the moment; if we add it now we'll be adding it to the end
         * of the listeners array and it'll be called immediately) */
        this.onConnectionDetailsUpdate(connectionDetails, transport);
        platform_1.default.Config.nextTick(function () {
            transport.on('connected', function (connectedErr, _connectionId, connectionDetails) {
                _this.onConnectionDetailsUpdate(connectionDetails, transport);
                _this.emit('update', new connectionstatechange_1.default(connectedState, connectedState, null, connectedErr));
            });
        });
        /* If previously not connected, notify the state change (including any
         * error). */
        if (existingState.state === this.states.connected.state) {
            if (error) {
                /* if upgrading without error, leave any existing errorReason alone */
                this.errorReason = this.realtime.connection.errorReason = error;
                /* Only bother emitting an upgrade if there's an error; otherwise it's
                 * just a transport upgrade, so auth details won't have changed */
                this.emit('update', new connectionstatechange_1.default(connectedState, connectedState, null, error));
            }
        }
        else {
            this.notifyState({ state: 'connected', error: error });
            this.errorReason = this.realtime.connection.errorReason = error || null;
        }
        /* Send after the connection state update, as Channels hooks into this to
         * resend attaches on a new transport if necessary */
        this.emit('transport.active', transport);
        /* Gracefully terminate existing protocol */
        if (existingActiveProtocol) {
            if (existingActiveProtocol.messageQueue.count() > 0) {
                /* We could just requeue pending messages on the new transport, but
                 * actually this should never happen: transports should only take over
                 * from other active transports when upgrading, and upgrading waits for
                 * the old transport to be idle. So log an error. */
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', 'Previous active protocol (for transport ' +
                    existingActiveProtocol.transport.shortName +
                    ', new one is ' +
                    transport.shortName +
                    ') finishing with ' +
                    existingActiveProtocol.messageQueue.count() +
                    ' messages still pending');
            }
            if (existingActiveProtocol.transport === transport) {
                var msg = 'Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = ' +
                    transport.shortName +
                    '; stack = ' +
                    new Error().stack;
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
            }
            else {
                existingActiveProtocol.finish();
            }
        }
        /* Terminate any other pending transport(s), and
         * abort any not-yet-pending transport attempts */
        Utils.safeArrForEach(this.pendingTransports, function (pendingTransport) {
            if (pendingTransport === transport) {
                var msg = 'Assumption violated: activating a transport that is still marked as a pending transport; transport = ' +
                    transport.shortName +
                    '; stack = ' +
                    new Error().stack;
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
                Utils.arrDeleteValue(_this.pendingTransports, transport);
            }
            else {
                pendingTransport.disconnect();
            }
        });
        Utils.safeArrForEach(this.proposedTransports, function (proposedTransport) {
            if (proposedTransport === transport) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', 'Assumption violated: activating a transport that is still marked as a proposed transport; transport = ' +
                    transport.shortName +
                    '; stack = ' +
                    new Error().stack);
                Utils.arrDeleteValue(_this.proposedTransports, transport);
            }
            else {
                proposedTransport.dispose();
            }
        });
        return true;
    };
    /**
     * Called when a transport is no longer the active transport. This can occur
     * in any transport connection state.
     * @param transport
     */
    ConnectionManager.prototype.deactivateTransport = function (transport, state, error) {
        var currentProtocol = this.activeProtocol, wasActive = currentProtocol && currentProtocol.getTransport() === transport, wasPending = Utils.arrDeleteValue(this.pendingTransports, transport), wasProposed = Utils.arrDeleteValue(this.proposedTransports, transport), noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'transport = ' + transport);
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'state = ' +
            state +
            (wasActive ? '; was active' : wasPending ? '; was pending' : wasProposed ? '; was proposed' : '') +
            (noTransportsScheduledForActivation ? '' : '; another transport is scheduled for activation'));
        if (error && error.message)
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'reason =  ' + error.message);
        if (wasActive) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'Getting, clearing, and requeuing ' +
                this.activeProtocol.messageQueue.count() +
                ' pending messages');
            this.queuePendingMessages(currentProtocol.getPendingMessages());
            /* Clear any messages we requeue to allow the protocol to become idle.
             * In case of an upgrade, this will trigger an immediate activation of
             * the upgrade transport, so delay a tick so this transport can finish
             * deactivating */
            platform_1.default.Config.nextTick(function () {
                currentProtocol.clearPendingMessages();
            });
            this.activeProtocol = this.host = null;
        }
        this.emit('transport.inactive', transport);
        /* this transport state change is a state change for the connectionmanager if
         * - the transport was the active transport and there are no transports
         *   which are connected and scheduled for activation, just waiting for the
         *   active transport to finish what its doing; or
         * - the transport was the active transport and the error was fatal (so
         *   unhealable by another transport); or
         * - there is no active transport, and this is the last remaining
         *   pending transport (so we were in the connecting state)
         */
        if ((wasActive && noTransportsScheduledForActivation) ||
            (wasActive && state === 'failed') ||
            state === 'closed' ||
            (currentProtocol === null && wasPending && this.pendingTransports.length === 0)) {
            /* If we're disconnected with a 5xx we need to try fallback hosts
             * (RTN14d), but (a) due to how the upgrade sequence works, the
             * host/transport selection sequence only cares about getting to
             * `preconnect` (eg establishing a websocket) getting a `disconnected`
             * protocol message afterwards is too late; and (b) host retry only
             * applies to connectBase unless the stored preference transport doesn't
             * work. We solve this by unpersisting the transport preference and
             * setting an instance variable to force fallback hosts to be used (if
             * any) here. Bit of a kludge, but no real better alternatives without
             * rewriting the entire thing */
            if (state === 'disconnected' && error && error.statusCode > 500 && this.httpHosts.length > 1) {
                this.unpersistTransportPreference();
                this.forceFallbackHost = true;
                /* and try to connect again to try a fallback host without waiting for the usual 15s disconnectedRetryTimeout */
                this.notifyState({ state: state, error: error, retryImmediately: true });
                return;
            }
            /* TODO remove below line once realtime sends token errors as DISCONNECTEDs */
            var newConnectionState = state === 'failed' && auth_1.default.isTokenErr(error) ? 'disconnected' : state;
            this.notifyState({ state: newConnectionState, error: error });
            return;
        }
        if (wasActive && state === 'disconnected' && this.state !== this.states.synchronizing) {
            /* If we were active but there is another transport scheduled for
             * activation, go into to the connecting state until that transport
             * activates and sets us back to connected. (manually starting the
             * transition timers in case that never happens). (If we were in the
             * synchronizing state, then that's fine, the old transport just got its
             * disconnected before the new one got the sync -- ignore it and keep
             * waiting for the sync. If it fails we have a separate sync timer that
             * will expire). */
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'wasActive but another transport is connected and scheduled for activation, so going into the connecting state until it activates');
            this.startSuspendTimer();
            this.startTransitionTimer(this.states.connecting);
            this.notifyState({ state: 'connecting', error: error });
        }
    };
    /* Helper that returns true if there are no transports which are pending,
     * have been connected, and are just waiting for onceNoPending to fire before
     * being activated */
    ConnectionManager.prototype.noTransportsScheduledForActivation = function () {
        return (Utils.isEmpty(this.pendingTransports) ||
            this.pendingTransports.every(function (transport) {
                return !transport.isConnected;
            }));
    };
    ConnectionManager.prototype.setConnection = function (connectionId, connectionDetails, hasConnectionError) {
        /* if connectionKey changes but connectionId stays the same, then just a
         * transport change on the same connection. If connectionId changes, we're
         * on a new connection, with implications for msgSerial and channel state */
        /* If no previous connectionId, don't reset the msgSerial as it may have
         * been set by recover data (unless the recover failed) */
        var prevConnId = this.connectionId, connIdChanged = prevConnId && prevConnId !== connectionId, recoverFailure = !prevConnId && hasConnectionError;
        if (connIdChanged || recoverFailure) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.setConnection()', 'Resetting msgSerial');
            this.msgSerial = 0;
            // RTN19a2: In the event of a new connectionId, previous msgSerials are
            // meaningless.
            this.queuedMessages.resetSendAttempted();
        }
        if (this.connectionId !== connectionId) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.setConnection()', 'New connectionId; reattaching any attached channels');
        }
        this.realtime.connection.id = this.connectionId = connectionId;
        this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;
    };
    ConnectionManager.prototype.clearConnection = function () {
        this.realtime.connection.id = this.connectionId = undefined;
        this.realtime.connection.key = this.connectionKey = undefined;
        this.msgSerial = 0;
        this.unpersistConnection();
    };
    ConnectionManager.prototype.createRecoveryKey = function () {
        // RTN16g2.
        if (!this.connectionKey) {
            return null;
        }
        return JSON.stringify({
            connectionKey: this.connectionKey,
            msgSerial: this.msgSerial,
            channelSerials: this.realtime.channels.channelSerials(),
        });
    };
    ConnectionManager.prototype.checkConnectionStateFreshness = function () {
        if (!this.lastActivity || !this.connectionId) {
            return;
        }
        var sinceLast = Utils.now() - this.lastActivity;
        if (sinceLast > this.connectionStateTtl + this.maxIdleInterval) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.checkConnectionStateFreshness()', 'Last known activity from realtime was ' + sinceLast + 'ms ago; discarding connection state');
            this.clearConnection();
            this.states.connecting.failState = 'suspended';
        }
    };
    /**
     * Called when the connectionmanager wants to persist transport
     * state for later recovery. Only applicable in the browser context.
     */
    ConnectionManager.prototype.persistConnection = function () {
        if (haveSessionStorage()) {
            var recoveryKey = this.createRecoveryKey();
            if (recoveryKey) {
                setSessionRecoverData({
                    recoveryKey: recoveryKey,
                    disconnectedAt: Utils.now(),
                    location: global.location,
                    clientId: this.realtime.auth.clientId,
                });
            }
        }
    };
    /**
     * Called when the connectionmanager wants to persist transport
     * state for later recovery. Only applicable in the browser context.
     */
    ConnectionManager.prototype.unpersistConnection = function () {
        clearSessionRecoverData();
    };
    /*********************
     * state management
     *********************/
    ConnectionManager.prototype.getError = function () {
        return this.errorReason || this.getStateError();
    };
    ConnectionManager.prototype.getStateError = function () {
        var _a, _b;
        return (_b = (_a = connectionerrors_1.default)[this.state.state]) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    ConnectionManager.prototype.activeState = function () {
        return this.state.queueEvents || this.state.sendEvents;
    };
    ConnectionManager.prototype.enactStateChange = function (stateChange) {
        var logLevel = stateChange.current === 'failed' ? logger_1.default.LOG_ERROR : logger_1.default.LOG_MAJOR;
        logger_1.default.logAction(logLevel, 'Connection state', stateChange.current + (stateChange.reason ? '; reason: ' + stateChange.reason : ''));
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.enactStateChange', 'setting new state: ' +
            stateChange.current +
            '; reason = ' +
            (stateChange.reason && stateChange.reason.message));
        var newState = (this.state = this.states[stateChange.current]);
        if (stateChange.reason) {
            this.errorReason = stateChange.reason;
            this.realtime.connection.errorReason = stateChange.reason;
        }
        if (newState.terminal || newState.state === 'suspended') {
            /* suspended is nonterminal, but once in the suspended state, realtime
             * will have discarded our connection state, so futher connection
             * attempts should start from scratch */
            this.clearConnection();
        }
        this.emit('connectionstate', stateChange);
    };
    /****************************************
     * ConnectionManager connection lifecycle
     ****************************************/
    ConnectionManager.prototype.startTransitionTimer = function (transitionState) {
        var _this = this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'transitionState: ' + transitionState.state);
        if (this.transitionTimer) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'clearing already-running timer');
            clearTimeout(this.transitionTimer);
        }
        this.transitionTimer = setTimeout(function () {
            if (_this.transitionTimer) {
                _this.transitionTimer = null;
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager ' + transitionState.state + ' timer expired', 'requesting new state: ' + transitionState.failState);
                _this.notifyState({ state: transitionState.failState });
            }
        }, transitionState.retryDelay);
    };
    ConnectionManager.prototype.cancelTransitionTimer = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.cancelTransitionTimer()', '');
        if (this.transitionTimer) {
            clearTimeout(this.transitionTimer);
            this.transitionTimer = null;
        }
    };
    ConnectionManager.prototype.startSuspendTimer = function () {
        var _this = this;
        if (this.suspendTimer)
            return;
        this.suspendTimer = setTimeout(function () {
            if (_this.suspendTimer) {
                _this.suspendTimer = null;
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager suspend timer expired', 'requesting new state: suspended');
                _this.states.connecting.failState = 'suspended';
                _this.notifyState({ state: 'suspended' });
            }
        }, this.connectionStateTtl);
    };
    ConnectionManager.prototype.checkSuspendTimer = function (state) {
        if (state !== 'disconnected' && state !== 'suspended' && state !== 'connecting')
            this.cancelSuspendTimer();
    };
    ConnectionManager.prototype.cancelSuspendTimer = function () {
        this.states.connecting.failState = 'disconnected';
        if (this.suspendTimer) {
            clearTimeout(this.suspendTimer);
            this.suspendTimer = null;
        }
    };
    ConnectionManager.prototype.startRetryTimer = function (interval) {
        var _this = this;
        this.retryTimer = setTimeout(function () {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager retry timer expired', 'retrying');
            _this.retryTimer = null;
            _this.requestState({ state: 'connecting' });
        }, interval);
    };
    ConnectionManager.prototype.cancelRetryTimer = function () {
        if (this.retryTimer) {
            clearTimeout(this.retryTimer);
            this.retryTimer = null;
        }
    };
    ConnectionManager.prototype.notifyState = function (indicated) {
        var _this = this;
        var _a, _b;
        var state = indicated.state;
        /* We retry immediately if:
         * - something disconnects us while we're connected, or
         * - a viable (but not yet active) transport fails due to a token error (so
         *   this.errorReason will be set, and startConnect will do a forced
         *   authorize). If this.errorReason is already set (to a token error),
         *   then there has been at least one previous attempt to connect that also
         *   failed for a token error, so by RTN14b we go to DISCONNECTED and wait
         *   before trying again */
        var retryImmediately = state === 'disconnected' &&
            (this.state === this.states.connected ||
                this.state === this.states.synchronizing ||
                indicated.retryImmediately ||
                (this.state === this.states.connecting &&
                    indicated.error &&
                    auth_1.default.isTokenErr(indicated.error) &&
                    !(this.errorReason && auth_1.default.isTokenErr(this.errorReason))));
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.notifyState()', 'new state: ' + state + (retryImmediately ? '; will retry connection immediately' : ''));
        /* do nothing if we're already in the indicated state */
        if (state == this.state.state)
            return;
        /* kill timers (possibly excepting suspend timer depending on the notified
         * state), as these are superseded by this notification */
        this.cancelTransitionTimer();
        this.cancelRetryTimer();
        this.checkSuspendTimer(indicated.state);
        if (state === 'suspended' || state === 'connected') {
            this.disconnectedRetryCount = 0;
        }
        /* do nothing if we're unable to move from the current state */
        if (this.state.terminal)
            return;
        /* process new state */
        var newState = this.states[indicated.state];
        var retryDelay = newState.retryDelay;
        if (newState.state === 'disconnected') {
            this.disconnectedRetryCount++;
            retryDelay = Utils.getRetryTime(newState.retryDelay, this.disconnectedRetryCount);
        }
        var change = new connectionstatechange_1.default(this.state.state, newState.state, retryDelay, indicated.error || ((_b = (_a = connectionerrors_1.default)[newState.state]) === null || _b === void 0 ? void 0 : _b.call(_a)));
        if (retryImmediately) {
            var autoReconnect = function () {
                if (_this.state === _this.states.disconnected) {
                    _this.lastAutoReconnectAttempt = Utils.now();
                    _this.requestState({ state: 'connecting' });
                }
            };
            var sinceLast = this.lastAutoReconnectAttempt && Utils.now() - this.lastAutoReconnectAttempt + 1;
            if (sinceLast && sinceLast < 1000) {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.notifyState()', 'Last reconnect attempt was only ' +
                    sinceLast +
                    'ms ago, waiting another ' +
                    (1000 - sinceLast) +
                    'ms before trying again');
                setTimeout(autoReconnect, 1000 - sinceLast);
            }
            else {
                platform_1.default.Config.nextTick(autoReconnect);
            }
        }
        else if (state === 'disconnected' || state === 'suspended') {
            this.startRetryTimer(retryDelay);
        }
        /* If going into disconnect/suspended (and not retrying immediately), or a
         * terminal state, ensure there are no orphaned transports hanging around. */
        if ((state === 'disconnected' && !retryImmediately) || state === 'suspended' || newState.terminal) {
            /* Wait till the next tick so the connection state change is enacted,
             * so aborting transports doesn't trigger redundant state changes */
            platform_1.default.Config.nextTick(function () {
                _this.disconnectAllTransports();
            });
        }
        if (state == 'connected' && !this.activeProtocol) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.notifyState()', 'Broken invariant: attempted to go into connected state, but there is no active protocol');
        }
        /* implement the change and notify */
        this.enactStateChange(change);
        if (this.state.sendEvents) {
            this.sendQueuedMessages();
        }
        else if (!this.state.queueEvents) {
            this.realtime.channels.propogateConnectionInterruption(state, change.reason);
            this.failQueuedMessages(change.reason); // RTN7c
        }
    };
    ConnectionManager.prototype.requestState = function (request) {
        var _this = this;
        var _a, _b;
        var state = request.state;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.requestState()', 'requested state: ' + state + '; current state: ' + this.state.state);
        if (state == this.state.state)
            return; /* silently do nothing */
        /* kill running timers, as this request supersedes them */
        this.cancelTransitionTimer();
        this.cancelRetryTimer();
        /* for suspend timer check rather than cancel -- eg requesting a connecting
         * state should not reset the suspend timer */
        this.checkSuspendTimer(state);
        if (state == 'connecting' && this.state.state == 'connected')
            return;
        if (state == 'closing' && this.state.state == 'closed')
            return;
        var newState = this.states[state], change = new connectionstatechange_1.default(this.state.state, newState.state, null, request.error || ((_b = (_a = connectionerrors_1.default)[newState.state]) === null || _b === void 0 ? void 0 : _b.call(_a)));
        this.enactStateChange(change);
        if (state == 'connecting') {
            platform_1.default.Config.nextTick(function () {
                _this.startConnect();
            });
        }
        if (state == 'closing') {
            this.closeImpl();
        }
    };
    ConnectionManager.prototype.startConnect = function () {
        var _this = this;
        if (this.state !== this.states.connecting) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.startConnect()', 'Must be in connecting state to connect, but was ' + this.state.state);
            return;
        }
        var auth = this.realtime.auth;
        /* The point of the connectCounter mechanism is to ensure that the
         * connection procedure can be cancelled. We want disconnectAllTransports
         * to be able to stop any in-progress connection, even before it gets to
         * the stage of having a pending (or even a proposed) transport that it can
         * dispose() of. So we check that it's still current after any async stage,
         * up until the stage that is synchronous with instantiating a transport */
        var connectCount = ++this.connectCounter;
        var connect = function () {
            _this.checkConnectionStateFreshness();
            _this.getTransportParams(function (transportParams) {
                if (transportParams.mode === 'recover' && transportParams.options.recover) {
                    var recoveryContext = decodeRecoveryKey(transportParams.options.recover);
                    if (recoveryContext) {
                        _this.realtime.channels.recoverChannels(recoveryContext.channelSerials);
                    }
                }
                if (connectCount !== _this.connectCounter) {
                    return;
                }
                _this.connectImpl(transportParams, connectCount);
            });
        };
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.startConnect()', 'starting connection');
        this.startSuspendTimer();
        this.startTransitionTimer(this.states.connecting);
        if (auth.method === 'basic') {
            connect();
        }
        else {
            var authCb = function (err) {
                if (connectCount !== _this.connectCounter) {
                    return;
                }
                if (err) {
                    _this.actOnErrorFromAuthorize(err);
                }
                else {
                    connect();
                }
            };
            if (this.errorReason && auth_1.default.isTokenErr(this.errorReason)) {
                /* Force a refetch of a new token */
                auth._forceNewToken(null, null, authCb);
            }
            else {
                auth._ensureValidAuthCredentials(false, authCb);
            }
        }
    };
    /**
     * There are three stages in connecting:
     * - preference: if there is a cached transport preference, we try to connect
     *   on that. If that fails or times out we abort the attempt, remove the
     *   preference and fall back to base. If it succeeds, we try upgrading it if
     *   needed (will only be in the case where the preference is xhrs and the
     *   browser supports ws).
     * - base: we try to connect with the best transport that we think will
     *   never fail for this browser (usually this is xhr_polling; for very old
     *   browsers will be jsonp, for node will be comet). If it doesn't work, we
     *   try fallback hosts.
     * - upgrade: given a connected transport, we see if there are any better
     *   ones, and if so, try to upgrade to them.
     *
     * connectImpl works out what stage you're at (which is purely a function of
     * the current connection state and whether there are any stored preferences),
     * and dispatches accordingly. After a transport has been set pending,
     * tryATransport calls connectImpl to see if there's another stage to be done.
     * */
    ConnectionManager.prototype.connectImpl = function (transportParams, connectCount) {
        var state = this.state.state;
        if (state !== this.states.connecting.state && state !== this.states.connected.state) {
            /* Only keep trying as long as in the 'connecting' state (or 'connected'
             * for upgrading). Any operation can put us into 'disconnected' to cancel
             * connection attempts and wait before retrying, or 'failed' to fail. */
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectImpl()', 'Must be in connecting state to connect (or connected to upgrade), but was ' + state);
        }
        else if (this.pendingTransports.length) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectImpl()', 'Transports ' + this.pendingTransports[0].toString() + ' currently pending; taking no action');
        }
        else if (state == this.states.connected.state) {
            this.upgradeIfNeeded(transportParams);
        }
        else if (this.transports.length > 1 && this.getTransportPreference()) {
            this.connectPreference(transportParams, connectCount);
        }
        else {
            this.connectBase(transportParams, connectCount);
        }
    };
    ConnectionManager.prototype.connectPreference = function (transportParams, connectCount) {
        var _this = this;
        var preference = this.getTransportPreference();
        var preferenceTimeoutExpired = false;
        if (!Utils.arrIn(this.transports, preference)) {
            this.unpersistTransportPreference();
            this.connectImpl(transportParams, connectCount);
        }
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectPreference()', 'Trying to connect with stored transport preference ' + preference);
        var preferenceTimeout = setTimeout(function () {
            preferenceTimeoutExpired = true;
            if (!(_this.state.state === _this.states.connected.state)) {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectPreference()', 'Shortcircuit connection attempt with ' + preference + ' failed; clearing preference and trying from scratch');
                /* Abort all connection attempts. (This also disconnects the active
                 * protocol, but none exists if we're not in the connected state) */
                _this.disconnectAllTransports();
                /* Be quite agressive about clearing the stored preference if ever it doesn't work */
                _this.unpersistTransportPreference();
            }
            _this.connectImpl(transportParams, connectCount);
        }, this.options.timeouts.preferenceConnectTimeout);
        /* For connectPreference, just use the main host. If host fallback is needed, do it in connectBase.
         * The wstransport it will substitute the httphost for an appropriate wshost */
        transportParams.host = this.httpHosts[0];
        this.tryATransport(transportParams, preference, function (fatal, transport) {
            clearTimeout(preferenceTimeout);
            if (preferenceTimeoutExpired && transport) {
                /* Viable, but too late - connectImpl() will already be trying
                 * connectBase, and we weren't in upgrade mode. Just remove the
                 * onconnected listener and get rid of it */
                transport.off();
                transport.disconnect();
                Utils.arrDeleteValue(_this.pendingTransports, transport);
            }
            else if (!transport && !fatal) {
                /* Preference failed in a transport-specific way. Try more */
                _this.unpersistTransportPreference();
                _this.connectImpl(transportParams, connectCount);
            }
            /* If suceeded, or failed fatally, nothing to do */
        });
    };
    /**
     * Try to establish a transport on the base transport (the best transport
     * such that if it doesn't work, nothing will work) as determined through
     * static feature detection, checking for network connectivity and trying
     * fallback hosts if applicable.
     * @param transportParams
     */
    ConnectionManager.prototype.connectBase = function (transportParams, connectCount) {
        var _this = this;
        var giveUp = function (err) {
            _this.notifyState({ state: _this.states.connecting.failState, error: err });
        };
        var candidateHosts = this.httpHosts.slice();
        var hostAttemptCb = function (fatal, transport) {
            if (connectCount !== _this.connectCounter) {
                return;
            }
            if (!transport && !fatal) {
                tryFallbackHosts();
            }
        };
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectBase()', 'Trying to connect with base transport ' + this.baseTransport);
        /* first try to establish a connection with the priority host with http transport */
        var host = candidateHosts.shift();
        if (!host) {
            giveUp(new errorinfo_1.default('Unable to connect (no available host)', 80003, 404));
            return;
        }
        transportParams.host = host;
        /* this is what we'll be doing if the attempt for the main host fails */
        var tryFallbackHosts = function () {
            /* if there aren't any fallback hosts, fail */
            if (!candidateHosts.length) {
                giveUp(new errorinfo_1.default('Unable to connect (and no more fallback hosts to try)', 80003, 404));
                return;
            }
            /* before trying any fallback (or any remaining fallback) we decide if
             * there is a problem with the ably host, or there is a general connectivity
             * problem */
            if (!_this.realtime.http.checkConnectivity) {
                giveUp(new errorinfo_1.PartialErrorInfo('Internal error: Http.checkConnectivity not set', null, 500));
                return;
            }
            _this.realtime.http.checkConnectivity(function (err, connectivity) {
                if (connectCount !== _this.connectCounter) {
                    return;
                }
                /* we know err won't happen but handle it here anyway */
                if (err) {
                    giveUp(err);
                    return;
                }
                if (!connectivity) {
                    /* the internet isn't reachable, so don't try the fallback hosts */
                    giveUp(new errorinfo_1.default('Unable to connect (network unreachable)', 80003, 404));
                    return;
                }
                /* the network is there, so there's a problem with the main host, or
                 * its dns. Try the fallback hosts. We could try them simultaneously but
                 * that would potentially cause a huge spike in load on the load balancer */
                transportParams.host = Utils.arrPopRandomElement(candidateHosts);
                _this.tryATransport(transportParams, _this.baseTransport, hostAttemptCb);
            });
        };
        if (this.forceFallbackHost && candidateHosts.length) {
            this.forceFallbackHost = false;
            tryFallbackHosts();
            return;
        }
        this.tryATransport(transportParams, this.baseTransport, hostAttemptCb);
    };
    ConnectionManager.prototype.getUpgradePossibilities = function () {
        /* returns the subset of upgradeTransports to the right of the current
         * transport in upgradeTransports (if it's in there - if not, currentSerial
         * will be -1, so return upgradeTransports.slice(0) == upgradeTransports */
        var current = this.activeProtocol.getTransport().shortName;
        var currentSerial = Utils.arrIndexOf(this.upgradeTransports, current);
        return this.upgradeTransports.slice(currentSerial + 1);
    };
    ConnectionManager.prototype.upgradeIfNeeded = function (transportParams) {
        var _this = this;
        var upgradePossibilities = this.getUpgradePossibilities();
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.upgradeIfNeeded()', 'upgrade possibilities: ' + platform_1.default.Config.inspect(upgradePossibilities));
        if (!upgradePossibilities.length) {
            return;
        }
        Utils.arrForEach(upgradePossibilities, function (upgradeTransport) {
            /* Note: the transport may mutate the params, so give each transport a fresh one */
            var upgradeTransportParams = _this.createTransportParams(transportParams.host, 'upgrade');
            _this.tryATransport(upgradeTransportParams, upgradeTransport, noop);
        });
    };
    ConnectionManager.prototype.closeImpl = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.closeImpl()', 'closing connection');
        this.cancelSuspendTimer();
        this.startTransitionTimer(this.states.closing);
        Utils.safeArrForEach(this.pendingTransports, function (transport) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing pending transport: ' + transport);
            if (transport)
                transport.close();
        });
        Utils.safeArrForEach(this.proposedTransports, function (transport) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.closeImpl()', 'Disposing of proposed transport: ' + transport);
            if (transport)
                transport.dispose();
        });
        if (this.activeProtocol) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing active transport: ' + this.activeProtocol.getTransport());
            this.activeProtocol.getTransport().close();
        }
        /* If there was an active transport, this will probably be
         * preempted by the notifyState call in deactivateTransport */
        this.notifyState({ state: 'closed' });
    };
    ConnectionManager.prototype.onAuthUpdated = function (tokenDetails, callback) {
        var _this = this;
        var _a;
        switch (this.state.state) {
            case 'connected': {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.onAuthUpdated()', 'Sending AUTH message on active transport');
                /* If there are any proposed/pending transports (eg an upgrade that
                 * isn't yet scheduled for activation) that hasn't yet started syncing,
                 * just to get rid of them & restart the upgrade with the new token, to
                 * avoid a race condition. (If it has started syncing, the AUTH will be
                 * queued until the upgrade is complete, so everything's fine) */
                if ((this.pendingTransports.length || this.proposedTransports.length) &&
                    this.state !== this.states.synchronizing) {
                    this.disconnectAllTransports(/* exceptActive: */ true);
                    var transportParams_1 = this.activeProtocol.getTransport().params;
                    platform_1.default.Config.nextTick(function () {
                        if (_this.state.state === 'connected') {
                            _this.upgradeIfNeeded(transportParams_1);
                        }
                    });
                }
                /* Do any transport-specific new-token action */
                var activeTransport = (_a = this.activeProtocol) === null || _a === void 0 ? void 0 : _a.getTransport();
                if (activeTransport && activeTransport.onAuthUpdated) {
                    activeTransport.onAuthUpdated(tokenDetails);
                }
                var authMsg = protocolmessage_1.default.fromValues({
                    action: actions.AUTH,
                    auth: {
                        accessToken: tokenDetails.token,
                    },
                });
                this.send(authMsg);
                /* The answer will come back as either a connectiondetails event
                 * (realtime sends a CONNECTED to acknowledge the reauth) or a
                 * statechange to failed */
                var successListener_1 = function () {
                    _this.off(failureListener_1);
                    callback(null, tokenDetails);
                };
                var failureListener_1 = function (stateChange) {
                    if (stateChange.current === 'failed') {
                        _this.off(successListener_1);
                        _this.off(failureListener_1);
                        callback(stateChange.reason || _this.getStateError());
                    }
                };
                this.once('connectiondetails', successListener_1);
                this.on('connectionstate', failureListener_1);
                break;
            }
            case 'connecting':
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.onAuthUpdated()', 'Aborting current connection attempts in order to start again with the new auth details');
                this.disconnectAllTransports();
            /* fallthrough to add statechange listener */
            default: {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.onAuthUpdated()', 'Connection state is ' + this.state.state + '; waiting until either connected or failed');
                var listener_1 = function (stateChange) {
                    switch (stateChange.current) {
                        case 'connected':
                            _this.off(listener_1);
                            callback(null, tokenDetails);
                            break;
                        case 'failed':
                        case 'closed':
                        case 'suspended':
                            _this.off(listener_1);
                            callback(stateChange.reason || _this.getStateError());
                            break;
                        default:
                            /* ignore till we get either connected or failed */
                            break;
                    }
                };
                this.on('connectionstate', listener_1);
                if (this.state.state === 'connecting') {
                    /* can happen if in the connecting state but no transport was pending
                     * yet, so disconnectAllTransports did not trigger a disconnected state */
                    this.startConnect();
                }
                else {
                    this.requestState({ state: 'connecting' });
                }
            }
        }
    };
    ConnectionManager.prototype.disconnectAllTransports = function (exceptActive) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting all transports' + (exceptActive ? ' except the active transport' : ''));
        /* This will prevent any connection procedure in an async part of one of its early stages from continuing */
        this.connectCounter++;
        Utils.safeArrForEach(this.pendingTransports, function (transport) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting pending transport: ' + transport);
            if (transport)
                transport.disconnect();
        });
        this.pendingTransports = [];
        Utils.safeArrForEach(this.proposedTransports, function (transport) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disposing of proposed transport: ' + transport);
            if (transport)
                transport.dispose();
        });
        this.proposedTransports = [];
        if (this.activeProtocol && !exceptActive) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting active transport: ' + this.activeProtocol.getTransport());
            this.activeProtocol.getTransport().disconnect();
        }
        /* No need to notify state disconnected; disconnecting the active transport
         * will have that effect */
    };
    /******************
     * event queueing
     ******************/
    ConnectionManager.prototype.send = function (msg, queueEvent, callback) {
        callback = callback || noop;
        var state = this.state;
        if (state.sendEvents) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.send()', 'sending event');
            this.sendImpl(new protocol_1.PendingMessage(msg, callback));
            return;
        }
        var shouldQueue = (queueEvent && state.queueEvents) || state.forceQueueEvents;
        if (!shouldQueue) {
            var err = 'rejecting event, queueEvent was ' + queueEvent + ', state was ' + state.state;
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.send()', err);
            callback(this.errorReason || new errorinfo_1.default(err, 90000, 400));
            return;
        }
        if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.send()', 'queueing msg; ' + protocolmessage_1.default.stringify(msg));
        }
        this.queue(msg, callback);
    };
    ConnectionManager.prototype.sendImpl = function (pendingMessage) {
        var msg = pendingMessage.message;
        /* If have already attempted to send this, resend with the same msgSerial,
         * so Ably can dedup if the previous send succeeded */
        if (pendingMessage.ackRequired && !pendingMessage.sendAttempted) {
            msg.msgSerial = this.msgSerial++;
        }
        try {
            this.activeProtocol.send(pendingMessage);
        }
        catch (e) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.sendImpl()', 'Unexpected exception in transport.send(): ' + e.stack);
        }
    };
    ConnectionManager.prototype.queue = function (msg, callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.queue()', 'queueing event');
        var lastQueued = this.queuedMessages.last();
        var maxSize = this.options.maxMessageSize;
        /* If have already attempted to send a message, don't merge more messages
         * into it, as if the previous send actually succeeded and realtime ignores
         * the dup, they'll be lost */
        if (lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {
            if (!lastQueued.merged) {
                lastQueued.callback = multicaster_1.default.create([lastQueued.callback]);
                lastQueued.merged = true;
            }
            lastQueued.callback.push(callback);
        }
        else {
            this.queuedMessages.push(new protocol_1.PendingMessage(msg, callback));
        }
    };
    ConnectionManager.prototype.sendQueuedMessages = function () {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.sendQueuedMessages()', 'sending ' + this.queuedMessages.count() + ' queued messages');
        var pendingMessage;
        while ((pendingMessage = this.queuedMessages.shift()))
            this.sendImpl(pendingMessage);
    };
    ConnectionManager.prototype.queuePendingMessages = function (pendingMessages) {
        if (pendingMessages && pendingMessages.length) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.queuePendingMessages()', 'queueing ' + pendingMessages.length + ' pending messages');
            this.queuedMessages.prepend(pendingMessages);
        }
    };
    ConnectionManager.prototype.failQueuedMessages = function (err) {
        var numQueued = this.queuedMessages.count();
        if (numQueued > 0) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.failQueuedMessages()', 'failing ' + numQueued + ' queued messages, err = ' + Utils.inspectError(err));
            this.queuedMessages.completeAllMessages(err);
        }
    };
    ConnectionManager.prototype.onChannelMessage = function (message, transport) {
        var onActiveTransport = this.activeProtocol && transport === this.activeProtocol.getTransport(), onUpgradeTransport = Utils.arrIn(this.pendingTransports, transport) && this.state == this.states.synchronizing;
        /* As the lib now has a period where the upgrade transport is synced but
         * before it's become active (while waiting for the old one to become
         * idle), message can validly arrive on it even though it isn't active */
        if (onActiveTransport || onUpgradeTransport) {
            this.realtime.channels.onChannelMessage(message);
        }
        else {
            // Message came in on a defunct transport. Allow only acks, nacks, & errors for outstanding
            // messages,  no new messages (as sync has been sent on new transport so new messages will
            // be resent there, or connection has been closed so don't want new messages)
            if (Utils.arrIndexOf([actions.ACK, actions.NACK, actions.ERROR], message.action) > -1) {
                this.realtime.channels.onChannelMessage(message);
            }
            else {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.onChannelMessage()', 'received message ' + JSON.stringify(message) + 'on defunct transport; discarding');
            }
        }
    };
    ConnectionManager.prototype.ping = function (transport, callback) {
        var _this = this;
        /* if transport is specified, try that */
        if (transport) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.ping()', 'transport = ' + transport);
            var onTimeout = function () {
                transport.off('heartbeat', onHeartbeat_1);
                callback(new errorinfo_1.default('Timeout waiting for heartbeat response', 50000, 500));
            };
            var pingStart_1 = Utils.now(), id_1 = Utils.cheapRandStr();
            var onHeartbeat_1 = function (responseId) {
                if (responseId === id_1) {
                    transport.off('heartbeat', onHeartbeat_1);
                    clearTimeout(timer_1);
                    var responseTime = Utils.now() - pingStart_1;
                    callback(null, responseTime);
                }
            };
            var timer_1 = setTimeout(onTimeout, this.options.timeouts.realtimeRequestTimeout);
            transport.on('heartbeat', onHeartbeat_1);
            transport.ping(id_1);
            return;
        }
        /* if we're not connected, don't attempt */
        if (this.state.state !== 'connected') {
            callback(new errorinfo_1.default('Unable to ping service; not connected', 40000, 400));
            return;
        }
        /* no transport was specified, so use the current (connected) one
         * but ensure that we retry if the transport is superseded before we complete */
        var completed = false;
        var onPingComplete = function (err, responseTime) {
            _this.off('transport.active', onTransportActive);
            if (!completed) {
                completed = true;
                callback(err, responseTime);
            }
        };
        var onTransportActive = function () {
            if (!completed) {
                /* ensure that no callback happens for the currently outstanding operation */
                completed = true;
                /* repeat but picking up the new transport */
                platform_1.default.Config.nextTick(function () {
                    _this.ping(null, callback);
                });
            }
        };
        this.on('transport.active', onTransportActive);
        this.ping(this.activeProtocol.getTransport(), onPingComplete);
    };
    ConnectionManager.prototype.abort = function (error) {
        this.activeProtocol.getTransport().fail(error);
    };
    ConnectionManager.prototype.registerProposedTransport = function (transport) {
        this.proposedTransports.push(transport);
    };
    ConnectionManager.prototype.getTransportPreference = function () {
        var _a, _b;
        return this.transportPreference || (haveWebStorage() && ((_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.get) === null || _b === void 0 ? void 0 : _b.call(_a, transportPreferenceName)));
    };
    ConnectionManager.prototype.persistTransportPreference = function (transport) {
        var _a, _b;
        if (Utils.arrIn(defaults_1.default.upgradeTransports, transport.shortName)) {
            this.transportPreference = transport.shortName;
            if (haveWebStorage()) {
                (_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.set) === null || _b === void 0 ? void 0 : _b.call(_a, transportPreferenceName, transport.shortName);
            }
        }
    };
    ConnectionManager.prototype.unpersistTransportPreference = function () {
        var _a, _b;
        this.transportPreference = null;
        if (haveWebStorage()) {
            (_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.remove) === null || _b === void 0 ? void 0 : _b.call(_a, transportPreferenceName);
        }
    };
    /* This method is only used during connection attempts, so implements RSA4c1, RSA4c2,
     * and RSA4d. It is generally not invoked for serverside-triggered reauths or manual
     * reauths, so RSA4c3 does not apply, except (per per RSA4d1) in the case that the auth
     * server returns 403. */
    ConnectionManager.prototype.actOnErrorFromAuthorize = function (err) {
        if (err.code === 40171) {
            /* No way to reauth */
            this.notifyState({ state: 'failed', error: err });
        }
        else if (err.code === 40102) {
            this.notifyState({ state: 'failed', error: err });
        }
        else if (err.statusCode === HttpStatusCodes_1.default.Forbidden) {
            var msg = 'Client configured authentication provider returned 403; failing the connection';
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.actOnErrorFromAuthorize()', msg);
            this.notifyState({ state: 'failed', error: new errorinfo_1.default(msg, 80019, 403, err) });
        }
        else {
            var msg = 'Client configured authentication provider request failed';
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.actOnErrorFromAuthorize', msg);
            this.notifyState({ state: this.state.failState, error: new errorinfo_1.default(msg, 80019, 401, err) });
        }
    };
    ConnectionManager.prototype.onConnectionDetailsUpdate = function (connectionDetails, transport) {
        if (!connectionDetails) {
            return;
        }
        this.connectionDetails = connectionDetails;
        if (connectionDetails.maxMessageSize) {
            this.options.maxMessageSize = connectionDetails.maxMessageSize;
        }
        var clientId = connectionDetails.clientId;
        if (clientId) {
            var err = this.realtime.auth._uncheckedSetClientId(clientId);
            if (err) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.onConnectionDetailsUpdate()', err.message);
                /* Errors setting the clientId are fatal to the connection */
                transport.fail(err);
                return;
            }
        }
        var connectionStateTtl = connectionDetails.connectionStateTtl;
        if (connectionStateTtl) {
            this.connectionStateTtl = connectionStateTtl;
        }
        this.maxIdleInterval = connectionDetails.maxIdleInterval;
        this.emit('connectiondetails', connectionDetails);
    };
    /*********************
     * transport management
     *********************/
    ConnectionManager.supportedTransports = {};
    return ConnectionManager;
}(eventemitter_1.default));
exports.default = ConnectionManager;

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_301120__(13)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __nested_webpack_require_391408__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_391408__(0);
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_391408__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_391408__(2));
var MessageQueue = /** @class */ (function (_super) {
    tslib_1.__extends(MessageQueue, _super);
    function MessageQueue() {
        var _this = _super.call(this) || this;
        _this.messages = [];
        return _this;
    }
    MessageQueue.prototype.count = function () {
        return this.messages.length;
    };
    MessageQueue.prototype.push = function (message) {
        this.messages.push(message);
    };
    MessageQueue.prototype.shift = function () {
        return this.messages.shift();
    };
    MessageQueue.prototype.last = function () {
        return this.messages[this.messages.length - 1];
    };
    MessageQueue.prototype.copyAll = function () {
        return this.messages.slice();
    };
    MessageQueue.prototype.append = function (messages) {
        this.messages.push.apply(this.messages, messages);
    };
    MessageQueue.prototype.prepend = function (messages) {
        this.messages.unshift.apply(this.messages, messages);
    };
    MessageQueue.prototype.completeMessages = function (serial, count, err) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'MessageQueue.completeMessages()', 'serial = ' + serial + '; count = ' + count);
        err = err || null;
        var messages = this.messages;
        if (messages.length === 0) {
            throw new Error('MessageQueue.completeMessages(): completeMessages called on any empty MessageQueue');
        }
        var first = messages[0];
        if (first) {
            var startSerial = first.message.msgSerial;
            var endSerial = serial + count; /* the serial of the first message that is *not* the subject of this call */
            if (endSerial > startSerial) {
                var completeMessages = messages.splice(0, endSerial - startSerial);
                for (var _i = 0, completeMessages_1 = completeMessages; _i < completeMessages_1.length; _i++) {
                    var message = completeMessages_1[_i];
                    message.callback(err);
                }
            }
            if (messages.length == 0)
                this.emit('idle');
        }
    };
    MessageQueue.prototype.completeAllMessages = function (err) {
        this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);
    };
    MessageQueue.prototype.resetSendAttempted = function () {
        for (var _i = 0, _a = this.messages; _i < _a.length; _i++) {
            var msg = _a[_i];
            msg.sendAttempted = false;
        }
    };
    MessageQueue.prototype.clear = function () {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'MessageQueue.clear()', 'clearing ' + this.messages.length + ' messages');
        this.messages = [];
        this.emit('idle');
    };
    return MessageQueue;
}(eventemitter_1.default));
exports.default = MessageQueue;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ConnectionStateChange = /** @class */ (function () {
    function ConnectionStateChange(previous, current, retryIn, reason) {
        this.previous = previous;
        this.current = current;
        if (retryIn)
            this.retryIn = retryIn;
        if (reason)
            this.reason = reason;
    }
    return ConnectionStateChange;
}());
exports.default = ConnectionStateChange;


/***/ }),
/* 38 */
/***/ (function(module, exports, __nested_webpack_require_395113__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_395113__(0);
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(10));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(7));
var Utils = tslib_1.__importStar(__nested_webpack_require_395113__(1));
var channel_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(33));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(2));
var realtimepresence_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(54));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(9));
var channelstatechange_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(39));
var errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_395113__(4));
var presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(15));
var connectionerrors_1 = tslib_1.__importDefault(__nested_webpack_require_395113__(20));
var actions = protocolmessage_1.default.Action;
var noop = function () { };
function validateChannelOptions(options) {
    if (options && 'params' in options && !Utils.isObject(options.params)) {
        return new errorinfo_1.default('options.params must be an object', 40000, 400);
    }
    if (options && 'modes' in options) {
        if (!Utils.isArray(options.modes)) {
            return new errorinfo_1.default('options.modes must be an array', 40000, 400);
        }
        for (var i = 0; i < options.modes.length; i++) {
            var currentMode = options.modes[i];
            if (!currentMode ||
                typeof currentMode !== 'string' ||
                !Utils.arrIn(protocolmessage_1.default.channelModes, String.prototype.toUpperCase.call(currentMode))) {
                return new errorinfo_1.default('Invalid channel mode: ' + currentMode, 40000, 400);
            }
        }
    }
}
var RealtimeChannel = /** @class */ (function (_super) {
    tslib_1.__extends(RealtimeChannel, _super);
    function RealtimeChannel(realtime, name, options) {
        var _this = _super.call(this, realtime, name, options) || this;
        _this.retryCount = 0;
        _this.history = function (params, callback) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.history()', 'channel = ' + this.name);
            /* params and callback are optional; see if params contains the callback */
            if (callback === undefined) {
                if (typeof params == 'function') {
                    callback = params;
                    params = null;
                }
                else {
                    if (this.rest.options.promises) {
                        return Utils.promisify(this, 'history', arguments);
                    }
                    callback = noop;
                }
            }
            if (params && params.untilAttach) {
                if (this.state !== 'attached') {
                    callback(new errorinfo_1.default('option untilAttach requires the channel to be attached', 40000, 400));
                    return;
                }
                if (!this.properties.attachSerial) {
                    callback(new errorinfo_1.default('untilAttach was specified and channel is attached, but attachSerial is not defined', 40000, 400));
                    return;
                }
                delete params.untilAttach;
                params.from_serial = this.properties.attachSerial;
            }
            channel_1.default.prototype._history.call(this, params, callback);
        };
        _this.whenState = (function (state, listener) {
            return eventemitter_1.default.prototype.whenState.call(_this, state, _this.state, listener);
        });
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel()', 'started; name = ' + name);
        _this.realtime = realtime;
        _this.presence = new realtimepresence_1.default(_this);
        _this.connectionManager = realtime.connection.connectionManager;
        _this.state = 'initialized';
        _this.subscriptions = new eventemitter_1.default();
        _this.syncChannelSerial = undefined;
        _this.properties = {
            attachSerial: undefined,
            channelSerial: undefined,
        };
        _this.setOptions(options);
        _this.errorReason = null;
        _this._requestedFlags = null;
        _this._mode = null;
        _this._attachResume = false;
        _this._decodingContext = {
            channelOptions: _this.channelOptions,
            plugins: realtime.options.plugins || {},
            baseEncodedPreviousPayload: undefined,
        };
        _this._lastPayload = {
            messageId: null,
            protocolMessageChannelSerial: null,
            decodeFailureRecoveryInProgress: null,
        };
        /* Only differences between this and the public event emitter is that this emits an
         * update event for all ATTACHEDs, whether resumed or not */
        _this._allChannelChanges = new eventemitter_1.default();
        return _this;
    }
    RealtimeChannel.prototype.invalidStateError = function () {
        return new errorinfo_1.default('Channel operation failed as channel state is ' + this.state, 90001, 400, this.errorReason || undefined);
    };
    RealtimeChannel.processListenerArgs = function (args) {
        /* [event], listener, [callback] */
        args = Array.prototype.slice.call(args);
        if (typeof args[0] === 'function') {
            args.unshift(null);
        }
        if (args[args.length - 1] == undefined) {
            args.pop();
        }
        return args;
    };
    RealtimeChannel.prototype.setOptions = function (options, callback) {
        if (!callback) {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'setOptions', arguments);
            }
        }
        var _callback = callback ||
            function (err) {
                if (err) {
                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.setOptions()', 'Set options failed: ' + err.toString());
                }
            };
        var err = validateChannelOptions(options);
        if (err) {
            _callback(err);
            return;
        }
        channel_1.default.prototype.setOptions.call(this, options);
        if (this._decodingContext)
            this._decodingContext.channelOptions = this.channelOptions;
        if (this._shouldReattachToSetOptions(options)) {
            /* This does not just do _attach(true, null, callback) because that would put us
             * into the 'attaching' state until we receive the new attached, which is
             * conceptually incorrect: we are still attached, we just have a pending request to
             * change some channel params. Per RTL17 going into the attaching state would mean
             * rejecting messages until we have confirmation that the options have changed,
             * which would unnecessarily lose message continuity. */
            this.attachImpl();
            // Ignore 'attaching' -- could be just due to to a resume & reattach, should not
            // call back setOptions until we're definitely attached with the new options (or
            // else in a terminal state)
            this._allChannelChanges.once(['attached', 'update', 'detached', 'failed'], function (stateChange) {
                switch (this.event) {
                    case 'update':
                    case 'attached':
                        _callback === null || _callback === void 0 ? void 0 : _callback(null);
                        return;
                    default:
                        _callback === null || _callback === void 0 ? void 0 : _callback(stateChange.reason);
                        return;
                }
            });
        }
        else {
            _callback();
        }
    };
    RealtimeChannel.prototype._shouldReattachToSetOptions = function (options) {
        return (this.state === 'attached' || this.state === 'attaching') && ((options === null || options === void 0 ? void 0 : options.params) || (options === null || options === void 0 ? void 0 : options.modes));
    };
    RealtimeChannel.prototype.publish = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var messages = args[0];
        var argCount = args.length;
        var callback = args[argCount - 1];
        if (typeof callback !== 'function') {
            if (this.realtime.options.promises) {
                return Utils.promisify(this, 'publish', arguments);
            }
            callback = noop;
            ++argCount;
        }
        if (!this.connectionManager.activeState()) {
            callback(this.connectionManager.getError());
            return;
        }
        if (argCount == 2) {
            if (Utils.isObject(messages))
                messages = [message_1.default.fromValues(messages)];
            else if (Utils.isArray(messages))
                messages = message_1.default.fromValuesArray(messages);
            else
                throw new errorinfo_1.default('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);
        }
        else {
            messages = [message_1.default.fromValues({ name: args[0], data: args[1] })];
        }
        var maxMessageSize = this.realtime.options.maxMessageSize;
        message_1.default.encodeArray(messages, this.channelOptions, function (err) {
            if (err) {
                callback(err);
                return;
            }
            /* RSL1i */
            var size = message_1.default.getMessagesSize(messages);
            if (size > maxMessageSize) {
                callback(new errorinfo_1.default('Maximum size of messages that can be published at once exceeded ( was ' +
                    size +
                    ' bytes; limit is ' +
                    maxMessageSize +
                    ' bytes)', 40009, 400));
                return;
            }
            _this.__publish(messages, callback);
        });
    };
    // Double underscore used to prevent type conflict with underlying Channel._publish method
    RealtimeChannel.prototype.__publish = function (messages, callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.publish()', 'message count = ' + messages.length);
        var state = this.state;
        switch (state) {
            case 'failed':
            case 'suspended':
                callback(errorinfo_1.default.fromValues(this.invalidStateError()));
                break;
            default: {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.publish()', 'sending message; channel state is ' + state);
                var msg = new protocolmessage_1.default();
                msg.action = actions.MESSAGE;
                msg.channel = this.name;
                msg.messages = messages;
                this.sendMessage(msg, callback);
                break;
            }
        }
    };
    RealtimeChannel.prototype.onEvent = function (messages) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.onEvent()', 'received message');
        var subscriptions = this.subscriptions;
        for (var i = 0; i < messages.length; i++) {
            var message = messages[i];
            subscriptions.emit(message.name, message);
        }
    };
    RealtimeChannel.prototype.attach = function (flags, callback) {
        var _flags;
        if (typeof flags === 'function') {
            callback = flags;
            _flags = null;
        }
        else {
            _flags = flags;
        }
        if (!callback) {
            if (this.realtime.options.promises) {
                return Utils.promisify(this, 'attach', arguments);
            }
            callback = function (err) {
                if (err) {
                    logger_1.default.logAction(logger_1.default.LOG_MAJOR, 'RealtimeChannel.attach()', 'Channel attach failed: ' + err.toString());
                }
            };
        }
        if (_flags) {
            logger_1.default.deprecated('channel.attach() with flags', 'channel.setOptions() with channelOptions.params');
            /* If flags requested, always do a re-attach. TODO only do this if
             * current mode differs from requested mode */
            this._requestedFlags = _flags;
        }
        else if (this.state === 'attached') {
            callback(null, null);
            return;
        }
        this._attach(false, null, callback);
    };
    RealtimeChannel.prototype._attach = function (forceReattach, attachReason, callback) {
        if (!callback) {
            callback = function (err) {
                if (err) {
                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel._attach()', 'Channel attach failed: ' + err.toString());
                }
            };
        }
        var connectionManager = this.connectionManager;
        if (!connectionManager.activeState()) {
            callback(connectionManager.getError());
            return;
        }
        if (this.state !== 'attaching' || forceReattach) {
            this.requestState('attaching', attachReason);
        }
        this.once(function (stateChange) {
            switch (this.event) {
                case 'attached':
                    callback === null || callback === void 0 ? void 0 : callback(null, stateChange);
                    break;
                case 'detached':
                case 'suspended':
                case 'failed':
                    callback === null || callback === void 0 ? void 0 : callback(stateChange.reason ||
                        connectionManager.getError() ||
                        new errorinfo_1.default('Unable to attach; reason unknown; state = ' + this.event, 90000, 500));
                    break;
                case 'detaching':
                    callback === null || callback === void 0 ? void 0 : callback(new errorinfo_1.default('Attach request superseded by a subsequent detach request', 90000, 409));
                    break;
            }
        });
    };
    RealtimeChannel.prototype.attachImpl = function () {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.attachImpl()', 'sending ATTACH message');
        var attachMsg = protocolmessage_1.default.fromValues({
            action: actions.ATTACH,
            channel: this.name,
            params: this.channelOptions.params,
            // RTL4c1: Includes the channel serial to resume from a previous message
            // or attachment.
            channelSerial: this.properties.channelSerial,
        });
        if (this._requestedFlags) {
            attachMsg.encodeModesToFlags(this._requestedFlags);
        }
        else if (this.channelOptions.modes) {
            attachMsg.encodeModesToFlags(Utils.allToUpperCase(this.channelOptions.modes));
        }
        if (this._attachResume) {
            attachMsg.setFlag('ATTACH_RESUME');
        }
        if (this._lastPayload.decodeFailureRecoveryInProgress) {
            attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;
        }
        this.sendMessage(attachMsg, noop);
    };
    RealtimeChannel.prototype.detach = function (callback) {
        if (!callback) {
            if (this.realtime.options.promises) {
                return Utils.promisify(this, 'detach', arguments);
            }
            callback = noop;
        }
        var connectionManager = this.connectionManager;
        if (!connectionManager.activeState()) {
            callback(connectionManager.getError());
            return;
        }
        switch (this.state) {
            case 'suspended':
                this.notifyState('detached');
                callback();
                break;
            case 'detached':
                callback();
                break;
            case 'failed':
                callback(new errorinfo_1.default('Unable to detach; channel state = failed', 90001, 400));
                break;
            default:
                this.requestState('detaching');
            // eslint-disable-next-line no-fallthrough
            case 'detaching':
                this.once(function (stateChange) {
                    switch (this.event) {
                        case 'detached':
                            callback();
                            break;
                        case 'attached':
                        case 'suspended':
                        case 'failed':
                            callback(stateChange.reason ||
                                connectionManager.getError() ||
                                new errorinfo_1.default('Unable to detach; reason unknown; state = ' + this.event, 90000, 500));
                            break;
                        case 'attaching':
                            callback(new errorinfo_1.default('Detach request superseded by a subsequent attach request', 90000, 409));
                            break;
                    }
                });
        }
    };
    RealtimeChannel.prototype.detachImpl = function (callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.detach()', 'sending DETACH message');
        var msg = protocolmessage_1.default.fromValues({ action: actions.DETACH, channel: this.name });
        this.sendMessage(msg, callback || noop);
    };
    RealtimeChannel.prototype.subscribe = function () {
        var args = []; /* [event], listener, [callback] */
        for (var _i = 0 /* [event], listener, [callback] */; _i < arguments.length /* [event], listener, [callback] */; _i++ /* [event], listener, [callback] */) {
            args[_i] = arguments[_i]; /* [event], listener, [callback] */
        }
        var _a = RealtimeChannel.processListenerArgs(args), event = _a[0], listener = _a[1], callback = _a[2];
        if (!callback && this.realtime.options.promises) {
            return Utils.promisify(this, 'subscribe', [event, listener]);
        }
        if (this.state === 'failed') {
            callback === null || callback === void 0 ? void 0 : callback(errorinfo_1.default.fromValues(this.invalidStateError()));
            return;
        }
        // Filtered
        if (event && typeof event === 'object' && !Array.isArray(event)) {
            this._subscribeFilter(event, listener);
        }
        else {
            this.subscriptions.on(event, listener);
        }
        return this.attach(callback || noop);
    };
    RealtimeChannel.prototype._subscribeFilter = function (filter, listener) {
        var filteredListener = function (m) {
            var _a, _b, _c, _d, _e, _f;
            var mapping = {
                name: m.name,
                refTimeserial: (_b = (_a = m.extras) === null || _a === void 0 ? void 0 : _a.ref) === null || _b === void 0 ? void 0 : _b.timeserial,
                refType: (_d = (_c = m.extras) === null || _c === void 0 ? void 0 : _c.ref) === null || _d === void 0 ? void 0 : _d.type,
                isRef: !!((_f = (_e = m.extras) === null || _e === void 0 ? void 0 : _e.ref) === null || _f === void 0 ? void 0 : _f.timeserial),
                clientId: m.clientId,
            };
            // Check if any values are defined in the filter and if they match the value in the message object
            if (Object.entries(filter).find(function (_a) {
                var key = _a[0], value = _a[1];
                return value !== undefined ? mapping[key] !== value : false;
            })) {
                return;
            }
            listener(m);
        };
        this._addFilteredSubscription(filter, listener, filteredListener);
        this.subscriptions.on(filteredListener);
    };
    // Adds a new filtered subscription
    RealtimeChannel.prototype._addFilteredSubscription = function (filter, realListener, filteredListener) {
        var _a;
        if (!this.filteredSubscriptions) {
            this.filteredSubscriptions = new Map();
        }
        if (this.filteredSubscriptions.has(realListener)) {
            var realListenerMap = this.filteredSubscriptions.get(realListener);
            // Add the filtered listener to the map, or append to the array if this filter has already been used
            realListenerMap.set(filter, ((_a = realListenerMap === null || realListenerMap === void 0 ? void 0 : realListenerMap.get(filter)) === null || _a === void 0 ? void 0 : _a.concat(filteredListener)) || [filteredListener]);
        }
        else {
            this.filteredSubscriptions.set(realListener, new Map([[filter, [filteredListener]]]));
        }
    };
    RealtimeChannel.prototype._getAndDeleteFilteredSubscriptions = function (filter, realListener) {
        var _this = this;
        // No filtered subscriptions map means there has been no filtered subscriptions yet, so return nothing
        if (!this.filteredSubscriptions) {
            return [];
        }
        // Only a filter is passed in with no specific listener
        if (!realListener && filter) {
            // Return each listener which is attached to the specified filter object
            return Array.from(this.filteredSubscriptions.entries())
                .map(function (_a) {
                var _b;
                var key = _a[0], filterMaps = _a[1];
                // Get (then delete) the maps matching this filter
                var listenerMaps = filterMaps.get(filter);
                filterMaps.delete(filter);
                // Clear the parent if nothing is left
                if (filterMaps.size === 0) {
                    (_b = _this.filteredSubscriptions) === null || _b === void 0 ? void 0 : _b.delete(key);
                }
                return listenerMaps;
            })
                .reduce(function (prev, cur) {
                var _a;
                return (cur ? (_a = prev).concat.apply(_a, cur) : prev);
            }, []);
        }
        // No subscriptions for this listener
        if (!realListener || !this.filteredSubscriptions.has(realListener)) {
            return [];
        }
        var realListenerMap = this.filteredSubscriptions.get(realListener);
        // If no filter is specified return all listeners using that function
        if (!filter) {
            // array.flat is not available unless we support es2019 or higher
            var listeners_1 = Array.from(realListenerMap.values()).reduce(function (prev, cur) { return prev.concat.apply(prev, cur); }, []);
            // remove the listener from the map
            this.filteredSubscriptions.delete(realListener);
            return listeners_1;
        }
        var listeners = realListenerMap.get(filter);
        realListenerMap.delete(filter);
        return listeners || [];
    };
    RealtimeChannel.prototype.unsubscribe = function () {
        var _this = this;
        var _a;
        var args = []; /* [event], listener */
        for (var _i = 0 /* [event], listener */; _i < arguments.length /* [event], listener */; _i++ /* [event], listener */) {
            args[_i] = arguments[_i]; /* [event], listener */
        }
        var _b = RealtimeChannel.processListenerArgs(args), event = _b[0], listener = _b[1];
        // If we either have a filtered listener, a filter or both we need to do additional processing to find the original function(s)
        if ((typeof event === 'object' && !listener) || ((_a = this.filteredSubscriptions) === null || _a === void 0 ? void 0 : _a.has(listener))) {
            this._getAndDeleteFilteredSubscriptions(event, listener).forEach(function (l) { return _this.subscriptions.off(l); });
            return;
        }
        this.subscriptions.off(event, listener);
    };
    RealtimeChannel.prototype.sync = function () {
        /* check preconditions */
        switch (this.state) {
            case 'initialized':
            case 'detaching':
            case 'detached':
                throw new errorinfo_1.PartialErrorInfo('Unable to sync to channel; not attached', 40000);
            default:
        }
        var connectionManager = this.connectionManager;
        if (!connectionManager.activeState()) {
            throw connectionManager.getError();
        }
        /* send sync request */
        var syncMessage = protocolmessage_1.default.fromValues({ action: actions.SYNC, channel: this.name });
        if (this.syncChannelSerial) {
            syncMessage.channelSerial = this.syncChannelSerial;
        }
        connectionManager.send(syncMessage);
    };
    RealtimeChannel.prototype.sendMessage = function (msg, callback) {
        this.connectionManager.send(msg, this.realtime.options.queueMessages, callback);
    };
    RealtimeChannel.prototype.sendPresence = function (presence, callback) {
        var msg = protocolmessage_1.default.fromValues({
            action: actions.PRESENCE,
            channel: this.name,
            presence: Utils.isArray(presence)
                ? presencemessage_1.default.fromValuesArray(presence)
                : [presencemessage_1.default.fromValues(presence)],
        });
        this.sendMessage(msg, callback);
    };
    RealtimeChannel.prototype.onMessage = function (message) {
        if (message.action === actions.ATTACHED ||
            message.action === actions.MESSAGE ||
            message.action === actions.PRESENCE) {
            // RTL15b
            this.setChannelSerial(message.channelSerial);
        }
        var syncChannelSerial, isSync = false;
        switch (message.action) {
            case actions.ATTACHED: {
                this.properties.attachSerial = message.channelSerial;
                this._mode = message.getMode();
                this.params = message.params || {};
                var modesFromFlags = message.decodeModesFromFlags();
                this.modes = (modesFromFlags && Utils.allToLowerCase(modesFromFlags)) || undefined;
                var resumed = message.hasFlag('RESUMED');
                var hasPresence = message.hasFlag('HAS_PRESENCE');
                var hasBacklog = message.hasFlag('HAS_BACKLOG');
                if (this.state === 'attached') {
                    if (!resumed) {
                        /* On a loss of continuity, the presence set needs to be re-synced */
                        this.presence.onAttached(hasPresence);
                    }
                    var change = new channelstatechange_1.default(this.state, this.state, resumed, hasBacklog, message.error);
                    this._allChannelChanges.emit('update', change);
                    if (!resumed || this.channelOptions.updateOnAttached) {
                        this.emit('update', change);
                    }
                }
                else if (this.state === 'detaching') {
                    /* RTL5i: re-send DETACH and remain in the 'detaching' state */
                    this.checkPendingState();
                }
                else {
                    this.notifyState('attached', message.error, resumed, hasPresence, hasBacklog);
                }
                break;
            }
            case actions.DETACHED: {
                var detachErr = message.error
                    ? errorinfo_1.default.fromValues(message.error)
                    : new errorinfo_1.default('Channel detached', 90001, 404);
                if (this.state === 'detaching') {
                    this.notifyState('detached', detachErr);
                }
                else if (this.state === 'attaching') {
                    /* Only retry immediately if we were previously attached. If we were
                     * attaching, go into suspended, fail messages, and wait a few seconds
                     * before retrying */
                    this.notifyState('suspended', detachErr);
                }
                else {
                    this.requestState('attaching', detachErr);
                }
                break;
            }
            case actions.SYNC:
                /* syncs can have channelSerials, but might not if the sync is one page long */
                isSync = true;
                syncChannelSerial = this.syncChannelSerial = message.channelSerial;
                /* syncs can happen on channels with no presence data as part of connection
                 * resuming, in which case protocol message has no presence property */
                if (!message.presence)
                    break;
            // eslint-disable-next-line no-fallthrough
            case actions.PRESENCE: {
                var presence = message.presence;
                var id = message.id, connectionId = message.connectionId, timestamp = message.timestamp;
                var options = this.channelOptions;
                var presenceMsg = void 0;
                for (var i = 0; i < presence.length; i++) {
                    try {
                        presenceMsg = presence[i];
                        presencemessage_1.default.decode(presenceMsg, options);
                        if (!presenceMsg.connectionId)
                            presenceMsg.connectionId = connectionId;
                        if (!presenceMsg.timestamp)
                            presenceMsg.timestamp = timestamp;
                        if (!presenceMsg.id)
                            presenceMsg.id = id + ':' + i;
                    }
                    catch (e) {
                        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());
                    }
                }
                this.presence.setPresence(presence, isSync, syncChannelSerial);
                break;
            }
            case actions.MESSAGE: {
                //RTL17
                if (this.state !== 'attached') {
                    logger_1.default.logAction(logger_1.default.LOG_MAJOR, 'RealtimeChannel.onMessage()', 'Message "' +
                        message.id +
                        '" skipped as this channel "' +
                        this.name +
                        '" state is not "attached" (state is "' +
                        this.state +
                        '").');
                    return;
                }
                var messages = message.messages, firstMessage = messages[0], lastMessage = messages[messages.length - 1], id = message.id, connectionId = message.connectionId, timestamp = message.timestamp;
                if (firstMessage.extras &&
                    firstMessage.extras.delta &&
                    firstMessage.extras.delta.from !== this._lastPayload.messageId) {
                    var msg = 'Delta message decode failure - previous message not available for message "' +
                        message.id +
                        '" on this channel "' +
                        this.name +
                        '".';
                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.onMessage()', msg);
                    this._startDecodeFailureRecovery(new errorinfo_1.default(msg, 40018, 400));
                    break;
                }
                for (var i = 0; i < messages.length; i++) {
                    var msg = messages[i];
                    try {
                        message_1.default.decode(msg, this._decodingContext);
                    }
                    catch (e) {
                        /* decrypt failed .. the most likely cause is that we have the wrong key */
                        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());
                        switch (e.code) {
                            case 40018:
                                /* decode failure */
                                this._startDecodeFailureRecovery(e);
                                return;
                            case 40019:
                            /* No vcdiff plugin passed in - no point recovering, give up */
                            // eslint-disable-next-line no-fallthrough
                            case 40021:
                                /* Browser does not support deltas, similarly no point recovering */
                                this.notifyState('failed', e);
                                return;
                        }
                    }
                    if (!msg.connectionId)
                        msg.connectionId = connectionId;
                    if (!msg.timestamp)
                        msg.timestamp = timestamp;
                    if (!msg.id)
                        msg.id = id + ':' + i;
                }
                this._lastPayload.messageId = lastMessage.id;
                this._lastPayload.protocolMessageChannelSerial = message.channelSerial;
                this.onEvent(messages);
                break;
            }
            case actions.ERROR: {
                /* there was a channel-specific error */
                var err = message.error;
                if (err && err.code == 80016) {
                    /* attach/detach operation attempted on superseded transport handle */
                    this.checkPendingState();
                }
                else {
                    this.notifyState('failed', errorinfo_1.default.fromValues(err));
                }
                break;
            }
            default:
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.onMessage()', 'Fatal protocol error: unrecognised action (' + message.action + ')');
                this.connectionManager.abort(connectionerrors_1.default.unknownChannelErr());
        }
    };
    RealtimeChannel.prototype._startDecodeFailureRecovery = function (reason) {
        var _this = this;
        if (!this._lastPayload.decodeFailureRecoveryInProgress) {
            logger_1.default.logAction(logger_1.default.LOG_MAJOR, 'RealtimeChannel.onMessage()', 'Starting decode failure recovery process.');
            this._lastPayload.decodeFailureRecoveryInProgress = true;
            this._attach(true, reason, function () {
                _this._lastPayload.decodeFailureRecoveryInProgress = false;
            });
        }
    };
    RealtimeChannel.prototype.onAttached = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.onAttached', 'activating channel; name = ' + this.name);
    };
    RealtimeChannel.prototype.notifyState = function (state, reason, resumed, hasPresence, hasBacklog) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.notifyState', 'name = ' + this.name + ', current state = ' + this.state + ', notifying state ' + state);
        this.clearStateTimer();
        // RTP5a1
        if (Utils.arrIn(['detached', 'suspended', 'failed'], state)) {
            this.properties.channelSerial = null;
        }
        if (state === this.state) {
            return;
        }
        this.presence.actOnChannelState(state, hasPresence, reason);
        if (state === 'suspended' && this.connectionManager.state.sendEvents) {
            this.startRetryTimer();
        }
        else {
            this.cancelRetryTimer();
        }
        if (reason) {
            this.errorReason = reason;
        }
        var change = new channelstatechange_1.default(this.state, state, resumed, hasBacklog, reason);
        var logLevel = state === 'failed' ? logger_1.default.LOG_ERROR : logger_1.default.LOG_MAJOR;
        logger_1.default.logAction(logLevel, 'Channel state for channel "' + this.name + '"', state + (reason ? '; reason: ' + reason : ''));
        if (state !== 'attaching' && state !== 'suspended') {
            this.retryCount = 0;
        }
        /* Note: we don't set inProgress for pending states until the request is actually in progress */
        if (state === 'attached') {
            this.onAttached();
        }
        if (state === 'attached') {
            this._attachResume = true;
        }
        else if (state === 'detaching' || state === 'failed') {
            this._attachResume = false;
        }
        this.state = state;
        this._allChannelChanges.emit(state, change);
        this.emit(state, change);
    };
    RealtimeChannel.prototype.requestState = function (state, reason) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.requestState', 'name = ' + this.name + ', state = ' + state);
        this.notifyState(state, reason);
        /* send the event and await response */
        this.checkPendingState();
    };
    RealtimeChannel.prototype.checkPendingState = function () {
        /* if can't send events, do nothing */
        var cmState = this.connectionManager.state;
        /* Allow attach messages to queue up when synchronizing, since this will be
         * the state we'll be in when upgrade transport.active triggers a checkpendingstate */
        if (!(cmState.sendEvents || cmState.forceQueueEvents)) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.checkPendingState', 'sendEvents is false; state is ' + this.connectionManager.state.state);
            return;
        }
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.checkPendingState', 'name = ' + this.name + ', state = ' + this.state);
        /* Only start the state timer running when actually sending the event */
        switch (this.state) {
            case 'attaching':
                this.startStateTimerIfNotRunning();
                this.attachImpl();
                break;
            case 'detaching':
                this.startStateTimerIfNotRunning();
                this.detachImpl();
                break;
            case 'attached':
                /* resume any sync operation that was in progress */
                this.sync();
                break;
            default:
                break;
        }
    };
    RealtimeChannel.prototype.timeoutPendingState = function () {
        switch (this.state) {
            case 'attaching': {
                var err = new errorinfo_1.default('Channel attach timed out', 90007, 408);
                this.notifyState('suspended', err);
                break;
            }
            case 'detaching': {
                var err = new errorinfo_1.default('Channel detach timed out', 90007, 408);
                this.notifyState('attached', err);
                break;
            }
            default:
                this.checkPendingState();
                break;
        }
    };
    RealtimeChannel.prototype.startStateTimerIfNotRunning = function () {
        var _this = this;
        if (!this.stateTimer) {
            this.stateTimer = setTimeout(function () {
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.startStateTimerIfNotRunning', 'timer expired');
                _this.stateTimer = null;
                _this.timeoutPendingState();
            }, this.realtime.options.timeouts.realtimeRequestTimeout);
        }
    };
    RealtimeChannel.prototype.clearStateTimer = function () {
        var stateTimer = this.stateTimer;
        if (stateTimer) {
            clearTimeout(stateTimer);
            this.stateTimer = null;
        }
    };
    RealtimeChannel.prototype.startRetryTimer = function () {
        var _this = this;
        if (this.retryTimer)
            return;
        this.retryCount++;
        var retryDelay = Utils.getRetryTime(this.realtime.options.timeouts.channelRetryTimeout, this.retryCount);
        this.retryTimer = setTimeout(function () {
            /* If connection is not connected, just leave in suspended, a reattach
             * will be triggered once it connects again */
            if (_this.state === 'suspended' && _this.connectionManager.state.sendEvents) {
                _this.retryTimer = null;
                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel retry timer expired', 'attempting a new attach');
                _this.requestState('attaching');
            }
        }, retryDelay);
    };
    RealtimeChannel.prototype.cancelRetryTimer = function () {
        if (this.retryTimer) {
            clearTimeout(this.retryTimer);
            this.retryTimer = null;
        }
    };
    /* @returns null (if can safely be released) | ErrorInfo (if cannot) */
    RealtimeChannel.prototype.getReleaseErr = function () {
        var s = this.state;
        if (s === 'initialized' || s === 'detached' || s === 'failed') {
            return null;
        }
        return new errorinfo_1.default('Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was ' +
            s, 90001, 400);
    };
    RealtimeChannel.prototype.setChannelSerial = function (channelSerial) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.setChannelSerial()', 'Updating channel serial; serial = ' + channelSerial + '; previous = ' + this.properties.channelSerial);
        // RTP17h: Only update the channel serial if its present (it won't always
        // be set).
        if (channelSerial) {
            this.properties.channelSerial = channelSerial;
        }
    };
    return RealtimeChannel;
}(channel_1.default));
exports.default = RealtimeChannel;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ChannelStateChange = /** @class */ (function () {
    function ChannelStateChange(previous, current, resumed, hasBacklog, reason) {
        this.previous = previous;
        this.current = current;
        if (current === 'attached') {
            this.resumed = resumed;
            this.hasBacklog = hasBacklog;
        }
        if (reason)
            this.reason = reason;
    }
    return ChannelStateChange;
}());
exports.default = ChannelStateChange;


/***/ }),
/* 40 */
/***/ (function(module, exports, __nested_webpack_require_437421__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_437421__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function inspect(buffer) {
    if (buffer === undefined)
        return 'undefined';
    var view;
    var type;
    if (buffer instanceof ArrayBuffer) {
        type = 'ArrayBuffer';
        view = new DataView(buffer);
    }
    else if (buffer instanceof DataView) {
        type = 'DataView';
        view = buffer;
    }
    if (!view)
        return JSON.stringify(buffer);
    var bytes = [];
    for (var i = 0; i < buffer.byteLength; i++) {
        if (i > 20) {
            bytes.push('...');
            break;
        }
        var byte_ = view.getUint8(i).toString(16);
        if (byte_.length === 1)
            byte_ = '0' + byte_;
        bytes.push(byte_);
    }
    return '<' + type + ' ' + bytes.join(' ') + '>';
}
// Encode string as utf8 into dataview at offset
function utf8Write(view, offset, string) {
    for (var i = 0, l = string.length; i < l; i++) {
        var codePoint = string.charCodeAt(i);
        // One byte of UTF-8
        if (codePoint < 0x80) {
            view.setUint8(offset++, ((codePoint >>> 0) & 0x7f) | 0x00);
            continue;
        }
        // Two bytes of UTF-8
        if (codePoint < 0x800) {
            view.setUint8(offset++, ((codePoint >>> 6) & 0x1f) | 0xc0);
            view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);
            continue;
        }
        // Three bytes of UTF-8.
        if (codePoint < 0x10000) {
            view.setUint8(offset++, ((codePoint >>> 12) & 0x0f) | 0xe0);
            view.setUint8(offset++, ((codePoint >>> 6) & 0x3f) | 0x80);
            view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);
            continue;
        }
        // Four bytes of UTF-8
        if (codePoint < 0x110000) {
            view.setUint8(offset++, ((codePoint >>> 18) & 0x07) | 0xf0);
            view.setUint8(offset++, ((codePoint >>> 12) & 0x3f) | 0x80);
            view.setUint8(offset++, ((codePoint >>> 6) & 0x3f) | 0x80);
            view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);
            continue;
        }
        throw new Error('bad codepoint ' + codePoint);
    }
}
function utf8Read(view, offset, length) {
    var string = '';
    for (var i = offset, end = offset + length; i < end; i++) {
        var byte_ = view.getUint8(i);
        // One byte character
        if ((byte_ & 0x80) === 0x00) {
            string += String.fromCharCode(byte_);
            continue;
        }
        // Two byte character
        if ((byte_ & 0xe0) === 0xc0) {
            string += String.fromCharCode(((byte_ & 0x0f) << 6) | (view.getUint8(++i) & 0x3f));
            continue;
        }
        // Three byte character
        if ((byte_ & 0xf0) === 0xe0) {
            string += String.fromCharCode(((byte_ & 0x0f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0));
            continue;
        }
        // Four byte character
        if ((byte_ & 0xf8) === 0xf0) {
            string += String.fromCharCode(((byte_ & 0x07) << 18) |
                ((view.getUint8(++i) & 0x3f) << 12) |
                ((view.getUint8(++i) & 0x3f) << 6) |
                ((view.getUint8(++i) & 0x3f) << 0));
            continue;
        }
        throw new Error('Invalid byte ' + byte_.toString(16));
    }
    return string;
}
function utf8ByteCount(string) {
    var count = 0;
    for (var i = 0, l = string.length; i < l; i++) {
        var codePoint = string.charCodeAt(i);
        if (codePoint < 0x80) {
            count += 1;
            continue;
        }
        if (codePoint < 0x800) {
            count += 2;
            continue;
        }
        if (codePoint < 0x10000) {
            count += 3;
            continue;
        }
        if (codePoint < 0x110000) {
            count += 4;
            continue;
        }
        throw new Error('bad codepoint ' + codePoint);
    }
    return count;
}
function encode(value, sparse) {
    var size = sizeof(value, sparse);
    if (size === 0)
        return undefined;
    var buffer = new ArrayBuffer(size);
    var view = new DataView(buffer);
    _encode(value, view, 0, sparse);
    return buffer;
}
var SH_L_32 = (1 << 16) * (1 << 16), SH_R_32 = 1 / SH_L_32;
function getInt64(view, offset) {
    offset = offset || 0;
    return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);
}
function getUint64(view, offset) {
    offset = offset || 0;
    return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);
}
function setInt64(view, offset, val) {
    if (val < 0x8000000000000000) {
        view.setInt32(offset, Math.floor(val * SH_R_32));
        view.setInt32(offset + 4, val & -1);
    }
    else {
        view.setUint32(offset, 0x7fffffff);
        view.setUint32(offset + 4, 0x7fffffff);
    }
}
function setUint64(view, offset, val) {
    if (val < 0x10000000000000000) {
        view.setUint32(offset, Math.floor(val * SH_R_32));
        view.setInt32(offset + 4, val & -1);
    }
    else {
        view.setUint32(offset, 0xffffffff);
        view.setUint32(offset + 4, 0xffffffff);
    }
}
// https://gist.github.com/frsyuki/5432559 - v5 spec
//
// I've used one extension point from `fixext 1` to store `undefined`. On the wire this
// should translate to exactly 0xd40000
//
// +--------+--------+--------+
// |  0xd4  |  0x00  |  0x00  |
// +--------+--------+--------+
//    ^ fixext |        ^ value part unused (fixed to be 0)
//             ^ indicates undefined value
//
var Decoder = /** @class */ (function () {
    function Decoder(view, offset) {
        var _this = this;
        this.map = function (length) {
            var value = {};
            for (var i = 0; i < length; i++) {
                var key = _this.parse();
                value[key] = _this.parse();
            }
            return value;
        };
        this.bin = function (length) {
            var value = new ArrayBuffer(length);
            new Uint8Array(value).set(new Uint8Array(_this.view.buffer, _this.offset, length), 0);
            _this.offset += length;
            return value;
        };
        this.buf = this.bin;
        this.str = function (length) {
            var value = utf8Read(_this.view, _this.offset, length);
            _this.offset += length;
            return value;
        };
        this.array = function (length) {
            var value = new Array(length);
            for (var i = 0; i < length; i++) {
                value[i] = _this.parse();
            }
            return value;
        };
        this.ext = function (length) {
            _this.offset += length;
            return {
                type: _this.view.getInt8(_this.offset),
                data: _this.buf(length),
            };
        };
        this.parse = function () {
            var type = _this.view.getUint8(_this.offset);
            var value, length;
            // Positive FixInt - 0xxxxxxx
            if ((type & 0x80) === 0x00) {
                _this.offset++;
                return type;
            }
            // FixMap - 1000xxxx
            if ((type & 0xf0) === 0x80) {
                length = type & 0x0f;
                _this.offset++;
                return _this.map(length);
            }
            // FixArray - 1001xxxx
            if ((type & 0xf0) === 0x90) {
                length = type & 0x0f;
                _this.offset++;
                return _this.array(length);
            }
            // FixStr - 101xxxxx
            if ((type & 0xe0) === 0xa0) {
                length = type & 0x1f;
                _this.offset++;
                return _this.str(length);
            }
            // Negative FixInt - 111xxxxx
            if ((type & 0xe0) === 0xe0) {
                value = _this.view.getInt8(_this.offset);
                _this.offset++;
                return value;
            }
            switch (type) {
                // nil
                case 0xc0:
                    _this.offset++;
                    return null;
                // 0xc1 never used - use for undefined (NON-STANDARD)
                case 0xc1:
                    _this.offset++;
                    return undefined;
                // false
                case 0xc2:
                    _this.offset++;
                    return false;
                // true
                case 0xc3:
                    _this.offset++;
                    return true;
                // bin 8
                case 0xc4:
                    length = _this.view.getUint8(_this.offset + 1);
                    _this.offset += 2;
                    return _this.bin(length);
                // bin 16
                case 0xc5:
                    length = _this.view.getUint16(_this.offset + 1);
                    _this.offset += 3;
                    return _this.bin(length);
                // bin 32
                case 0xc6:
                    length = _this.view.getUint32(_this.offset + 1);
                    _this.offset += 5;
                    return _this.bin(length);
                // ext 8
                case 0xc7:
                    length = _this.view.getUint8(_this.offset + 1);
                    _this.offset += 2;
                    return _this.ext(length);
                // ext 16
                case 0xc8:
                    length = _this.view.getUint16(_this.offset + 1);
                    _this.offset += 3;
                    return _this.ext(length);
                // ext 32
                case 0xc9:
                    length = _this.view.getUint32(_this.offset + 1);
                    _this.offset += 5;
                    return _this.ext(length);
                // float 32
                case 0xca:
                    value = _this.view.getFloat32(_this.offset + 1);
                    _this.offset += 5;
                    return value;
                // float 64
                case 0xcb:
                    value = _this.view.getFloat64(_this.offset + 1);
                    _this.offset += 9;
                    return value;
                // uint8
                case 0xcc:
                    value = _this.view.getUint8(_this.offset + 1);
                    _this.offset += 2;
                    return value;
                // uint 16
                case 0xcd:
                    value = _this.view.getUint16(_this.offset + 1);
                    _this.offset += 3;
                    return value;
                // uint 32
                case 0xce:
                    value = _this.view.getUint32(_this.offset + 1);
                    _this.offset += 5;
                    return value;
                // uint 64
                case 0xcf:
                    value = getUint64(_this.view, _this.offset + 1);
                    _this.offset += 9;
                    return value;
                // int 8
                case 0xd0:
                    value = _this.view.getInt8(_this.offset + 1);
                    _this.offset += 2;
                    return value;
                // int 16
                case 0xd1:
                    value = _this.view.getInt16(_this.offset + 1);
                    _this.offset += 3;
                    return value;
                // int 32
                case 0xd2:
                    value = _this.view.getInt32(_this.offset + 1);
                    _this.offset += 5;
                    return value;
                // int 64
                case 0xd3:
                    value = getInt64(_this.view, _this.offset + 1);
                    _this.offset += 9;
                    return value;
                // fixext 1
                case 0xd4:
                    length = 1;
                    _this.offset++;
                    return _this.ext(length);
                // fixext 2
                case 0xd5:
                    length = 2;
                    _this.offset++;
                    return _this.ext(length);
                // fixext 4
                case 0xd6:
                    length = 4;
                    _this.offset++;
                    return _this.ext(length);
                // fixext 8
                case 0xd7:
                    length = 8;
                    _this.offset++;
                    return _this.ext(length);
                // fixext 16
                case 0xd8:
                    length = 16;
                    _this.offset++;
                    return _this.ext(length);
                // str8
                case 0xd9:
                    length = _this.view.getUint8(_this.offset + 1);
                    _this.offset += 2;
                    return _this.str(length);
                // str 16
                case 0xda:
                    length = _this.view.getUint16(_this.offset + 1);
                    _this.offset += 3;
                    return _this.str(length);
                // str 32
                case 0xdb:
                    length = _this.view.getUint32(_this.offset + 1);
                    _this.offset += 5;
                    return _this.str(length);
                // array 16
                case 0xdc:
                    length = _this.view.getUint16(_this.offset + 1);
                    _this.offset += 3;
                    return _this.array(length);
                // array 32
                case 0xdd:
                    length = _this.view.getUint32(_this.offset + 1);
                    _this.offset += 5;
                    return _this.array(length);
                // map 16
                case 0xde:
                    length = _this.view.getUint16(_this.offset + 1);
                    _this.offset += 3;
                    return _this.map(length);
                // map 32
                case 0xdf:
                    length = _this.view.getUint32(_this.offset + 1);
                    _this.offset += 5;
                    return _this.map(length);
            }
            throw new Error('Unknown type 0x' + type.toString(16));
        };
        this.offset = offset || 0;
        this.view = view;
    }
    return Decoder;
}());
function decode(buffer) {
    var view = new DataView(buffer);
    var decoder = new Decoder(view);
    var value = decoder.parse();
    if (decoder.offset !== buffer.byteLength)
        throw new Error(buffer.byteLength - decoder.offset + ' trailing bytes');
    return value;
}
function encodeableKeys(value, sparse) {
    return Object.keys(value).filter(function (e) {
        var val = value[e], type = typeof val;
        return (!sparse || (val !== undefined && val !== null)) && ('function' !== type || !!val.toJSON);
    });
}
function _encode(value, view, offset, sparse) {
    var type = typeof value;
    // Strings Bytes
    // There are four string types: fixstr/str8/str16/str32
    if (typeof value === 'string') {
        var length_1 = utf8ByteCount(value);
        // fixstr
        if (length_1 < 0x20) {
            view.setUint8(offset, length_1 | 0xa0);
            utf8Write(view, offset + 1, value);
            return 1 + length_1;
        }
        // str8
        if (length_1 < 0x100) {
            view.setUint8(offset, 0xd9);
            view.setUint8(offset + 1, length_1);
            utf8Write(view, offset + 2, value);
            return 2 + length_1;
        }
        // str16
        if (length_1 < 0x10000) {
            view.setUint8(offset, 0xda);
            view.setUint16(offset + 1, length_1);
            utf8Write(view, offset + 3, value);
            return 3 + length_1;
        }
        // str32
        if (length_1 < 0x100000000) {
            view.setUint8(offset, 0xdb);
            view.setUint32(offset + 1, length_1);
            utf8Write(view, offset + 5, value);
            return 5 + length_1;
        }
    }
    if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {
        // extract the arraybuffer and fallthrough
        value = value.buffer;
    }
    // There are three bin types: bin8/bin16/bin32
    if (value instanceof ArrayBuffer) {
        var length_2 = value.byteLength;
        // bin8
        if (length_2 < 0x100) {
            view.setUint8(offset, 0xc4);
            view.setUint8(offset + 1, length_2);
            new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 2);
            return 2 + length_2;
        }
        // bin16
        if (length_2 < 0x10000) {
            view.setUint8(offset, 0xc5);
            view.setUint16(offset + 1, length_2);
            new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 3);
            return 3 + length_2;
        }
        // bin 32
        if (length_2 < 0x100000000) {
            view.setUint8(offset, 0xc6);
            view.setUint32(offset + 1, length_2);
            new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 5);
            return 5 + length_2;
        }
    }
    if (typeof value === 'number') {
        // Floating Point
        // NOTE: We're always using float64
        if (Math.floor(value) !== value) {
            view.setUint8(offset, 0xcb);
            view.setFloat64(offset + 1, value);
            return 9;
        }
        // Integers
        if (value >= 0) {
            // positive fixnum
            if (value < 0x80) {
                view.setUint8(offset, value);
                return 1;
            }
            // uint 8
            if (value < 0x100) {
                view.setUint8(offset, 0xcc);
                view.setUint8(offset + 1, value);
                return 2;
            }
            // uint 16
            if (value < 0x10000) {
                view.setUint8(offset, 0xcd);
                view.setUint16(offset + 1, value);
                return 3;
            }
            // uint 32
            if (value < 0x100000000) {
                view.setUint8(offset, 0xce);
                view.setUint32(offset + 1, value);
                return 5;
            }
            // uint 64
            if (value < 0x10000000000000000) {
                view.setUint8(offset, 0xcf);
                setUint64(view, offset + 1, value);
                return 9;
            }
            throw new Error('Number too big 0x' + value.toString(16));
        }
        // negative fixnum
        if (value >= -0x20) {
            view.setInt8(offset, value);
            return 1;
        }
        // int 8
        if (value >= -0x80) {
            view.setUint8(offset, 0xd0);
            view.setInt8(offset + 1, value);
            return 2;
        }
        // int 16
        if (value >= -0x8000) {
            view.setUint8(offset, 0xd1);
            view.setInt16(offset + 1, value);
            return 3;
        }
        // int 32
        if (value >= -0x80000000) {
            view.setUint8(offset, 0xd2);
            view.setInt32(offset + 1, value);
            return 5;
        }
        // int 64
        if (value >= -0x8000000000000000) {
            view.setUint8(offset, 0xd3);
            setInt64(view, offset + 1, value);
            return 9;
        }
        throw new Error('Number too small -0x' + (-value).toString(16).substr(1));
    }
    // undefined - use d4 (NON-STANDARD)
    if (type === 'undefined') {
        if (sparse)
            return 0;
        view.setUint8(offset, 0xd4);
        view.setUint8(offset + 1, 0x00);
        view.setUint8(offset + 2, 0x00);
        return 3;
    }
    // null
    if (value === null) {
        if (sparse)
            return 0;
        view.setUint8(offset, 0xc0);
        return 1;
    }
    // Boolean
    if (type === 'boolean') {
        view.setUint8(offset, value ? 0xc3 : 0xc2);
        return 1;
    }
    if ('function' === typeof value.toJSON)
        return _encode(value.toJSON(), view, offset, sparse);
    // Container Types
    if (type === 'object') {
        var length_3, size = 0;
        var keys = void 0;
        var isArray = Array.isArray(value);
        if (isArray) {
            length_3 = value.length;
        }
        else {
            keys = encodeableKeys(value, sparse);
            length_3 = keys.length;
        }
        if (length_3 < 0x10) {
            view.setUint8(offset, length_3 | (isArray ? 0x90 : 0x80));
            size = 1;
        }
        else if (length_3 < 0x10000) {
            view.setUint8(offset, isArray ? 0xdc : 0xde);
            view.setUint16(offset + 1, length_3);
            size = 3;
        }
        else if (length_3 < 0x100000000) {
            view.setUint8(offset, isArray ? 0xdd : 0xdf);
            view.setUint32(offset + 1, length_3);
            size = 5;
        }
        if (isArray) {
            for (var i = 0; i < length_3; i++) {
                size += _encode(value[i], view, offset + size, sparse);
            }
        }
        else if (keys) {
            for (var i = 0; i < length_3; i++) {
                var key = keys[i];
                size += _encode(key, view, offset + size);
                size += _encode(value[key], view, offset + size, sparse);
            }
        }
        return size;
    }
    if (type === 'function')
        return 0;
    throw new Error('Unknown type ' + type);
}
function sizeof(value, sparse) {
    var type = typeof value;
    // fixstr or str8 or str16 or str32
    if (type === 'string') {
        var length_4 = utf8ByteCount(value);
        if (length_4 < 0x20) {
            return 1 + length_4;
        }
        if (length_4 < 0x100) {
            return 2 + length_4;
        }
        if (length_4 < 0x10000) {
            return 3 + length_4;
        }
        if (length_4 < 0x100000000) {
            return 5 + length_4;
        }
    }
    if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {
        // extract the arraybuffer and fallthrough
        value = value.buffer;
    }
    // bin8 or bin16 or bin32
    if (value instanceof ArrayBuffer) {
        var length_5 = value.byteLength;
        if (length_5 < 0x100) {
            return 2 + length_5;
        }
        if (length_5 < 0x10000) {
            return 3 + length_5;
        }
        if (length_5 < 0x100000000) {
            return 5 + length_5;
        }
    }
    if (typeof value === 'number') {
        // Floating Point (32 bits)
        // double
        if (Math.floor(value) !== value)
            return 9;
        // Integers
        if (value >= 0) {
            // positive fixint
            if (value < 0x80)
                return 1;
            // uint 8
            if (value < 0x100)
                return 2;
            // uint 16
            if (value < 0x10000)
                return 3;
            // uint 32
            if (value < 0x100000000)
                return 5;
            // uint 64
            if (value < 0x10000000000000000)
                return 9;
            // Too big
            throw new Error('Number too big 0x' + value.toString(16));
        }
        // negative fixint
        if (value >= -0x20)
            return 1;
        // int 8
        if (value >= -0x80)
            return 2;
        // int 16
        if (value >= -0x8000)
            return 3;
        // int 32
        if (value >= -0x80000000)
            return 5;
        // int 64
        if (value >= -0x8000000000000000)
            return 9;
        // Too small
        throw new Error('Number too small -0x' + value.toString(16).substr(1));
    }
    // Boolean
    if (type === 'boolean')
        return 1;
    // undefined, null
    if (value === null)
        return sparse ? 0 : 1;
    if (value === undefined)
        return sparse ? 0 : 3;
    if ('function' === typeof value.toJSON)
        return sizeof(value.toJSON(), sparse);
    // Container Types
    if (type === 'object') {
        var length_6, size = 0;
        if (Array.isArray(value)) {
            length_6 = value.length;
            for (var i = 0; i < length_6; i++) {
                size += sizeof(value[i], sparse);
            }
        }
        else {
            var keys = encodeableKeys(value, sparse);
            length_6 = keys.length;
            for (var i = 0; i < length_6; i++) {
                var key = keys[i];
                size += sizeof(key) + sizeof(value[key], sparse);
            }
        }
        if (length_6 < 0x10) {
            return 1 + size;
        }
        if (length_6 < 0x10000) {
            return 3 + size;
        }
        if (length_6 < 0x100000000) {
            return 5 + size;
        }
        throw new Error('Array or object too long 0x' + length_6.toString(16));
    }
    if (type === 'function')
        return 0;
    throw new Error('Unknown type ' + type);
}
exports.default = {
    encode: encode,
    decode: decode,
    inspect: inspect,
    utf8Write: utf8Write,
    utf8Read: utf8Read,
    utf8ByteCount: utf8ByteCount,
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __nested_webpack_require_466211__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_466211__(0);
// Common
var rest_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(30));
var realtime_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(50));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(3));
// Platform Specific
var bufferutils_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(55));
// @ts-ignore
var crypto_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(57));
var http_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(62));
var config_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(64));
// @ts-ignore
var transport_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(68));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(2));
var defaults_1 = __nested_webpack_require_466211__(8);
var webstorage_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(65));
var defaults_2 = tslib_1.__importDefault(__nested_webpack_require_466211__(66));
var msgpack_1 = tslib_1.__importDefault(__nested_webpack_require_466211__(41));
var Crypto = (0, crypto_1.default)(config_1.default, bufferutils_1.default);
platform_1.default.Crypto = Crypto;
platform_1.default.BufferUtils = bufferutils_1.default;
platform_1.default.Http = http_1.default;
platform_1.default.Config = config_1.default;
platform_1.default.Transports = transport_1.default;
platform_1.default.WebStorage = webstorage_1.default;
rest_1.default.Crypto = Crypto;
realtime_1.default.Crypto = Crypto;
logger_1.default.initLogHandlers();
platform_1.default.Defaults = (0, defaults_1.getDefaults)(defaults_2.default);
if (platform_1.default.Config.agent) {
    // @ts-ignore
    platform_1.default.Defaults.agent += ' ' + platform_1.default.Config.agent;
}
/* If using IE8, don't attempt to upgrade from xhr_polling to xhr_streaming -
 * while it can do streaming, the low max http-connections-per-host limit means
 * that the polling transport is crippled during the upgrade process. So just
 * leave it at the base transport */
if (platform_1.default.Config.noUpgrade) {
    platform_1.default.Defaults.upgradeTransports = [];
}
exports.default = {
    Rest: rest_1.default,
    Realtime: realtime_1.default,
    msgpack: msgpack_1.default,
};


/***/ }),
/* 43 */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"ably\",\"description\":\"Realtime client library for Ably, the realtime messaging service\",\"version\":\"1.2.43\",\"license\":\"Apache-2.0\",\"bugs\":{\"url\":\"https://github.com/ably/ably-js/issues\",\"email\":\"support@ably.com\"},\"main\":\"./build/ably-node.js\",\"typings\":\"./ably.d.ts\",\"react-native\":{\"./build/ably-node.js\":\"./build/ably-reactnative.js\"},\"browser\":{\"./build/ably-node.js\":\"./build/ably-commonjs.js\"},\"files\":[\"build/**\",\"ably.d.ts\",\"callbacks.d.ts\",\"callbacks.js\",\"promises.d.ts\",\"promises.js\",\"resources/**\"],\"dependencies\":{\"@ably/msgpack-js\":\"^0.4.0\",\"got\":\"^11.8.5\",\"ws\":\"^5.1\"},\"devDependencies\":{\"@ably/vcdiff-decoder\":\"1.0.4\",\"@types/crypto-js\":\"^4.0.1\",\"@types/node\":\"^15.0.0\",\"@types/request\":\"^2.48.7\",\"@types/ws\":\"^8.2.0\",\"@typescript-eslint/eslint-plugin\":\"^5.14.0\",\"@typescript-eslint/parser\":\"^5.14.0\",\"async\":\"ably-forks/async#requirejs\",\"aws-sdk\":\"^2.1413.0\",\"chai\":\"^4.2.0\",\"copy-webpack-plugin\":\"^6.4.1\",\"cors\":\"^2.8.5\",\"crypto-js\":\"ably-forks/crypto-js#crypto-lite\",\"eslint\":\"^7.13.0\",\"eslint-plugin-jsdoc\":\"^40.0.0\",\"eslint-plugin-security\":\"^1.4.0\",\"express\":\"^4.17.1\",\"glob\":\"~4.4\",\"google-closure-compiler\":\"^20180610.0.1\",\"grunt\":\"^1.6.1\",\"grunt-bump\":\"^0.3.1\",\"grunt-cli\":\"~1.2.0\",\"grunt-closure-tools\":\"^1.0.0\",\"grunt-contrib-concat\":\"~0.5\",\"grunt-shell\":\"~1.1\",\"grunt-webpack\":\"^4.0.2\",\"hexy\":\"~0.2\",\"kexec\":\"ably-forks/node-kexec#update-for-node-12\",\"minimist\":\"^1.2.5\",\"mocha\":\"^8.1.3\",\"null-loader\":\"^4.0.1\",\"playwright\":\"^1.10.0\",\"prettier\":\"^2.5.1\",\"requirejs\":\"~2.1\",\"shelljs\":\"~0.8\",\"source-map-explorer\":\"^2.5.2\",\"ts-loader\":\"^8.2.0\",\"tsconfig-paths-webpack-plugin\":\"^4.0.1\",\"tslib\":\"^2.3.1\",\"typedoc\":\"^0.23.8\",\"typescript\":\"^4.6.4\",\"webpack\":\"^4.44.2\",\"webpack-cli\":\"^4.2.0\"},\"engines\":{\"node\":\">=5.10.x\"},\"repository\":\"ably/ably-js\",\"jspm\":{\"registry\":\"npm\",\"directories\":{\"lib\":\"build\"},\"main\":\"ably\"},\"scripts\":{\"grunt\":\"grunt\",\"test\":\"grunt test\",\"test:node\":\"grunt test:node\",\"test:node:skip-build\":\"grunt mocha\",\"test:webserver\":\"grunt test:webserver\",\"test:playwright\":\"node test/support/runPlaywrightTests.js\",\"concat\":\"grunt concat\",\"build\":\"grunt build:all\",\"build:node\":\"grunt build:node\",\"build:browser\":\"grunt build:browser\",\"requirejs\":\"grunt requirejs\",\"lint\":\"eslint .\",\"lint:fix\":\"eslint --fix .\",\"check-closure-compiler\":\"grunt check-closure-compiler\",\"prepare\":\"npm run build\",\"format\":\"prettier --write --ignore-path .gitignore --ignore-path .prettierignore src test ably.d.ts webpack.config.js Gruntfile.js scripts/cdn_deploy.js docs/chrome-mv3.md\",\"format:check\":\"prettier --check --ignore-path .gitignore --ignore-path .prettierignore src test ably.d.ts webpack.config.js Gruntfile.js scripts/cdn_deploy.js\",\"sourcemap\":\"source-map-explorer build/ably.min.js\",\"sourcemap:noencryption\":\"source-map-explorer build/ably.noencryption.min.js\",\"docs\":\"typedoc --entryPoints ably.d.ts --out docs/generated/default --readme docs/landing-pages/default.md && typedoc --entryPoints promises.d.ts --out docs/generated/promises --name \\\"ably (Promise-based)\\\" --readme docs/landing-pages/promises.md && cp docs/landing-pages/choose-library.html docs/generated/index.html\"}}");

/***/ }),
/* 44 */
/***/ (function(module, exports) {



/***/ }),
/* 45 */
/***/ (function(module, exports, __nested_webpack_require_472099__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_472099__(6), __nested_webpack_require_472099__(32), __nested_webpack_require_472099__(24));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.HmacSHA256;

}));

/***/ }),
/* 46 */
/***/ (function(module, exports, __nested_webpack_require_472422__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_472422__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_472422__(1));
var devicedetails_1 = tslib_1.__importDefault(__nested_webpack_require_472422__(47));
var resource_1 = tslib_1.__importDefault(__nested_webpack_require_472422__(14));
var paginatedresource_1 = tslib_1.__importDefault(__nested_webpack_require_472422__(19));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_472422__(4));
var pushchannelsubscription_1 = tslib_1.__importDefault(__nested_webpack_require_472422__(48));
var noop = function () { };
var Push = /** @class */ (function () {
    function Push(rest) {
        this.rest = rest;
        this.admin = new Admin(rest);
    }
    return Push;
}());
var Admin = /** @class */ (function () {
    function Admin(rest) {
        this.rest = rest;
        this.deviceRegistrations = new DeviceRegistrations(rest);
        this.channelSubscriptions = new ChannelSubscriptions(rest);
    }
    Admin.prototype.publish = function (recipient, payload, callback) {
        var rest = this.rest;
        var format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(rest.options, format), params = {};
        var body = Utils.mixin({ recipient: recipient }, payload);
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'publish', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        var requestBody = Utils.encodeBody(body, format);
        resource_1.default.post(rest, '/push/publish', requestBody, headers, params, null, function (err) { return callback(err); });
    };
    return Admin;
}());
var DeviceRegistrations = /** @class */ (function () {
    function DeviceRegistrations(rest) {
        this.rest = rest;
    }
    DeviceRegistrations.prototype.save = function (device, callback) {
        var rest = this.rest;
        var body = devicedetails_1.default.fromValues(device);
        var format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(rest.options, format), params = {};
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'save', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        var requestBody = Utils.encodeBody(body, format);
        resource_1.default.put(rest, '/push/deviceRegistrations/' + encodeURIComponent(device.id), requestBody, headers, params, null, function (err, body, headers, unpacked) {
            callback(err, !err
                ? devicedetails_1.default.fromResponseBody(body, unpacked ? undefined : format)
                : undefined);
        });
    };
    DeviceRegistrations.prototype.get = function (deviceIdOrDetails, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultGetHeaders(rest.options, format), deviceId = deviceIdOrDetails.id || deviceIdOrDetails;
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'get', arguments);
            }
            callback = noop;
        }
        if (typeof deviceId !== 'string' || !deviceId.length) {
            callback(new errorinfo_1.default('First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails', 40000, 400));
            return;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        resource_1.default.get(rest, '/push/deviceRegistrations/' + encodeURIComponent(deviceId), headers, {}, null, function (err, body, headers, unpacked) {
            callback(err, !err
                ? devicedetails_1.default.fromResponseBody(body, unpacked ? undefined : format)
                : undefined);
        });
    };
    DeviceRegistrations.prototype.list = function (params, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'list', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        new paginatedresource_1.default(rest, '/push/deviceRegistrations', headers, envelope, function (body, headers, unpacked) {
            return devicedetails_1.default.fromResponseBody(body, unpacked ? undefined : format);
        }).get(params, callback);
    };
    DeviceRegistrations.prototype.remove = function (deviceIdOrDetails, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultGetHeaders(rest.options, format), params = {}, deviceId = deviceIdOrDetails.id || deviceIdOrDetails;
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'remove', arguments);
            }
            callback = noop;
        }
        if (typeof deviceId !== 'string' || !deviceId.length) {
            callback(new errorinfo_1.default('First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails', 40000, 400));
            return;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        resource_1.default['delete'](rest, '/push/deviceRegistrations/' + encodeURIComponent(deviceId), headers, params, null, function (err) { return callback(err); });
    };
    DeviceRegistrations.prototype.removeWhere = function (params, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultGetHeaders(rest.options, format);
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'removeWhere', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        resource_1.default['delete'](rest, '/push/deviceRegistrations', headers, params, null, function (err) { return callback(err); });
    };
    return DeviceRegistrations;
}());
var ChannelSubscriptions = /** @class */ (function () {
    function ChannelSubscriptions(rest) {
        /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */
        this.remove = ChannelSubscriptions.prototype.removeWhere;
        this.rest = rest;
    }
    ChannelSubscriptions.prototype.save = function (subscription, callback) {
        var rest = this.rest;
        var body = pushchannelsubscription_1.default.fromValues(subscription);
        var format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(rest.options, format), params = {};
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'save', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        var requestBody = Utils.encodeBody(body, format);
        resource_1.default.post(rest, '/push/channelSubscriptions', requestBody, headers, params, null, function (err, body, headers, unpacked) {
            callback(err, !err && pushchannelsubscription_1.default.fromResponseBody(body, unpacked ? undefined : format));
        });
    };
    ChannelSubscriptions.prototype.list = function (params, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'list', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        new paginatedresource_1.default(rest, '/push/channelSubscriptions', headers, envelope, function (body, headers, unpacked) {
            return pushchannelsubscription_1.default.fromResponseBody(body, unpacked ? undefined : format);
        }).get(params, callback);
    };
    ChannelSubscriptions.prototype.removeWhere = function (params, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultGetHeaders(rest.options, format);
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'removeWhere', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        resource_1.default['delete'](rest, '/push/channelSubscriptions', headers, params, null, function (err) { return callback(err); });
    };
    ChannelSubscriptions.prototype.listChannels = function (params, callback) {
        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);
        if (typeof callback !== 'function') {
            if (this.rest.options.promises) {
                return Utils.promisify(this, 'listChannels', arguments);
            }
            callback = noop;
        }
        if (rest.options.headers)
            Utils.mixin(headers, rest.options.headers);
        if (rest.options.pushFullWait)
            Utils.mixin(params, { fullWait: 'true' });
        new paginatedresource_1.default(rest, '/push/channels', headers, envelope, function (body, headers, unpacked) {
            var parsedBody = (!unpacked && format ? Utils.decodeBody(body, format) : body);
            for (var i = 0; i < parsedBody.length; i++) {
                parsedBody[i] = String(parsedBody[i]);
            }
            return parsedBody;
        }).get(params, callback);
    };
    return ChannelSubscriptions;
}());
exports.default = Push;


/***/ }),
/* 47 */
/***/ (function(module, exports, __nested_webpack_require_484001__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_484001__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_484001__(1));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_484001__(4));
var DeviceFormFactor;
(function (DeviceFormFactor) {
    DeviceFormFactor["Phone"] = "phone";
    DeviceFormFactor["Tablet"] = "tablet";
    DeviceFormFactor["Desktop"] = "desktop";
    DeviceFormFactor["TV"] = "tv";
    DeviceFormFactor["Watch"] = "watch";
    DeviceFormFactor["Car"] = "car";
    DeviceFormFactor["Embedded"] = "embedded";
    DeviceFormFactor["Other"] = "other";
})(DeviceFormFactor || (DeviceFormFactor = {}));
var DevicePlatform;
(function (DevicePlatform) {
    DevicePlatform["Android"] = "android";
    DevicePlatform["IOS"] = "ios";
    DevicePlatform["Browser"] = "browser";
})(DevicePlatform || (DevicePlatform = {}));
var DeviceDetails = /** @class */ (function () {
    function DeviceDetails() {
    }
    DeviceDetails.prototype.toJSON = function () {
        var _a, _b, _c;
        return {
            id: this.id,
            deviceSecret: this.deviceSecret,
            platform: this.platform,
            formFactor: this.formFactor,
            clientId: this.clientId,
            metadata: this.metadata,
            deviceIdentityToken: this.deviceIdentityToken,
            push: {
                recipient: (_a = this.push) === null || _a === void 0 ? void 0 : _a.recipient,
                state: (_b = this.push) === null || _b === void 0 ? void 0 : _b.state,
                error: (_c = this.push) === null || _c === void 0 ? void 0 : _c.error,
            },
        };
    };
    DeviceDetails.prototype.toString = function () {
        var _a, _b, _c, _d;
        var result = '[DeviceDetails';
        if (this.id)
            result += '; id=' + this.id;
        if (this.platform)
            result += '; platform=' + this.platform;
        if (this.formFactor)
            result += '; formFactor=' + this.formFactor;
        if (this.clientId)
            result += '; clientId=' + this.clientId;
        if (this.metadata)
            result += '; metadata=' + this.metadata;
        if (this.deviceIdentityToken)
            result += '; deviceIdentityToken=' + JSON.stringify(this.deviceIdentityToken);
        if ((_a = this.push) === null || _a === void 0 ? void 0 : _a.recipient)
            result += '; push.recipient=' + JSON.stringify(this.push.recipient);
        if ((_b = this.push) === null || _b === void 0 ? void 0 : _b.state)
            result += '; push.state=' + this.push.state;
        if ((_c = this.push) === null || _c === void 0 ? void 0 : _c.error)
            result += '; push.error=' + JSON.stringify(this.push.error);
        if ((_d = this.push) === null || _d === void 0 ? void 0 : _d.metadata)
            result += '; push.metadata=' + this.push.metadata;
        result += ']';
        return result;
    };
    DeviceDetails.fromResponseBody = function (body, format) {
        if (format) {
            body = Utils.decodeBody(body, format);
        }
        if (Utils.isArray(body)) {
            return DeviceDetails.fromValuesArray(body);
        }
        else {
            return DeviceDetails.fromValues(body);
        }
    };
    DeviceDetails.fromValues = function (values) {
        values.error = values.error && errorinfo_1.default.fromValues(values.error);
        return Object.assign(new DeviceDetails(), values);
    };
    DeviceDetails.fromValuesArray = function (values) {
        var count = values.length, result = new Array(count);
        for (var i = 0; i < count; i++)
            result[i] = DeviceDetails.fromValues(values[i]);
        return result;
    };
    DeviceDetails.toRequestBody = Utils.encodeBody;
    return DeviceDetails;
}());
exports.default = DeviceDetails;


/***/ }),
/* 48 */
/***/ (function(module, exports, __nested_webpack_require_487921__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_487921__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_487921__(1));
var PushChannelSubscription = /** @class */ (function () {
    function PushChannelSubscription() {
    }
    /**
     * Overload toJSON() to intercept JSON.stringify()
     * @return {*}
     */
    PushChannelSubscription.prototype.toJSON = function () {
        return {
            channel: this.channel,
            deviceId: this.deviceId,
            clientId: this.clientId,
        };
    };
    PushChannelSubscription.prototype.toString = function () {
        var result = '[PushChannelSubscription';
        if (this.channel)
            result += '; channel=' + this.channel;
        if (this.deviceId)
            result += '; deviceId=' + this.deviceId;
        if (this.clientId)
            result += '; clientId=' + this.clientId;
        result += ']';
        return result;
    };
    PushChannelSubscription.fromResponseBody = function (body, format) {
        if (format) {
            body = Utils.decodeBody(body, format);
        }
        if (Utils.isArray(body)) {
            return PushChannelSubscription.fromValuesArray(body);
        }
        else {
            return PushChannelSubscription.fromValues(body);
        }
    };
    PushChannelSubscription.fromValues = function (values) {
        return Object.assign(new PushChannelSubscription(), values);
    };
    PushChannelSubscription.fromValuesArray = function (values) {
        var count = values.length, result = new Array(count);
        for (var i = 0; i < count; i++)
            result[i] = PushChannelSubscription.fromValues(values[i]);
        return result;
    };
    PushChannelSubscription.toRequestBody = Utils.encodeBody;
    return PushChannelSubscription;
}());
exports.default = PushChannelSubscription;


/***/ }),
/* 49 */
/***/ (function(module, exports, __nested_webpack_require_489889__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_489889__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_489889__(1));
var MessageCount = /** @class */ (function () {
    function MessageCount(values) {
        this.count = (values && values.count) || 0;
        this.data = (values && values.data) || 0;
        this.uncompressedData = (values && values.uncompressedData) || 0;
        this.failed = (values && values.failed) || 0;
        this.refused = (values && values.refused) || 0;
    }
    return MessageCount;
}());
var MessageCategory = /** @class */ (function (_super) {
    tslib_1.__extends(MessageCategory, _super);
    function MessageCategory(values) {
        var _this = _super.call(this, values) || this;
        if (values && values.category) {
            _this.category = {};
            Utils.forInOwnNonNullProperties(values.category, function (prop) {
                _this.category[prop] = new MessageCount(values.category[prop]);
            });
        }
        return _this;
    }
    return MessageCategory;
}(MessageCount));
var ResourceCount = /** @class */ (function () {
    function ResourceCount(values) {
        this.peak = (values && values.peak) || 0;
        this.min = (values && values.min) || 0;
        this.mean = (values && values.mean) || 0;
        this.opened = (values && values.opened) || 0;
        this.refused = (values && values.refused) || 0;
    }
    return ResourceCount;
}());
var RequestCount = /** @class */ (function () {
    function RequestCount(values) {
        this.succeeded = (values && values.succeeded) || 0;
        this.failed = (values && values.failed) || 0;
        this.refused = (values && values.refused) || 0;
    }
    return RequestCount;
}());
var ConnectionTypes = /** @class */ (function () {
    function ConnectionTypes(values) {
        this.plain = new ResourceCount(values && values.plain);
        this.tls = new ResourceCount(values && values.tls);
        this.all = new ResourceCount(values && values.all);
    }
    return ConnectionTypes;
}());
var MessageTypes = /** @class */ (function () {
    function MessageTypes(values) {
        this.messages = new MessageCategory(values && values.messages);
        this.presence = new MessageCategory(values && values.presence);
        this.all = new MessageCategory(values && values.all);
    }
    return MessageTypes;
}());
var MessageTraffic = /** @class */ (function () {
    function MessageTraffic(values) {
        this.realtime = new MessageTypes(values && values.realtime);
        this.rest = new MessageTypes(values && values.rest);
        this.webhook = new MessageTypes(values && values.webhook);
        this.sharedQueue = new MessageTypes(values && values.sharedQueue);
        this.externalQueue = new MessageTypes(values && values.externalQueue);
        this.httpEvent = new MessageTypes(values && values.httpEvent);
        this.push = new MessageTypes(values && values.push);
        this.all = new MessageTypes(values && values.all);
    }
    return MessageTraffic;
}());
var MessageDirections = /** @class */ (function () {
    function MessageDirections(values) {
        this.all = new MessageTypes(values && values.all);
        this.inbound = new MessageTraffic(values && values.inbound);
        this.outbound = new MessageTraffic(values && values.outbound);
    }
    return MessageDirections;
}());
var XchgMessages = /** @class */ (function () {
    function XchgMessages(values) {
        this.all = new MessageTypes(values && values.all);
        this.producerPaid = new MessageDirections(values && values.producerPaid);
        this.consumerPaid = new MessageDirections(values && values.consumerPaid);
    }
    return XchgMessages;
}());
var PushStats = /** @class */ (function () {
    function PushStats(values) {
        this.messages = (values && values.messages) || 0;
        var notifications = values && values.notifications;
        this.notifications = {
            invalid: (notifications && notifications.invalid) || 0,
            attempted: (notifications && notifications.attempted) || 0,
            successful: (notifications && notifications.successful) || 0,
            failed: (notifications && notifications.failed) || 0,
        };
        this.directPublishes = (values && values.directPublishes) || 0;
    }
    return PushStats;
}());
var ProcessedCount = /** @class */ (function () {
    function ProcessedCount(values) {
        this.succeeded = (values && values.succeeded) || 0;
        this.skipped = (values && values.skipped) || 0;
        this.failed = (values && values.failed) || 0;
    }
    return ProcessedCount;
}());
var ProcessedMessages = /** @class */ (function () {
    function ProcessedMessages(values) {
        var _this = this;
        this.delta = undefined;
        if (values && values.delta) {
            this.delta = {};
            Utils.forInOwnNonNullProperties(values.delta, function (prop) {
                _this.delta[prop] = new ProcessedCount(values.delta[prop]);
            });
        }
    }
    return ProcessedMessages;
}());
var Stats = /** @class */ (function (_super) {
    tslib_1.__extends(Stats, _super);
    function Stats(values) {
        var _this = _super.call(this, values) || this;
        _this.persisted = new MessageTypes(values && values.persisted);
        _this.connections = new ConnectionTypes(values && values.connections);
        _this.channels = new ResourceCount(values && values.channels);
        _this.apiRequests = new RequestCount(values && values.apiRequests);
        _this.tokenRequests = new RequestCount(values && values.tokenRequests);
        _this.xchgProducer = new XchgMessages(values && values.xchgProducer);
        _this.xchgConsumer = new XchgMessages(values && values.xchgConsumer);
        _this.push = new PushStats(values && values.pushStats);
        _this.processed = new ProcessedMessages(values && values.processed);
        _this.inProgress = (values && values.inProgress) || undefined;
        _this.unit = (values && values.unit) || undefined;
        _this.intervalId = (values && values.intervalId) || undefined;
        return _this;
    }
    Stats.fromValues = function (values) {
        return new Stats(values);
    };
    return Stats;
}(MessageDirections));
exports.default = Stats;


/***/ }),
/* 50 */
/***/ (function(module, exports, __nested_webpack_require_496325__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_496325__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_496325__(1));
var rest_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(30));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(2));
var connection_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(51));
var realtimechannel_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(38));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(8));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(4));
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(10));
var connectionmanager_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(35));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(3));
var message_1 = tslib_1.__importDefault(__nested_webpack_require_496325__(9));
var Realtime = /** @class */ (function (_super) {
    tslib_1.__extends(Realtime, _super);
    function Realtime(options) {
        var _this = _super.call(this, options) || this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Realtime()', '');
        _this.connection = new connection_1.default(_this, _this.options);
        _this.channels = new Channels(_this);
        if (options.autoConnect !== false)
            _this.connect();
        return _this;
    }
    Realtime.prototype.connect = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Realtime.connect()', '');
        this.connection.connect();
    };
    Realtime.prototype.close = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Realtime.close()', '');
        this.connection.close();
    };
    Realtime.Promise = function (options) {
        options = defaults_1.default.objectifyOptions(options);
        options.promises = true;
        return new Realtime(options);
    };
    Realtime.Callbacks = Realtime;
    Realtime.Utils = Utils;
    Realtime.ConnectionManager = connectionmanager_1.default;
    Realtime.Platform = platform_1.default;
    Realtime.ProtocolMessage = protocolmessage_1.default;
    Realtime.Message = message_1.default;
    return Realtime;
}(rest_1.default));
var Channels = /** @class */ (function (_super) {
    tslib_1.__extends(Channels, _super);
    function Channels(realtime) {
        var _this = _super.call(this) || this;
        _this.realtime = realtime;
        _this.all = Object.create(null);
        realtime.connection.connectionManager.on('transport.active', function () {
            _this.onTransportActive();
        });
        return _this;
    }
    Channels.prototype.channelSerials = function () {
        var serials = {};
        for (var _i = 0, _a = Utils.keysArray(this.all, true); _i < _a.length; _i++) {
            var name_1 = _a[_i];
            var channel = this.all[name_1];
            if (channel.properties.channelSerial) {
                serials[name_1] = channel.properties.channelSerial;
            }
        }
        return serials;
    };
    // recoverChannels gets the given channels and sets their channel serials.
    Channels.prototype.recoverChannels = function (channelSerials) {
        for (var _i = 0, _a = Utils.keysArray(channelSerials, true); _i < _a.length; _i++) {
            var name_2 = _a[_i];
            var channel = this.get(name_2);
            channel.properties.channelSerial = channelSerials[name_2];
        }
    };
    Channels.prototype.onChannelMessage = function (msg) {
        var channelName = msg.channel;
        if (channelName === undefined) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Channels.onChannelMessage()', 'received event unspecified channel, action = ' + msg.action);
            return;
        }
        var channel = this.all[channelName];
        if (!channel) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Channels.onChannelMessage()', 'received event for non-existent channel: ' + channelName);
            return;
        }
        channel.onMessage(msg);
    };
    /* called when a transport becomes connected; reattempt attach/detach
     * for channels that are attaching or detaching. */
    Channels.prototype.onTransportActive = function () {
        for (var channelName in this.all) {
            var channel = this.all[channelName];
            if (channel.state === 'attaching' || channel.state === 'detaching') {
                channel.checkPendingState();
            }
            else if (channel.state === 'suspended') {
                channel._attach(false, null);
            }
            else if (channel.state === 'attached') {
                // Note explicity request the state, channel.attach() would do nothing
                // as its already attached.
                channel.requestState('attaching');
            }
        }
    };
    /* Connection interruptions (ie when the connection will no longer queue
     * events) imply connection state changes for any channel which is either
     * attached, pending, or will attempt to become attached in the future */
    Channels.prototype.propogateConnectionInterruption = function (connectionState, reason) {
        var connectionStateToChannelState = {
            closing: 'detached',
            closed: 'detached',
            failed: 'failed',
            suspended: 'suspended',
        };
        var fromChannelStates = ['attaching', 'attached', 'detaching', 'suspended'];
        var toChannelState = connectionStateToChannelState[connectionState];
        for (var channelId in this.all) {
            var channel = this.all[channelId];
            if (Utils.arrIn(fromChannelStates, channel.state)) {
                channel.notifyState(toChannelState, reason);
            }
        }
    };
    Channels.prototype.get = function (name, channelOptions) {
        name = String(name);
        var channel = this.all[name];
        if (!channel) {
            channel = this.all[name] = new realtimechannel_1.default(this.realtime, name, channelOptions);
        }
        else if (channelOptions) {
            if (channel._shouldReattachToSetOptions(channelOptions)) {
                throw new errorinfo_1.default('Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.', 40000, 400);
            }
            channel.setOptions(channelOptions);
        }
        return channel;
    };
    Channels.prototype.getDerived = function (name, deriveOptions, channelOptions) {
        if (deriveOptions.filter) {
            var filter = Utils.toBase64(deriveOptions.filter);
            var match = Utils.matchDerivedChannel(name);
            name = "[filter=".concat(filter).concat(match.qualifierParam, "]").concat(match.channelName);
        }
        return this.get(name, channelOptions);
    };
    /* Included to support certain niche use-cases; most users should ignore this.
     * Please do not use this unless you know what you're doing */
    Channels.prototype.release = function (name) {
        name = String(name);
        var channel = this.all[name];
        if (!channel) {
            return;
        }
        var releaseErr = channel.getReleaseErr();
        if (releaseErr) {
            throw releaseErr;
        }
        delete this.all[name];
    };
    return Channels;
}(eventemitter_1.default));
exports.default = Realtime;


/***/ }),
/* 51 */
/***/ (function(module, exports, __nested_webpack_require_503898__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_503898__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_503898__(1));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_503898__(7));
var connectionmanager_1 = tslib_1.__importDefault(__nested_webpack_require_503898__(35));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_503898__(2));
var connectionstatechange_1 = tslib_1.__importDefault(__nested_webpack_require_503898__(37));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_503898__(3));
function noop() { }
var Connection = /** @class */ (function (_super) {
    tslib_1.__extends(Connection, _super);
    function Connection(ably, options) {
        var _this = _super.call(this) || this;
        _this.whenState = (function (state, listener) {
            return eventemitter_1.default.prototype.whenState.call(_this, state, _this.state, listener, new connectionstatechange_1.default(undefined, state));
        });
        _this.ably = ably;
        _this.connectionManager = new connectionmanager_1.default(ably, options);
        _this.state = _this.connectionManager.state.state;
        _this.key = undefined;
        _this.id = undefined;
        _this.errorReason = null;
        _this.connectionManager.on('connectionstate', function (stateChange) {
            var state = (_this.state = stateChange.current);
            platform_1.default.Config.nextTick(function () {
                _this.emit(state, stateChange);
            });
        });
        _this.connectionManager.on('update', function (stateChange) {
            platform_1.default.Config.nextTick(function () {
                _this.emit('update', stateChange);
            });
        });
        return _this;
    }
    Connection.prototype.connect = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Connection.connect()', '');
        this.connectionManager.requestState({ state: 'connecting' });
    };
    Connection.prototype.ping = function (callback) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Connection.ping()', '');
        if (!callback) {
            if (this.ably.options.promises) {
                return Utils.promisify(this, 'ping', arguments);
            }
            callback = noop;
        }
        this.connectionManager.ping(null, callback);
    };
    Connection.prototype.close = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Connection.close()', 'connectionKey = ' + this.key);
        this.connectionManager.requestState({ state: 'closing' });
    };
    Object.defineProperty(Connection.prototype, "recoveryKey", {
        get: function () {
            return this.createRecoveryKey();
        },
        enumerable: false,
        configurable: true
    });
    Connection.prototype.createRecoveryKey = function () {
        return this.connectionManager.createRecoveryKey();
    };
    return Connection;
}(eventemitter_1.default));
exports.default = Connection;


/***/ }),
/* 52 */
/***/ (function(module, exports, __nested_webpack_require_506979__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PendingMessage = void 0;
var tslib_1 = __nested_webpack_require_506979__(0);
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_506979__(10));
var Utils = tslib_1.__importStar(__nested_webpack_require_506979__(1));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_506979__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_506979__(2));
var messagequeue_1 = tslib_1.__importDefault(__nested_webpack_require_506979__(36));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_506979__(4));
var actions = protocolmessage_1.default.Action;
var PendingMessage = /** @class */ (function () {
    function PendingMessage(message, callback) {
        this.message = message;
        this.callback = callback;
        this.merged = false;
        var action = message.action;
        this.sendAttempted = false;
        this.ackRequired = action == actions.MESSAGE || action == actions.PRESENCE;
    }
    return PendingMessage;
}());
exports.PendingMessage = PendingMessage;
var Protocol = /** @class */ (function (_super) {
    tslib_1.__extends(Protocol, _super);
    function Protocol(transport) {
        var _this = _super.call(this) || this;
        _this.transport = transport;
        _this.messageQueue = new messagequeue_1.default();
        transport.on('ack', function (serial, count) {
            _this.onAck(serial, count);
        });
        transport.on('nack', function (serial, count, err) {
            _this.onNack(serial, count, err);
        });
        return _this;
    }
    Protocol.prototype.onAck = function (serial, count) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Protocol.onAck()', 'serial = ' + serial + '; count = ' + count);
        this.messageQueue.completeMessages(serial, count);
    };
    Protocol.prototype.onNack = function (serial, count, err) {
        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Protocol.onNack()', 'serial = ' + serial + '; count = ' + count + '; err = ' + Utils.inspectError(err));
        if (!err) {
            err = new errorinfo_1.default('Unable to send message; channel not responding', 50001, 500);
        }
        this.messageQueue.completeMessages(serial, count, err);
    };
    Protocol.prototype.onceIdle = function (listener) {
        var messageQueue = this.messageQueue;
        if (messageQueue.count() === 0) {
            listener();
            return;
        }
        messageQueue.once('idle', listener);
    };
    Protocol.prototype.send = function (pendingMessage) {
        if (pendingMessage.ackRequired) {
            this.messageQueue.push(pendingMessage);
        }
        if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Protocol.send()', 'sending msg; ' + protocolmessage_1.default.stringify(pendingMessage.message));
        }
        pendingMessage.sendAttempted = true;
        this.transport.send(pendingMessage.message);
    };
    Protocol.prototype.getTransport = function () {
        return this.transport;
    };
    Protocol.prototype.getPendingMessages = function () {
        return this.messageQueue.copyAll();
    };
    Protocol.prototype.clearPendingMessages = function () {
        return this.messageQueue.clear();
    };
    Protocol.prototype.finish = function () {
        var transport = this.transport;
        this.onceIdle(function () {
            transport.disconnect();
        });
    };
    return Protocol;
}(eventemitter_1.default));
exports.default = Protocol;


/***/ }),
/* 53 */
/***/ (function(module, exports, __nested_webpack_require_510629__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_510629__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_510629__(3));
var Utils = tslib_1.__importStar(__nested_webpack_require_510629__(1));
var transport_1 = tslib_1.__importDefault(__nested_webpack_require_510629__(26));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_510629__(8));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_510629__(2));
var protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_510629__(10));
var errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_510629__(4));
var shortName = 'web_socket';
function isNodeWebSocket(ws) {
    return !!ws.on;
}
var WebSocketTransport = /** @class */ (function (_super) {
    tslib_1.__extends(WebSocketTransport, _super);
    function WebSocketTransport(connectionManager, auth, params) {
        var _this = _super.call(this, connectionManager, auth, params) || this;
        _this.shortName = shortName;
        /* If is a browser, can't detect pings, so request protocol heartbeats */
        params.heartbeats = platform_1.default.Config.useProtocolHeartbeats;
        _this.wsHost = defaults_1.default.getHost(params.options, params.host, true);
        return _this;
    }
    WebSocketTransport.isAvailable = function () {
        return !!platform_1.default.Config.WebSocket;
    };
    WebSocketTransport.prototype.createWebSocket = function (uri, connectParams) {
        this.uri = uri + Utils.toQueryString(connectParams);
        return new platform_1.default.Config.WebSocket(this.uri);
    };
    WebSocketTransport.prototype.toString = function () {
        return 'WebSocketTransport; uri=' + this.uri;
    };
    WebSocketTransport.prototype.connect = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.connect()', 'starting');
        transport_1.default.prototype.connect.call(this);
        var self = this, params = this.params, options = params.options;
        var wsScheme = options.tls ? 'wss://' : 'ws://';
        var wsUri = wsScheme + this.wsHost + ':' + defaults_1.default.getPort(options) + '/';
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.connect()', 'uri: ' + wsUri);
        this.auth.getAuthParams(function (err, authParams) {
            if (self.isDisposed) {
                return;
            }
            var paramStr = '';
            for (var param in authParams)
                paramStr += ' ' + param + ': ' + authParams[param] + ';';
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.connect()', 'authParams:' + paramStr + ' err: ' + err);
            if (err) {
                self.disconnect(err);
                return;
            }
            var connectParams = params.getConnectParams(authParams);
            try {
                var wsConnection = (self.wsConnection = self.createWebSocket(wsUri, connectParams));
                wsConnection.binaryType = platform_1.default.Config.binaryType;
                wsConnection.onopen = function () {
                    self.onWsOpen();
                };
                wsConnection.onclose = function (ev) {
                    self.onWsClose(ev);
                };
                wsConnection.onmessage = function (ev) {
                    self.onWsData(ev.data);
                };
                wsConnection.onerror = function (ev) {
                    self.onWsError(ev);
                };
                if (isNodeWebSocket(wsConnection)) {
                    /* node; browsers currently don't have a general eventemitter and can't detect
                     * pings. Also, no need to reply with a pong explicitly, ws lib handles that */
                    wsConnection.on('ping', function () {
                        self.onActivity();
                    });
                }
            }
            catch (e) {
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'WebSocketTransport.connect()', 'Unexpected exception creating websocket: err = ' + (e.stack || e.message));
                self.disconnect(e);
            }
        });
    };
    WebSocketTransport.prototype.send = function (message) {
        var wsConnection = this.wsConnection;
        if (!wsConnection) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'WebSocketTransport.send()', 'No socket connection');
            return;
        }
        try {
            wsConnection.send(protocolmessage_1.default.serialize(message, this.params.format));
        }
        catch (e) {
            var msg = 'Exception from ws connection when trying to send: ' + Utils.inspectError(e);
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'WebSocketTransport.send()', msg);
            /* Don't try to request a disconnect, that'll just involve sending data
             * down the websocket again. Just finish the transport. */
            this.finish('disconnected', new errorinfo_1.default(msg, 50000, 500));
        }
    };
    WebSocketTransport.prototype.onWsData = function (data) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'WebSocketTransport.onWsData()', 'data received; length = ' + data.length + '; type = ' + typeof data);
        try {
            this.onProtocolMessage(protocolmessage_1.default.deserialize(data, this.format));
        }
        catch (e) {
            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'WebSocketTransport.onWsData()', 'Unexpected exception handing channel message: ' + e.stack);
        }
    };
    WebSocketTransport.prototype.onWsOpen = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.onWsOpen()', 'opened WebSocket');
        this.emit('preconnect');
    };
    WebSocketTransport.prototype.onWsClose = function (ev) {
        var wasClean, code;
        if (typeof ev == 'object') {
            /* W3C spec-compatible */
            code = ev.code;
            // ev.wasClean is undefined in reactnative
            wasClean = ev.wasClean || code === 1000;
        } /*if(typeof(ev) == 'number')*/
        else {
            /* ws in node */
            code = ev;
            wasClean = code == 1000;
        }
        delete this.wsConnection;
        if (wasClean) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.onWsClose()', 'Cleanly closed WebSocket');
            var err = new errorinfo_1.default('Websocket closed', 80003, 400);
            this.finish('disconnected', err);
        }
        else {
            var msg = 'Unclean disconnection of WebSocket ; code = ' + code, err = new errorinfo_1.default(msg, 80003, 400);
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.onWsClose()', msg);
            this.finish('disconnected', err);
        }
        this.emit('disposed');
    };
    WebSocketTransport.prototype.onWsError = function (err) {
        var _this = this;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.onError()', 'Error from WebSocket: ' + err.message);
        /* Wait a tick before aborting: if the websocket was connected, this event
         * will be immediately followed by an onclose event with a close code. Allow
         * that to close it (so we see the close code) rather than anticipating it */
        platform_1.default.Config.nextTick(function () {
            _this.disconnect(Error(err.message));
        });
    };
    WebSocketTransport.prototype.dispose = function () {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.dispose()', '');
        this.isDisposed = true;
        var wsConnection = this.wsConnection;
        if (wsConnection) {
            /* Ignore any messages that come through after dispose() is called but before
             * websocket is actually closed. (mostly would be harmless, but if it's a
             * CONNECTED, it'll re-tick isConnected and cause all sorts of havoc) */
            wsConnection.onmessage = function () { };
            delete this.wsConnection;
            /* defer until the next event loop cycle before closing the socket,
             * giving some implementations the opportunity to send any outstanding close message */
            platform_1.default.Config.nextTick(function () {
                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'WebSocketTransport.dispose()', 'closing websocket');
                if (!wsConnection) {
                    throw new Error('WebSocketTransport.dispose(): wsConnection is not defined');
                }
                wsConnection.close();
            });
        }
    };
    return WebSocketTransport;
}(transport_1.default));
function initialiseTransport(connectionManager) {
    if (WebSocketTransport.isAvailable())
        connectionManager.supportedTransports[shortName] = WebSocketTransport;
    return WebSocketTransport;
}
exports.default = initialiseTransport;


/***/ }),
/* 54 */
/***/ (function(module, exports, __nested_webpack_require_519747__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_519747__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_519747__(1));
var presence_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(34));
var eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(7));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(2));
var presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(15));
var errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_519747__(4));
var realtimechannel_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(38));
var multicaster_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(23));
var channelstatechange_1 = tslib_1.__importDefault(__nested_webpack_require_519747__(39));
var noop = function () { };
function getClientId(realtimePresence) {
    return realtimePresence.channel.realtime.auth.clientId;
}
function isAnonymousOrWildcard(realtimePresence) {
    var realtime = realtimePresence.channel.realtime;
    /* If not currently connected, we can't assume that we're an anonymous
     * client, as realtime may inform us of our clientId in the CONNECTED
     * message. So assume we're not anonymous and leave it to realtime to
     * return an error if we are */
    var clientId = realtime.auth.clientId;
    return (!clientId || clientId === '*') && realtime.connection.state === 'connected';
}
/* Callback is called only in the event of an error */
function waitAttached(channel, callback, action) {
    switch (channel.state) {
        case 'attached':
        case 'suspended':
            action();
            break;
        case 'initialized':
        case 'detached':
        case 'detaching':
        case 'attaching':
            channel.attach(function (err) {
                if (err)
                    callback(err);
                else
                    action();
            });
            break;
        default:
            callback(errorinfo_1.default.fromValues(channel.invalidStateError()));
    }
}
function newerThan(item, existing) {
    /* RTP2b1: if either is synthesised, compare by timestamp */
    if (item.isSynthesized() || existing.isSynthesized()) {
        // RTP2b1a: if equal, prefer the newly-arrived one
        return item.timestamp >= existing.timestamp;
    }
    /* RTP2b2 */
    var itemOrderings = item.parseId(), existingOrderings = existing.parseId();
    if (itemOrderings.msgSerial === existingOrderings.msgSerial) {
        return itemOrderings.index > existingOrderings.index;
    }
    else {
        return itemOrderings.msgSerial > existingOrderings.msgSerial;
    }
}
var RealtimePresence = /** @class */ (function (_super) {
    tslib_1.__extends(RealtimePresence, _super);
    function RealtimePresence(channel) {
        var _this = _super.call(this, channel) || this;
        _this.channel = channel;
        _this.syncComplete = false;
        _this.members = new PresenceMap(_this, function (item) { return item.clientId + ':' + item.connectionId; });
        // RTP17h: Store own members by clientId only.
        _this._myMembers = new PresenceMap(_this, function (item) { return item.clientId; });
        _this.subscriptions = new eventemitter_1.default();
        _this.pendingPresence = [];
        return _this;
    }
    RealtimePresence.prototype.enter = function (data, callback) {
        if (isAnonymousOrWildcard(this)) {
            throw new errorinfo_1.default('clientId must be specified to enter a presence channel', 40012, 400);
        }
        return this._enterOrUpdateClient(undefined, undefined, data, 'enter', callback);
    };
    RealtimePresence.prototype.update = function (data, callback) {
        if (isAnonymousOrWildcard(this)) {
            throw new errorinfo_1.default('clientId must be specified to update presence data', 40012, 400);
        }
        return this._enterOrUpdateClient(undefined, undefined, data, 'update', callback);
    };
    RealtimePresence.prototype.enterClient = function (clientId, data, callback) {
        return this._enterOrUpdateClient(undefined, clientId, data, 'enter', callback);
    };
    RealtimePresence.prototype.updateClient = function (clientId, data, callback) {
        return this._enterOrUpdateClient(undefined, clientId, data, 'update', callback);
    };
    RealtimePresence.prototype._enterOrUpdateClient = function (id, clientId, data, action, callback) {
        var _this = this;
        if (!callback) {
            if (typeof data === 'function') {
                callback = data;
                data = null;
            }
            else {
                if (this.channel.realtime.options.promises) {
                    return Utils.promisify(this, '_enterOrUpdateClient', [id, clientId, data, action]);
                }
                callback = noop;
            }
        }
        var channel = this.channel;
        if (!channel.connectionManager.activeState()) {
            callback(channel.connectionManager.getError());
            return;
        }
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.' + action + 'Client()', 'channel = ' + channel.name + ', id = ' + id + ', client = ' + (clientId || '(implicit) ' + getClientId(this)));
        var presence = presencemessage_1.default.fromData(data);
        presence.action = action;
        if (id) {
            presence.id = id;
        }
        if (clientId) {
            presence.clientId = clientId;
        }
        presencemessage_1.default.encode(presence, channel.channelOptions, function (err) {
            if (err) {
                callback(err);
                return;
            }
            switch (channel.state) {
                case 'attached':
                    channel.sendPresence(presence, callback);
                    break;
                case 'initialized':
                case 'detached':
                    channel.attach();
                // eslint-disable-next-line no-fallthrough
                case 'attaching':
                    _this.pendingPresence.push({
                        presence: presence,
                        callback: callback,
                    });
                    break;
                default:
                    err = new errorinfo_1.PartialErrorInfo('Unable to ' + action + ' presence channel while in ' + channel.state + ' state', 90001);
                    err.code = 90001;
                    callback(err);
            }
        });
    };
    RealtimePresence.prototype.leave = function (data, callback) {
        if (isAnonymousOrWildcard(this)) {
            throw new errorinfo_1.default('clientId must have been specified to enter or leave a presence channel', 40012, 400);
        }
        return this.leaveClient(undefined, data, callback);
    };
    RealtimePresence.prototype.leaveClient = function (clientId, data, callback) {
        if (!callback) {
            if (typeof data === 'function') {
                callback = data;
                data = null;
            }
            else {
                if (this.channel.realtime.options.promises) {
                    return Utils.promisify(this, 'leaveClient', [clientId, data]);
                }
                callback = noop;
            }
        }
        var channel = this.channel;
        if (!channel.connectionManager.activeState()) {
            callback === null || callback === void 0 ? void 0 : callback(channel.connectionManager.getError());
            return;
        }
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.leaveClient()', 'leaving; channel = ' + this.channel.name + ', client = ' + clientId);
        var presence = presencemessage_1.default.fromValues({
            action: 'leave',
            data: data,
        });
        if (clientId) {
            presence.clientId = clientId;
        }
        switch (channel.state) {
            case 'attached':
                channel.sendPresence(presence, callback);
                break;
            case 'attaching':
                this.pendingPresence.push({
                    presence: presence,
                    callback: callback,
                });
                break;
            case 'initialized':
            case 'failed': {
                /* we're not attached; therefore we let any entered status
                 * timeout by itself instead of attaching just in order to leave */
                var err = new errorinfo_1.PartialErrorInfo('Unable to leave presence channel (incompatible state)', 90001);
                callback === null || callback === void 0 ? void 0 : callback(err);
                break;
            }
            default:
                callback === null || callback === void 0 ? void 0 : callback(channel.invalidStateError());
        }
    };
    // Return type is any to avoid conflict with base Presence class
    RealtimePresence.prototype.get = function (params, callback) {
        var _this = this;
        var args = Array.prototype.slice.call(arguments);
        if (args.length == 1 && typeof args[0] == 'function')
            args.unshift(null);
        params = args[0];
        callback = args[1];
        var waitForSync = !params || ('waitForSync' in params ? params.waitForSync : true);
        if (!callback) {
            if (this.channel.realtime.options.promises) {
                return Utils.promisify(this, 'get', args);
            }
            callback = noop;
        }
        function returnMembers(members) {
            callback(null, params ? members.list(params) : members.values());
        }
        /* Special-case the suspended state: can still get (stale) presence set if waitForSync is false */
        if (this.channel.state === 'suspended') {
            if (waitForSync) {
                callback(errorinfo_1.default.fromValues({
                    statusCode: 400,
                    code: 91005,
                    message: 'Presence state is out of sync due to channel being in the SUSPENDED state',
                }));
            }
            else {
                returnMembers(this.members);
            }
            return;
        }
        waitAttached(this.channel, callback, function () {
            var members = _this.members;
            if (waitForSync) {
                members.waitSync(function () {
                    returnMembers(members);
                });
            }
            else {
                returnMembers(members);
            }
        });
    };
    RealtimePresence.prototype.history = function (params, callback) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.history()', 'channel = ' + this.name);
        /* params and callback are optional; see if params contains the callback */
        if (callback === undefined) {
            if (typeof params == 'function') {
                callback = params;
                params = null;
            }
            else {
                if (this.channel.realtime.options.promises) {
                    return Utils.promisify(this, 'history', arguments);
                }
                callback = noop;
            }
        }
        if (params && params.untilAttach) {
            if (this.channel.state === 'attached') {
                delete params.untilAttach;
                params.from_serial = this.channel.properties.attachSerial;
            }
            else {
                callback(new errorinfo_1.default('option untilAttach requires the channel to be attached, was: ' + this.channel.state, 40000, 400));
            }
        }
        presence_1.default.prototype._history.call(this, params, callback);
    };
    RealtimePresence.prototype.setPresence = function (presenceSet, isSync, syncChannelSerial) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.setPresence()', 'received presence for ' + presenceSet.length + ' participants; syncChannelSerial = ' + syncChannelSerial);
        var syncCursor, match;
        var members = this.members, myMembers = this._myMembers, broadcastMessages = [], connId = this.channel.connectionManager.connectionId;
        if (isSync) {
            this.members.startSync();
            if (syncChannelSerial && (match = syncChannelSerial.match(/^[\w-]+:(.*)$/))) {
                syncCursor = match[1];
            }
        }
        for (var i = 0; i < presenceSet.length; i++) {
            var presence = presencemessage_1.default.fromValues(presenceSet[i]);
            switch (presence.action) {
                case 'leave':
                    if (members.remove(presence)) {
                        broadcastMessages.push(presence);
                    }
                    if (presence.connectionId === connId && !presence.isSynthesized()) {
                        myMembers.remove(presence);
                    }
                    break;
                case 'enter':
                case 'present':
                case 'update':
                    if (members.put(presence)) {
                        broadcastMessages.push(presence);
                    }
                    if (presence.connectionId === connId) {
                        myMembers.put(presence);
                    }
                    break;
            }
        }
        /* if this is the last (or only) message in a sequence of sync updates, end the sync */
        if (isSync && !syncCursor) {
            members.endSync();
            this.channel.syncChannelSerial = null;
        }
        /* broadcast to listeners */
        for (var i = 0; i < broadcastMessages.length; i++) {
            var presence = broadcastMessages[i];
            this.subscriptions.emit(presence.action, presence);
        }
    };
    RealtimePresence.prototype.onAttached = function (hasPresence) {
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimePresence.onAttached()', 'channel = ' + this.channel.name + ', hasPresence = ' + hasPresence);
        if (hasPresence) {
            this.members.startSync();
        }
        else {
            this._synthesizeLeaves(this.members.values());
            this.members.clear();
        }
        // RTP17f: Re-enter own members when moving into the attached state.
        this._ensureMyMembersPresent();
        /* NB this must be after the _ensureMyMembersPresent call, which may add items to pendingPresence */
        var pendingPresence = this.pendingPresence, pendingPresCount = pendingPresence.length;
        if (pendingPresCount) {
            this.pendingPresence = [];
            var presenceArray = [];
            var multicaster = multicaster_1.default.create();
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.onAttached', 'sending ' + pendingPresCount + ' queued presence messages');
            for (var i = 0; i < pendingPresCount; i++) {
                var event_1 = pendingPresence[i];
                presenceArray.push(event_1.presence);
                multicaster.push(event_1.callback);
            }
            this.channel.sendPresence(presenceArray, multicaster);
        }
    };
    RealtimePresence.prototype.actOnChannelState = function (state, hasPresence, err) {
        switch (state) {
            case 'attached':
                this.onAttached(hasPresence);
                break;
            case 'detached':
            case 'failed':
                this._clearMyMembers();
                this.members.clear();
            /* falls through */
            case 'suspended':
                this.failPendingPresence(err);
                break;
        }
    };
    RealtimePresence.prototype.failPendingPresence = function (err) {
        if (this.pendingPresence.length) {
            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.failPendingPresence', 'channel; name = ' + this.channel.name + ', err = ' + Utils.inspectError(err));
            for (var i = 0; i < this.pendingPresence.length; i++)
                try {
                    this.pendingPresence[i].callback(err);
                    // eslint-disable-next-line no-empty
                }
                catch (e) { }
            this.pendingPresence = [];
        }
    };
    RealtimePresence.prototype._clearMyMembers = function () {
        this._myMembers.clear();
    };
    RealtimePresence.prototype._ensureMyMembersPresent = function () {
        var _this = this;
        var myMembers = this._myMembers, reenterCb = function (err) {
            if (err) {
                var msg = 'Presence auto-re-enter failed: ' + err.toString();
                var wrappedErr = new errorinfo_1.default(msg, 91004, 400);
                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimePresence._ensureMyMembersPresent()', msg);
                var change = new channelstatechange_1.default(_this.channel.state, _this.channel.state, true, false, wrappedErr);
                _this.channel.emit('update', change);
            }
        };
        for (var memberKey in myMembers.map) {
            var entry = myMembers.map[memberKey];
            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence._ensureMyMembersPresent()', 'Auto-reentering clientId "' + entry.clientId + '" into the presence set');
            // RTP17g: Send ENTER containing the member id, clientId and data
            // attributes.
            this._enterOrUpdateClient(entry.id, entry.clientId, entry.data, 'enter', reenterCb);
        }
    };
    RealtimePresence.prototype._synthesizeLeaves = function (items) {
        var subscriptions = this.subscriptions;
        Utils.arrForEach(items, function (item) {
            var presence = presencemessage_1.default.fromValues({
                action: 'leave',
                connectionId: item.connectionId,
                clientId: item.clientId,
                data: item.data,
                encoding: item.encoding,
                timestamp: Utils.now(),
            });
            subscriptions.emit('leave', presence);
        });
    };
    /* Deprecated */
    RealtimePresence.prototype.on = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        logger_1.default.deprecated('presence.on', 'presence.subscribe');
        this.subscribe.apply(this, args);
    };
    /* Deprecated */
    RealtimePresence.prototype.off = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        logger_1.default.deprecated('presence.off', 'presence.unsubscribe');
        this.unsubscribe.apply(this, args);
    };
    RealtimePresence.prototype.subscribe = function () {
        var _args = []; /* [event], listener, [callback] */
        for (var _i = 0 /* [event], listener, [callback] */; _i < arguments.length /* [event], listener, [callback] */; _i++ /* [event], listener, [callback] */) {
            _args[_i] = arguments[_i]; /* [event], listener, [callback] */
        }
        var args = realtimechannel_1.default.processListenerArgs(_args);
        var event = args[0];
        var listener = args[1];
        var callback = args[2];
        var channel = this.channel;
        if (!callback) {
            if (this.channel.realtime.options.promises) {
                return Utils.promisify(this, 'subscribe', [event, listener]);
            }
            callback = noop;
        }
        if (channel.state === 'failed') {
            callback(errorinfo_1.default.fromValues(channel.invalidStateError()));
            return;
        }
        this.subscriptions.on(event, listener);
        channel.attach(callback);
    };
    RealtimePresence.prototype.unsubscribe = function () {
        var _args = []; /* [event], listener */
        for (var _i = 0 /* [event], listener */; _i < arguments.length /* [event], listener */; _i++ /* [event], listener */) {
            _args[_i] = arguments[_i]; /* [event], listener */
        }
        var args = realtimechannel_1.default.processListenerArgs(_args);
        var event = args[0];
        var listener = args[1];
        this.subscriptions.off(event, listener);
    };
    return RealtimePresence;
}(presence_1.default));
var PresenceMap = /** @class */ (function (_super) {
    tslib_1.__extends(PresenceMap, _super);
    function PresenceMap(presence, memberKey) {
        var _this = _super.call(this) || this;
        _this.presence = presence;
        _this.map = Object.create(null);
        _this.syncInProgress = false;
        _this.residualMembers = null;
        _this.memberKey = memberKey;
        return _this;
    }
    PresenceMap.prototype.get = function (key) {
        return this.map[key];
    };
    PresenceMap.prototype.getClient = function (clientId) {
        var map = this.map, result = [];
        for (var key in map) {
            var item = map[key];
            if (item.clientId == clientId && item.action != 'absent')
                result.push(item);
        }
        return result;
    };
    PresenceMap.prototype.list = function (params) {
        var map = this.map, clientId = params && params.clientId, connectionId = params && params.connectionId, result = [];
        for (var key in map) {
            var item = map[key];
            if (item.action === 'absent')
                continue;
            if (clientId && clientId != item.clientId)
                continue;
            if (connectionId && connectionId != item.connectionId)
                continue;
            result.push(item);
        }
        return result;
    };
    PresenceMap.prototype.put = function (item) {
        if (item.action === 'enter' || item.action === 'update') {
            item = presencemessage_1.default.fromValues(item);
            item.action = 'present';
        }
        var map = this.map, key = this.memberKey(item);
        /* we've seen this member, so do not remove it at the end of sync */
        if (this.residualMembers)
            delete this.residualMembers[key];
        /* compare the timestamp of the new item with any existing member (or ABSENT witness) */
        var existingItem = map[key];
        if (existingItem && !newerThan(item, existingItem)) {
            return false;
        }
        map[key] = item;
        return true;
    };
    PresenceMap.prototype.values = function () {
        var map = this.map, result = [];
        for (var key in map) {
            var item = map[key];
            if (item.action != 'absent')
                result.push(item);
        }
        return result;
    };
    PresenceMap.prototype.remove = function (item) {
        var map = this.map, key = this.memberKey(item);
        var existingItem = map[key];
        if (existingItem && !newerThan(item, existingItem)) {
            return false;
        }
        /* RTP2f */
        if (this.syncInProgress) {
            item = presencemessage_1.default.fromValues(item);
            item.action = 'absent';
            map[key] = item;
        }
        else {
            delete map[key];
        }
        return true;
    };
    PresenceMap.prototype.startSync = function () {
        var map = this.map, syncInProgress = this.syncInProgress;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'PresenceMap.startSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
        /* we might be called multiple times while a sync is in progress */
        if (!this.syncInProgress) {
            this.residualMembers = Utils.copy(map);
            this.setInProgress(true);
        }
    };
    PresenceMap.prototype.endSync = function () {
        var map = this.map, syncInProgress = this.syncInProgress;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'PresenceMap.endSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
        if (syncInProgress) {
            /* we can now strip out the ABSENT members, as we have
             * received all of the out-of-order sync messages */
            for (var memberKey in map) {
                var entry = map[memberKey];
                if (entry.action === 'absent') {
                    delete map[memberKey];
                }
            }
            /* any members that were present at the start of the sync,
             * and have not been seen in sync, can be removed, and leave events emitted */
            this.presence._synthesizeLeaves(Utils.valuesArray(this.residualMembers));
            for (var memberKey in this.residualMembers) {
                delete map[memberKey];
            }
            this.residualMembers = null;
            /* finish, notifying any waiters */
            this.setInProgress(false);
        }
        this.emit('sync');
    };
    PresenceMap.prototype.waitSync = function (callback) {
        var syncInProgress = this.syncInProgress;
        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'PresenceMap.waitSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
        if (!syncInProgress) {
            callback();
            return;
        }
        this.once('sync', callback);
    };
    PresenceMap.prototype.clear = function () {
        this.map = {};
        this.setInProgress(false);
        this.residualMembers = null;
    };
    PresenceMap.prototype.setInProgress = function (inProgress) {
        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'PresenceMap.setInProgress()', 'inProgress = ' + inProgress);
        this.syncInProgress = inProgress;
        this.presence.syncComplete = !inProgress;
    };
    return PresenceMap;
}(eventemitter_1.default));
exports.default = RealtimePresence;


/***/ }),
/* 55 */
/***/ (function(module, exports, __nested_webpack_require_545633__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_545633__(0);
var enc_hex_1 = __nested_webpack_require_545633__(56);
var enc_utf8_1 = __nested_webpack_require_545633__(31);
var enc_base64_1 = __nested_webpack_require_545633__(11);
var lib_typedarrays_1 = tslib_1.__importDefault(__nested_webpack_require_545633__(5));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_545633__(3));
var BufferUtils = /** @class */ (function () {
    function BufferUtils() {
        this.base64CharSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        this.hexCharSet = '0123456789abcdef';
    }
    BufferUtils.prototype.isWordArray = function (ob) {
        return ob !== null && ob !== undefined && ob.sigBytes !== undefined;
    };
    BufferUtils.prototype.isArrayBuffer = function (ob) {
        return ob !== null && ob !== undefined && ob.constructor === ArrayBuffer;
    };
    BufferUtils.prototype.isTypedArray = function (ob) {
        return !!ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(ob);
    };
    // // https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js
    BufferUtils.prototype.uint8ViewToBase64 = function (bytes) {
        var base64 = '';
        var encodings = this.base64CharSet;
        var byteLength = bytes.byteLength;
        var byteRemainder = byteLength % 3;
        var mainLength = byteLength - byteRemainder;
        var a, b, c, d;
        var chunk;
        // Main loop deals with bytes in chunks of 3
        for (var i = 0; i < mainLength; i = i + 3) {
            // Combine the three bytes into a single integer
            chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
            // Use bitmasks to extract 6-bit segments from the triplet
            a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
            b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12
            c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6
            d = chunk & 63; // 63       = 2^6 - 1
            // Convert the raw binary segments to the appropriate ASCII encoding
            base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
        }
        // Deal with the remaining bytes and padding
        if (byteRemainder == 1) {
            chunk = bytes[mainLength];
            a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2
            // Set the 4 least significant bits to zero
            b = (chunk & 3) << 4; // 3   = 2^2 - 1
            base64 += encodings[a] + encodings[b] + '==';
        }
        else if (byteRemainder == 2) {
            chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];
            a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
            b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4
            // Set the 2 least significant bits to zero
            c = (chunk & 15) << 2; // 15    = 2^4 - 1
            base64 += encodings[a] + encodings[b] + encodings[c] + '=';
        }
        return base64;
    };
    BufferUtils.prototype.base64ToArrayBuffer = function (base64) {
        var binary_string = atob === null || atob === void 0 ? void 0 : atob(base64); // this will always be defined in browser so it's safe to cast
        var len = binary_string.length;
        var bytes = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
            var ascii = binary_string.charCodeAt(i);
            bytes[i] = ascii;
        }
        return bytes.buffer;
    };
    BufferUtils.prototype.isBuffer = function (buffer) {
        return this.isArrayBuffer(buffer) || this.isWordArray(buffer) || this.isTypedArray(buffer);
    };
    /* In browsers, returns a Uint8Array */
    BufferUtils.prototype.toBuffer = function (buffer) {
        if (!ArrayBuffer) {
            throw new Error("Can't convert to Buffer: browser does not support the necessary types");
        }
        if (this.isArrayBuffer(buffer)) {
            return new Uint8Array(buffer);
        }
        if (this.isTypedArray(buffer)) {
            return new Uint8Array(buffer.buffer);
        }
        if (this.isWordArray(buffer)) {
            /* Backported from unreleased CryptoJS
             * https://code.google.com/p/crypto-js/source/browse/branches/3.x/src/lib-typedarrays.js?r=661 */
            var arrayBuffer = new ArrayBuffer(buffer.sigBytes);
            var uint8View = new Uint8Array(arrayBuffer);
            for (var i = 0; i < buffer.sigBytes; i++) {
                uint8View[i] = (buffer.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
            }
            return uint8View;
        }
        throw new Error('BufferUtils.toBuffer expected an arraybuffer, typed array, or CryptoJS wordarray');
    };
    BufferUtils.prototype.toArrayBuffer = function (buffer) {
        if (this.isArrayBuffer(buffer)) {
            return buffer;
        }
        return this.toBuffer(buffer).buffer;
    };
    BufferUtils.prototype.toWordArray = function (buffer) {
        if (this.isTypedArray(buffer)) {
            buffer = buffer.buffer;
        }
        return this.isWordArray(buffer) ? buffer : lib_typedarrays_1.default.create(buffer);
    };
    BufferUtils.prototype.base64Encode = function (buffer) {
        if (this.isWordArray(buffer)) {
            return (0, enc_base64_1.stringify)(buffer);
        }
        return this.uint8ViewToBase64(this.toBuffer(buffer));
    };
    BufferUtils.prototype.base64Decode = function (str) {
        if (ArrayBuffer && platform_1.default.Config.atob) {
            return this.base64ToArrayBuffer(str);
        }
        return (0, enc_base64_1.parse)(str);
    };
    BufferUtils.prototype.hexEncode = function (buffer) {
        return (0, enc_hex_1.stringify)(this.toWordArray(buffer));
    };
    BufferUtils.prototype.hexDecode = function (string) {
        var wordArray = (0, enc_hex_1.parse)(string);
        return ArrayBuffer ? this.toArrayBuffer(wordArray) : wordArray;
    };
    BufferUtils.prototype.utf8Encode = function (string) {
        if (platform_1.default.Config.TextEncoder) {
            return new platform_1.default.Config.TextEncoder().encode(string).buffer;
        }
        return (0, enc_utf8_1.parse)(string);
    };
    /* For utf8 decoding we apply slightly stricter input validation than to
     * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from
     * can take (in particular allowing strings, which are just interpreted as
     * binary); here we ensure that the input is actually a buffer since trying
     * to utf8-decode a string to another string is almost certainly a mistake */
    BufferUtils.prototype.utf8Decode = function (buffer) {
        if (!this.isBuffer(buffer)) {
            throw new Error('Expected input of utf8decode to be an arraybuffer, typed array, or CryptoJS wordarray');
        }
        if (TextDecoder && !this.isWordArray(buffer)) {
            return new TextDecoder().decode(buffer);
        }
        buffer = this.toWordArray(buffer);
        return (0, enc_utf8_1.stringify)(buffer);
    };
    BufferUtils.prototype.bufferCompare = function (buffer1, buffer2) {
        if (!buffer1)
            return -1;
        if (!buffer2)
            return 1;
        var wordArray1 = this.toWordArray(buffer1);
        var wordArray2 = this.toWordArray(buffer2);
        wordArray1.clamp();
        wordArray2.clamp();
        var cmp = wordArray1.sigBytes - wordArray2.sigBytes;
        if (cmp != 0)
            return cmp;
        var words1 = wordArray1.words;
        var words2 = wordArray2.words;
        for (var i = 0; i < words1.length; i++) {
            cmp = words1[i] - words2[i];
            if (cmp != 0)
                return cmp;
        }
        return 0;
    };
    BufferUtils.prototype.byteLength = function (buffer) {
        if (this.isArrayBuffer(buffer) || this.isTypedArray(buffer)) {
            return buffer.byteLength;
        }
        else if (this.isWordArray(buffer)) {
            return buffer.sigBytes;
        }
        return -1;
    };
    /* Returns ArrayBuffer on browser and Buffer on Node.js */
    BufferUtils.prototype.typedArrayToBuffer = function (typedArray) {
        return typedArray.buffer;
    };
    return BufferUtils;
}());
exports.default = new BufferUtils();


/***/ }),
/* 56 */
/***/ (function(module, exports, __nested_webpack_require_554008__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_554008__(6));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Hex;

}));

/***/ }),
/* 57 */
/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_554290__) {

"use strict";
__nested_webpack_require_554290__.r(__nested_webpack_exports__);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_554290__(5);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_554290__.n(crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_554290__(11);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_554290__.n(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crypto_js_build__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_554290__(22);
/* harmony import */ var crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_554290__.n(crypto_js_build__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_554290__(2);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_554290__.n(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_554290__(4);
/* harmony import */ var common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__nested_webpack_require_554290__.n(common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_4__);






var CryptoFactory = function (config, bufferUtils) {
  var DEFAULT_ALGORITHM = 'aes';
  var DEFAULT_KEYLENGTH = 256; // bits
  var DEFAULT_MODE = 'cbc';
  var DEFAULT_BLOCKLENGTH = 16; // bytes
  var DEFAULT_BLOCKLENGTH_WORDS = 4; // 32-bit words
  var UINT32_SUP = 0x100000000;
  var INT32_SUP = 0x80000000;

  /**
   * Internal: generate an array of secure random words corresponding to the given length of bytes
   * @param bytes
   * @param callback
   */
  var generateRandom;
  if (config.getRandomWordArray) {
    generateRandom = config.getRandomWordArray;
  } else if (typeof Uint32Array !== 'undefined' && config.getRandomValues) {
    var blockRandomArray = new Uint32Array(DEFAULT_BLOCKLENGTH_WORDS);
    generateRandom = function (bytes, callback) {
      var words = bytes / 4,
        nativeArray = words == DEFAULT_BLOCKLENGTH_WORDS ? blockRandomArray : new Uint32Array(words);
      config.getRandomValues(nativeArray, function (err) {
        if (typeof callback !== 'undefined') {
          callback(err, bufferUtils.toWordArray(nativeArray));
        }
      });
    };
  } else {
    generateRandom = function (bytes, callback) {
      _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.logAction(
        _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.LOG_MAJOR,
        'Ably.Crypto.generateRandom()',
        'Warning: the browser you are using does not support secure cryptographically secure randomness generation; falling back to insecure Math.random()'
      );
      var words = bytes / 4,
        array = new Array(words);
      for (var i = 0; i < words; i++) {
        /* cryptojs wordarrays use signed ints. When WordArray.create is fed a
         * Uint32Array unsigned are converted to signed automatically, but when
         * fed a normal array they aren't, so need to do so ourselves by
         * subtracting INT32_SUP */
        array[i] = Math.floor(Math.random() * UINT32_SUP) - INT32_SUP;
      }

      callback(null, crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(array));
    };
  }

  /**
   * Internal: calculate the padded length of a given plaintext
   * using PKCS5.
   * @param plaintextLength
   * @return
   */
  function getPaddedLength(plaintextLength) {
    return (plaintextLength + DEFAULT_BLOCKLENGTH) & -DEFAULT_BLOCKLENGTH;
  }

  /**
   * Internal: checks that the cipherParams are a valid combination. Currently
   * just checks that the calculated keyLength is a valid one for aes-cbc
   */
  function validateCipherParams(params) {
    if (params.algorithm === 'aes' && params.mode === 'cbc') {
      if (params.keyLength === 128 || params.keyLength === 256) {
        return;
      }
      throw new Error(
        'Unsupported key length ' +
          params.keyLength +
          ' for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)'
      );
    }
  }

  function normaliseBase64(string) {
    /* url-safe base64 strings use _ and - instread of / and + */
    return string.replace('_', '/').replace('-', '+');
  }

  /**
   * Internal: obtain the pkcs5 padding string for a given padded length;
   */
  var pkcs5Padding = [
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x10101010, 0x10101010, 0x10101010, 0x10101010], 16),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x01000000], 1),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x02020000], 2),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x03030300], 3),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x04040404], 4),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x05050505, 0x05000000], 5),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x06060606, 0x06060000], 6),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x07070707, 0x07070700], 7),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x08080808, 0x08080808], 8),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x09090909, 0x09090909, 0x09000000], 9),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0a0a0a0a, 0x0a0a0a0a, 0x0a0a0000], 10),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0b0b0b0b, 0x0b0b0b0b, 0x0b0b0b00], 11),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0c0c0c0c, 0x0c0c0c0c, 0x0c0c0c0c], 12),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0d0d0d0d, 0x0d0d0d0d, 0x0d0d0d0d, 0x0d000000], 13),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0e0e0e0e, 0x0e0e0e0e, 0x0e0e0e0e, 0x0e0e0000], 14),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f], 15),
    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x10101010, 0x10101010, 0x10101010, 0x10101010], 16),
  ];

  /**
   * Utility classes and interfaces for message payload encryption.
   *
   * This class supports AES/CBC/PKCS5 with a default keylength of 128 bits
   * but supporting other keylengths. Other algorithms and chaining modes are
   * not supported directly, but supportable by extending/implementing the base
   * classes and interfaces here.
   *-
   * Secure random data for creation of Initialization Vectors (IVs) and keys
   * is obtained from window.crypto.getRandomValues if available, or from
   * Math.random() if not. Clients who do not want to depend on Math.random()
   * should polyfill window.crypto.getRandomValues with a library that seeds
   * a PRNG with real entropy.
   *
   * Each message payload is encrypted with an IV in CBC mode, and the IV is
   * concatenated with the resulting raw ciphertext to construct the "ciphertext"
   * data passed to the recipient.
   */
  function Crypto() {}

  /**
   * A class encapsulating the client-specifiable parameters for
   * the cipher.
   *
   * algorithm is the name of the algorithm in the default system provider,
   * or the lower-cased version of it; eg "aes" or "AES".
   *
   * Clients are recommended to not call this directly, but instead to use the
   * Crypto.getDefaultParams helper, which will fill in any fields not supplied
   * with default values and validation the result.
   */
  function CipherParams() {
    this.algorithm = null;
    this.keyLength = null;
    this.mode = null;
    this.key = null;
  }
  Crypto.CipherParams = CipherParams;

  /**
   * Obtain a complete CipherParams instance from the provided params, filling
   * in any not provided with default values, calculating a keyLength from
   * the supplied key, and validating the result.
   * @param params an object containing at a minimum a `key` key with value the
   * key, as either a binary (ArrayBuffer, Array, WordArray) or a
   * base64-encoded string. May optionally also contain: algorithm (defaults to
   * AES), mode (defaults to 'cbc')
   */
  Crypto.getDefaultParams = function (params) {
    var key;
    /* Backward compatibility */
    if (typeof params === 'function' || typeof params === 'string') {
      _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.deprecated('Crypto.getDefaultParams(key, callback)', 'Crypto.getDefaultParams({key: key})');
      if (typeof params === 'function') {
        Crypto.generateRandomKey(function (key) {
          params(null, Crypto.getDefaultParams({ key: key }));
        });
      } else if (typeof arguments[1] === 'function') {
        arguments[1](null, Crypto.getDefaultParams({ key: params }));
      } else {
        throw new Error('Invalid arguments for Crypto.getDefaultParams');
      }
      return;
    }

    if (!params.key) {
      throw new Error('Crypto.getDefaultParams: a key is required');
    }

    if (typeof params.key === 'string') {
      key = Object(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__["parse"])(normaliseBase64(params.key));
    } else {
      key = bufferUtils.toWordArray(params.key); // Expect key to be an Array, ArrayBuffer, or WordArray at this point
    }

    var cipherParams = new CipherParams();
    cipherParams.key = key;
    cipherParams.algorithm = params.algorithm || DEFAULT_ALGORITHM;
    cipherParams.keyLength = key.words.length * (4 * 8);
    cipherParams.mode = params.mode || DEFAULT_MODE;

    if (params.keyLength && params.keyLength !== cipherParams.keyLength) {
      throw new Error(
        'Crypto.getDefaultParams: a keyLength of ' +
          params.keyLength +
          ' was specified, but the key actually has length ' +
          cipherParams.keyLength
      );
    }

    validateCipherParams(cipherParams);
    return cipherParams;
  };

  /**
   * Generate a random encryption key from the supplied keylength (or the
   * default keyLength if none supplied) as a CryptoJS WordArray
   * @param keyLength (optional) the required keyLength in bits
   * @param callback (optional) (err, key)
   */
  Crypto.generateRandomKey = function (keyLength, callback) {
    if (arguments.length == 1 && typeof keyLength == 'function') {
      callback = keyLength;
      keyLength = undefined;
    }

    generateRandom((keyLength || DEFAULT_KEYLENGTH) / 8, function (err, buf) {
      if (callback !== undefined) {
        callback(err ? common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_4___default.a.fromValues(err) : null, buf);
      }
    });
  };

  /**
   * Internal; get a ChannelCipher instance based on the given cipherParams
   * @param params either a CipherParams instance or some subset of its
   * fields that includes a key
   */
  Crypto.getCipher = function (params) {
    var cipherParams = params instanceof CipherParams ? params : Crypto.getDefaultParams(params);

    return { cipherParams: cipherParams, cipher: new CBCCipher(cipherParams, DEFAULT_BLOCKLENGTH_WORDS, params.iv) };
  };

  function CBCCipher(params, blockLengthWords, iv) {
    this.algorithm = params.algorithm + '-' + String(params.keyLength) + '-' + params.mode;
    this.cjsAlgorithm = params.algorithm.toUpperCase().replace(/-\d+$/, '');
    this.key = bufferUtils.toWordArray(params.key);
    if (iv) {
      this.iv = bufferUtils.toWordArray(iv).clone();
    }
    this.blockLengthWords = blockLengthWords;
  }

  CBCCipher.prototype.encrypt = function (plaintext, callback) {
    _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.LOG_MICRO, 'CBCCipher.encrypt()', '');
    plaintext = bufferUtils.toWordArray(plaintext);
    var plaintextLength = plaintext.sigBytes,
      paddedLength = getPaddedLength(plaintextLength),
      self = this;

    var then = function () {
      self.getIv(function (err, iv) {
        if (err) {
          callback(err);
          return;
        }
        var cipherOut = self.encryptCipher.process(plaintext.concat(pkcs5Padding[paddedLength - plaintextLength]));
        var ciphertext = iv.concat(cipherOut);
        callback(null, ciphertext);
      });
    };

    if (!this.encryptCipher) {
      if (this.iv) {
        this.encryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[this.cjsAlgorithm].createEncryptor(this.key, { iv: this.iv });
        then();
      } else {
        generateRandom(DEFAULT_BLOCKLENGTH, function (err, iv) {
          if (err) {
            callback(err);
            return;
          }
          self.encryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[self.cjsAlgorithm].createEncryptor(self.key, { iv: iv });
          self.iv = iv;
          then();
        });
      }
    } else {
      then();
    }
  };

  CBCCipher.prototype.decrypt = function (ciphertext) {
    _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.LOG_MICRO, 'CBCCipher.decrypt()', '');
    ciphertext = bufferUtils.toWordArray(ciphertext);
    var blockLengthWords = this.blockLengthWords,
      ciphertextWords = ciphertext.words,
      iv = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(ciphertextWords.slice(0, blockLengthWords)),
      ciphertextBody = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(ciphertextWords.slice(blockLengthWords));

    var decryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[this.cjsAlgorithm].createDecryptor(this.key, { iv: iv });
    var plaintext = decryptCipher.process(ciphertextBody);
    var epilogue = decryptCipher.finalize();
    decryptCipher.reset();
    if (epilogue && epilogue.sigBytes) plaintext.concat(epilogue);
    return plaintext;
  };

  CBCCipher.prototype.getIv = function (callback) {
    if (this.iv) {
      var iv = this.iv;
      this.iv = null;
      callback(null, iv);
      return;
    }

    /* Since the iv for a new block is the ciphertext of the last, this
     * sets a new iv (= aes(randomBlock XOR lastCipherText)) as well as
     * returning it */
    var self = this;
    generateRandom(DEFAULT_BLOCKLENGTH, function (err, randomBlock) {
      if (err) {
        callback(err);
        return;
      }
      callback(null, self.encryptCipher.process(randomBlock));
    });
  };

  return Crypto;
};

/* harmony default export */ __nested_webpack_exports__["default"] = (CryptoFactory);


/***/ }),
/* 58 */
/***/ (function(module, exports, __nested_webpack_require_569507__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_569507__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	return CryptoJS.enc.Utf16;

}));

/***/ }),
/* 59 */
/***/ (function(module, exports, __nested_webpack_require_573504__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_573504__(6), __nested_webpack_require_573504__(28));
	}
	else {}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	return CryptoJS.format.Hex;

}));

/***/ }),
/* 60 */
/***/ (function(module, exports, __nested_webpack_require_575212__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_575212__(6), __nested_webpack_require_575212__(11), __nested_webpack_require_575212__(61), __nested_webpack_require_575212__(27), __nested_webpack_require_575212__(28));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            var t;

	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));

/***/ }),
/* 61 */
/***/ (function(module, exports, __nested_webpack_require_583721__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_583721__(6));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),
/* 62 */
/***/ (function(module, exports, __nested_webpack_require_593050__) {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_593050__(0);
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(3));
var Utils = tslib_1.__importStar(__nested_webpack_require_593050__(1));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(8));
var errorinfo_1 = __nested_webpack_require_593050__(4);
var HttpMethods_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(18));
var xhrrequest_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(16));
var XHRStates_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(21));
var logger_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(2));
var jsonptransport_1 = __nested_webpack_require_593050__(29);
var fetchrequest_1 = tslib_1.__importDefault(__nested_webpack_require_593050__(63));
var HttpStatusCodes_1 = __nested_webpack_require_593050__(25);
function shouldFallback(errorInfo) {
    var statusCode = errorInfo.statusCode;
    /* 400 + no code = a generic xhr onerror. Browser doesn't give us enough
     * detail to know whether it's fallback-fixable, but it may be (eg if a
     * network issue), so try just in case */
    return ((statusCode === 408 && !errorInfo.code) ||
        (statusCode === 400 && !errorInfo.code) ||
        (statusCode >= 500 && statusCode <= 504));
}
function getHosts(client) {
    /* If we're a connected realtime client, try the endpoint we're connected
     * to first -- but still have fallbacks, being connected is not an absolute
     * guarantee that a datacenter has free capacity to service REST requests. */
    var connection = client.connection, connectionHost = connection && connection.connectionManager.host;
    if (connectionHost) {
        return [connectionHost].concat(defaults_1.default.getFallbackHosts(client.options));
    }
    return defaults_1.default.getHosts(client.options);
}
var Http = (_a = /** @class */ (function () {
        function class_1(options) {
            this.checksInProgress = null;
            this.checkConnectivity = undefined;
            this.supportsAuthHeaders = false;
            this.supportsLinkHeaders = false;
            this._getHosts = getHosts;
            this.options = options || {};
            var connectivityCheckUrl = this.options.connectivityCheckUrl || defaults_1.default.connectivityCheckUrl;
            var connectivityCheckParams = this.options.connectivityCheckParams;
            var connectivityUrlIsDefault = !this.options.connectivityCheckUrl;
            if (platform_1.default.Config.xhrSupported) {
                this.supportsAuthHeaders = true;
                this.Request = function (method, rest, uri, headers, params, body, callback) {
                    var req = xhrrequest_1.default.createRequest(uri, headers, params, body, XHRStates_1.default.REQ_SEND, rest && rest.options.timeouts, method);
                    req.once('complete', callback);
                    req.exec();
                    return req;
                };
                if (this.options.disableConnectivityCheck) {
                    this.checkConnectivity = function (callback) {
                        callback(null, true);
                    };
                }
                else {
                    this.checkConnectivity = function (callback) {
                        logger_1.default.logAction(logger_1.default.LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Sending; ' + connectivityCheckUrl);
                        this.doUri(HttpMethods_1.default.Get, null, connectivityCheckUrl, null, null, connectivityCheckParams, function (err, responseText, headers, unpacked, statusCode) {
                            var result = false;
                            if (!connectivityUrlIsDefault) {
                                result = !err && (0, HttpStatusCodes_1.isSuccessCode)(statusCode);
                            }
                            else {
                                result = !err && (responseText === null || responseText === void 0 ? void 0 : responseText.replace(/\n/, '')) == 'yes';
                            }
                            logger_1.default.logAction(logger_1.default.LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Result: ' + result);
                            callback(null, result);
                        });
                    };
                }
            }
            else if (platform_1.default.Config.jsonpSupported) {
                this.Request = function (method, rest, uri, headers, params, body, callback) {
                    var req = (0, jsonptransport_1.createRequest)(uri, headers, params, body, XHRStates_1.default.REQ_SEND, rest && rest.options.timeouts, method);
                    req.once('complete', callback);
                    platform_1.default.Config.nextTick(function () {
                        req.exec();
                    });
                    return req;
                };
                if (this.options.disableConnectivityCheck) {
                    this.checkConnectivity = function (callback) {
                        callback(null, true);
                    };
                }
                else {
                    this.checkConnectivity = function (callback) {
                        var _this = this;
                        var upUrl = defaults_1.default.jsonpInternetUpUrl;
                        if (this.checksInProgress) {
                            this.checksInProgress.push(callback);
                            return;
                        }
                        this.checksInProgress = [callback];
                        logger_1.default.logAction(logger_1.default.LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Sending; ' + upUrl);
                        var req = new jsonptransport_1.Request('isTheInternetUp', upUrl, null, null, null, XHRStates_1.default.REQ_SEND, defaults_1.default.TIMEOUTS);
                        req.once('complete', function (err, response) {
                            var result = !err && response;
                            logger_1.default.logAction(logger_1.default.LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Result: ' + result);
                            for (var i = 0; i < _this.checksInProgress.length; i++)
                                _this.checksInProgress[i](null, result);
                            _this.checksInProgress = null;
                        });
                        platform_1.default.Config.nextTick(function () {
                            req.exec();
                        });
                    };
                }
            }
            else if (platform_1.default.Config.fetchSupported) {
                this.supportsAuthHeaders = true;
                this.Request = fetchrequest_1.default;
                this.checkConnectivity = function (callback) {
                    logger_1.default.logAction(logger_1.default.LOG_MICRO, '(Fetch)Http.checkConnectivity()', 'Sending; ' + connectivityCheckUrl);
                    this.doUri(HttpMethods_1.default.Get, null, connectivityCheckUrl, null, null, null, function (err, responseText) {
                        var result = !err && (responseText === null || responseText === void 0 ? void 0 : responseText.replace(/\n/, '')) == 'yes';
                        logger_1.default.logAction(logger_1.default.LOG_MICRO, '(Fetch)Http.checkConnectivity()', 'Result: ' + result);
                        callback(null, result);
                    });
                };
            }
            else {
                this.Request = function (method, rest, uri, headers, params, body, callback) {
                    callback(new errorinfo_1.PartialErrorInfo('no supported HTTP transports available', null, 400), null);
                };
            }
        }
        /* Unlike for doUri, the 'rest' param here is mandatory, as it's used to generate the hosts */
        class_1.prototype.do = function (method, rest, path, headers, body, params, callback) {
            var _this = this;
            var uriFromHost = typeof path == 'function'
                ? path
                : function (host) {
                    return rest.baseUri(host) + path;
                };
            var currentFallback = rest._currentFallback;
            if (currentFallback) {
                if (currentFallback.validUntil > Utils.now()) {
                    /* Use stored fallback */
                    if (!this.Request) {
                        callback === null || callback === void 0 ? void 0 : callback(new errorinfo_1.PartialErrorInfo('Request invoked before assigned to', null, 500));
                        return;
                    }
                    this.Request(method, rest, uriFromHost(currentFallback.host), headers, params, body, function (err) {
                        var args = [];
                        for (var _i = 1; _i < arguments.length; _i++) {
                            args[_i - 1] = arguments[_i];
                        }
                        // This typecast is safe because ErrnoExceptions are only thrown in NodeJS
                        if (err && shouldFallback(err)) {
                            /* unstore the fallback and start from the top with the default sequence */
                            rest._currentFallback = null;
                            _this.do(method, rest, path, headers, body, params, callback);
                            return;
                        }
                        callback === null || callback === void 0 ? void 0 : callback.apply(void 0, tslib_1.__spreadArray([err], args, false));
                    });
                    return;
                }
                else {
                    /* Fallback expired; remove it and fallthrough to normal sequence */
                    rest._currentFallback = null;
                }
            }
            var hosts = getHosts(rest);
            /* if there is only one host do it */
            if (hosts.length === 1) {
                this.doUri(method, rest, uriFromHost(hosts[0]), headers, body, params, callback);
                return;
            }
            /* hosts is an array with preferred host plus at least one fallback */
            var tryAHost = function (candidateHosts, persistOnSuccess) {
                var host = candidateHosts.shift();
                _this.doUri(method, rest, uriFromHost(host), headers, body, params, function (err) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    // This typecast is safe because ErrnoExceptions are only thrown in NodeJS
                    if (err && shouldFallback(err) && candidateHosts.length) {
                        tryAHost(candidateHosts, true);
                        return;
                    }
                    if (persistOnSuccess) {
                        /* RSC15f */
                        rest._currentFallback = {
                            host: host,
                            validUntil: Utils.now() + rest.options.timeouts.fallbackRetryTimeout,
                        };
                    }
                    callback === null || callback === void 0 ? void 0 : callback.apply(void 0, tslib_1.__spreadArray([err], args, false));
                });
            };
            tryAHost(hosts);
        };
        class_1.prototype.doUri = function (method, rest, uri, headers, body, params, callback) {
            if (!this.Request) {
                callback(new errorinfo_1.PartialErrorInfo('Request invoked before assigned to', null, 500));
                return;
            }
            this.Request(method, rest, uri, headers, params, body, callback);
        };
        return class_1;
    }()),
    _a.methods = [HttpMethods_1.default.Get, HttpMethods_1.default.Delete, HttpMethods_1.default.Post, HttpMethods_1.default.Put, HttpMethods_1.default.Patch],
    _a.methodsWithoutBody = [HttpMethods_1.default.Get, HttpMethods_1.default.Delete],
    _a.methodsWithBody = [HttpMethods_1.default.Post, HttpMethods_1.default.Put, HttpMethods_1.default.Patch],
    _a);
exports.default = Http;


/***/ }),
/* 63 */
/***/ (function(module, exports, __nested_webpack_require_605278__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_605278__(0);
var errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_605278__(4));
var platform_1 = tslib_1.__importDefault(__nested_webpack_require_605278__(3));
var defaults_1 = tslib_1.__importDefault(__nested_webpack_require_605278__(8));
var Utils = tslib_1.__importStar(__nested_webpack_require_605278__(1));
var utils_1 = __nested_webpack_require_605278__(1);
function isAblyError(responseBody, headers) {
    return !!headers.get('x-ably-errorcode');
}
function getAblyError(responseBody, headers) {
    if (isAblyError(responseBody, headers)) {
        return responseBody.error && errorinfo_1.default.fromValues(responseBody.error);
    }
}
function fetchRequest(method, rest, uri, headers, params, body, callback) {
    var fetchHeaders = new Headers(headers || {});
    var _method = method ? method.toUpperCase() : Utils.isEmptyArg(body) ? 'GET' : 'POST';
    var controller = new AbortController();
    var timeout = setTimeout(function () {
        controller.abort();
        callback(new errorinfo_1.PartialErrorInfo('Request timed out', null, 408));
    }, rest ? rest.options.timeouts.httpRequestTimeout : defaults_1.default.TIMEOUTS.httpRequestTimeout);
    var requestInit = {
        method: _method,
        headers: fetchHeaders,
        body: body,
    };
    if (!platform_1.default.Config.isWebworker) {
        requestInit.credentials = fetchHeaders.has('authorization') ? 'include' : 'same-origin';
    }
    (0, utils_1.getGlobalObject)()
        .fetch(uri + '?' + new URLSearchParams(params || {}), requestInit)
        .then(function (res) {
        clearTimeout(timeout);
        var contentType = res.headers.get('Content-Type');
        var prom;
        if (contentType && contentType.indexOf('application/x-msgpack') > -1) {
            prom = res.arrayBuffer();
        }
        else if (contentType && contentType.indexOf('application/json') > -1) {
            prom = res.json();
        }
        else {
            prom = res.text();
        }
        prom.then(function (body) {
            var unpacked = !!contentType && contentType.indexOf('application/x-msgpack') === -1;
            if (!res.ok) {
                var err = getAblyError(body, res.headers) ||
                    new errorinfo_1.PartialErrorInfo('Error response received from server: ' + res.status + ' body was: ' + platform_1.default.Config.inspect(body), null, res.status);
                callback(err, body, res.headers, unpacked, res.status);
            }
            else {
                callback(null, body, res.headers, unpacked, res.status);
            }
        });
    })
        .catch(function (err) {
        clearTimeout(timeout);
        callback(err);
    });
}
exports.default = fetchRequest;


/***/ }),
/* 64 */
/***/ (function(module, exports, __nested_webpack_require_608129__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_608129__(0);
var msgpack_1 = tslib_1.__importDefault(__nested_webpack_require_608129__(41));
var Utils = tslib_1.__importStar(__nested_webpack_require_608129__(1));
// Workaround for salesforce lightning locker compat
var globalObject = Utils.getGlobalObject();
if (typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') {
    console.log("Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm");
}
function allowComet() {
    /* xhr requests from local files are unreliable in some browsers, such as Chrome 65 and higher -- see eg
     * https://stackoverflow.com/questions/49256429/chrome-65-unable-to-make-post-requests-from-local-files-to-flask
     * So if websockets are supported, then just forget about comet transports and use that */
    var loc = globalObject.location;
    return !globalObject.WebSocket || !loc || !loc.origin || loc.origin.indexOf('http') > -1;
}
var userAgent = globalObject.navigator && globalObject.navigator.userAgent.toString();
var currentUrl = globalObject.location && globalObject.location.href;
var Config = {
    agent: 'browser',
    logTimestamps: true,
    userAgent: userAgent,
    currentUrl: currentUrl,
    noUpgrade: userAgent && !!userAgent.match(/MSIE\s8\.0/),
    binaryType: 'arraybuffer',
    WebSocket: globalObject.WebSocket,
    fetchSupported: !!globalObject.fetch,
    xhrSupported: globalObject.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest(),
    jsonpSupported: typeof document !== 'undefined',
    allowComet: allowComet(),
    streamingSupported: true,
    useProtocolHeartbeats: true,
    createHmac: null,
    msgpack: msgpack_1.default,
    supportsBinary: !!globalObject.TextDecoder,
    preferBinary: false,
    ArrayBuffer: globalObject.ArrayBuffer,
    atob: globalObject.atob,
    nextTick: typeof globalObject.setImmediate !== 'undefined'
        ? globalObject.setImmediate.bind(globalObject)
        : function (f) {
            setTimeout(f, 0);
        },
    addEventListener: globalObject.addEventListener,
    inspect: JSON.stringify,
    stringByteSize: function (str) {
        /* str.length will be an underestimate for non-ascii strings. But if we're
         * in a browser too old to support TextDecoder, not much we can do. Better
         * to underestimate, so if we do go over-size, the server will reject the
         * message */
        return (globalObject.TextDecoder && new globalObject.TextEncoder().encode(str).length) || str.length;
    },
    TextEncoder: globalObject.TextEncoder,
    TextDecoder: globalObject.TextDecoder,
    Promise: globalObject.Promise,
    getRandomValues: (function (crypto) {
        if (crypto === undefined) {
            return undefined;
        }
        return function (arr, callback) {
            crypto.getRandomValues(arr);
            if (callback) {
                callback(null);
            }
        };
    })(globalObject.crypto || msCrypto),
};
exports.default = Config;


/***/ }),
/* 65 */
/***/ (function(module, exports, __nested_webpack_require_611284__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_611284__(0);
var Utils = tslib_1.__importStar(__nested_webpack_require_611284__(1));
var test = 'ablyjs-storage-test';
var Webstorage = /** @class */ (function () {
    function Webstorage() {
        /* Even just accessing the session/localStorage object can throw a
         * security exception in some circumstances with some browsers. In
         * others, calling setItem will throw. So have to check in this
         * somewhat roundabout way. (If unsupported or no global object,
         * will throw on accessing a property of undefined) */
        try {
            global.sessionStorage.setItem(test, test);
            global.sessionStorage.removeItem(test);
            this.sessionSupported = true;
        }
        catch (e) {
            this.sessionSupported = false;
        }
        try {
            global.localStorage.setItem(test, test);
            global.localStorage.removeItem(test);
            this.localSupported = true;
        }
        catch (e) {
            this.localSupported = false;
        }
    }
    Webstorage.prototype.get = function (name) {
        return this._get(name, false);
    };
    Webstorage.prototype.getSession = function (name) {
        return this._get(name, true);
    };
    Webstorage.prototype.remove = function (name) {
        return this._remove(name, false);
    };
    Webstorage.prototype.removeSession = function (name) {
        return this._remove(name, true);
    };
    Webstorage.prototype.set = function (name, value, ttl) {
        return this._set(name, value, ttl, false);
    };
    Webstorage.prototype.setSession = function (name, value, ttl) {
        return this._set(name, value, ttl, true);
    };
    Webstorage.prototype._set = function (name, value, ttl, session) {
        var wrappedValue = { value: value };
        if (ttl) {
            wrappedValue.expires = Utils.now() + ttl;
        }
        return this.storageInterface(session).setItem(name, JSON.stringify(wrappedValue));
    };
    Webstorage.prototype._get = function (name, session) {
        if (session && !this.sessionSupported)
            throw new Error('Session Storage not supported');
        if (!session && !this.localSupported)
            throw new Error('Local Storage not supported');
        var rawItem = this.storageInterface(session).getItem(name);
        if (!rawItem)
            return null;
        var wrappedValue = JSON.parse(rawItem);
        if (wrappedValue.expires && wrappedValue.expires < Utils.now()) {
            this.storageInterface(session).removeItem(name);
            return null;
        }
        return wrappedValue.value;
    };
    Webstorage.prototype._remove = function (name, session) {
        return this.storageInterface(session).removeItem(name);
    };
    Webstorage.prototype.storageInterface = function (session) {
        return session ? global.sessionStorage : global.localStorage;
    };
    return Webstorage;
}());
exports.default = new Webstorage();

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_611284__(13)))

/***/ }),
/* 66 */
/***/ (function(module, exports, __nested_webpack_require_614538__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __nested_webpack_require_614538__(0);
var TransportNames_1 = tslib_1.__importDefault(__nested_webpack_require_614538__(67));
var Defaults = {
    connectivityCheckUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up.txt',
    jsonpInternetUpUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up-0-9.js',
    /* Order matters here: the base transport is the leftmost one in the
     * intersection of baseTransportOrder and the transports clientOption that's
     * supported.  This is not quite the same as the preference order -- e.g.
     * xhr_polling is preferred to jsonp, but for browsers that support it we want
     * the base transport to be xhr_polling, not jsonp */
    defaultTransports: [
        TransportNames_1.default.XhrPolling,
        TransportNames_1.default.XhrStreaming,
        TransportNames_1.default.JsonP,
        TransportNames_1.default.WebSocket,
    ],
    baseTransportOrder: [
        TransportNames_1.default.XhrPolling,
        TransportNames_1.default.XhrStreaming,
        TransportNames_1.default.JsonP,
        TransportNames_1.default.WebSocket,
    ],
    transportPreferenceOrder: [
        TransportNames_1.default.JsonP,
        TransportNames_1.default.XhrPolling,
        TransportNames_1.default.XhrStreaming,
        TransportNames_1.default.WebSocket,
    ],
    upgradeTransports: [TransportNames_1.default.XhrStreaming, TransportNames_1.default.WebSocket],
};
exports.default = Defaults;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var TransportNames;
(function (TransportNames) {
    TransportNames["WebSocket"] = "web_socket";
    TransportNames["Comet"] = "comet";
    TransportNames["XhrStreaming"] = "xhr_streaming";
    TransportNames["XhrPolling"] = "xhr_polling";
    TransportNames["JsonP"] = "jsonp";
})(TransportNames || (TransportNames = {}));
exports.default = TransportNames;


/***/ }),
/* 68 */
/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_616665__) {

"use strict";
// ESM COMPAT FLAG
__nested_webpack_require_616665__.r(__nested_webpack_exports__);

// EXTERNAL MODULE: ./src/platform/web/lib/transport/jsonptransport.ts
var jsonptransport = __nested_webpack_require_616665__(29);
var jsonptransport_default = /*#__PURE__*/__nested_webpack_require_616665__.n(jsonptransport);

// EXTERNAL MODULE: ./src/common/lib/util/utils.ts
var utils = __nested_webpack_require_616665__(1);

// EXTERNAL MODULE: ./src/common/platform.ts
var platform = __nested_webpack_require_616665__(3);
var platform_default = /*#__PURE__*/__nested_webpack_require_616665__.n(platform);

// EXTERNAL MODULE: ./src/common/lib/transport/comettransport.ts
var comettransport = __nested_webpack_require_616665__(12);
var comettransport_default = /*#__PURE__*/__nested_webpack_require_616665__.n(comettransport);

// EXTERNAL MODULE: ./src/platform/web/lib/transport/xhrrequest.ts
var xhrrequest = __nested_webpack_require_616665__(16);
var xhrrequest_default = /*#__PURE__*/__nested_webpack_require_616665__.n(xhrrequest);

// CONCATENATED MODULE: ./src/platform/web/lib/transport/xhrpollingtransport.js





var xhrpollingtransport_XHRPollingTransport = function (connectionManager) {
  var shortName = 'xhr_polling';

  function XHRPollingTransport(connectionManager, auth, params) {
    params.stream = false;
    comettransport_default.a.call(this, connectionManager, auth, params);
    this.shortName = shortName;
  }
  utils["inherits"](XHRPollingTransport, comettransport_default.a);

  XHRPollingTransport.isAvailable = function () {
    return platform_default.a.Config.xhrSupported && platform_default.a.Config.allowComet;
  };

  XHRPollingTransport.prototype.toString = function () {
    return 'XHRPollingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
  };

  XHRPollingTransport.prototype.createRequest = function (uri, headers, params, body, requestMode) {
    return xhrrequest_default.a.createRequest(uri, headers, params, body, requestMode, this.timeouts);
  };

  if (typeof connectionManager !== 'undefined' && XHRPollingTransport.isAvailable()) {
    connectionManager.supportedTransports[shortName] = XHRPollingTransport;
  }

  return XHRPollingTransport;
};

/* harmony default export */ var xhrpollingtransport = (xhrpollingtransport_XHRPollingTransport);

// CONCATENATED MODULE: ./src/platform/web/lib/transport/xhrstreamingtransport.js





var xhrstreamingtransport_XHRStreamingTransport = function (connectionManager) {
  var shortName = 'xhr_streaming';

  /* public constructor */
  function XHRStreamingTransport(connectionManager, auth, params) {
    comettransport_default.a.call(this, connectionManager, auth, params);
    this.shortName = shortName;
  }
  utils["inherits"](XHRStreamingTransport, comettransport_default.a);

  XHRStreamingTransport.isAvailable = function () {
    return platform_default.a.Config.xhrSupported && platform_default.a.Config.streamingSupported && platform_default.a.Config.allowComet;
  };

  XHRStreamingTransport.prototype.toString = function () {
    return 'XHRStreamingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
  };

  XHRStreamingTransport.prototype.createRequest = function (uri, headers, params, body, requestMode) {
    return xhrrequest_default.a.createRequest(uri, headers, params, body, requestMode, this.timeouts);
  };

  if (typeof connectionManager !== 'undefined' && XHRStreamingTransport.isAvailable()) {
    connectionManager.supportedTransports[shortName] = XHRStreamingTransport;
  }

  return XHRStreamingTransport;
};

/* harmony default export */ var xhrstreamingtransport = (xhrstreamingtransport_XHRStreamingTransport);

// CONCATENATED MODULE: ./src/platform/web/lib/transport/index.js




/* harmony default export */ var transport = __nested_webpack_exports__["default"] = ([jsonptransport_default.a, xhrpollingtransport, xhrstreamingtransport]);


/***/ })
/******/ ])["default"];
});

/***/ }),

/***/ "./node_modules/ably/promises.js":
/*!***************************************!*\
  !*** ./node_modules/ably/promises.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

function promisifyOptions(options) {
  if (typeof options == 'string') {
    options = options.indexOf(':') == -1 ? { token: options } : { key: options };
  }
  options.promises = true;
  return options;
}

/* Please note that the file imported below is only generated after running
 * the build task. */
// eslint-disable-next-line @typescript-eslint/no-var-requires
var Ably = __webpack_require__(/*! ./build/ably-node */ "./node_modules/ably/build/ably-commonjs.js");

var RestPromise = function (options) {
  return new Ably.Rest(promisifyOptions(options));
};
Object.assign(RestPromise, Ably.Rest);

var RealtimePromise = function (options) {
  return new Ably.Realtime(promisifyOptions(options));
};
Object.assign(RealtimePromise, Ably.Realtime);

module.exports = {
  Rest: RestPromise,
  Realtime: RealtimePromise,
};


/***/ }),

/***/ "./src/controller.js":
/*!***************************!*\
  !*** ./src/controller.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Controller: () => (/* binding */ Controller)
/* harmony export */ });
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./server */ "./src/server.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view */ "./src/view.js");
/* harmony import */ var _untils_random__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./untils/random */ "./src/untils/random.js");




class Controller {
  localState = {
    userID: "",
    userName: "",
    theme: localStorage.getItem("style") ?? "light",
  };

  gameState = {
    roles: {
      player1: "",
      player2: "",
    },
    cellsData: [],
    currentMove: (0,_untils_random__WEBPACK_IMPORTED_MODULE_2__.getRandomInt)(1) === 0 ? "x" : "o",
  };

  async init() {
    this.restoreLocalState();

    _view__WEBPACK_IMPORTED_MODULE_1__.view.setStyle(this.localState.theme);

    _view__WEBPACK_IMPORTED_MODULE_1__.view.onCellPress = (cell) => this.onCellPress(cell);

    _view__WEBPACK_IMPORTED_MODULE_1__.view.themeSwitcher.onclick = () => this.toggleStyle();

    if (!this.localState.userName) {
      const userName = await _view__WEBPACK_IMPORTED_MODULE_1__.view.showUserNameInput();
      const userID = btoa(userName + Date.now() + Math.random());
      this.updateLocalState({ userName, userID });
    }

    _view__WEBPACK_IMPORTED_MODULE_1__.view.changeName = (userName) => this.changeName(userName);

    _view__WEBPACK_IMPORTED_MODULE_1__.view.showMessage("Waiting for opponent...");
    _view__WEBPACK_IMPORTED_MODULE_1__.view.hideRoomNameInput();

    this.generateRoomID();
    await _server__WEBPACK_IMPORTED_MODULE_0__.server.initRoom(this.roomID);

    this.sendUserReady(this.roomID);

    _server__WEBPACK_IMPORTED_MODULE_0__.server.on[_server__WEBPACK_IMPORTED_MODULE_0__.messages.userReady] = (data) => {
      if (data.userID === this.localState.userID) return;
      console.log(_server__WEBPACK_IMPORTED_MODULE_0__.messages.userReady, data);

      _view__WEBPACK_IMPORTED_MODULE_1__.view.showMessage(`${data.userName} joined game`);
      setTimeout(() => _view__WEBPACK_IMPORTED_MODULE_1__.view.hideMessage(), 3000);

      _view__WEBPACK_IMPORTED_MODULE_1__.view.showField();

      this.startGame();
    };

    _server__WEBPACK_IMPORTED_MODULE_0__.server.on[_server__WEBPACK_IMPORTED_MODULE_0__.messages.startGame] = (data) => {
      if (data.userID === this.localState.userID) return;
      console.log(_server__WEBPACK_IMPORTED_MODULE_0__.messages.userReady, data);

      _view__WEBPACK_IMPORTED_MODULE_1__.view.showField();

      _view__WEBPACK_IMPORTED_MODULE_1__.view.showMessage(`${data.userName} joined game`);
      setTimeout(() => _view__WEBPACK_IMPORTED_MODULE_1__.view.hideMessage(), 3000);
    };

    _server__WEBPACK_IMPORTED_MODULE_0__.server.on[_server__WEBPACK_IMPORTED_MODULE_0__.messages.move] = (data) => this.onMove(data);

    // window.addEventListener("beforeunload", async (event) => {
    //   event.returnValue = `Are you sure you want to leave?`;

    //   server.closeConnection();
    // });
  }

  restoreLocalState() {
    const storedState = localStorage.getItem("localState");

    if (!storedState) {
      return;
    }

    this.localState = JSON.parse(storedState);
  }

  saveLocalState() {
    localStorage.setItem("localState", JSON.stringify(this.localState));
  }

  updateLocalState(state) {
    this.localState = {
      ...this.localState,
      ...state,
    };

    this.saveLocalState();
  }

  get roomID() {
    const urlParams = new URLSearchParams(window.location.search);

    return urlParams.get("roomID");
  }

  set roomID(roomID) {
    const urlParams = new URLSearchParams(window.location.search);

    if (urlParams.get("roomID") === roomID) {
      return;
    }

    urlParams.set("roomID", roomID);
    window.location.search = urlParams;
  }

  generateRoomID() {
    if (!this.roomID) {
      this.roomID = this.localState.userID;
    }
  }

  sendUserReady(roomID) {
    _server__WEBPACK_IMPORTED_MODULE_0__.server.message(_server__WEBPACK_IMPORTED_MODULE_0__.messages.userReady, {
      userID: this.localState.userID,
      userName: this.localState.userName,
    });
  }



  startGame() {
    _server__WEBPACK_IMPORTED_MODULE_0__.server.message(_server__WEBPACK_IMPORTED_MODULE_0__.messages.startGame, {
      userID: this.localState.userID,
      userName: this.localState.userName,
    });

    this.resetGame();

    _view__WEBPACK_IMPORTED_MODULE_1__.view.setTurn(this.step);
  }

  toggleStyle() {
    const theme = this.localState.theme === "light" ? "dark" : "light";
    _view__WEBPACK_IMPORTED_MODULE_1__.view.setStyle(theme);
    this.updateLocalState({ theme });
  }

  resetGame() {
    this.gameState.cellsData = new Array(9).fill("empty");
    _view__WEBPACK_IMPORTED_MODULE_1__.view.clearCells();
    _view__WEBPACK_IMPORTED_MODULE_1__.view.setTurn(this.step);
  }

  onMove(data) {
    console.log("onMove", data);
    this.step = data.step;
    this.cell = _view__WEBPACK_IMPORTED_MODULE_1__.view.cells[data.cell];
    this.gameState.cellsData[data.cell] = this.step;

    _view__WEBPACK_IMPORTED_MODULE_1__.view.updateCell(_view__WEBPACK_IMPORTED_MODULE_1__.view.cells[data.cell], this.step);
    _view__WEBPACK_IMPORTED_MODULE_1__.view.setTurn(this.step);

    this.switchStep();
    _view__WEBPACK_IMPORTED_MODULE_1__.view.setTurn(this.step);

    this.checkDraw();
    this.checkWin();
  }

  onUserConnected(message) {
    const data = JSON.parse(message.data);

    // TODO: show user message: "${friendNam} joined game"
    console.log(data.name);

    this.gameState.opponentName = data.name;

    // veiw.showMessage(`${data.name} joined game`);

    // this.assignUserRoles();
  }

  // TODO: call this method when user enter name and press OK
  changeName(name) {
    this.gameState.currentUserName = name;

    _server__WEBPACK_IMPORTED_MODULE_0__.server.changeName({
      name: name,
    });
  }

  switchStep() {
    this.step = this.step === "x" ? "o" : "x";
    console.log("switchStep", this.step);
  }

  onCellPress(cell) {
    console.log("onCellPress", this.step);

    if (this.gameState.cellsData[_view__WEBPACK_IMPORTED_MODULE_1__.view.cells.indexOf(cell)] !== "empty") {
      return;
    }

    _server__WEBPACK_IMPORTED_MODULE_0__.server.message(_server__WEBPACK_IMPORTED_MODULE_0__.messages.move, {
      cell: _view__WEBPACK_IMPORTED_MODULE_1__.view.cells.indexOf(cell),
      step: this.step,
    });
  }

  checkWin() {
    const winner = this.getWinner();

    if (!winner) {
      return;
    }

    _view__WEBPACK_IMPORTED_MODULE_1__.view.setWin();
    _view__WEBPACK_IMPORTED_MODULE_1__.view.setComment(this.step);
    _view__WEBPACK_IMPORTED_MODULE_1__.view.setWinText(winner);
    this.gameState.cellsData.fill("full");

    setTimeout(() => this.resetGame(), 5000);
    console.log(`winner: ${winner}`);
  }

  getWinner() {
    if (this.checkWinningPositions("x")) {
      return "x";
    }

    if (this.checkWinningPositions("o")) {
      return "o";
    }

    return null;
  }

  checkWinningPositions(winningMark) {
    let winningPositions = [
      [0, 1, 2],
      [3, 4, 5],
      [6, 7, 8],
      [0, 3, 6],
      [1, 4, 7],
      [2, 5, 8],
      [0, 4, 8],
      [2, 4, 6],
    ];

    for (let i = 0; i < winningPositions.length; i++) {
      const [pos1, pos2, pos3] = winningPositions[i];

      if (
        this.gameState.cellsData[pos1] === winningMark &&
        this.gameState.cellsData[pos2] === winningMark &&
        this.gameState.cellsData[pos3] === winningMark
      ) {
        return true;
      }
    }

    return false;
  }

  checkDraw() {
    for (let i = 0; i < this.gameState.cellsData.length; i++) {
      if (
        this.gameState.cellsData[i] !== "x" &&
        this.gameState.cellsData[i] !== "o"
      ) {
        return false;
      }
    }
    console.log("DRAW");

    _view__WEBPACK_IMPORTED_MODULE_1__.view.setDraw();
    _view__WEBPACK_IMPORTED_MODULE_1__.view.setComment(this.step);

    setTimeout(() => this.resetGame(), 5000);
  }
}


/***/ }),

/***/ "./src/server.js":
/*!***********************!*\
  !*** ./src/server.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   messages: () => (/* binding */ messages),
/* harmony export */   server: () => (/* binding */ server)
/* harmony export */ });
/* harmony import */ var ably_promises__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ably/promises */ "./node_modules/ably/promises.js");
/* harmony import */ var ably_promises__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ably_promises__WEBPACK_IMPORTED_MODULE_0__);


const API_KEY = "Z9oq-w.SeC0sA:RWchQVoe5OW6HCx_ogk-pRt_g2qoBkzE3huhxdsSI_A";

const messages = {
  userReady: "userReady",
  startGame: "startGame",
  move: "move",
};

class Server {
  roomState = {
    users: new Map(),
  };

  on = {
    [messages.userReady]: () => {},
  };

  async connect() {
    // For the full code sample see here: https://github.com/ably/quickstart-js
    const server = new (ably_promises__WEBPACK_IMPORTED_MODULE_0___default().Realtime).Promise(API_KEY);

    await server.connection.once("connected");

    return server;
  }

  async initRoom(channelName) {
    const server = await this.connect();

    this.channel = server.channels.get(channelName);

    console.log("Connected to room " + channelName);

    this.subscribeToMessages();
  }

  subscribeToMessages() {
    for (const message in messages) {
      this.on[message] = () => {};

      this.channel.subscribe(message, (data) => {
        const parsedData = JSON.parse(data.data);
        this.on[message](parsedData);

        const { users } = this.roomState;

        switch (message) {
          case messages.userReady:
          case messages.startGame:
            users.set(parsedData.userID, parsedData.userName);
            break;
        }
      });
    }
  }

  async message(messageType, data) {
    await this.channel.publish(messageType, JSON.stringify(data));
  }

  closeConnection() {
    ably_promises__WEBPACK_IMPORTED_MODULE_0___default().close();
  }
}

const server = new Server();



/***/ }),

/***/ "./src/untils/htmlHelpers.js":
/*!***********************************!*\
  !*** ./src/untils/htmlHelpers.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createButton: () => (/* binding */ createButton),
/* harmony export */   createDiv: () => (/* binding */ createDiv),
/* harmony export */   createHTMLElement: () => (/* binding */ createHTMLElement),
/* harmony export */   createInput: () => (/* binding */ createInput)
/* harmony export */ });
function createDiv(className) {
  return createHTMLElement("div", className);
}

function createButton(text, className) {
  const button = createHTMLElement("button", className);

  button.innerHTML = text;

  return button;
}

function createInput(placeholder, className, value) {
  const input = createHTMLElement("input", className);

  if (placeholder) input.placeholder = placeholder;
  if (value) input.value = value;

  return input;
}

function createHTMLElement(tagName, className) {
  const element = document.createElement(tagName);
  element.className = className;

  return element;
}

/***/ }),

/***/ "./src/untils/random.js":
/*!******************************!*\
  !*** ./src/untils/random.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getRandomInt: () => (/* binding */ getRandomInt)
/* harmony export */ });
function getRandomInt(max) {
    return Math.floor(Math.random() * max);
}

/***/ }),

/***/ "./src/view.js":
/*!*********************!*\
  !*** ./src/view.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   View: () => (/* binding */ View),
/* harmony export */   view: () => (/* binding */ view)
/* harmony export */ });
/* harmony import */ var _untils_htmlHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./untils/htmlHelpers */ "./src/untils/htmlHelpers.js");

class View {
  cells = [];

  constructor() {
    this.parent = document.getElementById("parent");

    this.ticTacToeDiv = (0,_untils_htmlHelpers__WEBPACK_IMPORTED_MODULE_0__.createDiv)("tictactoeDiv");
    this.parent.appendChild(this.ticTacToeDiv);

    this.themeSwitcher = (0,_untils_htmlHelpers__WEBPACK_IMPORTED_MODULE_0__.createButton)("", "buttonTopic");
    this.parent.appendChild(this.themeSwitcher);

    const playerDiv = (0,_untils_htmlHelpers__WEBPACK_IMPORTED_MODULE_0__.createDiv)("playerDiv");
    this.ticTacToeDiv.appendChild(playerDiv);

    this.turnPointer = (0,_untils_htmlHelpers__WEBPACK_IMPORTED_MODULE_0__.createDiv)("player");
    playerDiv.appendChild(this.turnPointer);

    this.comments = (0,_untils_htmlHelpers__WEBPACK_IMPORTED_MODULE_0__.createDiv)("playerP");
    playerDiv.appendChild(this.comments);

    const cellDiv = (0,_untils_htmlHelpers__WEBPACK_IMPORTED_MODULE_0__.createDiv)("cellDiv");
    this.ticTacToeDiv.appendChild(cellDiv);

    this.createUserNameInput();
    this.createMessageDiv();
    this.createErrorDiv();

    this.createCells(cellDiv);

    this.hideField();
  }
  
  createErrorDiv() {
    this.errorMessage = (0,_untils_htmlHelpers__WEBPACK_IMPORTED_MODULE_0__.createDiv)("errorMessage");
    this.errorMessage.style.display = "none";
    this.parent.appendChild(this.errorMessage);
  }
  
  createMessageDiv() {
    this.message = (0,_untils_htmlHelpers__WEBPACK_IMPORTED_MODULE_0__.createDiv)("message");
    this.message.style.display = "none";
    this.parent.appendChild(this.message);
  }

  createUserNameInput() {
    this.userNameInputDiv = (0,_untils_htmlHelpers__WEBPACK_IMPORTED_MODULE_0__.createDiv)("roomNameInputDiv");
    this.parent.appendChild(this.userNameInputDiv);

    this.userNameInput = (0,_untils_htmlHelpers__WEBPACK_IMPORTED_MODULE_0__.createInput)("Enter your name", "nameInput");
    this.userNameInputDiv.appendChild(this.userNameInput);

    this.userNameInputEnter = (0,_untils_htmlHelpers__WEBPACK_IMPORTED_MODULE_0__.createButton)("Enter room", "nameInputEnter");
    this.userNameInputDiv.appendChild(this.userNameInputEnter);
  }

  createCells(cellsDiv) {
    for (let cellNum = 0; cellNum < 9; cellNum++) {
      const cell = (0,_untils_htmlHelpers__WEBPACK_IMPORTED_MODULE_0__.createButton)("", "cell full");

      cell.onclick = () => this.onCellPress(cell);

      cellsDiv.appendChild(cell);

      this.cells.push(cell);
    }
  }

  showMessage(message) {
    console.log(message);
  }

  setTurn(turn) {
    if (turn === "x") {
      this.turnPointer.innerHTML = "X Turn";
    } else if (turn === "o") {
      this.turnPointer.innerHTML = "O Turn";
    }
  }

  setComment(turn) {
    if (turn === "x") {
      this.comments.innerHTML = "Next turn X";
    } else if (turn === "o") {
      this.comments.innerHTML = "Next turn O";
    }
  }

  setWinText(winSymbol) {
    if (winSymbol === "x") {
      this.turnPointer.innerHTML = "X Won!";
    } else if (winSymbol === "o") {
      this.turnPointer.innerHTML = "O Won!";
    }
  }

  setStyle(style) {
    if (style === "dark") {
      this.parent.classList.add("dark");
    } else if (style === "light") {
      this.parent.classList.remove("dark");
    }
  }

  updateCell(cell, step) {
    if (step === "x") {
      cell.classList.add("x", "empty", "stepX");
      cell.classList.remove("full");
    } else if (step === "o") {
      cell.classList.add("o", "empty", "stepO");
      cell.classList.remove("cellWait", "full");
    }
  }

  setWin() {
    this.parent.classList.add("win");
  }

  setDraw() {
    this.turnPointer.innerHTML = "Draw!";
    this.parent.classList.add("draw");
  }

  clearCells() {
    for (const cell of this.cells) {
      cell.classList.add("full");
      cell.classList.remove("o", "x", "stepX", "stepO", "empty");
    }

    this.parent.classList.remove("win", "draw");
    this.comments.innerHTML = "";

    console.log("clear");
  }

  showUserNameInput(userName) {
    return new Promise((resolve) => {
      if (userName) {
        view.userNameInput.value = userName;
      }

      this.userNameInputEnter.onclick = () => {
        if (view.userNameInput.value === "") {
          this.showError("Please enter your name");
        } else {
          changeName(userName);
          resolve(view.userNameInput.value);
        }
      };
    });
  }



  showError(message) {
    this.hideMessage();
    this.errorMessage.innerHTML = message;
    this.errorMessage.style.display = "block";
    setTimeout(() => this.hideError(), 3000);
  }

  

  showMessage(message) {
    this.hideError();
    this.message.innerHTML = message;
    this.message.style.display = "block";
  }

  hideError() {
    this.errorMessage.style.display = "none";
  }

  hideMessage() {
    this.message.style.display = "none";
  }

  hideField() {
    this.ticTacToeDiv.classList.add("displayNone");
  }

  hideRoomNameInput() {
    this.userNameInputDiv.style.display = "none";
    this.ticTacToeDiv.style.display = "block";
  }

  showField() {
    this.ticTacToeDiv.style.display = "block";
  }
}

const view = new View();


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./controller */ "./src/controller.js");


new _controller__WEBPACK_IMPORTED_MODULE_0__.Controller().init();

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELG1CQUFtQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlEQUFpRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxxQ0FBcUM7QUFDNUYsbURBQW1ELHFDQUFxQztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLFlBQVksZ0NBQW1COztBQUUzRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRDtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQsY0FBYyxnQ0FBbUI7QUFDakMseUNBQXlDLGdDQUFtQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLDRCQUE0QixZQUFZLGdDQUFtQjs7QUFFM0QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsK0NBQStDLGFBQWE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBEOztBQUVBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0EsY0FBYyxnQ0FBbUI7QUFDakMseUNBQXlDLGdDQUFtQjtBQUM1RCxpQ0FBaUMsZ0NBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBELENBQUM7QUFDRCxLQUFLLElBQUk7QUFDVDtBQUNBLHFDQUFxQyxnQ0FBbUI7QUFDeEQ7QUFDQSxNQUFNLEVBQUU7QUFDUixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QiwwQkFBMEI7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRCwrQ0FBK0M7QUFDL0MsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBTSxFQUFFO0FBQ1IsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQW1CO0FBQ3pDLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLFlBQVk7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQztBQUNELDRCQUE0QixZQUFZLGdDQUFtQjs7QUFFM0QsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQ7O0FBRUEsK0NBQStDLGFBQWE7QUFDNUQsY0FBYyxnQ0FBbUI7QUFDakMsaUNBQWlDLGdDQUFtQjtBQUNwRCx1Q0FBdUMsZ0NBQW1CO0FBQzFELHlDQUF5QyxnQ0FBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUlBQWlJO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywrQ0FBK0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix5Q0FBeUMsdUNBQXVDO0FBQ2hGLDBDQUEwQztBQUMxQztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBEOztBQUVBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0EsY0FBYyxnQ0FBbUI7QUFDakMseUNBQXlDLGdDQUFtQjtBQUM1RCxpQ0FBaUMsZ0NBQW1CO0FBQ3BELHVDQUF1QyxnQ0FBbUI7QUFDMUQsMENBQTBDLGdDQUFtQjtBQUM3RCxxQkFBcUIsZ0NBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsaUJBQWlCLElBQUk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYyxLQUFLLCtDQUErQyxZQUFZO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGdCQUFnQixpREFBaUQ7QUFDL0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQSwyUkFBMlI7QUFDM1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBEOztBQUVBLCtDQUErQyxhQUFhO0FBQzVELGNBQWMsZ0NBQW1CO0FBQ2pDLHlDQUF5QyxnQ0FBbUI7QUFDNUQsdUNBQXVDLGdDQUFtQjtBQUMxRCwwQ0FBMEMsZ0NBQW1CO0FBQzdELGlDQUFpQyxnQ0FBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFh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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLDRCQUE0QixZQUFZLGlDQUFtQjs7QUFFM0QsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7O0FBRUEsK0NBQStDLGFBQWE7QUFDNUQsY0FBYyxpQ0FBbUI7QUFDakMsdUNBQXVDLGlDQUFtQjtBQUMxRCxpQ0FBaUMsaUNBQW1CO0FBQ3BELDRDQUE0QyxpQ0FBbUI7QUFDL0QsMENBQTBDLGlDQUFtQjtBQUM3RCw0Q0FBNEMsaUNBQW1CO0FBQy9ELG1CQUFtQixpQ0FBbUI7QUFDdEMsNENBQTRDLGlDQUFtQjtBQUMvRCxnREFBZ0QsaUNBQW1CO0FBQ25FLHlDQUF5QyxpQ0FBbUI7QUFDNUQseUNBQXlDLGlDQUFtQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SCxhQUFhO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCLDZGQUE2RjtBQUNuSCxzQkFBc0IsNkZBQTZGO0FBQ25I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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSTtBQUNwSTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrTEFBa0w7QUFDbEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlMQUFpTDtBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNEQUFzRDtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJKQUEySjtBQUMzSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MscUJBQXFCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw4QkFBOEI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNIQUFzSDtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGdCQUFnQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGdCQUFnQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDRDQUE0QztBQUNyRztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsNkRBQTZELDJEQUEyRDtBQUN4SCxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLHNDQUFzQztBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLGlEQUFpRCwrQ0FBK0M7QUFDaEcsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLG9DQUFvQztBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwwQ0FBMEM7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esa0hBQWtIO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSEFBbUg7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SDtBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpS0FBaUs7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBb0g7QUFDcEgsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLDZEQUE2RCwyREFBMkQ7QUFDeEgsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsaURBQWlELCtDQUErQztBQUNoRyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SUFBeUk7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVJQUF1STtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0lBQXdJO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOztBQUVBLCtDQUErQyxhQUFhO0FBQzVELGNBQWMsaUNBQW1CO0FBQ2pDLGdCQUFnQixpQ0FBbUI7QUFDbkMsaUJBQWlCLGlDQUFtQjtBQUNwQyxtQkFBbUIsaUNBQW1CO0FBQ3RDLGdEQUFnRCxpQ0FBbUI7QUFDbkUseUNBQXlDLGlDQUFtQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyx3Q0FBd0M7QUFDeEMscUNBQXFDO0FBQ3JDLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMscUNBQXFDO0FBQ3JDO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBELENBQUM7QUFDRCxLQUFLLElBQUk7QUFDVDtBQUNBLHFDQUFxQyxpQ0FBbUI7QUFDeEQ7QUFDQSxNQUFNLEVBQUU7QUFDUixDQUFDOztBQUVEOztBQUVBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0Esd0JBQXdCLDBCQUFtQixFQUFFLGlDQUFtQjs7QUFFaEU7QUFDQSxpQ0FBbUIsR0FBRywwQkFBbUI7QUFDekMsd0ZBQXdGLGlDQUFtQjtBQUMzRyw2R0FBNkcsaUNBQW1CO0FBQ2hJLG1GQUFtRixpQ0FBbUI7QUFDdEcsd0dBQXdHLGlDQUFtQjtBQUMzSCx3RUFBd0UsaUNBQW1CO0FBQzNGLDZGQUE2RixpQ0FBbUI7QUFDaEgsZ0ZBQWdGLGlDQUFtQjtBQUNuRyxxR0FBcUcsaUNBQW1CO0FBQ3hILG1GQUFtRixpQ0FBbUI7QUFDdEcsd0dBQXdHLGlDQUFtQjs7Ozs7OztBQU8zSDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsZ0NBQWdDO0FBQ2hDLHFDQUFxQztBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSDtBQUNwSDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9KQUFvSixTQUFTO0FBQzdKO0FBQ0E7QUFDQSxpREFBaUQsVUFBVTtBQUMzRCxTQUFTO0FBQ1QsUUFBUTtBQUNSLHFEQUFxRCxhQUFhO0FBQ2xFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTixpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSx3SUFBd0ksYUFBYTtBQUNySjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMElBQTBJLFFBQVE7QUFDbEo7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUlBQW1JLFFBQVE7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCLDBCQUFtQjs7O0FBR2hELE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBELENBQUM7QUFDRCxLQUFLLElBQUk7QUFDVDtBQUNBLHFDQUFxQyxpQ0FBbUI7QUFDeEQ7QUFDQSxNQUFNLEVBQUU7QUFDUixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsb0JBQW9CO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0I7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxDQUFDO0FBQ0QsS0FBSyxJQUFJO0FBQ1Q7QUFDQSxxQ0FBcUMsaUNBQW1CLEtBQUssaUNBQW1CO0FBQ2hGO0FBQ0EsTUFBTSxFQUFFO0FBQ1IsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdCQUF3QjtBQUNsRTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxDQUFDO0FBQ0QsS0FBSyxJQUFJO0FBQ1Q7QUFDQSxxQ0FBcUMsaUNBQW1CLEtBQUssaUNBQW1CLE1BQU0saUNBQW1CLE1BQU0saUNBQW1CLE1BQU0saUNBQW1CO0FBQzNKO0FBQ0EsTUFBTSxFQUFFO0FBQ1IsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxDQUFDO0FBQ0QsS0FBSyxJQUFJO0FBQ1Q7QUFDQSxxQ0FBcUMsaUNBQW1CO0FBQ3hEO0FBQ0EsTUFBTSxFQUFFO0FBQ1IsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Es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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087Ozs7Ozs7VUNoTVA7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGlDQUFpQyxXQUFXO1dBQzVDO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7Ozs7Ozs7Ozs7QUNOMEM7QUFDMUM7QUFDQSxJQUFJLG1EQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGljdHRhYy10b2UvLi9ub2RlX21vZHVsZXMvYWJseS9idWlsZC9hYmx5LWNvbW1vbmpzLmpzIiwid2VicGFjazovL3RpY3R0YWMtdG9lLy4vbm9kZV9tb2R1bGVzL2FibHkvcHJvbWlzZXMuanMiLCJ3ZWJwYWNrOi8vdGljdHRhYy10b2UvLi9zcmMvY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly90aWN0dGFjLXRvZS8uL3NyYy9zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vdGljdHRhYy10b2UvLi9zcmMvdW50aWxzL2h0bWxIZWxwZXJzLmpzIiwid2VicGFjazovL3RpY3R0YWMtdG9lLy4vc3JjL3VudGlscy9yYW5kb20uanMiLCJ3ZWJwYWNrOi8vdGljdHRhYy10b2UvLi9zcmMvdmlldy5qcyIsIndlYnBhY2s6Ly90aWN0dGFjLXRvZS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly90aWN0dGFjLXRvZS93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly90aWN0dGFjLXRvZS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vdGljdHRhYy10b2Uvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly90aWN0dGFjLXRvZS93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3RpY3R0YWMtdG9lLy4vc3JjL21haW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAxNS0yMDIyIEFibHkgUmVhbC10aW1lIEx0ZCAoYWJseS5jb20pXG4gKiBcbiAqIEFibHkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYxLjIuNDNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5L2FibHktanNcbiAqIFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbmNlIHYyLjBcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiQWJseVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJBYmx5XCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDQyKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19leHRlbmRzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19leHRlbmRzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2Fzc2lnblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fYXNzaWduOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX3Jlc3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX3Jlc3Q7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZGVjb3JhdGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2RlY29yYXRlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX3BhcmFtXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19wYXJhbTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19tZXRhZGF0YVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fbWV0YWRhdGE7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fYXdhaXRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fYXdhaXRlcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19nZW5lcmF0b3JcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2dlbmVyYXRvcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19jcmVhdGVCaW5kaW5nXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19jcmVhdGVCaW5kaW5nOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2V4cG9ydFN0YXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2V4cG9ydFN0YXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fdmFsdWVzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX192YWx1ZXM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fcmVhZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fcmVhZDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19zcHJlYWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX3NwcmVhZDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19zcHJlYWRBcnJheXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX3NwcmVhZEFycmF5czsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19zcHJlYWRBcnJheVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fc3ByZWFkQXJyYXk7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fYXdhaXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2F3YWl0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2FzeW5jR2VuZXJhdG9yXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19hc3luY0dlbmVyYXRvcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19hc3luY0RlbGVnYXRvclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fYXN5bmNEZWxlZ2F0b3I7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fYXN5bmNWYWx1ZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2FzeW5jVmFsdWVzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX21ha2VUZW1wbGF0ZU9iamVjdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fbWFrZVRlbXBsYXRlT2JqZWN0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2ltcG9ydFN0YXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2ltcG9ydFN0YXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9faW1wb3J0RGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9faW1wb3J0RGVmYXVsdDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19jbGFzc1ByaXZhdGVGaWVsZEdldFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fY2xhc3NQcml2YXRlRmllbGRTZXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0OyB9KTtcbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWxsVG9VcHBlckNhc2UgPSBleHBvcnRzLmFsbFRvTG93ZXJDYXNlID0gZXhwb3J0cy5lbmNvZGVCb2R5ID0gZXhwb3J0cy5kZWNvZGVCb2R5ID0gZXhwb3J0cy5Gb3JtYXQgPSBleHBvcnRzLnByb21pc2lmeSA9IGV4cG9ydHMudHJpbSA9IGV4cG9ydHMuYXJyQ2hvb3NlTiA9IGV4cG9ydHMucmFuZG9tSGV4U3RyaW5nID0gZXhwb3J0cy5yYW5kb21TdHJpbmcgPSBleHBvcnRzLmNoZWFwUmFuZFN0ciA9IGV4cG9ydHMuZGF0YVNpemVCeXRlcyA9IGV4cG9ydHMuaW5zcGVjdEJvZHkgPSBleHBvcnRzLmluc3BlY3RFcnJvciA9IGV4cG9ydHMuaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm8gPSBleHBvcnRzLm5vdyA9IGV4cG9ydHMucGFyc2VRdWVyeVN0cmluZyA9IGV4cG9ydHMudG9RdWVyeVN0cmluZyA9IGV4cG9ydHMuYXJyUG9wUmFuZG9tRWxlbWVudCA9IGV4cG9ydHMuZGVmYXVsdFBvc3RIZWFkZXJzID0gZXhwb3J0cy5kZWZhdWx0R2V0SGVhZGVycyA9IGV4cG9ydHMuYWxsU2FtZSA9IGV4cG9ydHMuYXJyRXZlcnkgPSBleHBvcnRzLmFyckZpbHRlciA9IGV4cG9ydHMuYXJyTWFwID0gZXhwb3J0cy5zYWZlQXJyRm9yRWFjaCA9IGV4cG9ydHMuYXJyRm9yRWFjaCA9IGV4cG9ydHMuZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllcyA9IGV4cG9ydHMudmFsdWVzQXJyYXkgPSBleHBvcnRzLmtleXNBcnJheSA9IGV4cG9ydHMuYXJyV2l0aG91dFZhbHVlID0gZXhwb3J0cy5hcnJEZWxldGVWYWx1ZSA9IGV4cG9ydHMuYXJySW4gPSBleHBvcnRzLmFyckluZGV4T2YgPSBleHBvcnRzLmFyclN1YnRyYWN0ID0gZXhwb3J0cy5hcnJJbnRlcnNlY3RPYiA9IGV4cG9ydHMuYXJySW50ZXJzZWN0ID0gZXhwb3J0cy5pbnRlcnNlY3QgPSBleHBvcnRzLmNvbnRhaW5zVmFsdWUgPSBleHBvcnRzLmluaGVyaXRzID0gZXhwb3J0cy5wcm90b3R5cGljYWxDbG9uZSA9IGV4cG9ydHMuc2hhbGxvd0Nsb25lID0gZXhwb3J0cy5pc0VtcHR5QXJnID0gZXhwb3J0cy5pc09ubHlQcm9wSW4gPSBleHBvcnRzLmlzRW1wdHkgPSBleHBvcnRzLmlzT2JqZWN0ID0gZXhwb3J0cy5lbnN1cmVBcnJheSA9IGV4cG9ydHMuaXNBcnJheSA9IGV4cG9ydHMuY29weSA9IGV4cG9ydHMubWl4aW4gPSB2b2lkIDA7XG5leHBvcnRzLnRvQmFzZTY0ID0gZXhwb3J0cy5tYXRjaERlcml2ZWRDaGFubmVsID0gZXhwb3J0cy5zaGFsbG93RXF1YWxzID0gZXhwb3J0cy5nZXRHbG9iYWxPYmplY3QgPSBleHBvcnRzLmdldFJldHJ5VGltZSA9IGV4cG9ydHMuZ2V0Sml0dGVyQ29lZmZpY2llbnQgPSBleHBvcnRzLmdldEJhY2tvZmZDb2VmZmljaWVudCA9IHZvaWQgMDtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgZGVmYXVsdHNfMSA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oOCkpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgZW5jX2Jhc2U2NF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG52YXIgZW5jX3V0ZjhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuZnVuY3Rpb24gcmFuZG9tUG9zbihhcnJPclN0cikge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhcnJPclN0ci5sZW5ndGgpO1xufVxuLypcbiAqIEFkZCBhIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGEgdGFyZ2V0IG9iamVjdFxuICogdGFyZ2V0OiB0aGUgdGFyZ2V0IG9iamVjdFxuICogcHJvcHM6ICBhbiBvYmplY3Qgd2hvc2UgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZVxuICogICAgICAgICBhZGRlZCwgYnkgcmVmZXJlbmNlIG9ubHlcbiAqL1xuZnVuY3Rpb24gbWl4aW4odGFyZ2V0KSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3NbaV07XG4gICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5IHx8IGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZXhwb3J0cy5taXhpbiA9IG1peGluO1xuLypcbiAqIEFkZCBhIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGEgdGFyZ2V0IG9iamVjdFxuICogdGFyZ2V0OiB0aGUgdGFyZ2V0IG9iamVjdFxuICogcHJvcHM6ICBhbiBvYmplY3Qgd2hvc2UgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZVxuICogICAgICAgICBhZGRlZCwgYnkgcmVmZXJlbmNlIG9ubHlcbiAqL1xuZnVuY3Rpb24gY29weShzcmMpIHtcbiAgICByZXR1cm4gbWl4aW4oe30sIHNyYyk7XG59XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuLypcbiAqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhIGdpdmVuIG9iamVjdCBpc1xuICogYW4gYXJyYXkuXG4gKi9cbmV4cG9ydHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHxcbiAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuLypcbiAqIEVuc3VyZXMgdGhhdCBhbiBBcnJheSBvYmplY3QgaXMgYWx3YXlzIHJldHVybmVkXG4gKiByZXR1cm5pbmcgdGhlIG9yaWdpbmFsIEFycmF5IG9mIG9iaiBpcyBhbiBBcnJheVxuICogZWxzZSB3cmFwcGluZyB0aGUgb2JqIGluIGEgc2luZ2xlIGVsZW1lbnQgQXJyYXlcbiAqL1xuZnVuY3Rpb24gZW5zdXJlQXJyYXkob2JqKSB7XG4gICAgaWYgKGlzRW1wdHlBcmcob2JqKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICgoMCwgZXhwb3J0cy5pc0FycmF5KShvYmopKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHJldHVybiBbb2JqXTtcbn1cbmV4cG9ydHMuZW5zdXJlQXJyYXkgPSBlbnN1cmVBcnJheTtcbmZ1bmN0aW9uIGlzT2JqZWN0KG9iKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYikgPT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4vKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBjb250YWluc1xuICogYW55IGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqIG9iOiB0aGUgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkob2IpIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzRW1wdHkgPSBpc0VtcHR5O1xuZnVuY3Rpb24gaXNPbmx5UHJvcEluKG9iLCBwcm9wZXJ0eSkge1xuICAgIGZvciAodmFyIHByb3AgaW4gb2IpIHtcbiAgICAgICAgaWYgKHByb3AgIT09IHByb3BlcnR5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzT25seVByb3BJbiA9IGlzT25seVByb3BJbjtcbi8qXG4gKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYW4gYXJndW1lbnQgdG8gYW4gb3ZlcmxvYWRlZCBmdW5jdGlvbiBpc1xuICogdW5kZWZpbmVkIChtaXNzaW5nKSBvciBudWxsLlxuICogVGhpcyBtZXRob2QgaXMgdXNlZnVsIHdoZW4gY29uc3RydWN0aW5nIGZ1bmN0aW9ucyBzdWNoIGFzIChXZWJJREwgdGVybWlub2xvZ3kpOlxuICogICBvZmYoW1RyZWF0VW5kZWZpbmVkQXM9TnVsbF0gRE9NU3RyaW5nPyBldmVudClcbiAqIGFzIHlvdSBjYW4gdGhlbiBjb25maXJtIHRoZSBhcmd1bWVudCB1c2luZzpcbiAqICAgVXRpbHMuaXNFbXB0eUFyZyhldmVudClcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eUFyZyhhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsIHx8IGFyZyA9PT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5pc0VtcHR5QXJnID0gaXNFbXB0eUFyZztcbi8qXG4gKiBQZXJmb3JtIGEgc2ltcGxlIHNoYWxsb3cgY2xvbmUgb2YgYW4gb2JqZWN0LlxuICogUmVzdWx0IGlzIGFuIG9iamVjdCBpcnJlc3BlY3RpdmUgb2Ygd2hldGhlclxuICogdGhlIGlucHV0IGlzIGFuIG9iamVjdCBvciBhcnJheS4gQWxsXG4gKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGNvcGllZC5cbiAqIG9iOiB0aGUgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dDbG9uZShvYikge1xuICAgIHZhciByZXN1bHQgPSBuZXcgT2JqZWN0KCk7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYilcbiAgICAgICAgcmVzdWx0W3Byb3BdID0gb2JbcHJvcF07XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuc2hhbGxvd0Nsb25lID0gc2hhbGxvd0Nsb25lO1xuLypcbiAqIENsb25lIGFuIG9iamVjdCBieSBjcmVhdGluZyBhIG5ldyBvYmplY3Qgd2l0aCB0aGVcbiAqIGdpdmVuIG9iamVjdCBhcyBpdHMgcHJvdG90eXBlLiBPcHRpb25hbGx5XG4gKiBhIHNldCBvZiBhZGRpdGlvbmFsIG93biBwcm9wZXJ0aWVzIGNhbiBiZVxuICogc3VwcGxpZWQgdG8gYmUgYWRkZWQgdG8gdGhlIG5ld2x5IGNyZWF0ZWQgY2xvbmUuXG4gKiBvYjogICAgICAgICAgICB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZFxuICogb3duUHJvcGVydGllczogb3B0aW9uYWwgb2JqZWN0IHdpdGggYWRkaXRpb25hbFxuICogICAgICAgICAgICAgICAgcHJvcGVydGllcyB0byBhZGRcbiAqL1xuZnVuY3Rpb24gcHJvdG90eXBpY2FsQ2xvbmUob2IsIG93blByb3BlcnRpZXMpIHtcbiAgICB2YXIgRiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRigpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRjtcbiAgICB9KCkpO1xuICAgIEYucHJvdG90eXBlID0gb2I7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBGKCk7XG4gICAgaWYgKG93blByb3BlcnRpZXMpXG4gICAgICAgIG1peGluKHJlc3VsdCwgb3duUHJvcGVydGllcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucHJvdG90eXBpY2FsQ2xvbmUgPSBwcm90b3R5cGljYWxDbG9uZTtcbi8qXG4gKiBEZWNsYXJlIGEgY29uc3RydWN0b3IgdG8gcmVwcmVzZW50IGEgc3ViY2xhc3NcbiAqIG9mIGFub3RoZXIgY29uc3RydWN0b3JcbiAqIElmIHBsYXRmb3JtIGhhcyBhIGJ1aWx0LWluIHZlcnNpb24gd2UgdXNlIHRoYXQgZnJvbSBQbGF0Zm9ybSwgZWxzZSB3ZVxuICogZGVmaW5lIGhlcmUgKHNvIGNhbiBtYWtlIHVzZSBvZiBvdGhlciBVdGlscyBmbnMpXG4gKiBTZWUgbm9kZS5qcyB1dGlsLmluaGVyaXRzXG4gKi9cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uIChjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAocGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbmhlcml0cykge1xuICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBwcm90b3R5cGljYWxDbG9uZShzdXBlckN0b3IucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiBjdG9yIH0pO1xufTtcbmV4cG9ydHMuaW5oZXJpdHMgPSBpbmhlcml0cztcbi8qXG4gKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGhhcyBhbiBlbnVtZXJhYmxlXG4gKiBwcm9wZXJ0eSB3aG9zZSB2YWx1ZSBlcXVhbHMgYSBnaXZlbiB2YWx1ZS5cbiAqIG9iOiAgdGhlIG9iamVjdFxuICogdmFsOiB0aGUgdmFsdWUgdG8gZmluZFxuICovXG5mdW5jdGlvbiBjb250YWluc1ZhbHVlKG9iLCB2YWwpIHtcbiAgICBmb3IgKHZhciBpIGluIG9iKSB7XG4gICAgICAgIGlmIChvYltpXSA9PSB2YWwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5jb250YWluc1ZhbHVlID0gY29udGFpbnNWYWx1ZTtcbmZ1bmN0aW9uIGludGVyc2VjdChhcnIsIG9iKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmlzQXJyYXkpKG9iKSA/IGFyckludGVyc2VjdChhcnIsIG9iKSA6IGFyckludGVyc2VjdE9iKGFyciwgb2IpO1xufVxuZXhwb3J0cy5pbnRlcnNlY3QgPSBpbnRlcnNlY3Q7XG5mdW5jdGlvbiBhcnJJbnRlcnNlY3QoYXJyMSwgYXJyMikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycjEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG1lbWJlciA9IGFycjFbaV07XG4gICAgICAgIGlmICgoMCwgZXhwb3J0cy5hcnJJbmRleE9mKShhcnIyLCBtZW1iZXIpICE9IC0xKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobWVtYmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuYXJySW50ZXJzZWN0ID0gYXJySW50ZXJzZWN0O1xuZnVuY3Rpb24gYXJySW50ZXJzZWN0T2IoYXJyLCBvYikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbWVtYmVyID0gYXJyW2ldO1xuICAgICAgICBpZiAobWVtYmVyIGluIG9iKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobWVtYmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuYXJySW50ZXJzZWN0T2IgPSBhcnJJbnRlcnNlY3RPYjtcbmZ1bmN0aW9uIGFyclN1YnRyYWN0KGFycjEsIGFycjIpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gYXJyMVtpXTtcbiAgICAgICAgaWYgKCgwLCBleHBvcnRzLmFyckluZGV4T2YpKGFycjIsIGVsZW1lbnQpID09IC0xKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmFyclN1YnRyYWN0ID0gYXJyU3VidHJhY3Q7XG5leHBvcnRzLmFyckluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZlxuICAgID8gZnVuY3Rpb24gKGFyciwgZWxlbSwgZnJvbUluZGV4KSB7XG4gICAgICAgIHJldHVybiBhcnIuaW5kZXhPZihlbGVtLCBmcm9tSW5kZXgpO1xuICAgIH1cbiAgICA6IGZ1bmN0aW9uIChhcnIsIGVsZW0sIGZyb21JbmRleCkge1xuICAgICAgICBmcm9tSW5kZXggPSBmcm9tSW5kZXggfHwgMDtcbiAgICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIGZvciAoOyBmcm9tSW5kZXggPCBsZW47IGZyb21JbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2Zyb21JbmRleF0gPT09IGVsZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuZnVuY3Rpb24gYXJySW4oYXJyLCB2YWwpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuYXJySW5kZXhPZikoYXJyLCB2YWwpICE9PSAtMTtcbn1cbmV4cG9ydHMuYXJySW4gPSBhcnJJbjtcbmZ1bmN0aW9uIGFyckRlbGV0ZVZhbHVlKGFyciwgdmFsKSB7XG4gICAgdmFyIGlkeCA9ICgwLCBleHBvcnRzLmFyckluZGV4T2YpKGFyciwgdmFsKTtcbiAgICB2YXIgcmVzID0gaWR4ICE9IC0xO1xuICAgIGlmIChyZXMpXG4gICAgICAgIGFyci5zcGxpY2UoaWR4LCAxKTtcbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5hcnJEZWxldGVWYWx1ZSA9IGFyckRlbGV0ZVZhbHVlO1xuZnVuY3Rpb24gYXJyV2l0aG91dFZhbHVlKGFyciwgdmFsKSB7XG4gICAgdmFyIG5ld0FyciA9IGFyci5zbGljZSgpO1xuICAgIGFyckRlbGV0ZVZhbHVlKG5ld0FyciwgdmFsKTtcbiAgICByZXR1cm4gbmV3QXJyO1xufVxuZXhwb3J0cy5hcnJXaXRob3V0VmFsdWUgPSBhcnJXaXRob3V0VmFsdWU7XG4vKlxuICogQ29uc3RydWN0IGFuIGFycmF5IG9mIHRoZSBrZXlzIG9mIHRoZSBlbnVtZXJhYmxlXG4gKiBwcm9wZXJ0aWVzIG9mIGEgZ2l2ZW4gb2JqZWN0LCBvcHRpb25hbGx5IGxpbWl0ZWRcbiAqIHRvIG9ubHkgdGhlIG93biBwcm9wZXJ0aWVzLlxuICogb2I6ICAgICAgdGhlIG9iamVjdFxuICogb3duT25seTogYm9vbGVhbiwgZ2V0IG93biBwcm9wZXJ0aWVzIG9ubHlcbiAqL1xuZnVuY3Rpb24ga2V5c0FycmF5KG9iLCBvd25Pbmx5KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIHByb3AgaW4gb2IpIHtcbiAgICAgICAgaWYgKG93bk9ubHkgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYiwgcHJvcCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmVzdWx0LnB1c2gocHJvcCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmtleXNBcnJheSA9IGtleXNBcnJheTtcbi8qXG4gKiBDb25zdHJ1Y3QgYW4gYXJyYXkgb2YgdGhlIHZhbHVlcyBvZiB0aGUgZW51bWVyYWJsZVxuICogcHJvcGVydGllcyBvZiBhIGdpdmVuIG9iamVjdCwgb3B0aW9uYWxseSBsaW1pdGVkXG4gKiB0byBvbmx5IHRoZSBvd24gcHJvcGVydGllcy5cbiAqIG9iOiAgICAgIHRoZSBvYmplY3RcbiAqIG93bk9ubHk6IGJvb2xlYW4sIGdldCBvd24gcHJvcGVydGllcyBvbmx5XG4gKi9cbmZ1bmN0aW9uIHZhbHVlc0FycmF5KG9iLCBvd25Pbmx5KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIHByb3AgaW4gb2IpIHtcbiAgICAgICAgaWYgKG93bk9ubHkgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYiwgcHJvcCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmVzdWx0LnB1c2gob2JbcHJvcF0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy52YWx1ZXNBcnJheSA9IHZhbHVlc0FycmF5O1xuZnVuY3Rpb24gZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllcyhvYiwgZm4pIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2IsIHByb3ApICYmIG9iW3Byb3BdKSB7XG4gICAgICAgICAgICBmbihwcm9wKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllcyA9IGZvckluT3duTm9uTnVsbFByb3BlcnRpZXM7XG5leHBvcnRzLmFyckZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaFxuICAgID8gZnVuY3Rpb24gKGFyciwgZm4pIHtcbiAgICAgICAgYXJyLmZvckVhY2goZm4pO1xuICAgIH1cbiAgICA6IGZ1bmN0aW9uIChhcnIsIGZuKSB7XG4gICAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBmbihhcnJbaV0sIGksIGFycik7XG4gICAgICAgIH1cbiAgICB9O1xuLyogVXNlZnVsIHdoZW4gdGhlIGZ1bmN0aW9uIG1heSBtdXRhdGUgdGhlIGFycmF5ICovXG5mdW5jdGlvbiBzYWZlQXJyRm9yRWFjaChhcnIsIGZuKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmFyckZvckVhY2gpKGFyci5zbGljZSgpLCBmbik7XG59XG5leHBvcnRzLnNhZmVBcnJGb3JFYWNoID0gc2FmZUFyckZvckVhY2g7XG5leHBvcnRzLmFyck1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXBcbiAgICA/IGZ1bmN0aW9uIChhcnIsIGZuKSB7XG4gICAgICAgIHJldHVybiBhcnIubWFwKGZuKTtcbiAgICB9XG4gICAgOiBmdW5jdGlvbiAoYXJyLCBmbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChmbihhcnJbaV0sIGksIGFycikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbmV4cG9ydHMuYXJyRmlsdGVyID0gQXJyYXkucHJvdG90eXBlLmZpbHRlclxuICAgID8gZnVuY3Rpb24gKGFyciwgZm4pIHtcbiAgICAgICAgcmV0dXJuIGFyci5maWx0ZXIoZm4pO1xuICAgIH1cbiAgICA6IGZ1bmN0aW9uIChhcnIsIGZuKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXSwgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGZuKGFycltpXSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhcnJbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbmV4cG9ydHMuYXJyRXZlcnkgPSBBcnJheS5wcm90b3R5cGUuZXZlcnlcbiAgICA/IGZ1bmN0aW9uIChhcnIsIGZuKSB7XG4gICAgICAgIHJldHVybiBhcnIuZXZlcnkoZm4pO1xuICAgIH1cbiAgICA6IGZ1bmN0aW9uIChhcnIsIGZuKSB7XG4gICAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWZuKGFycltpXSwgaSwgYXJyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuZnVuY3Rpb24gYWxsU2FtZShhcnIsIHByb3ApIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGZpcnN0ID0gYXJyWzBdW3Byb3BdO1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5hcnJFdmVyeSkoYXJyLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbVtwcm9wXSA9PT0gZmlyc3Q7XG4gICAgfSk7XG59XG5leHBvcnRzLmFsbFNhbWUgPSBhbGxTYW1lO1xudmFyIGNvbnRlbnRUeXBlcyA9IHtcbiAgICBqc29uOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAganNvbnA6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyxcbiAgICB4bWw6ICdhcHBsaWNhdGlvbi94bWwnLFxuICAgIGh0bWw6ICd0ZXh0L2h0bWwnLFxuICAgIG1zZ3BhY2s6ICdhcHBsaWNhdGlvbi94LW1zZ3BhY2snLFxufTtcbmZ1bmN0aW9uIGRlZmF1bHRHZXRIZWFkZXJzKG9wdGlvbnMsIGZvcm1hdCkge1xuICAgIHZhciBhY2NlcHQgPSBjb250ZW50VHlwZXNbZm9ybWF0IHx8IEZvcm1hdC5qc29uXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhY2NlcHQ6IGFjY2VwdCxcbiAgICAgICAgJ1gtQWJseS1WZXJzaW9uJzogZGVmYXVsdHNfMS5kZWZhdWx0LnByb3RvY29sVmVyc2lvbi50b1N0cmluZygpLFxuICAgICAgICAnQWJseS1BZ2VudCc6ICgwLCBkZWZhdWx0c18xLmdldEFnZW50U3RyaW5nKShvcHRpb25zKSxcbiAgICB9O1xufVxuZXhwb3J0cy5kZWZhdWx0R2V0SGVhZGVycyA9IGRlZmF1bHRHZXRIZWFkZXJzO1xuZnVuY3Rpb24gZGVmYXVsdFBvc3RIZWFkZXJzKG9wdGlvbnMsIGZvcm1hdCkge1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB2YXIgYWNjZXB0ID0gKGNvbnRlbnRUeXBlID0gY29udGVudFR5cGVzW2Zvcm1hdCB8fCBGb3JtYXQuanNvbl0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFjY2VwdDogYWNjZXB0LFxuICAgICAgICAnY29udGVudC10eXBlJzogY29udGVudFR5cGUsXG4gICAgICAgICdYLUFibHktVmVyc2lvbic6IGRlZmF1bHRzXzEuZGVmYXVsdC5wcm90b2NvbFZlcnNpb24udG9TdHJpbmcoKSxcbiAgICAgICAgJ0FibHktQWdlbnQnOiAoMCwgZGVmYXVsdHNfMS5nZXRBZ2VudFN0cmluZykob3B0aW9ucyksXG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdFBvc3RIZWFkZXJzID0gZGVmYXVsdFBvc3RIZWFkZXJzO1xuZnVuY3Rpb24gYXJyUG9wUmFuZG9tRWxlbWVudChhcnIpIHtcbiAgICByZXR1cm4gYXJyLnNwbGljZShyYW5kb21Qb3NuKGFyciksIDEpWzBdO1xufVxuZXhwb3J0cy5hcnJQb3BSYW5kb21FbGVtZW50ID0gYXJyUG9wUmFuZG9tRWxlbWVudDtcbmZ1bmN0aW9uIHRvUXVlcnlTdHJpbmcocGFyYW1zKSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcGFyYW1zKVxuICAgICAgICAgICAgcGFydHMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNba2V5XSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHMubGVuZ3RoID8gJz8nICsgcGFydHMuam9pbignJicpIDogJyc7XG59XG5leHBvcnRzLnRvUXVlcnlTdHJpbmcgPSB0b1F1ZXJ5U3RyaW5nO1xuZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZyhxdWVyeSkge1xuICAgIHZhciBtYXRjaDtcbiAgICB2YXIgc2VhcmNoID0gLyhbXj8mPV0rKT0/KFteJl0qKS9nO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB3aGlsZSAoKG1hdGNoID0gc2VhcmNoLmV4ZWMocXVlcnkpKSlcbiAgICAgICAgcmVzdWx0W2RlY29kZVVSSUNvbXBvbmVudChtYXRjaFsxXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzJdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5wYXJzZVF1ZXJ5U3RyaW5nID0gcGFyc2VRdWVyeVN0cmluZztcbmV4cG9ydHMubm93ID0gRGF0ZS5ub3cgfHxcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIElFIDggKi9cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG5mdW5jdGlvbiBpc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbyhlcnIpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBlcnIgPT0gJ29iamVjdCcgJiZcbiAgICAgICAgZXJyICE9PSBudWxsICYmXG4gICAgICAgIChlcnIuY29uc3RydWN0b3IubmFtZSA9PSAnRXJyb3JJbmZvJyB8fCBlcnIuY29uc3RydWN0b3IubmFtZSA9PSAnUGFydGlhbEVycm9ySW5mbycpKTtcbn1cbmV4cG9ydHMuaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm8gPSBpc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbztcbmZ1bmN0aW9uIGluc3BlY3RFcnJvcihlcnIpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciB8fFxuICAgICAgICAoKF9hID0gZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgPT09ICdFcnJvckluZm8nIHx8XG4gICAgICAgICgoX2IgPSBlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uYW1lKSA9PT0gJ1BhcnRpYWxFcnJvckluZm8nKVxuICAgICAgICByZXR1cm4gZXJyLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChlcnIpO1xufVxuZXhwb3J0cy5pbnNwZWN0RXJyb3IgPSBpbnNwZWN0RXJyb3I7XG5mdW5jdGlvbiBpbnNwZWN0Qm9keShib2R5KSB7XG4gICAgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5pc0J1ZmZlcihib2R5KSkge1xuICAgICAgICByZXR1cm4gYm9keS50b1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KGJvZHkpO1xuICAgIH1cbn1cbmV4cG9ydHMuaW5zcGVjdEJvZHkgPSBpbnNwZWN0Qm9keTtcbi8qIERhdGEgaXMgYXNzdW1lZCB0byBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBidWZmZXIuICovXG5mdW5jdGlvbiBkYXRhU2l6ZUJ5dGVzKGRhdGEpIHtcbiAgICBpZiAocGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5zdHJpbmdCeXRlU2l6ZShkYXRhKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnB1dCBvZiBVdGlscy5kYXRhU2l6ZUJ5dGVzIHRvIGJlIGEgYnVmZmVyIG9yIHN0cmluZywgYnV0IHdhczogJyArIHR5cGVvZiBkYXRhKTtcbn1cbmV4cG9ydHMuZGF0YVNpemVCeXRlcyA9IGRhdGFTaXplQnl0ZXM7XG5mdW5jdGlvbiBjaGVhcFJhbmRTdHIoKSB7XG4gICAgcmV0dXJuIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zdWJzdHIoMik7XG59XG5leHBvcnRzLmNoZWFwUmFuZFN0ciA9IGNoZWFwUmFuZFN0cjtcbi8qIFRha2VzIHBhcmFtIHRoZSBtaW5pbXVtIG51bWJlciBvZiBieXRlcyBvZiBlbnRyb3B5IHRoZSBzdHJpbmcgbXVzdFxuICogaW5jbHVkZSwgbm90IHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZy4gU3RyaW5nIGxlbmd0aCBwcm9kdWNlZCBpcyBub3RcbiAqIGd1YXJhbnRlZWQuICovXG52YXIgcmFuZG9tU3RyaW5nID0gZnVuY3Rpb24gKG51bUJ5dGVzKSB7XG4gICAgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuZ2V0UmFuZG9tVmFsdWVzICYmIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgdUludEFyciA9IG5ldyBVaW50OEFycmF5KG51bUJ5dGVzKTtcbiAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5nZXRSYW5kb21WYWx1ZXModUludEFycik7XG4gICAgICAgIHJldHVybiBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKHVJbnRBcnIpO1xuICAgIH1cbiAgICAvKiBPbGQgYnJvd3NlcjsgZmFsbCBiYWNrIHRvIE1hdGgucmFuZG9tLiBDb3VsZCBqdXN0IHVzZSBhXG4gICAgICogQ3J5cHRvSlMgdmVyc2lvbiBvZiB0aGUgYWJvdmUsIGJ1dCB3YW50IHRoaXMgdG8gc3RpbGwgd29yayBpbiBub2NyeXB0b1xuICAgICAqIHZlcnNpb25zIG9mIHRoZSBsaWJyYXJ5ICovXG4gICAgdmFyIGNoYXJzZXQgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuYmFzZTY0Q2hhclNldDtcbiAgICAvKiBiYXNlNjQgaGFzIDMzJSBvdmVyaGVhZDsgcm91bmQgbGVuZ3RoIHVwICovXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgucm91bmQoKG51bUJ5dGVzICogNCkgLyAzKTtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gY2hhcnNldFtyYW5kb21Qb3NuKGNoYXJzZXQpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLnJhbmRvbVN0cmluZyA9IHJhbmRvbVN0cmluZztcbnZhciByYW5kb21IZXhTdHJpbmcgPSBmdW5jdGlvbiAobnVtQnl0ZXMpIHtcbiAgICBpZiAocGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5nZXRSYW5kb21WYWx1ZXMgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciB1SW50QXJyID0gbmV3IFVpbnQ4QXJyYXkobnVtQnl0ZXMpO1xuICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmdldFJhbmRvbVZhbHVlcyh1SW50QXJyKTtcbiAgICAgICAgcmV0dXJuIHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5oZXhFbmNvZGUodUludEFycik7XG4gICAgfVxuICAgIHZhciBjaGFyc2V0ID0gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmhleENoYXJTZXQ7XG4gICAgdmFyIGxlbmd0aCA9IG51bUJ5dGVzICogMjtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gY2hhcnNldFtyYW5kb21Qb3NuKGNoYXJzZXQpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLnJhbmRvbUhleFN0cmluZyA9IHJhbmRvbUhleFN0cmluZztcbi8qIFBpY2sgbiBlbGVtZW50cyBhdCByYW5kb20gd2l0aG91dCByZXBsYWNlbWVudCBmcm9tIGFuIGFycmF5ICovXG5mdW5jdGlvbiBhcnJDaG9vc2VOKGFyciwgbikge1xuICAgIHZhciBudW1JdGVtcyA9IE1hdGgubWluKG4sIGFyci5sZW5ndGgpLCBtdXRhYmxlQXJyID0gYXJyLnNsaWNlKCksIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtSXRlbXM7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChhcnJQb3BSYW5kb21FbGVtZW50KG11dGFibGVBcnIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuYXJyQ2hvb3NlTiA9IGFyckNob29zZU47XG5leHBvcnRzLnRyaW0gPSBTdHJpbmcucHJvdG90eXBlLnRyaW1cbiAgICA/IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci50cmltKCk7XG4gICAgfVxuICAgIDogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJyk7XG4gICAgfTtcbmZ1bmN0aW9uIHByb21pc2lmeShvYiwgZm5OYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgb2JbZm5OYW1lXS5hcHBseShvYiwgdHNsaWJfMS5fX3NwcmVhZEFycmF5KHRzbGliXzEuX19zcHJlYWRBcnJheShbXSwgYXJncywgZmFsc2UpLCBbZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICAgICAgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICB9XSwgZmFsc2UpKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucHJvbWlzaWZ5ID0gcHJvbWlzaWZ5O1xudmFyIEZvcm1hdDtcbihmdW5jdGlvbiAoRm9ybWF0KSB7XG4gICAgRm9ybWF0W1wibXNncGFja1wiXSA9IFwibXNncGFja1wiO1xuICAgIEZvcm1hdFtcImpzb25cIl0gPSBcImpzb25cIjtcbn0pKEZvcm1hdCA9IGV4cG9ydHMuRm9ybWF0IHx8IChleHBvcnRzLkZvcm1hdCA9IHt9KSk7XG5mdW5jdGlvbiBkZWNvZGVCb2R5KGJvZHksIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXQgPT0gJ21zZ3BhY2snID8gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5tc2dwYWNrLmRlY29kZShib2R5KSA6IEpTT04ucGFyc2UoU3RyaW5nKGJvZHkpKTtcbn1cbmV4cG9ydHMuZGVjb2RlQm9keSA9IGRlY29kZUJvZHk7XG5mdW5jdGlvbiBlbmNvZGVCb2R5KGJvZHksIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXQgPT0gJ21zZ3BhY2snID8gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5tc2dwYWNrLmVuY29kZShib2R5LCB0cnVlKSA6IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xufVxuZXhwb3J0cy5lbmNvZGVCb2R5ID0gZW5jb2RlQm9keTtcbmZ1bmN0aW9uIGFsbFRvTG93ZXJDYXNlKGFycikge1xuICAgIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuYWxsVG9Mb3dlckNhc2UgPSBhbGxUb0xvd2VyQ2FzZTtcbmZ1bmN0aW9uIGFsbFRvVXBwZXJDYXNlKGFycikge1xuICAgIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuYWxsVG9VcHBlckNhc2UgPSBhbGxUb1VwcGVyQ2FzZTtcbmZ1bmN0aW9uIGdldEJhY2tvZmZDb2VmZmljaWVudChjb3VudCkge1xuICAgIHJldHVybiBNYXRoLm1pbigoY291bnQgKyAyKSAvIDMsIDIpO1xufVxuZXhwb3J0cy5nZXRCYWNrb2ZmQ29lZmZpY2llbnQgPSBnZXRCYWNrb2ZmQ29lZmZpY2llbnQ7XG5mdW5jdGlvbiBnZXRKaXR0ZXJDb2VmZmljaWVudCgpIHtcbiAgICByZXR1cm4gMSAtIE1hdGgucmFuZG9tKCkgKiAwLjI7XG59XG5leHBvcnRzLmdldEppdHRlckNvZWZmaWNpZW50ID0gZ2V0Sml0dGVyQ29lZmZpY2llbnQ7XG4vKipcbiAqXG4gKiBAcGFyYW0gaW5pdGlhbFRpbWVvdXQgaW5pdGlhbCB0aW1lb3V0IHZhbHVlXG4gKiBAcGFyYW0gcmV0cnlBdHRlbXB0IGludGVnZXIgaW5kaWNhdGluZyByZXRyeUF0dGVtcHRcbiAqIEByZXR1cm5zIFJldHJ5VGltZW91dCB2YWx1ZSBmb3IgZ2l2ZW4gdGltZW91dCBhbmQgcmV0cnlBdHRlbXB0LlxuICogSWYgeCBpcyB0aGUgdmFsdWUgZ2VuZXJhdGVkIHRoZW4sXG4gKiBVcHBlciBib3VuZCA9IG1pbigocmV0cnlBdHRlbXB0ICsgMikgLyAzLCAyKSAqIGluaXRpYWxUaW1lb3V0LFxuICogTG93ZXIgYm91bmQgPSAwLjggKiBVcHBlciBib3VuZCxcbiAqIExvd2VyIGJvdW5kIDwgeCA8IFVwcGVyIGJvdW5kXG4gKi9cbmZ1bmN0aW9uIGdldFJldHJ5VGltZShpbml0aWFsVGltZW91dCwgcmV0cnlBdHRlbXB0KSB7XG4gICAgcmV0dXJuIGluaXRpYWxUaW1lb3V0ICogZ2V0QmFja29mZkNvZWZmaWNpZW50KHJldHJ5QXR0ZW1wdCkgKiBnZXRKaXR0ZXJDb2VmZmljaWVudCgpO1xufVxuZXhwb3J0cy5nZXRSZXRyeVRpbWUgPSBnZXRSZXRyeVRpbWU7XG5mdW5jdGlvbiBnZXRHbG9iYWxPYmplY3QoKSB7XG4gICAgaWYgKGdsb2JhbCkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5leHBvcnRzLmdldEdsb2JhbE9iamVjdCA9IGdldEdsb2JhbE9iamVjdDtcbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbHMoc291cmNlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gKE9iamVjdC5rZXlzKHNvdXJjZSkuZXZlcnkoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gc291cmNlW2tleV0gPT09IHRhcmdldFtrZXldOyB9KSAmJlxuICAgICAgICBPYmplY3Qua2V5cyh0YXJnZXQpLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHRhcmdldFtrZXldID09PSBzb3VyY2Vba2V5XTsgfSkpO1xufVxuZXhwb3J0cy5zaGFsbG93RXF1YWxzID0gc2hhbGxvd0VxdWFscztcbmZ1bmN0aW9uIG1hdGNoRGVyaXZlZENoYW5uZWwobmFtZSkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgcmVnZXggY2hlY2sgaXMgdG8gcmV0YWluIGV4aXN0aW5nIGNoYW5uZWwgcGFyYW1zIGlmIGFueSBlLmcgWz9yZXdpbmQ9MV1mb28gdG9cbiAgICAgKiBbZmlsdGVyPXh5ej9yZXdpbmQ9MV1mb28uIFRoaXMgaXMgdG8ga2VlcCBjaGFubmVsIGNvbXBhdGliaWxpdHkgYXJvdW5kIHVzZSBvZlxuICAgICAqIGNoYW5uZWwgcGFyYW1zIHRoYXQgd29yayB3aXRoIGRlcml2ZWQgY2hhbm5lbHMuXG4gICAgICpcbiAgICAgKiBUaGlzIGVzbGludCB1bnNhZmUgcmVnZXggd2FybmluZyBpcyB0cmlnZ2VyZWQgYmVjYXVzZSB0aGUgUmVnRXhwIHVzZXMgbmVzdGVkIHF1YW50aWZpZXJzLFxuICAgICAqIGJ1dCBpdCBkb2VzIG5vdCBjcmVhdGUgYW55IHNpdHVhdGlvbiB3aGVyZSB0aGUgcmVnZXggZW5naW5lIGhhcyB0b1xuICAgICAqIGV4cGxvcmUgYSBsYXJnZSBudW1iZXIgb2YgcG9zc2libGUgbWF0Y2hlcyBzbyBpdOKAmXMgc2FmZSB0byBpZ25vcmVcbiAgICAgKi9cbiAgICB2YXIgcmVnZXggPSAvXihcXFsoW14/XSopKD86KC4qKSlcXF0pPyguKykkLzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gocmVnZXgpO1xuICAgIGlmICghbWF0Y2ggfHwgIW1hdGNoLmxlbmd0aCB8fCBtYXRjaC5sZW5ndGggPCA1KSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdyZWdleCBtYXRjaCBmYWlsZWQnLCA0MDAsIDQwMDEwKTtcbiAgICB9XG4gICAgLy8gRmFpbCBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgY2hhbm5lbCBxdWFsaWZpZXIsIGVnIFttZXRhXWZvbyBzaG91bGQgZmFpbCBpbnN0ZWFkIG9mIGp1c3Qgb3ZlcnJpZGluZyB3aXRoIFtmaWx0ZXI9eHl6XWZvb1xuICAgIGlmIChtYXRjaFsyXSkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChcImNhbm5vdCB1c2UgYSBkZXJpdmVkIG9wdGlvbiB3aXRoIGEgXCIuY29uY2F0KG1hdGNoWzJdLCBcIiBjaGFubmVsXCIpLCA0MDAsIDQwMDEwKTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIG1hdGNoIHZhbHVlcyB0byBiZSBhZGRlZCB0byBkZXJpdmUgY2hhbm5lbCBxdWFudGlmaWVyLlxuICAgIHJldHVybiB7XG4gICAgICAgIHF1YWxpZmllclBhcmFtOiBtYXRjaFszXSB8fCAnJyxcbiAgICAgICAgY2hhbm5lbE5hbWU6IG1hdGNoWzRdLFxuICAgIH07XG59XG5leHBvcnRzLm1hdGNoRGVyaXZlZENoYW5uZWwgPSBtYXRjaERlcml2ZWRDaGFubmVsO1xuZnVuY3Rpb24gdG9CYXNlNjQoc3RyKSB7XG4gICAgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuY3JlYXRlSG1hYykge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCAnYXNjaWknKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgZW5jX2Jhc2U2NF8xLnN0cmluZ2lmeSkoKDAsIGVuY191dGY4XzEucGFyc2UpKHN0cikpO1xufVxuZXhwb3J0cy50b0Jhc2U2NCA9IHRvQmFzZTY0O1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxMykpKVxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xuLy8gV29ya2Fyb3VuZCBmb3Igc2FsZXNmb3JjZSBsaWdodG5pbmcgbG9ja2VyIGNvbXBhdGliaWxpdHlcbi8vIFRoaXMgaXMgYSBzaG9ydGhhbmQgdmVyc2lvbiBvZiBVdGlscy5nZXRHbG9iYWxPYmplY3QgKHdoaWNoIHdlIGNhbid0IHVzZSBoZXJlIHdpdGhvdXQgY3JlYXRpbmcgYSBjaXJjdWxhciBpbXBvcnQpXG52YXIgZ2xvYmFsT2JqZWN0ID0gZ2xvYmFsIHx8ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHNlbGYpO1xudmFyIExvZ0xldmVscztcbihmdW5jdGlvbiAoTG9nTGV2ZWxzKSB7XG4gICAgTG9nTGV2ZWxzW0xvZ0xldmVsc1tcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgIExvZ0xldmVsc1tMb2dMZXZlbHNbXCJFcnJvclwiXSA9IDFdID0gXCJFcnJvclwiO1xuICAgIExvZ0xldmVsc1tMb2dMZXZlbHNbXCJNYWpvclwiXSA9IDJdID0gXCJNYWpvclwiO1xuICAgIExvZ0xldmVsc1tMb2dMZXZlbHNbXCJNaW5vclwiXSA9IDNdID0gXCJNaW5vclwiO1xuICAgIExvZ0xldmVsc1tMb2dMZXZlbHNbXCJNaWNyb1wiXSA9IDRdID0gXCJNaWNyb1wiO1xufSkoTG9nTGV2ZWxzIHx8IChMb2dMZXZlbHMgPSB7fSkpO1xuZnVuY3Rpb24gcGFkKHRpbWVTZWdtZW50LCB0aHJlZSkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aW1lU2VnbWVudCkucGFkU3RhcnQodGhyZWUgPyAzIDogMiwgJzAnKTtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZXIobG9nZ2VyKSB7XG4gICAgcmV0dXJuIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubG9nVGltZXN0YW1wc1xuICAgICAgICA/IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgIHZhciB0aW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGxvZ2dlcihwYWQodGltZS5nZXRIb3VycygpKSArXG4gICAgICAgICAgICAgICAgJzonICtcbiAgICAgICAgICAgICAgICBwYWQodGltZS5nZXRNaW51dGVzKCkpICtcbiAgICAgICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgICAgIHBhZCh0aW1lLmdldFNlY29uZHMoKSkgK1xuICAgICAgICAgICAgICAgICcuJyArXG4gICAgICAgICAgICAgICAgcGFkKHRpbWUuZ2V0TWlsbGlzZWNvbmRzKCksIDEpICtcbiAgICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgOiBsb2dnZXI7XG59XG52YXIgZ2V0RGVmYXVsdExvZ2dlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgY29uc29sZUxvZ2dlcjtcbiAgICB2YXIgZXJyb3JMb2dnZXI7XG4gICAgLyogQ2FuJ3QganVzdCBjaGVjayBmb3IgY29uc29sZSAmJiBjb25zb2xlLmxvZzsgZmFpbHMgaW4gSUUgPD05ICovXG4gICAgaWYgKCh0eXBlb2YgV2luZG93ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPT09ICd1bmRlZmluZWQnKSAvKiBub2RlICovIHx8XG4gICAgICAgIHR5cGVvZiAoKF9iID0gKF9hID0gZ2xvYmFsT2JqZWN0ID09PSBudWxsIHx8IGdsb2JhbE9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2xvYmFsT2JqZWN0LmNvbnNvbGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2cpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hcHBseSkgPT09ICdmdW5jdGlvbicgLyogc2Vuc2libGUgYnJvd3NlcnMgKi8pIHtcbiAgICAgICAgY29uc29sZUxvZ2dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBlcnJvckxvZ2dlciA9IGNvbnNvbGUud2FyblxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogY29uc29sZUxvZ2dlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ2xvYmFsT2JqZWN0ID09PSBudWxsIHx8IGdsb2JhbE9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2xvYmFsT2JqZWN0LmNvbnNvbGUubG9nKSB7XG4gICAgICAgIC8qIElFIDw9IDkgd2l0aCB0aGUgY29uc29sZSBvcGVuIC0tIGNvbnNvbGUubG9nIGRvZXMgbm90XG4gICAgICAgICAqIGluaGVyaXQgZnJvbSBGdW5jdGlvbiwgc28gaGFzIG5vIGFwcGx5IG1ldGhvZCAqL1xuICAgICAgICBjb25zb2xlTG9nZ2VyID0gZXJyb3JMb2dnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8qIElFIDw9IDkgd2hlbiBkZXYgdG9vbHMgYXJlIGNsb3NlZCAtIHdpbmRvdy5jb25zb2xlIG5vdCBldmVuIGRlZmluZWQgKi9cbiAgICAgICAgY29uc29sZUxvZ2dlciA9IGVycm9yTG9nZ2VyID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIH1cbiAgICByZXR1cm4gW2NvbnNvbGVMb2dnZXIsIGVycm9yTG9nZ2VyXS5tYXAoZ2V0SGFuZGxlcik7XG59O1xudmFyIExvZ2dlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2dnZXIoKSB7XG4gICAgICAgIExvZ2dlci5sb2dMZXZlbCA9IExvZ2dlci5MT0dfREVGQVVMVDtcbiAgICB9XG4gICAgTG9nZ2VyLmluaXRMb2dIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gZ2V0RGVmYXVsdExvZ2dlcnMoKSwgbG9nSGFuZGxlciA9IF9hWzBdLCBsb2dFcnJvckhhbmRsZXIgPSBfYVsxXTtcbiAgICAgICAgdGhpcy5sb2dIYW5kbGVyID0gbG9nSGFuZGxlcjtcbiAgICAgICAgdGhpcy5sb2dFcnJvckhhbmRsZXIgPSBsb2dFcnJvckhhbmRsZXI7XG4gICAgfTtcbiAgICBMb2dnZXIubG9nTGV2ZWwgPSBMb2dMZXZlbHMuRXJyb3I7IC8vIGRlZmF1bHQgbG9nTGV2ZWxcbiAgICAvLyBwdWJsaWMgY29uc3RhbnRzXG4gICAgTG9nZ2VyLkxPR19OT05FID0gTG9nTGV2ZWxzLk5vbmU7XG4gICAgTG9nZ2VyLkxPR19FUlJPUiA9IExvZ0xldmVscy5FcnJvcjtcbiAgICBMb2dnZXIuTE9HX01BSk9SID0gTG9nTGV2ZWxzLk1ham9yO1xuICAgIExvZ2dlci5MT0dfTUlOT1IgPSBMb2dMZXZlbHMuTWlub3I7XG4gICAgTG9nZ2VyLkxPR19NSUNSTyA9IExvZ0xldmVscy5NaWNybztcbiAgICAvLyBhbGlhc2VzXG4gICAgTG9nZ2VyLkxPR19ERUZBVUxUID0gTG9nTGV2ZWxzLkVycm9yO1xuICAgIExvZ2dlci5MT0dfREVCVUcgPSBMb2dMZXZlbHMuTWljcm87XG4gICAgLyogcHVibGljIHN0YXRpYyBmdW5jdGlvbnMgKi9cbiAgICBMb2dnZXIubG9nQWN0aW9uID0gZnVuY3Rpb24gKGxldmVsLCBhY3Rpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKExvZ2dlci5zaG91bGRMb2cobGV2ZWwpKSB7XG4gICAgICAgICAgICAobGV2ZWwgPT09IExvZ0xldmVscy5FcnJvciA/IExvZ2dlci5sb2dFcnJvckhhbmRsZXIgOiBMb2dnZXIubG9nSGFuZGxlcikoJ0FibHk6ICcgKyBhY3Rpb24gKyAnOiAnICsgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExvZ2dlci5kZXByZWNhdGVkID0gZnVuY3Rpb24gKG9yaWdpbmFsLCByZXBsYWNlbWVudCkge1xuICAgICAgICBMb2dnZXIuZGVwcmVjYXRlZFdpdGhNc2cob3JpZ2luYWwsIFwiUGxlYXNlIHVzZSAnXCIgKyByZXBsYWNlbWVudCArIFwiJyBpbnN0ZWFkLlwiKTtcbiAgICB9O1xuICAgIExvZ2dlci5kZXByZWNhdGVkV2l0aE1zZyA9IGZ1bmN0aW9uIChmdW5jTmFtZSwgbXNnKSB7XG4gICAgICAgIGlmIChMb2dnZXIuc2hvdWxkTG9nKExvZ0xldmVscy5FcnJvcikpIHtcbiAgICAgICAgICAgIExvZ2dlci5sb2dFcnJvckhhbmRsZXIoXCJBYmx5OiBEZXByZWNhdGlvbiB3YXJuaW5nIC0gJ1wiICsgZnVuY05hbWUgKyBcIicgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGZyb20gYSBmdXR1cmUgdmVyc2lvbi4gXCIgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiBXaGVyZSBhIGxvZ2dpbmcgb3BlcmF0aW9uIGlzIGV4cGVuc2l2ZSwgc3VjaCBhcyBzZXJpYWxpc2F0aW9uIG9mIGRhdGEsIHVzZSBzaG91bGRMb2cgd2lsbCBwcmV2ZW50XG4gICAgICAgICB0aGUgb2JqZWN0IGJlaW5nIHNlcmlhbGlzZWQgaWYgdGhlIGxvZyBsZXZlbCB3aWxsIG5vdCBvdXRwdXQgdGhlIG1lc3NhZ2UgKi9cbiAgICBMb2dnZXIuc2hvdWxkTG9nID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgIHJldHVybiBsZXZlbCA8PSBMb2dnZXIubG9nTGV2ZWw7XG4gICAgfTtcbiAgICBMb2dnZXIuc2V0TG9nID0gZnVuY3Rpb24gKGxldmVsLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChsZXZlbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgTG9nZ2VyLmxvZ0xldmVsID0gbGV2ZWw7XG4gICAgICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBMb2dnZXIubG9nSGFuZGxlciA9IExvZ2dlci5sb2dFcnJvckhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIH07XG4gICAgcmV0dXJuIExvZ2dlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBMb2dnZXI7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKSkpXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFBsYXRmb3JtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBsYXRmb3JtKCkge1xuICAgIH1cbiAgICByZXR1cm4gUGxhdGZvcm07XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUGxhdGZvcm07XG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhcnRpYWxFcnJvckluZm8gPSB2b2lkIDA7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG5mdW5jdGlvbiB0b1N0cmluZyhlcnIpIHtcbiAgICB2YXIgcmVzdWx0ID0gJ1snICsgZXJyLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKGVyci5tZXNzYWdlKVxuICAgICAgICByZXN1bHQgKz0gJzogJyArIGVyci5tZXNzYWdlO1xuICAgIGlmIChlcnIuc3RhdHVzQ29kZSlcbiAgICAgICAgcmVzdWx0ICs9ICc7IHN0YXR1c0NvZGU9JyArIGVyci5zdGF0dXNDb2RlO1xuICAgIGlmIChlcnIuY29kZSlcbiAgICAgICAgcmVzdWx0ICs9ICc7IGNvZGU9JyArIGVyci5jb2RlO1xuICAgIGlmIChlcnIuY2F1c2UpXG4gICAgICAgIHJlc3VsdCArPSAnOyBjYXVzZT0nICsgVXRpbHMuaW5zcGVjdEVycm9yKGVyci5jYXVzZSk7XG4gICAgaWYgKGVyci5ocmVmICYmICEoZXJyLm1lc3NhZ2UgJiYgZXJyLm1lc3NhZ2UuaW5kZXhPZignaGVscC5hYmx5LmlvJykgPiAtMSkpXG4gICAgICAgIHJlc3VsdCArPSAnOyBzZWUgJyArIGVyci5ocmVmICsgJyAnO1xuICAgIHJlc3VsdCArPSAnXSc7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBFcnJvckluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRXJyb3JJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVycm9ySW5mbyhtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlLCBjYXVzZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5zZXRQcm90b3R5cGVPZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgRXJyb3JJbmZvLnByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIF90aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICBfdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEVycm9ySW5mby5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZyh0aGlzKTtcbiAgICB9O1xuICAgIEVycm9ySW5mby5mcm9tVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICB2YXIgX2EgPSB2YWx1ZXMsIG1lc3NhZ2UgPSBfYS5tZXNzYWdlLCBjb2RlID0gX2EuY29kZSwgc3RhdHVzQ29kZSA9IF9hLnN0YXR1c0NvZGU7XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGNvZGUgIT09ICdudW1iZXInIHx8IHR5cGVvZiBzdGF0dXNDb2RlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvckluZm8uZnJvbVZhbHVlcygpOiBpbnZhbGlkIHZhbHVlczogJyArIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdCh2YWx1ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3JJbmZvKG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUpLCB2YWx1ZXMpO1xuICAgICAgICBpZiAocmVzdWx0LmNvZGUgJiYgIXJlc3VsdC5ocmVmKSB7XG4gICAgICAgICAgICByZXN1bHQuaHJlZiA9ICdodHRwczovL2hlbHAuYWJseS5pby9lcnJvci8nICsgcmVzdWx0LmNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBFcnJvckluZm87XG59KEVycm9yKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFcnJvckluZm87XG52YXIgUGFydGlhbEVycm9ySW5mbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhQYXJ0aWFsRXJyb3JJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhcnRpYWxFcnJvckluZm8obWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSwgY2F1c2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3Quc2V0UHJvdG90eXBlT2YgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFBhcnRpYWxFcnJvckluZm8ucHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgX3RoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICAgIF90aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUGFydGlhbEVycm9ySW5mby5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZyh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJ0aWFsRXJyb3JJbmZvO1xufShFcnJvcikpO1xuZXhwb3J0cy5QYXJ0aWFsRXJyb3JJbmZvID0gUGFydGlhbEVycm9ySW5mbztcblxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDYpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBDaGVjayBpZiB0eXBlZCBhcnJheXMgYXJlIHN1cHBvcnRlZFxuXHQgICAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cblx0ICAgIC8vIFJlZmVyZW5jZSBvcmlnaW5hbCBpbml0XG5cdCAgICB2YXIgc3VwZXJJbml0ID0gV29yZEFycmF5LmluaXQ7XG5cblx0ICAgIC8vIEF1Z21lbnQgV29yZEFycmF5LmluaXQgdG8gaGFuZGxlIHR5cGVkIGFycmF5c1xuXHQgICAgdmFyIHN1YkluaXQgPSBXb3JkQXJyYXkuaW5pdCA9IGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdCAgICAgICAgLy8gQ29udmVydCBidWZmZXJzIHRvIHVpbnQ4XG5cdCAgICAgICAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHQgICAgICAgICAgICB0eXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gQ29udmVydCBvdGhlciBhcnJheSB2aWV3cyB0byB1aW50OFxuXHQgICAgICAgIGlmIChcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSB8fFxuXHQgICAgICAgICAgICAodHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXlcblx0ICAgICAgICApIHtcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkuYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkuYnl0ZUxlbmd0aCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gSGFuZGxlIFVpbnQ4QXJyYXlcblx0ICAgICAgICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIHR5cGVkQXJyYXlCeXRlTGVuZ3RoID0gdHlwZWRBcnJheS5ieXRlTGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIEV4dHJhY3QgYnl0ZXNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWRBcnJheUJ5dGVMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMl0gfD0gdHlwZWRBcnJheVtpXSA8PCAoMjQgLSAoaSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoaXMgd29yZCBhcnJheVxuXHQgICAgICAgICAgICBzdXBlckluaXQuY2FsbCh0aGlzLCB3b3JkcywgdHlwZWRBcnJheUJ5dGVMZW5ndGgpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIEVsc2UgY2FsbCBub3JtYWwgaW5pdFxuXHQgICAgICAgICAgICBzdXBlckluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBzdWJJbml0LnByb3RvdHlwZSA9IFdvcmRBcnJheTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5saWIuV29yZEFycmF5O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7OyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeSgpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG5cdC8qZ2xvYmFscyB3aW5kb3csIGdsb2JhbCwgcmVxdWlyZSovXG5cblx0LyoqXG5cdCAqIENyeXB0b0pTIGNvcmUgY29tcG9uZW50cy5cblx0ICovXG5cdHZhciBDcnlwdG9KUyA9IENyeXB0b0pTIHx8IChmdW5jdGlvbiAoTWF0aCwgdW5kZWZpbmVkKSB7XG5cblx0ICAgIHZhciBjcnlwdG87XG5cblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gZnJvbSB3aW5kb3cgKEJyb3dzZXIpXG5cdCAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNyeXB0bykge1xuXHQgICAgICAgIGNyeXB0byA9IHdpbmRvdy5jcnlwdG87XG5cdCAgICB9XG5cblx0ICAgIC8vIE5hdGl2ZSAoZXhwZXJpbWVudGFsIElFIDExKSBjcnlwdG8gZnJvbSB3aW5kb3cgKEJyb3dzZXIpXG5cdCAgICBpZiAoIWNyeXB0byAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubXNDcnlwdG8pIHtcblx0ICAgICAgICBjcnlwdG8gPSB3aW5kb3cubXNDcnlwdG87XG5cdCAgICB9XG5cblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gZnJvbSBnbG9iYWwgKE5vZGVKUylcblx0ICAgIGlmICghY3J5cHRvICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5jcnlwdG8pIHtcblx0ICAgICAgICBjcnlwdG8gPSBnbG9iYWwuY3J5cHRvO1xuXHQgICAgfVxuXG5cdCAgICAvLyBOYXRpdmUgY3J5cHRvIGltcG9ydCB2aWEgcmVxdWlyZSAoTm9kZUpTKVxuXHQgICAgaWYgKCFjcnlwdG8gJiYgXCJmdW5jdGlvblwiID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgY3J5cHRvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XG5cdCAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgfVxuXG5cdCAgICAvKlxuXHQgICAgICogQ3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHBzZXVkb3JhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG5cdCAgICAgKlxuXHQgICAgICogQXMgTWF0aC5yYW5kb20oKSBpcyBjcnlwdG9ncmFwaGljYWxseSBub3Qgc2FmZSB0byB1c2Vcblx0ICAgICAqL1xuXHQgICAgdmFyIGNyeXB0b1NlY3VyZVJhbmRvbUludCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoY3J5cHRvKSB7XG5cdCAgICAgICAgICAgIC8vIFVzZSBnZXRSYW5kb21WYWx1ZXMgbWV0aG9kIChCcm93c2VyKVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFVzZSByYW5kb21CeXRlcyBtZXRob2QgKE5vZGVKUylcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8ucmFuZG9tQnl0ZXMgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcyg0KS5yZWFkSW50MzJMRSgpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYXRpdmUgY3J5cHRvIG1vZHVsZSBjb3VsZCBub3QgYmUgdXNlZCB0byBnZXQgc2VjdXJlIHJhbmRvbSBudW1iZXIuJyk7XG5cdCAgICB9O1xuXG5cdCAgICAvKlxuXHQgICAgICogTG9jYWwgcG9seWZpbGwgb2YgT2JqZWN0LmNyZWF0ZVxuXG5cdCAgICAgKi9cblx0ICAgIHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gRigpIHt9XG5cblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICB2YXIgc3VidHlwZTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG9iajtcblxuXHQgICAgICAgICAgICBzdWJ0eXBlID0gbmV3IEYoKTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG51bGw7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSlcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDcnlwdG9KUyBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogTGlicmFyeSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2xpYiA9IEMubGliID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogQmFzZSBvYmplY3QgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZSA9IChmdW5jdGlvbiAoKSB7XG5cblxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdmVycmlkZXMgUHJvcGVydGllcyB0byBjb3B5IGludG8gdGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnLFxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIH1cblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTcGF3blxuXHQgICAgICAgICAgICAgICAgdmFyIHN1YnR5cGUgPSBjcmVhdGUodGhpcyk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEF1Z21lbnRcblx0ICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLm1peEluKG92ZXJyaWRlcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBkZWZhdWx0IGluaXRpYWxpemVyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXN1YnR5cGUuaGFzT3duUHJvcGVydHkoJ2luaXQnKSB8fCB0aGlzLmluaXQgPT09IHN1YnR5cGUuaW5pdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemVyJ3MgcHJvdG90eXBlIGlzIHRoZSBzdWJ0eXBlIG9iamVjdFxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0LnByb3RvdHlwZSA9IHN1YnR5cGU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZSBzdXBlcnR5cGVcblx0ICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyID0gdGhpcztcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEV4dGVuZHMgdGhpcyBvYmplY3QgYW5kIHJ1bnMgdGhlIGluaXQgbWV0aG9kLlxuXHQgICAgICAgICAgICAgKiBBcmd1bWVudHMgdG8gY3JlYXRlKCkgd2lsbCBiZSBwYXNzZWQgdG8gaW5pdCgpLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgaW5zdGFuY2UgPSBNeVR5cGUuY3JlYXRlKCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuZXh0ZW5kKCk7XG5cdCAgICAgICAgICAgICAgICBpbnN0YW5jZS5pbml0LmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBvYmplY3QuXG5cdCAgICAgICAgICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFkZCBzb21lIGxvZ2ljIHdoZW4geW91ciBvYmplY3RzIGFyZSBjcmVhdGVkLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgKiAgICAgICAgICAgICAvLyAuLi5cblx0ICAgICAgICAgICAgICogICAgICAgICB9XG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ29waWVzIHByb3BlcnRpZXMgaW50byB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgVGhlIHByb3BlcnRpZXMgdG8gbWl4IGluLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgTXlUeXBlLm1peEluKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJ1xuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBtaXhJbjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJRSB3b24ndCBjb3B5IHRvU3RyaW5nIHVzaW5nIHRoZSBsb29wIGFib3ZlXG5cdCAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSgndG9TdHJpbmcnKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9TdHJpbmcgPSBwcm9wZXJ0aWVzLnRvU3RyaW5nO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBpbnN0YW5jZS5jbG9uZSgpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge0FycmF5fSB3b3JkcyBUaGUgYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNpZ0J5dGVzIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICovXG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5ID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgKE9wdGlvbmFsKSBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNpZ0J5dGVzIChPcHRpb25hbCkgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGUgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSwgNik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKHdvcmRzLCBzaWdCeXRlcykge1xuXHQgICAgICAgICAgICB3b3JkcyA9IHRoaXMud29yZHMgPSB3b3JkcyB8fCBbXTtcblxuXHQgICAgICAgICAgICBpZiAoc2lnQnl0ZXMgIT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gd29yZHMubGVuZ3RoICogNDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIHdvcmQgYXJyYXkgdG8gYSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXIgKE9wdGlvbmFsKSBUaGUgZW5jb2Rpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBDcnlwdG9KUy5lbmMuSGV4XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5ICsgJyc7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZyhDcnlwdG9KUy5lbmMuVXRmOCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChlbmNvZGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoZW5jb2RlciB8fCBIZXgpLnN0cmluZ2lmeSh0aGlzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uY2F0ZW5hdGVzIGEgd29yZCBhcnJheSB0byB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5IHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB3b3JkQXJyYXkxLmNvbmNhdCh3b3JkQXJyYXkyKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjb25jYXQ6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB0aGlzV29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgdGhhdFdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgdGhpc1NpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIHRoYXRTaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICB0aGlzLmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29uY2F0XG5cdCAgICAgICAgICAgIGlmICh0aGlzU2lnQnl0ZXMgJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSBieXRlIGF0IGEgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0aGF0Qnl0ZSA9ICh0aGF0V29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdIHw9IHRoYXRCeXRlIDw8ICgyNCAtICgodGhpc1NpZ0J5dGVzICsgaSkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgd29yZCBhdCBhIHRpbWVcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSA9IHRoYXRXb3Jkc1tpID4+PiAyXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzICs9IHRoYXRTaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlbW92ZXMgaW5zaWduaWZpY2FudCBiaXRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbGFtcDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gdGhpcy53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcFxuXHQgICAgICAgICAgICB3b3Jkc1tzaWdCeXRlcyA+Pj4gMl0gJj0gMHhmZmZmZmZmZiA8PCAoMzIgLSAoc2lnQnl0ZXMgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB3b3Jkcy5sZW5ndGggPSBNYXRoLmNlaWwoc2lnQnl0ZXMgLyA0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IHdvcmRBcnJheS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUud29yZHMgPSB0aGlzLndvcmRzLnNsaWNlKDApO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHdvcmQgYXJyYXkgZmlsbGVkIHdpdGggcmFuZG9tIGJ5dGVzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5CeXRlcyBUaGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHJhbmRvbSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oMTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJhbmRvbTogZnVuY3Rpb24gKG5CeXRlcykge1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5CeXRlczsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkcy5wdXNoKGNyeXB0b1NlY3VyZVJhbmRvbUludCgpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIG5CeXRlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRW5jb2RlciBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogSGV4IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgSGV4ID0gQ19lbmMuSGV4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhleFN0cmluZyA9IENyeXB0b0pTLmVuYy5IZXguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBoZXhDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgPj4+IDQpLnRvU3RyaW5nKDE2KSk7XG5cdCAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlICYgMHgwZikudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBoZXhDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXhTdHIgVGhlIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShoZXhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoaGV4U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoZXhTdHJMZW5ndGggPSBoZXhTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGV4U3RyTGVuZ3RoOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDNdIHw9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoaSwgMiksIDE2KSA8PCAoMjQgLSAoaSAlIDgpICogNCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBoZXhTdHJMZW5ndGggLyAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExhdGluMSBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIExhdGluMSA9IENfZW5jLkxhdGluMSA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBsYXRpbjFTdHJpbmcgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xQ2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICBsYXRpbjFDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYml0ZSkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGxhdGluMUNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIExhdGluMSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhdGluMVN0ciBUaGUgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnBhcnNlKGxhdGluMVN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChsYXRpbjFTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGxhdGluMVN0ckxlbmd0aCA9IGxhdGluMVN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRpbjFTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMl0gfD0gKGxhdGluMVN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZikgPDwgKDI0IC0gKGkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbGF0aW4xU3RyTGVuZ3RoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVURi04IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0ZjggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmOC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKExhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KSkpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBVVEYtOCBkYXRhJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBVVEYtOCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjhTdHIgVGhlIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZSh1dGY4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjhTdHIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIExhdGluMS5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodXRmOFN0cikpKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJ1ZmZlcmVkIGJsb2NrIGFsZ29yaXRobSB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBUaGUgcHJvcGVydHkgYmxvY2tTaXplIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gYSBjb25jcmV0ZSBzdWJ0eXBlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfbWluQnVmZmVyU2l6ZSBUaGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IHNob3VsZCBiZSBrZXB0IHVucHJvY2Vzc2VkIGluIHRoZSBidWZmZXIuIERlZmF1bHQ6IDBcblx0ICAgICAqL1xuXHQgICAgdmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBDX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGRhdGEgYnVmZmVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBXb3JkQXJyYXkuaW5pdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzID0gMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRkcyBuZXcgZGF0YSB0byB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGJ1ZmZlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBhcHBlbmQuIFN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byBhIFdvcmRBcnJheSB1c2luZyBVVEYtOC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9hcHBlbmQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICBkYXRhID0gVXRmOC5wYXJzZShkYXRhKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9kYXRhLmNvbmNhdChkYXRhKTtcblx0ICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyArPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBQcm9jZXNzZXMgYXZhaWxhYmxlIGRhdGEgYmxvY2tzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBfZG9Qcm9jZXNzQmxvY2sob2Zmc2V0KSwgd2hpY2ggbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBhIGNvbmNyZXRlIHN1YnR5cGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvRmx1c2ggV2hldGhlciBhbGwgYmxvY2tzIGFuZCBwYXJ0aWFsIGJsb2NrcyBzaG91bGQgYmUgcHJvY2Vzc2VkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcHJvY2Vzc2VkIGRhdGEuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcygpO1xuXHQgICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoISEnZmx1c2gnKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfcHJvY2VzczogZnVuY3Rpb24gKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgdmFyIHByb2Nlc3NlZFdvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVNpZ0J5dGVzID0gZGF0YS5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IHRoaXMuYmxvY2tTaXplO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvdW50IGJsb2NrcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbkJsb2Nrc1JlYWR5ID0gZGF0YVNpZ0J5dGVzIC8gYmxvY2tTaXplQnl0ZXM7XG5cdCAgICAgICAgICAgIGlmIChkb0ZsdXNoKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBSb3VuZCB1cCB0byBpbmNsdWRlIHBhcnRpYWwgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLmNlaWwobkJsb2Nrc1JlYWR5KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIGRvd24gdG8gaW5jbHVkZSBvbmx5IGZ1bGwgYmxvY2tzLFxuXHQgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IG11c3QgcmVtYWluIGluIHRoZSBidWZmZXJcblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGgubWF4KChuQmxvY2tzUmVhZHkgfCAwKSAtIHRoaXMuX21pbkJ1ZmZlclNpemUsIDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgd29yZHMgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5Xb3Jkc1JlYWR5ID0gbkJsb2Nrc1JlYWR5ICogYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgIC8vIENvdW50IGJ5dGVzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuQnl0ZXNSZWFkeSA9IE1hdGgubWluKG5Xb3Jkc1JlYWR5ICogNCwgZGF0YVNpZ0J5dGVzKTtcblxuXHQgICAgICAgICAgICAvLyBQcm9jZXNzIGJsb2Nrc1xuXHQgICAgICAgICAgICBpZiAobldvcmRzUmVhZHkpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IG5Xb3Jkc1JlYWR5OyBvZmZzZXQgKz0gYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1hbGdvcml0aG0gbG9naWNcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1Byb2Nlc3NCbG9jayhkYXRhV29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBwcm9jZXNzZWQgd29yZHNcblx0ICAgICAgICAgICAgICAgIHByb2Nlc3NlZFdvcmRzID0gZGF0YVdvcmRzLnNwbGljZSgwLCBuV29yZHNSZWFkeSk7XG5cdCAgICAgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5CeXRlc1JlYWR5O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHByb2Nlc3NlZFdvcmRzLCBuQnl0ZXNSZWFkeSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uY2xvbmUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9kYXRhID0gdGhpcy5fZGF0YS5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX21pbkJ1ZmZlclNpemU6IDBcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGhhc2hlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgaGFzaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxNiAoNTEyIGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBoYXNoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgaGFzaCBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2hlciA9IENyeXB0b0pTLmFsZ28uU0hBMjU2LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgaGFzaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxuXHQgICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcblx0ICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVcGRhdGVzIHRoaXMgaGFzaGVyIHdpdGggYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0hhc2hlcn0gVGhpcyBoYXNoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGhhc2hcblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBoYXNoIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gRmluYWwgbWVzc2FnZSB1cGRhdGVcblx0ICAgICAgICAgICAgaWYgKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDUxMi8zMixcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byBhIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaGFzaGVyLmluaXQoY2ZnKS5maW5hbGl6ZShtZXNzYWdlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byB1c2UgaW4gdGhpcyBITUFDIGhlbHBlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBIbWFjU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhtYWNIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ19hbGdvLkhNQUMuaW5pdChoYXNoZXIsIGtleSkuZmluYWxpemUobWVzc2FnZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWxnb3JpdGhtIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbyA9IHt9O1xuXG5cdCAgICByZXR1cm4gQztcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlM7XG5cbn0pKTtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKSkpXG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG4vKiBDYWxsIHRoZSBsaXN0ZW5lciwgY2F0Y2ggYW55IGV4Y2VwdGlvbnMgYW5kIGxvZywgYnV0IGNvbnRpbnVlIG9wZXJhdGlvbiovXG5mdW5jdGlvbiBjYWxsTGlzdGVuZXIoZXZlbnRUaGlzLCBsaXN0ZW5lciwgYXJncykge1xuICAgIHRyeSB7XG4gICAgICAgIGxpc3RlbmVyLmFwcGx5KGV2ZW50VGhpcywgYXJncyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnRXZlbnRFbWl0dGVyLmVtaXQoKScsICdVbmV4cGVjdGVkIGxpc3RlbmVyIGV4Y2VwdGlvbjogJyArIGUgKyAnOyBzdGFjayA9ICcgKyAoZSAmJiBlLnN0YWNrKSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZW1vdmUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggbGlzdGVuZXJcbiAqIEBwYXJhbSB0YXJnZXRMaXN0ZW5lcnMgaXMgYW4gYXJyYXkgb2YgbGlzdGVuZXIgYXJyYXlzIG9yIGV2ZW50IG9iamVjdHMgd2l0aCBhcnJheXMgb2YgbGlzdGVuZXJzXG4gKiBAcGFyYW0gbGlzdGVuZXIgdGhlIGxpc3RlbmVyIGNhbGxiYWNrIHRvIHJlbW92ZVxuICogQHBhcmFtIGV2ZW50RmlsdGVyIChvcHRpb25hbCkgZXZlbnQgbmFtZSBpbnN0cnVjdGluZyB0aGUgZnVuY3Rpb24gdG8gb25seSByZW1vdmUgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHRhcmdldExpc3RlbmVycywgbGlzdGVuZXIsIGV2ZW50RmlsdGVyKSB7XG4gICAgdmFyIGxpc3RlbmVycztcbiAgICB2YXIgaW5kZXg7XG4gICAgdmFyIGV2ZW50TmFtZTtcbiAgICBmb3IgKHZhciB0YXJnZXRMaXN0ZW5lcnNJbmRleCA9IDA7IHRhcmdldExpc3RlbmVyc0luZGV4IDwgdGFyZ2V0TGlzdGVuZXJzLmxlbmd0aDsgdGFyZ2V0TGlzdGVuZXJzSW5kZXgrKykge1xuICAgICAgICBsaXN0ZW5lcnMgPSB0YXJnZXRMaXN0ZW5lcnNbdGFyZ2V0TGlzdGVuZXJzSW5kZXhdO1xuICAgICAgICBpZiAoZXZlbnRGaWx0ZXIpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVyc1tldmVudEZpbHRlcl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWxzLmlzQXJyYXkobGlzdGVuZXJzKSkge1xuICAgICAgICAgICAgd2hpbGUgKChpbmRleCA9IFV0aWxzLmFyckluZGV4T2YobGlzdGVuZXJzLCBsaXN0ZW5lcikpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogSWYgZXZlbnRzIG9iamVjdCBoYXMgYW4gZXZlbnQgbmFtZSBrZXkgd2l0aCBubyBsaXN0ZW5lcnMgdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGtleSB0byBzdG9wIHRoZSBsaXN0IGdyb3dpbmcgaW5kZWZpbml0ZWx5ICovXG4gICAgICAgICAgICBpZiAoZXZlbnRGaWx0ZXIgJiYgbGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRMaXN0ZW5lcnNbdGFyZ2V0TGlzdGVuZXJzSW5kZXhdW2V2ZW50RmlsdGVyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChVdGlscy5pc09iamVjdChsaXN0ZW5lcnMpKSB7XG4gICAgICAgICAgICAvKiBldmVudHMgKi9cbiAgICAgICAgICAgIGZvciAoZXZlbnROYW1lIGluIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGlzdGVuZXJzLCBldmVudE5hbWUpICYmIFV0aWxzLmlzQXJyYXkobGlzdGVuZXJzW2V2ZW50TmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKFtsaXN0ZW5lcnNdLCBsaXN0ZW5lciwgZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgRXZlbnRFbWl0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgICAgICAgdGhpcy5hbnkgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmFueU9uY2UgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudHNPbmNlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGFyZ3NbMF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbnkucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50TGlzdGVuZXIub24oKTogSW52YWxpZCBhcmd1bWVudHM6ICcgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdmFyIGV2ZW50XzEgPSBhcmdzWzBdLCBsaXN0ZW5lcl8xID0gYXJnc1sxXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJfMSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnRMaXN0ZW5lci5vbigpOiBJbnZhbGlkIGFyZ3VtZW50czogJyArIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNFbXB0eUFyZyhldmVudF8xKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW55LnB1c2gobGlzdGVuZXJfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChVdGlscy5pc0FycmF5KGV2ZW50XzEpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRfMS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub24oZXZlbnROYW1lLCBsaXN0ZW5lcl8xKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnRfMSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudExpc3RlbmVyLm9uKCk6IEludmFsaWQgYXJndW1lbnRzOiAnICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuZXZlbnRzW2V2ZW50XzFdIHx8ICh0aGlzLmV2ZW50c1tldmVudF8xXSA9IFtdKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcl8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT0gMCB8fCAoVXRpbHMuaXNFbXB0eUFyZyhhcmdzWzBdKSAmJiBVdGlscy5pc0VtcHR5QXJnKGFyZ3NbMV0pKSkge1xuICAgICAgICAgICAgdGhpcy5hbnkgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHRoaXMuYW55T25jZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5ldmVudHNPbmNlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3RBcmcgPSBhcmdzWzBdLCBzZWNvbmRBcmcgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB2YXIgZXZlbnQgPSBudWxsO1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgfHwgIXNlY29uZEFyZykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8qIHdlIHRha2UgdGhpcyB0byBiZSB0aGUgbGlzdGVuZXIgYW5kIHRyZWF0IHRoZSBldmVudCBhcyBcImFueVwiIC4uICovXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBmaXJzdEFyZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gZmlyc3RBcmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiAuLi4gb3Igd2UgdGFrZSBldmVudCB0byBiZSB0aGUgYWN0dWFsIGV2ZW50IG5hbWUgYW5kIGxpc3RlbmVyIHRvIGJlIGFsbCAqL1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRBcmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50RW1pdHRlci5vZmYoKTogaW52YWxpZCBhcmd1bWVudHM6JyArIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfYSA9IFtmaXJzdEFyZywgc2Vjb25kQXJnXSwgZXZlbnQgPSBfYVswXSwgbGlzdGVuZXIgPSBfYVsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIgJiYgVXRpbHMuaXNFbXB0eUFyZyhldmVudCkpIHtcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKFt0aGlzLmFueSwgdGhpcy5ldmVudHMsIHRoaXMuYW55T25jZSwgdGhpcy5ldmVudHNPbmNlXSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChVdGlscy5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyogXCJub3JtYWxcIiBjYXNlIHdoZXJlIGV2ZW50IGlzIGFuIGFjdHVhbCBldmVudCAqL1xuICAgICAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudEVtaXR0ZXIub2ZmKCk6IGludmFsaWQgYXJndW1lbnRzOicgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoW3RoaXMuZXZlbnRzLCB0aGlzLmV2ZW50c09uY2VdLCBsaXN0ZW5lciwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c09uY2VbZXZlbnRdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGFycmF5IG9mIGxpc3RlbmVycyBmb3IgYSBnaXZlbiBldmVudDsgZXhjbHVkZXMgb25jZSBldmVudHNcbiAgICAgKiBAcGFyYW0gZXZlbnQgKG9wdGlvbmFsKSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQsIG9yIG5vbmUgZm9yICdhbnknXG4gICAgICogQHJldHVybiBhcnJheSBvZiBldmVudHMsIG9yIG51bGwgaWYgbm9uZVxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuZXZlbnRzW2V2ZW50XSB8fCBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50c09uY2VbZXZlbnRdKVxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgdGhpcy5ldmVudHNPbmNlW2V2ZW50XSk7XG4gICAgICAgICAgICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aCA/IGxpc3RlbmVycyA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYW55Lmxlbmd0aCA/IHRoaXMuYW55IDogbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVtaXQgYW4gZXZlbnRcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0gYXJncyB0aGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGxpc3RlbmVyXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBhcmdzID0gW107IC8qICwgYXJncy4uLiAqL1xuICAgICAgICBmb3IgKHZhciBfaSA9IDEgLyogLCBhcmdzLi4uICovOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGggLyogLCBhcmdzLi4uICovOyBfaSsrIC8qICwgYXJncy4uLiAqLykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTsgLyogLCBhcmdzLi4uICovXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50VGhpcyA9IHsgZXZlbnQ6IGV2ZW50IH07XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuYW55T25jZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgdGhpcy5hbnlPbmNlKTtcbiAgICAgICAgICAgIHRoaXMuYW55T25jZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFueS5sZW5ndGgpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgdGhpcy5hbnkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudHNPbmNlTGlzdGVuZXJzID0gdGhpcy5ldmVudHNPbmNlW2V2ZW50XTtcbiAgICAgICAgaWYgKGV2ZW50c09uY2VMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgZXZlbnRzT25jZUxpc3RlbmVycyk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ldmVudHNPbmNlW2V2ZW50XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRzTGlzdGVuZXJzID0gdGhpcy5ldmVudHNbZXZlbnRdO1xuICAgICAgICBpZiAoZXZlbnRzTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIGV2ZW50c0xpc3RlbmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgVXRpbHMuYXJyRm9yRWFjaChsaXN0ZW5lcnMsIGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY2FsbExpc3RlbmVyKGV2ZW50VGhpcywgbGlzdGVuZXIsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJnQ291bnQgPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgaWYgKChhcmdDb3VudCA9PT0gMCB8fCAoYXJnQ291bnQgPT09IDEgJiYgdHlwZW9mIGFyZ3NbMF0gIT09ICdmdW5jdGlvbicpKSAmJiBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLlByb21pc2UpIHtcbiAgICAgICAgICAgIHZhciBldmVudF8yID0gYXJnc1swXTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25jZShldmVudF8yLCByZXNvbHZlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXJzdEFyZyA9IGFyZ3NbMF0sIHNlY29uZEFyZyA9IGFyZ3NbMV07XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZmlyc3RBcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuYW55T25jZS5wdXNoKGZpcnN0QXJnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChVdGlscy5pc0VtcHR5QXJnKGZpcnN0QXJnKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRBcmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50RW1pdHRlci5vbmNlKCk6IEludmFsaWQgYXJndW1lbnRzOicgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hbnlPbmNlLnB1c2goc2Vjb25kQXJnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChVdGlscy5pc0FycmF5KGZpcnN0QXJnKSkge1xuICAgICAgICAgICAgdmFyIHNlbGZfMSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJXcmFwcGVyXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgVXRpbHMuYXJyRm9yRWFjaChmaXJzdEFyZywgZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmXzEub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXJXcmFwcGVyXzEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2Vjb25kQXJnICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6JyArIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlY29uZEFyZy5hcHBseSh0aGlzLCBpbm5lckFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFV0aWxzLmFyckZvckVhY2goZmlyc3RBcmcsIGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBzZWxmXzEub24oZXZlbnROYW1lLCBsaXN0ZW5lcldyYXBwZXJfMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlyc3RBcmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudEVtaXR0ZXIub25jZSgpOiBJbnZhbGlkIGFyZ3VtZW50czonICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c09uY2VbZmlyc3RBcmddIHx8ICh0aGlzLmV2ZW50c09uY2VbZmlyc3RBcmddID0gW10pO1xuICAgICAgICAgICAgaWYgKHNlY29uZEFyZykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2Vjb25kQXJnICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6JyArIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKHNlY29uZEFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByaXZhdGUgQVBJXG4gICAgICpcbiAgICAgKiBMaXN0ZW4gZm9yIGEgc2luZ2xlIG9jY3VycmVuY2Ugb2YgYSBzdGF0ZSBldmVudCBhbmQgZmlyZSBpbW1lZGlhdGVseSBpZiBjdXJyZW50U3RhdGUgbWF0Y2hlcyB0YXJnZXRTdGF0ZVxuICAgICAqIEBwYXJhbSB0YXJnZXRTdGF0ZSB0aGUgbmFtZSBvZiB0aGUgc3RhdGUgZXZlbnQgdG8gbGlzdGVuIHRvXG4gICAgICogQHBhcmFtIGN1cnJlbnRTdGF0ZSB0aGUgbmFtZSBvZiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGlzIG9iamVjdFxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciB0aGUgbGlzdGVuZXIgdG8gYmUgY2FsbGVkXG4gICAgICogQHBhcmFtIGxpc3RlbmVyQXJnc1xuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUud2hlblN0YXRlID0gZnVuY3Rpb24gKHRhcmdldFN0YXRlLCBjdXJyZW50U3RhdGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBsaXN0ZW5lckFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAzOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGxpc3RlbmVyQXJnc1tfaSAtIDNdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRUaGlzID0geyBldmVudDogdGFyZ2V0U3RhdGUgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRTdGF0ZSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGN1cnJlbnRTdGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93ICd3aGVuU3RhdGUgcmVxdWlyZXMgYSB2YWxpZCBldmVudCBTdHJpbmcgYXJndW1lbnQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicgJiYgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5Qcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUud2hlblN0YXRlLmFwcGx5KF90aGlzLCBbdGFyZ2V0U3RhdGUsIGN1cnJlbnRTdGF0ZSwgcmVzb2x2ZV0uY29uY2F0KGxpc3RlbmVyQXJncykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldFN0YXRlID09PSBjdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICAgIGNhbGxMaXN0ZW5lcihldmVudFRoaXMsIGxpc3RlbmVyLCBsaXN0ZW5lckFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbmNlKHRhcmdldFN0YXRlLCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRFbWl0dGVyO1xuXG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXREZWZhdWx0cyA9IGV4cG9ydHMubm9ybWFsaXNlT3B0aW9ucyA9IGV4cG9ydHMub2JqZWN0aWZ5T3B0aW9ucyA9IGV4cG9ydHMuZ2V0QWdlbnRTdHJpbmcgPSBleHBvcnRzLmdldEhvc3RzID0gZXhwb3J0cy5nZXRGYWxsYmFja0hvc3RzID0gZXhwb3J0cy5lbnZpcm9ubWVudEZhbGxiYWNrSG9zdHMgPSBleHBvcnRzLmdldEh0dHBTY2hlbWUgPSBleHBvcnRzLmdldFBvcnQgPSBleHBvcnRzLmdldEhvc3QgPSB2b2lkIDA7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIHBhY2thZ2VfanNvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG52YXIgYWdlbnQgPSAnYWJseS1qcy8nICsgcGFja2FnZV9qc29uXzEudmVyc2lvbjtcbnZhciBEZWZhdWx0cyA9IHtcbiAgICBFTlZJUk9OTUVOVDogJycsXG4gICAgUkVTVF9IT1NUOiAncmVzdC5hYmx5LmlvJyxcbiAgICBSRUFMVElNRV9IT1NUOiAncmVhbHRpbWUuYWJseS5pbycsXG4gICAgRkFMTEJBQ0tfSE9TVFM6IFtcbiAgICAgICAgJ0EuYWJseS1yZWFsdGltZS5jb20nLFxuICAgICAgICAnQi5hYmx5LXJlYWx0aW1lLmNvbScsXG4gICAgICAgICdDLmFibHktcmVhbHRpbWUuY29tJyxcbiAgICAgICAgJ0QuYWJseS1yZWFsdGltZS5jb20nLFxuICAgICAgICAnRS5hYmx5LXJlYWx0aW1lLmNvbScsXG4gICAgXSxcbiAgICBQT1JUOiA4MCxcbiAgICBUTFNfUE9SVDogNDQzLFxuICAgIFRJTUVPVVRTOiB7XG4gICAgICAgIC8qIERvY3VtZW50ZWQgYXMgb3B0aW9ucyBwYXJhbXM6ICovXG4gICAgICAgIGRpc2Nvbm5lY3RlZFJldHJ5VGltZW91dDogMTUwMDAsXG4gICAgICAgIHN1c3BlbmRlZFJldHJ5VGltZW91dDogMzAwMDAsXG4gICAgICAgIC8qIFVuZG9jdW1lbnRlZCwgYnV0IHBhcnQgb2YgdGhlIGFwaSBhbmQgY2FuIGJlIHVzZWQgYnkgY3VzdG9tZXJzOiAqL1xuICAgICAgICBodHRwUmVxdWVzdFRpbWVvdXQ6IDE1MDAwLFxuICAgICAgICBjaGFubmVsUmV0cnlUaW1lb3V0OiAxNTAwMCxcbiAgICAgICAgZmFsbGJhY2tSZXRyeVRpbWVvdXQ6IDYwMDAwMCxcbiAgICAgICAgLyogRm9yIGludGVybmFsIC8gdGVzdCB1c2Ugb25seTogKi9cbiAgICAgICAgY29ubmVjdGlvblN0YXRlVHRsOiAxMjAwMDAsXG4gICAgICAgIHJlYWx0aW1lUmVxdWVzdFRpbWVvdXQ6IDEwMDAwLFxuICAgICAgICByZWN2VGltZW91dDogOTAwMDAsXG4gICAgICAgIHByZWZlcmVuY2VDb25uZWN0VGltZW91dDogNjAwMCxcbiAgICAgICAgcGFyYWxsZWxVcGdyYWRlRGVsYXk6IDYwMDAsXG4gICAgfSxcbiAgICBodHRwTWF4UmV0cnlDb3VudDogMyxcbiAgICBtYXhNZXNzYWdlU2l6ZTogNjU1MzYsXG4gICAgdmVyc2lvbjogcGFja2FnZV9qc29uXzEudmVyc2lvbixcbiAgICBwcm90b2NvbFZlcnNpb246IDIsXG4gICAgYWdlbnQ6IGFnZW50LFxuICAgIGdldEhvc3Q6IGdldEhvc3QsXG4gICAgZ2V0UG9ydDogZ2V0UG9ydCxcbiAgICBnZXRIdHRwU2NoZW1lOiBnZXRIdHRwU2NoZW1lLFxuICAgIGVudmlyb25tZW50RmFsbGJhY2tIb3N0czogZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzLFxuICAgIGdldEZhbGxiYWNrSG9zdHM6IGdldEZhbGxiYWNrSG9zdHMsXG4gICAgZ2V0SG9zdHM6IGdldEhvc3RzLFxuICAgIGNoZWNrSG9zdDogY2hlY2tIb3N0LFxuICAgIG9iamVjdGlmeU9wdGlvbnM6IG9iamVjdGlmeU9wdGlvbnMsXG4gICAgbm9ybWFsaXNlT3B0aW9uczogbm9ybWFsaXNlT3B0aW9ucyxcbn07XG5mdW5jdGlvbiBnZXRIb3N0KG9wdGlvbnMsIGhvc3QsIHdzKSB7XG4gICAgaWYgKHdzKVxuICAgICAgICBob3N0ID0gKGhvc3QgPT0gb3B0aW9ucy5yZXN0SG9zdCAmJiBvcHRpb25zLnJlYWx0aW1lSG9zdCkgfHwgaG9zdCB8fCBvcHRpb25zLnJlYWx0aW1lSG9zdDtcbiAgICBlbHNlXG4gICAgICAgIGhvc3QgPSBob3N0IHx8IG9wdGlvbnMucmVzdEhvc3Q7XG4gICAgcmV0dXJuIGhvc3Q7XG59XG5leHBvcnRzLmdldEhvc3QgPSBnZXRIb3N0O1xuZnVuY3Rpb24gZ2V0UG9ydChvcHRpb25zLCB0bHMpIHtcbiAgICByZXR1cm4gdGxzIHx8IG9wdGlvbnMudGxzID8gb3B0aW9ucy50bHNQb3J0IDogb3B0aW9ucy5wb3J0O1xufVxuZXhwb3J0cy5nZXRQb3J0ID0gZ2V0UG9ydDtcbmZ1bmN0aW9uIGdldEh0dHBTY2hlbWUob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLnRscyA/ICdodHRwczovLycgOiAnaHR0cDovLyc7XG59XG5leHBvcnRzLmdldEh0dHBTY2hlbWUgPSBnZXRIdHRwU2NoZW1lO1xuLy8gY29uc3RydWN0IGVudmlyb25tZW50IGZhbGxiYWNrIGhvc3RzIGFzIHBlciBSU0MxNWlcbmZ1bmN0aW9uIGVudmlyb25tZW50RmFsbGJhY2tIb3N0cyhlbnZpcm9ubWVudCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGVudmlyb25tZW50ICsgJy1hLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tJyxcbiAgICAgICAgZW52aXJvbm1lbnQgKyAnLWItZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb20nLFxuICAgICAgICBlbnZpcm9ubWVudCArICctYy1mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbScsXG4gICAgICAgIGVudmlyb25tZW50ICsgJy1kLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tJyxcbiAgICAgICAgZW52aXJvbm1lbnQgKyAnLWUtZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb20nLFxuICAgIF07XG59XG5leHBvcnRzLmVudmlyb25tZW50RmFsbGJhY2tIb3N0cyA9IGVudmlyb25tZW50RmFsbGJhY2tIb3N0cztcbmZ1bmN0aW9uIGdldEZhbGxiYWNrSG9zdHMob3B0aW9ucykge1xuICAgIHZhciBmYWxsYmFja0hvc3RzID0gb3B0aW9ucy5mYWxsYmFja0hvc3RzLCBodHRwTWF4UmV0cnlDb3VudCA9IHR5cGVvZiBvcHRpb25zLmh0dHBNYXhSZXRyeUNvdW50ICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuaHR0cE1heFJldHJ5Q291bnQgOiBEZWZhdWx0cy5odHRwTWF4UmV0cnlDb3VudDtcbiAgICByZXR1cm4gZmFsbGJhY2tIb3N0cyA/IFV0aWxzLmFyckNob29zZU4oZmFsbGJhY2tIb3N0cywgaHR0cE1heFJldHJ5Q291bnQpIDogW107XG59XG5leHBvcnRzLmdldEZhbGxiYWNrSG9zdHMgPSBnZXRGYWxsYmFja0hvc3RzO1xuZnVuY3Rpb24gZ2V0SG9zdHMob3B0aW9ucykge1xuICAgIHJldHVybiBbb3B0aW9ucy5yZXN0SG9zdF0uY29uY2F0KGdldEZhbGxiYWNrSG9zdHMob3B0aW9ucykpO1xufVxuZXhwb3J0cy5nZXRIb3N0cyA9IGdldEhvc3RzO1xuZnVuY3Rpb24gY2hlY2tIb3N0KGhvc3QpIHtcbiAgICBpZiAodHlwZW9mIGhvc3QgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdob3N0IG11c3QgYmUgYSBzdHJpbmc7IHdhcyBhICcgKyB0eXBlb2YgaG9zdCwgNDAwMDAsIDQwMCk7XG4gICAgfVxuICAgIGlmICghaG9zdC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ2hvc3QgbXVzdCBub3QgYmUgemVyby1sZW5ndGgnLCA0MDAwMCwgNDAwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRSZWFsdGltZUhvc3Qob3B0aW9ucywgcHJvZHVjdGlvbiwgZW52aXJvbm1lbnQpIHtcbiAgICBpZiAob3B0aW9ucy5yZWFsdGltZUhvc3QpXG4gICAgICAgIHJldHVybiBvcHRpb25zLnJlYWx0aW1lSG9zdDtcbiAgICAvKiBwcmVmZXIgc2V0dGluZyByZWFsdGltZUhvc3QgdG8gcmVzdEhvc3QgYXMgYSBjdXN0b20gcmVzdEhvc3QgdHlwaWNhbGx5IGluZGljYXRlc1xuICAgICAqIGEgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnQgaXMgYmVpbmcgdXNlZCB0aGF0IGNhbid0IGJlIGluZmVycmVkIGJ5IHRoZSBsaWJyYXJ5ICovXG4gICAgaWYgKG9wdGlvbnMucmVzdEhvc3QpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zJywgJ3Jlc3RIb3N0IGlzIHNldCB0byBcIicgK1xuICAgICAgICAgICAgb3B0aW9ucy5yZXN0SG9zdCArXG4gICAgICAgICAgICAnXCIgYnV0IHJlYWx0aW1lSG9zdCBpcyBub3Qgc2V0LCBzbyBzZXR0aW5nIHJlYWx0aW1lSG9zdCB0byBcIicgK1xuICAgICAgICAgICAgb3B0aW9ucy5yZXN0SG9zdCArXG4gICAgICAgICAgICAnXCIgdG9vLiBJZiB0aGlzIGlzIG5vdCB3aGF0IHlvdSB3YW50LCBwbGVhc2Ugc2V0IHJlYWx0aW1lSG9zdCBleHBsaWNpdGx5LicpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5yZXN0SG9zdDtcbiAgICB9XG4gICAgcmV0dXJuIHByb2R1Y3Rpb24gPyBEZWZhdWx0cy5SRUFMVElNRV9IT1NUIDogZW52aXJvbm1lbnQgKyAnLScgKyBEZWZhdWx0cy5SRUFMVElNRV9IT1NUO1xufVxuZnVuY3Rpb24gZ2V0VGltZW91dHMob3B0aW9ucykge1xuICAgIC8qIEFsbG93IHZhbHVlcyBwYXNzZWQgaW4gb3B0aW9ucyB0byBvdmVycmlkZSBkZWZhdWx0IHRpbWVvdXRzICovXG4gICAgdmFyIHRpbWVvdXRzID0ge307XG4gICAgZm9yICh2YXIgcHJvcCBpbiBEZWZhdWx0cy5USU1FT1VUUykge1xuICAgICAgICB0aW1lb3V0c1twcm9wXSA9IG9wdGlvbnNbcHJvcF0gfHwgRGVmYXVsdHMuVElNRU9VVFNbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiB0aW1lb3V0cztcbn1cbmZ1bmN0aW9uIGdldEFnZW50U3RyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgYWdlbnRTdHIgPSBEZWZhdWx0cy5hZ2VudDtcbiAgICBpZiAob3B0aW9ucy5hZ2VudHMpIHtcbiAgICAgICAgZm9yICh2YXIgYWdlbnQgaW4gb3B0aW9ucy5hZ2VudHMpIHtcbiAgICAgICAgICAgIGFnZW50U3RyICs9ICcgJyArIGFnZW50ICsgJy8nICsgb3B0aW9ucy5hZ2VudHNbYWdlbnRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhZ2VudFN0cjtcbn1cbmV4cG9ydHMuZ2V0QWdlbnRTdHJpbmcgPSBnZXRBZ2VudFN0cmluZztcbmZ1bmN0aW9uIG9iamVjdGlmeU9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5pbmRleE9mKCc6JykgPT0gLTEgPyB7IHRva2VuOiBvcHRpb25zIH0gOiB7IGtleTogb3B0aW9ucyB9O1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbmV4cG9ydHMub2JqZWN0aWZ5T3B0aW9ucyA9IG9iamVjdGlmeU9wdGlvbnM7XG5mdW5jdGlvbiBub3JtYWxpc2VPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAvKiBEZXByZWNhdGVkIG9wdGlvbnMgKi9cbiAgICBpZiAob3B0aW9ucy5ob3N0KSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZGVwcmVjYXRlZCgnaG9zdCcsICdyZXN0SG9zdCcpO1xuICAgICAgICBvcHRpb25zLnJlc3RIb3N0ID0gb3B0aW9ucy5ob3N0O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy53c0hvc3QpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZXByZWNhdGVkKCd3c0hvc3QnLCAncmVhbHRpbWVIb3N0Jyk7XG4gICAgICAgIG9wdGlvbnMucmVhbHRpbWVIb3N0ID0gb3B0aW9ucy53c0hvc3Q7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnF1ZXVlRXZlbnRzKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZGVwcmVjYXRlZCgncXVldWVFdmVudHMnLCAncXVldWVNZXNzYWdlcycpO1xuICAgICAgICBvcHRpb25zLnF1ZXVlTWVzc2FnZXMgPSBvcHRpb25zLnF1ZXVlRXZlbnRzO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5mYWxsYmFja0hvc3RzVXNlRGVmYXVsdCkge1xuICAgICAgICAvKiBmYWxsYmFja0hvc3RzVXNlRGVmYXVsdCBhbmQgZmFsbGJhY2tIb3N0cyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlIGFzIHBlciBUTzNrNyAqL1xuICAgICAgICBpZiAob3B0aW9ucy5mYWxsYmFja0hvc3RzKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ2ZhbGxiYWNrSG9zdHMgYW5kIGZhbGxiYWNrSG9zdHNVc2VEZWZhdWx0IGNhbm5vdCBib3RoIGJlIHNldCc7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0RlZmF1bHRzLm5vcm1hbGlzZU9wdGlvbnMnLCBtc2cpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA0MDAwMCwgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBkZWZhdWx0IGZhbGxiYWNrcyBjYW4ndCBiZSB1c2VkIHdpdGggY3VzdG9tIHBvcnRzICovXG4gICAgICAgIGlmIChvcHRpb25zLnBvcnQgfHwgb3B0aW9ucy50bHNQb3J0KSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ2ZhbGxiYWNrSG9zdHNVc2VEZWZhdWx0IGNhbm5vdCBiZSBzZXQgd2hlbiBwb3J0IG9yIHRsc1BvcnQgYXJlIHNldCc7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0RlZmF1bHRzLm5vcm1hbGlzZU9wdGlvbnMnLCBtc2cpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA0MDAwMCwgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBlbWl0IGFuIGFwcHJvcHJpYXRlIGRlcHJlY2F0aW9uIHdhcm5pbmcgKi9cbiAgICAgICAgaWYgKG9wdGlvbnMuZW52aXJvbm1lbnQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZGVwcmVjYXRlZFdpdGhNc2coJ2ZhbGxiYWNrSG9zdHNVc2VEZWZhdWx0JywgJ1RoZXJlIGlzIG5vIGxvbmdlciBhIG5lZWQgdG8gc2V0IHRoaXMgd2hlbiB0aGUgZW52aXJvbm1lbnQgb3B0aW9uIGlzIGFsc28gc2V0IHNpbmNlIHRoZSBsaWJyYXJ5IHdpbGwgbm93IGdlbmVyYXRlIHRoZSBjb3JyZWN0IGZhbGxiYWNrIGhvc3RzIHVzaW5nIHRoZSBlbnZpcm9ubWVudCBvcHRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlcHJlY2F0ZWQoJ2ZhbGxiYWNrSG9zdHNVc2VEZWZhdWx0JywgJ2ZhbGxiYWNrSG9zdHM6IEFibHkuRGVmYXVsdHMuRkFMTEJBQ0tfSE9TVFMnKTtcbiAgICAgICAgfVxuICAgICAgICAvKiB1c2UgdGhlIGRlZmF1bHQgZmFsbGJhY2sgaG9zdHMgYXMgcmVxdWVzdGVkICovXG4gICAgICAgIG9wdGlvbnMuZmFsbGJhY2tIb3N0cyA9IERlZmF1bHRzLkZBTExCQUNLX0hPU1RTO1xuICAgIH1cbiAgICAvKiBvcHRpb25zLnJlY292ZXIgYXMgYSBib29sZWFuIGlzIGRlcHJlY2F0ZWQsIGFuZCB0aGVyZWZvcmUgaXMgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyB0eXBpbmcgKi9cbiAgICBpZiAob3B0aW9ucy5yZWNvdmVyID09PSB0cnVlKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZGVwcmVjYXRlZCgne3JlY292ZXI6IHRydWV9JywgJ3tyZWNvdmVyOiBmdW5jdGlvbihsYXN0Q29ubmVjdGlvbkRldGFpbHMsIGNiKSB7IGNiKHRydWUpOyB9fScpO1xuICAgICAgICBvcHRpb25zLnJlY292ZXIgPSBmdW5jdGlvbiAobGFzdENvbm5lY3Rpb25EZXRhaWxzLCBjYikge1xuICAgICAgICAgICAgY2IodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWNvdmVyID09PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMuY2xvc2VPblVubG9hZCA9PT0gdHJ1ZSkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0RlZmF1bHRzLm5vcm1hbGlzZU9wdGlvbnMnLCAnY2xvc2VPblVubG9hZCB3YXMgdHJ1ZSBhbmQgYSBzZXNzaW9uIHJlY292ZXJ5IGZ1bmN0aW9uIHdhcyBzZXQgLSB0aGVzZSBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLCBzbyB1bnNldHRpbmcgdGhlIGxhdHRlcicpO1xuICAgICAgICBvcHRpb25zLnJlY292ZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghKCdjbG9zZU9uVW5sb2FkJyBpbiBvcHRpb25zKSkge1xuICAgICAgICAvKiBIYXZlIGNsb3NlT25VbmxvYWQgZGVmYXVsdCB0byB0cnVlIHVubGVzcyB3ZSBoYXZlIGFueSBpbmRpY2F0aW9uIHRoYXRcbiAgICAgICAgICogdGhlIHVzZXIgbWF5IHdhbnQgdG8gcmVjb3ZlciB0aGUgY29ubmVjdGlvbiAqL1xuICAgICAgICBvcHRpb25zLmNsb3NlT25VbmxvYWQgPSAhb3B0aW9ucy5yZWNvdmVyO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50cmFuc3BvcnRzICYmIFV0aWxzLmFyckluKG9wdGlvbnMudHJhbnNwb3J0cywgJ3hocicpKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZGVwcmVjYXRlZCgndHJhbnNwb3J0czogW1wieGhyXCJdJywgJ3RyYW5zcG9ydHM6IFtcInhocl9zdHJlYW1pbmdcIl0nKTtcbiAgICAgICAgVXRpbHMuYXJyRGVsZXRlVmFsdWUob3B0aW9ucy50cmFuc3BvcnRzLCAneGhyJyk7XG4gICAgICAgIG9wdGlvbnMudHJhbnNwb3J0cy5wdXNoKCd4aHJfc3RyZWFtaW5nJyk7XG4gICAgfVxuICAgIGlmICghKCdxdWV1ZU1lc3NhZ2VzJyBpbiBvcHRpb25zKSlcbiAgICAgICAgb3B0aW9ucy5xdWV1ZU1lc3NhZ2VzID0gdHJ1ZTtcbiAgICAvKiBpbmZlciBob3N0cyBhbmQgZmFsbGJhY2tzIGJhc2VkIG9uIHRoZSBjb25maWd1cmVkIGVudmlyb25tZW50ICovXG4gICAgdmFyIGVudmlyb25tZW50ID0gKG9wdGlvbnMuZW52aXJvbm1lbnQgJiYgU3RyaW5nKG9wdGlvbnMuZW52aXJvbm1lbnQpLnRvTG93ZXJDYXNlKCkpIHx8IERlZmF1bHRzLkVOVklST05NRU5UO1xuICAgIHZhciBwcm9kdWN0aW9uID0gIWVudmlyb25tZW50IHx8IGVudmlyb25tZW50ID09PSAncHJvZHVjdGlvbic7XG4gICAgaWYgKCFvcHRpb25zLmZhbGxiYWNrSG9zdHMgJiYgIW9wdGlvbnMucmVzdEhvc3QgJiYgIW9wdGlvbnMucmVhbHRpbWVIb3N0ICYmICFvcHRpb25zLnBvcnQgJiYgIW9wdGlvbnMudGxzUG9ydCkge1xuICAgICAgICBvcHRpb25zLmZhbGxiYWNrSG9zdHMgPSBwcm9kdWN0aW9uID8gRGVmYXVsdHMuRkFMTEJBQ0tfSE9TVFMgOiBlbnZpcm9ubWVudEZhbGxiYWNrSG9zdHMoZW52aXJvbm1lbnQpO1xuICAgIH1cbiAgICB2YXIgcmVzdEhvc3QgPSBvcHRpb25zLnJlc3RIb3N0IHx8IChwcm9kdWN0aW9uID8gRGVmYXVsdHMuUkVTVF9IT1NUIDogZW52aXJvbm1lbnQgKyAnLScgKyBEZWZhdWx0cy5SRVNUX0hPU1QpO1xuICAgIHZhciByZWFsdGltZUhvc3QgPSBnZXRSZWFsdGltZUhvc3Qob3B0aW9ucywgcHJvZHVjdGlvbiwgZW52aXJvbm1lbnQpO1xuICAgIFV0aWxzLmFyckZvckVhY2goKG9wdGlvbnMuZmFsbGJhY2tIb3N0cyB8fCBbXSkuY29uY2F0KHJlc3RIb3N0LCByZWFsdGltZUhvc3QpLCBjaGVja0hvc3QpO1xuICAgIG9wdGlvbnMucG9ydCA9IG9wdGlvbnMucG9ydCB8fCBEZWZhdWx0cy5QT1JUO1xuICAgIG9wdGlvbnMudGxzUG9ydCA9IG9wdGlvbnMudGxzUG9ydCB8fCBEZWZhdWx0cy5UTFNfUE9SVDtcbiAgICBpZiAoISgndGxzJyBpbiBvcHRpb25zKSlcbiAgICAgICAgb3B0aW9ucy50bHMgPSB0cnVlO1xuICAgIHZhciB0aW1lb3V0cyA9IGdldFRpbWVvdXRzKG9wdGlvbnMpO1xuICAgIGlmICgndXNlQmluYXJ5UHJvdG9jb2wnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA9IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuc3VwcG9ydHNCaW5hcnkgJiYgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLnByZWZlckJpbmFyeTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2xpZW50SWQpIHtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSAob3B0aW9ucy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9KTtcbiAgICAgICAgaGVhZGVyc1snWC1BYmx5LUNsaWVudElkJ10gPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy51dGY4RW5jb2RlKG9wdGlvbnMuY2xpZW50SWQpKTtcbiAgICB9XG4gICAgaWYgKCEoJ2lkZW1wb3RlbnRSZXN0UHVibGlzaGluZycgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucy5pZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wcm9taXNlcyAmJiAhcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5Qcm9taXNlKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9ucycsICd7cHJvbWlzZXM6IHRydWV9IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyBQcm9taXNlIGNvbnN0cnVjdG9yIGZvdW5kOyBkaXNhYmxpbmcgcHJvbWlzZXMnKTtcbiAgICAgICAgb3B0aW9ucy5wcm9taXNlcyA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXMgPSBudWxsO1xuICAgIHZhciBjb25uZWN0aXZpdHlDaGVja1VybCA9IG9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmw7XG4gICAgaWYgKG9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmwpIHtcbiAgICAgICAgdmFyIF9hID0gb3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybC5zcGxpdCgnPycpLCB1cmkgPSBfYVswXSwgcXMgPSBfYVsxXTtcbiAgICAgICAgY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXMgPSBxcyA/IFV0aWxzLnBhcnNlUXVlcnlTdHJpbmcocXMpIDoge307XG4gICAgICAgIGlmICh1cmkuaW5kZXhPZignOi8vJykgPT09IC0xKSB7XG4gICAgICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3Rpdml0eUNoZWNrVXJsID0gdXJpO1xuICAgIH1cbiAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyB1c2VCaW5hcnlQcm90b2NvbDogJ3VzZUJpbmFyeVByb3RvY29sJyBpbiBvcHRpb25zXG4gICAgICAgICAgICA/IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuc3VwcG9ydHNCaW5hcnkgJiYgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbFxuICAgICAgICAgICAgOiBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLnByZWZlckJpbmFyeSwgcmVhbHRpbWVIb3N0OiByZWFsdGltZUhvc3QsIHJlc3RIb3N0OiByZXN0SG9zdCwgbWF4TWVzc2FnZVNpemU6IG9wdGlvbnMubWF4TWVzc2FnZVNpemUgfHwgRGVmYXVsdHMubWF4TWVzc2FnZVNpemUsIHRpbWVvdXRzOiB0aW1lb3V0cywgY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXM6IGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zLCBjb25uZWN0aXZpdHlDaGVja1VybDogY29ubmVjdGl2aXR5Q2hlY2tVcmwgfSk7XG59XG5leHBvcnRzLm5vcm1hbGlzZU9wdGlvbnMgPSBub3JtYWxpc2VPcHRpb25zO1xuZXhwb3J0cy5kZWZhdWx0ID0gRGVmYXVsdHM7XG5mdW5jdGlvbiBnZXREZWZhdWx0cyhwbGF0Zm9ybURlZmF1bHRzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oRGVmYXVsdHMsIHBsYXRmb3JtRGVmYXVsdHMpO1xufVxuZXhwb3J0cy5nZXREZWZhdWx0cyA9IGdldERlZmF1bHRzO1xuXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbmZ1bmN0aW9uIG5vcm1hbGlzZUNvbnRleHQoY29udGV4dCkge1xuICAgIGlmICghY29udGV4dCB8fCAhY29udGV4dC5jaGFubmVsT3B0aW9ucykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbm5lbE9wdGlvbnM6IGNvbnRleHQsXG4gICAgICAgICAgICBwbHVnaW5zOiB7fSxcbiAgICAgICAgICAgIGJhc2VFbmNvZGVkUHJldmlvdXNQYXlsb2FkOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2lwaGVyT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jaXBoZXIpIHtcbiAgICAgICAgaWYgKCFwbGF0Zm9ybV8xLmRlZmF1bHQuQ3J5cHRvKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIG5vdCBlbmFibGVkOyB1c2UgYWJseS5lbmNyeXB0aW9uLmpzIGluc3RlYWQnKTtcbiAgICAgICAgdmFyIGNpcGhlciA9IHBsYXRmb3JtXzEuZGVmYXVsdC5DcnlwdG8uZ2V0Q2lwaGVyKG9wdGlvbnMuY2lwaGVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNpcGhlcjogY2lwaGVyLmNpcGhlclBhcmFtcyxcbiAgICAgICAgICAgIGNoYW5uZWxDaXBoZXI6IGNpcGhlci5jaXBoZXIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VTaXplKG1zZykge1xuICAgIHZhciBzaXplID0gMDtcbiAgICBpZiAobXNnLm5hbWUpIHtcbiAgICAgICAgc2l6ZSArPSBtc2cubmFtZS5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChtc2cuY2xpZW50SWQpIHtcbiAgICAgICAgc2l6ZSArPSBtc2cuY2xpZW50SWQubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobXNnLmV4dHJhcykge1xuICAgICAgICBzaXplICs9IEpTT04uc3RyaW5naWZ5KG1zZy5leHRyYXMpLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKG1zZy5kYXRhKSB7XG4gICAgICAgIHNpemUgKz0gVXRpbHMuZGF0YVNpemVCeXRlcyhtc2cuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxudmFyIE1lc3NhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVzc2FnZSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcmxvYWQgdG9KU09OKCkgdG8gaW50ZXJjZXB0IEpTT04uc3RyaW5naWZ5KClcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuICAgIE1lc3NhZ2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyogZW5jb2RlIGRhdGEgdG8gYmFzZTY0IGlmIHByZXNlbnQgYW5kIHdlJ3JlIHJldHVybmluZyByZWFsIEpTT047XG4gICAgICAgICAqIGFsdGhvdWdoIG1zZ3BhY2sgY2FsbHMgdG9KU09OKCksIHdlIGtub3cgaXQgaXMgYSBzdHJpbmdpZnkoKVxuICAgICAgICAgKiBjYWxsIGlmIGl0IGhhcyBhIG5vbi1lbXB0eSBhcmd1bWVudHMgbGlzdCAqL1xuICAgICAgICB2YXIgZW5jb2RpbmcgPSB0aGlzLmVuY29kaW5nO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgaWYgKGRhdGEgJiYgcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvKiBzdHJpbmdpZnkgY2FsbCAqL1xuICAgICAgICAgICAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgPyBlbmNvZGluZyArICcvYmFzZTY0JyA6ICdiYXNlNjQnO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogQ2FsbGVkIGJ5IG1zZ3BhY2suIHRvQnVmZmVyIHJldHVybnMgYSBkYXRhdHlwZSB1bmRlcnN0YW5kYWJsZSBieVxuICAgICAgICAgICAgICAgICAqIHRoYXQgcGxhdGZvcm0ncyBtc2dwYWNrIGltcGxlbWVudGF0aW9uIChCdWZmZXIgaW4gbm9kZSwgVWludDhBcnJheVxuICAgICAgICAgICAgICAgICAqIGluIGJyb3dzZXJzKSAqL1xuICAgICAgICAgICAgICAgIGRhdGEgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMudG9CdWZmZXIoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgICAgICBjb25uZWN0aW9uSWQ6IHRoaXMuY29ubmVjdGlvbklkLFxuICAgICAgICAgICAgY29ubmVjdGlvbktleTogdGhpcy5jb25uZWN0aW9uS2V5LFxuICAgICAgICAgICAgZXh0cmFzOiB0aGlzLmV4dHJhcyxcbiAgICAgICAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZXNzYWdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICdbTWVzc2FnZSc7XG4gICAgICAgIGlmICh0aGlzLm5hbWUpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgbmFtZT0nICsgdGhpcy5uYW1lO1xuICAgICAgICBpZiAodGhpcy5pZClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBpZD0nICsgdGhpcy5pZDtcbiAgICAgICAgaWYgKHRoaXMudGltZXN0YW1wKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IHRpbWVzdGFtcD0nICsgdGhpcy50aW1lc3RhbXA7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudElkKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGNsaWVudElkPScgKyB0aGlzLmNsaWVudElkO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uSWQpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgY29ubmVjdGlvbklkPScgKyB0aGlzLmNvbm5lY3Rpb25JZDtcbiAgICAgICAgaWYgKHRoaXMuZW5jb2RpbmcpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgZW5jb2Rpbmc9JyArIHRoaXMuZW5jb2Rpbmc7XG4gICAgICAgIGlmICh0aGlzLmV4dHJhcylcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBleHRyYXMgPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmV4dHJhcyk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5kYXRhID09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnOyBkYXRhPScgKyB0aGlzLmRhdGE7XG4gICAgICAgICAgICBlbHNlIGlmIChwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuaXNCdWZmZXIodGhpcy5kYXRhKSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJzsgZGF0YSAoYnVmZmVyKT0nICsgcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZSh0aGlzLmRhdGEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnOyBkYXRhIChqc29uKT0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leHRyYXMpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgZXh0cmFzPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmV4dHJhcyk7XG4gICAgICAgIHJlc3VsdCArPSAnXSc7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNZXNzYWdlLmVuY3J5cHQgPSBmdW5jdGlvbiAobXNnLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZGF0YSA9IG1zZy5kYXRhLCBlbmNvZGluZyA9IG1zZy5lbmNvZGluZywgY2lwaGVyID0gb3B0aW9ucy5jaGFubmVsQ2lwaGVyO1xuICAgICAgICBlbmNvZGluZyA9IGVuY29kaW5nID8gZW5jb2RpbmcgKyAnLycgOiAnJztcbiAgICAgICAgaWYgKCFwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMudXRmOEVuY29kZShTdHJpbmcoZGF0YSkpO1xuICAgICAgICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyArICd1dGYtOC8nO1xuICAgICAgICB9XG4gICAgICAgIGNpcGhlci5lbmNyeXB0KGRhdGEsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1zZy5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIG1zZy5lbmNvZGluZyA9IGVuY29kaW5nICsgJ2NpcGhlcisnICsgY2lwaGVyLmFsZ29yaXRobTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1zZyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWVzc2FnZS5lbmNvZGUgPSBmdW5jdGlvbiAobXNnLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZGF0YSA9IG1zZy5kYXRhO1xuICAgICAgICB2YXIgbmF0aXZlRGF0YVR5cGUgPSB0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJyB8fCBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuaXNCdWZmZXIoZGF0YSkgfHwgZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghbmF0aXZlRGF0YVR5cGUpIHtcbiAgICAgICAgICAgIGlmIChVdGlscy5pc09iamVjdChkYXRhKSB8fCBVdGlscy5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgbXNnLmRhdGEgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgICAgICAgICBtc2cuZW5jb2RpbmcgPSBtc2cuZW5jb2RpbmcgPyBtc2cuZW5jb2RpbmcgKyAnL2pzb24nIDogJ2pzb24nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0RhdGEgdHlwZSBpcyB1bnN1cHBvcnRlZCcsIDQwMDEzLCA0MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5jaXBoZXIpIHtcbiAgICAgICAgICAgIE1lc3NhZ2UuZW5jcnlwdChtc2csIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1zZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lc3NhZ2UuZW5jb2RlQXJyYXkgPSBmdW5jdGlvbiAobWVzc2FnZXMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBwcm9jZXNzZWQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBNZXNzYWdlLmVuY29kZShtZXNzYWdlc1tpXSwgb3B0aW9ucywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9jZXNzZWQrKztcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc2VkID09IG1lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtZXNzYWdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lc3NhZ2UuZGVjb2RlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGlucHV0Q29udGV4dCkge1xuICAgICAgICB2YXIgY29udGV4dCA9IG5vcm1hbGlzZUNvbnRleHQoaW5wdXRDb250ZXh0KTtcbiAgICAgICAgdmFyIGxhc3RQYXlsb2FkID0gbWVzc2FnZS5kYXRhO1xuICAgICAgICB2YXIgZW5jb2RpbmcgPSBtZXNzYWdlLmVuY29kaW5nO1xuICAgICAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHZhciB4Zm9ybXMgPSBlbmNvZGluZy5zcGxpdCgnLycpO1xuICAgICAgICAgICAgdmFyIGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4ID0gdm9pZCAwLCBlbmNvZGluZ3NUb1Byb2Nlc3MgPSB4Zm9ybXMubGVuZ3RoLCBkYXRhID0gbWVzc2FnZS5kYXRhO1xuICAgICAgICAgICAgdmFyIHhmb3JtID0gJyc7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgobGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXggPSBlbmNvZGluZ3NUb1Byb2Nlc3MpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc2VjdXJpdHkvZGV0ZWN0LXVuc2FmZS1yZWdleFxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSB4Zm9ybXNbLS1lbmNvZGluZ3NUb1Byb2Nlc3NdLm1hdGNoKC8oWy1cXHddKykoXFwrKFtcXHctXSspKT8vKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB4Zm9ybSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHhmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuYmFzZTY0RGVjb2RlKFN0cmluZyhkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4ID09IHhmb3Jtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFBheWxvYWQgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLnV0ZjhEZWNvZGUoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NpcGhlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuY2hhbm5lbE9wdGlvbnMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNoYW5uZWxPcHRpb25zLmNpcGhlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNoYW5uZWxPcHRpb25zLmNoYW5uZWxDaXBoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhmb3JtQWxnb3JpdGhtID0gbWF0Y2hbM10sIGNpcGhlciA9IGNvbnRleHQuY2hhbm5lbE9wdGlvbnMuY2hhbm5lbENpcGhlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZG9uJ3QgYXR0ZW1wdCB0byBkZWNyeXB0IHVubGVzcyB0aGUgY2lwaGVyIHBhcmFtcyBhcmUgY29tcGF0aWJsZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGZvcm1BbGdvcml0aG0gIT0gY2lwaGVyLmFsZ29yaXRobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZGVjcnlwdCBtZXNzYWdlIHdpdGggZ2l2ZW4gY2lwaGVyOyBpbmNvbXBhdGlibGUgY2lwaGVyIHBhcmFtcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBjaXBoZXIuZGVjcnlwdChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZWNyeXB0IG1lc3NhZ2U7IG5vdCBhbiBlbmNyeXB0ZWQgY2hhbm5lbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ZjZGlmZic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0LnBsdWdpbnMgfHwgIWNvbnRleHQucGx1Z2lucy52Y2RpZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ01pc3NpbmcgVmNkaWZmIGRlY29kZXIgKGh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5LWZvcmtzL3ZjZGlmZi1kZWNvZGVyKScsIDQwMDE5LCA0MDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdEZWx0YSBkZWNvZGluZyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3NlciAobmVlZCBBcnJheUJ1ZmZlciAmIFVpbnQ4QXJyYXkpJywgNDAwMjAsIDQwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YUJhc2UgPSBjb250ZXh0LmJhc2VFbmNvZGVkUHJldmlvdXNQYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlbHRhQmFzZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhQmFzZSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy51dGY4RW5jb2RlKGRlbHRhQmFzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogdmNkaWZmIGV4cGVjdHMgVWludDhBcnJheXMsIGNhbid0IGNvcHkgd2l0aCBBcnJheUJ1ZmZlcnMuIChhbHNvLCBpZiB3ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBkb24ndCBoYXZlIGEgVGV4dERlY29kZXIsIGRlbHRhQmFzZSBtaWdodCBiZSBhIFdvcmRBcnJheSBoZXJlLCBzbyBuZWVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRvIHByb2Nlc3MgaXQgaW50byBhIGJ1ZmZlciBhbnl3YXkpICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhQmFzZSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy50b0J1ZmZlcihkZWx0YUJhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLnRvQnVmZmVyKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLnR5cGVkQXJyYXlUb0J1ZmZlcihjb250ZXh0LnBsdWdpbnMudmNkaWZmLmRlY29kZShkYXRhLCBkZWx0YUJhc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFBheWxvYWQgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVmNkaWZmIGRlbHRhIGRlY29kZSBmYWlsZWQgd2l0aCAnICsgZSwgNDAwMTgsIDQwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IGU7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0Vycm9yIHByb2Nlc3NpbmcgdGhlICcgKyB4Zm9ybSArICcgZW5jb2RpbmcsIGRlY29kZXIgcmV0dXJuZWQg4oCYJyArIGVyci5tZXNzYWdlICsgJ+KAmScsIGVyci5jb2RlIHx8IDQwMDEzLCA0MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5lbmNvZGluZyA9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4IDw9IDAgPyBudWxsIDogeGZvcm1zLnNsaWNlKDAsIGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4KS5qb2luKCcvJyk7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmJhc2VFbmNvZGVkUHJldmlvdXNQYXlsb2FkID0gbGFzdFBheWxvYWQ7XG4gICAgfTtcbiAgICBNZXNzYWdlLmZyb21SZXNwb25zZUJvZHkgPSBmdW5jdGlvbiAoYm9keSwgb3B0aW9ucywgZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGJvZHkgPSBVdGlscy5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gKGJvZHlbaV0gPSBNZXNzYWdlLmZyb21WYWx1ZXMoYm9keVtpXSkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBNZXNzYWdlLmRlY29kZShtc2csIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ01lc3NhZ2UuZnJvbVJlc3BvbnNlQm9keSgpJywgZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm9keTtcbiAgICB9O1xuICAgIE1lc3NhZ2UuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IE1lc3NhZ2UoKSwgdmFsdWVzKTtcbiAgICB9O1xuICAgIE1lc3NhZ2UuZnJvbVZhbHVlc0FycmF5ID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICB2YXIgY291bnQgPSB2YWx1ZXMubGVuZ3RoLCByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspXG4gICAgICAgICAgICByZXN1bHRbaV0gPSBNZXNzYWdlLmZyb21WYWx1ZXModmFsdWVzW2ldKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE1lc3NhZ2UuZnJvbUVuY29kZWQgPSBmdW5jdGlvbiAoZW5jb2RlZCwgaW5wdXRPcHRpb25zKSB7XG4gICAgICAgIHZhciBtc2cgPSBNZXNzYWdlLmZyb21WYWx1ZXMoZW5jb2RlZCk7XG4gICAgICAgIHZhciBvcHRpb25zID0gbm9ybWFsaXplQ2lwaGVyT3B0aW9ucyhpbnB1dE9wdGlvbnMgIT09IG51bGwgJiYgaW5wdXRPcHRpb25zICE9PSB2b2lkIDAgPyBpbnB1dE9wdGlvbnMgOiBudWxsKTtcbiAgICAgICAgLyogaWYgZGVjb2RpbmcgZmFpbHMgYXQgYW55IHBvaW50LCBjYXRjaCBhbmQgcmV0dXJuIHRoZSBtZXNzYWdlIGRlY29kZWQgdG9cbiAgICAgICAgICogdGhlIGZ1bGxlc3QgZXh0ZW50IHBvc3NpYmxlICovXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBNZXNzYWdlLmRlY29kZShtc2csIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ01lc3NhZ2UuZnJvbUVuY29kZWQoKScsIGUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9O1xuICAgIE1lc3NhZ2UuZnJvbUVuY29kZWRBcnJheSA9IGZ1bmN0aW9uIChlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZWRBcnJheS5tYXAoZnVuY3Rpb24gKGVuY29kZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBNZXNzYWdlLmZyb21FbmNvZGVkKGVuY29kZWQsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBvbiBlbmNvZGUoKWQgKGFuZCBlbmNyeXB0KClkKSBNZXNzYWdlcyAoYXMgaXRcbiAgICAgKiBhc3N1bWVzIHRoZSBkYXRhIGlzIGEgc3RyaW5nIG9yIGJ1ZmZlcikgKi9cbiAgICBNZXNzYWdlLmdldE1lc3NhZ2VzU2l6ZSA9IGZ1bmN0aW9uIChtZXNzYWdlcykge1xuICAgICAgICB2YXIgbXNnLCB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG1zZyA9IG1lc3NhZ2VzW2ldO1xuICAgICAgICAgICAgdG90YWwgKz0gbXNnLnNpemUgfHwgKG1zZy5zaXplID0gZ2V0TWVzc2FnZVNpemUobXNnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH07XG4gICAgTWVzc2FnZS5zZXJpYWxpemUgPSBVdGlscy5lbmNvZGVCb2R5O1xuICAgIHJldHVybiBNZXNzYWdlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE1lc3NhZ2U7XG5cblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDkpKTtcbnZhciBwcmVzZW5jZW1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTUpKTtcbnZhciBhY3Rpb25zID0ge1xuICAgIEhFQVJUQkVBVDogMCxcbiAgICBBQ0s6IDEsXG4gICAgTkFDSzogMixcbiAgICBDT05ORUNUOiAzLFxuICAgIENPTk5FQ1RFRDogNCxcbiAgICBESVNDT05ORUNUOiA1LFxuICAgIERJU0NPTk5FQ1RFRDogNixcbiAgICBDTE9TRTogNyxcbiAgICBDTE9TRUQ6IDgsXG4gICAgRVJST1I6IDksXG4gICAgQVRUQUNIOiAxMCxcbiAgICBBVFRBQ0hFRDogMTEsXG4gICAgREVUQUNIOiAxMixcbiAgICBERVRBQ0hFRDogMTMsXG4gICAgUFJFU0VOQ0U6IDE0LFxuICAgIE1FU1NBR0U6IDE1LFxuICAgIFNZTkM6IDE2LFxuICAgIEFVVEg6IDE3LFxuICAgIEFDVElWQVRFOiAxOCxcbn07XG52YXIgQWN0aW9uTmFtZSA9IFtdO1xuT2JqZWN0LmtleXMoYWN0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIEFjdGlvbk5hbWVbYWN0aW9uc1tuYW1lXV0gPSBuYW1lO1xufSk7XG52YXIgZmxhZ3MgPSB7XG4gICAgLyogQ2hhbm5lbCBhdHRhY2ggc3RhdGUgZmxhZ3MgKi9cbiAgICBIQVNfUFJFU0VOQ0U6IDEgPDwgMCxcbiAgICBIQVNfQkFDS0xPRzogMSA8PCAxLFxuICAgIFJFU1VNRUQ6IDEgPDwgMixcbiAgICBUUkFOU0lFTlQ6IDEgPDwgNCxcbiAgICBBVFRBQ0hfUkVTVU1FOiAxIDw8IDUsXG4gICAgLyogQ2hhbm5lbCBtb2RlIGZsYWdzICovXG4gICAgUFJFU0VOQ0U6IDEgPDwgMTYsXG4gICAgUFVCTElTSDogMSA8PCAxNyxcbiAgICBTVUJTQ1JJQkU6IDEgPDwgMTgsXG4gICAgUFJFU0VOQ0VfU1VCU0NSSUJFOiAxIDw8IDE5LFxufTtcbnZhciBmbGFnTmFtZXMgPSBPYmplY3Qua2V5cyhmbGFncyk7XG5mbGFncy5NT0RFX0FMTCA9IGZsYWdzLlBSRVNFTkNFIHwgZmxhZ3MuUFVCTElTSCB8IGZsYWdzLlNVQlNDUklCRSB8IGZsYWdzLlBSRVNFTkNFX1NVQlNDUklCRTtcbmZ1bmN0aW9uIHRvU3RyaW5nQXJyYXkoYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgaWYgKGFycmF5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnWyAnICsgcmVzdWx0LmpvaW4oJywgJykgKyAnIF0nO1xufVxudmFyIHNpbXBsZUF0dHJpYnV0ZXMgPSAnaWQgY2hhbm5lbCBjaGFubmVsU2VyaWFsIGNvbm5lY3Rpb25JZCBjb3VudCBtc2dTZXJpYWwgdGltZXN0YW1wJy5zcGxpdCgnICcpO1xudmFyIFByb3RvY29sTWVzc2FnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcm90b2NvbE1lc3NhZ2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaGFzRmxhZyA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gKF90aGlzLmZsYWdzICYgZmxhZ3NbZmxhZ10pID4gMDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJvdG9jb2xNZXNzYWdlLnByb3RvdHlwZS5zZXRGbGFnID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzID0gdGhpcy5mbGFncyB8IGZsYWdzW2ZsYWddKTtcbiAgICB9O1xuICAgIFByb3RvY29sTWVzc2FnZS5wcm90b3R5cGUuZ2V0TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MgJiYgdGhpcy5mbGFncyAmIGZsYWdzLk1PREVfQUxMO1xuICAgIH07XG4gICAgUHJvdG9jb2xNZXNzYWdlLnByb3RvdHlwZS5lbmNvZGVNb2Rlc1RvRmxhZ3MgPSBmdW5jdGlvbiAobW9kZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbW9kZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kZSkgeyByZXR1cm4gX3RoaXMuc2V0RmxhZyhtb2RlKTsgfSk7XG4gICAgfTtcbiAgICBQcm90b2NvbE1lc3NhZ2UucHJvdG90eXBlLmRlY29kZU1vZGVzRnJvbUZsYWdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbW9kZXMgPSBbXTtcbiAgICAgICAgUHJvdG9jb2xNZXNzYWdlLmNoYW5uZWxNb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaGFzRmxhZyhtb2RlKSkge1xuICAgICAgICAgICAgICAgIG1vZGVzLnB1c2gobW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbW9kZXMubGVuZ3RoID4gMCA/IG1vZGVzIDogdW5kZWZpbmVkO1xuICAgIH07XG4gICAgUHJvdG9jb2xNZXNzYWdlLmZyb21WYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBQcm90b2NvbE1lc3NhZ2UoKSwgdmFsdWVzKTtcbiAgICB9O1xuICAgIFByb3RvY29sTWVzc2FnZS5BY3Rpb24gPSBhY3Rpb25zO1xuICAgIFByb3RvY29sTWVzc2FnZS5jaGFubmVsTW9kZXMgPSBbJ1BSRVNFTkNFJywgJ1BVQkxJU0gnLCAnU1VCU0NSSUJFJywgJ1BSRVNFTkNFX1NVQlNDUklCRSddO1xuICAgIFByb3RvY29sTWVzc2FnZS5BY3Rpb25OYW1lID0gQWN0aW9uTmFtZTtcbiAgICBQcm90b2NvbE1lc3NhZ2Uuc2VyaWFsaXplID0gVXRpbHMuZW5jb2RlQm9keTtcbiAgICBQcm90b2NvbE1lc3NhZ2UuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoc2VyaWFsaXplZCwgZm9ybWF0KSB7XG4gICAgICAgIHZhciBkZXNlcmlhbGl6ZWQgPSBVdGlscy5kZWNvZGVCb2R5KHNlcmlhbGl6ZWQsIGZvcm1hdCk7XG4gICAgICAgIHJldHVybiBQcm90b2NvbE1lc3NhZ2UuZnJvbURlc2VyaWFsaXplZChkZXNlcmlhbGl6ZWQpO1xuICAgIH07XG4gICAgUHJvdG9jb2xNZXNzYWdlLmZyb21EZXNlcmlhbGl6ZWQgPSBmdW5jdGlvbiAoZGVzZXJpYWxpemVkKSB7XG4gICAgICAgIHZhciBlcnJvciA9IGRlc2VyaWFsaXplZC5lcnJvcjtcbiAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgZGVzZXJpYWxpemVkLmVycm9yID0gZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKGVycm9yKTtcbiAgICAgICAgdmFyIG1lc3NhZ2VzID0gZGVzZXJpYWxpemVkLm1lc3NhZ2VzO1xuICAgICAgICBpZiAobWVzc2FnZXMpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzW2ldID0gbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyhtZXNzYWdlc1tpXSk7XG4gICAgICAgIHZhciBwcmVzZW5jZSA9IGRlc2VyaWFsaXplZC5wcmVzZW5jZTtcbiAgICAgICAgaWYgKHByZXNlbmNlKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVzZW5jZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBwcmVzZW5jZVtpXSA9IHByZXNlbmNlbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyhwcmVzZW5jZVtpXSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBQcm90b2NvbE1lc3NhZ2UoKSwgZGVzZXJpYWxpemVkKTtcbiAgICB9O1xuICAgIFByb3RvY29sTWVzc2FnZS5zdHJpbmdpZnkgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnW1Byb3RvY29sTWVzc2FnZSc7XG4gICAgICAgIGlmIChtc2cuYWN0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgYWN0aW9uPScgKyBQcm90b2NvbE1lc3NhZ2UuQWN0aW9uTmFtZVttc2cuYWN0aW9uXSB8fCBmYWxzZTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZTtcbiAgICAgICAgZm9yICh2YXIgYXR0cmliSW5kZXggPSAwOyBhdHRyaWJJbmRleCA8IHNpbXBsZUF0dHJpYnV0ZXMubGVuZ3RoOyBhdHRyaWJJbmRleCsrKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgPSBzaW1wbGVBdHRyaWJ1dGVzW2F0dHJpYkluZGV4XTtcbiAgICAgICAgICAgIGlmIChtc2dbYXR0cmlidXRlXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnOyAnICsgYXR0cmlidXRlICsgJz0nICsgbXNnW2F0dHJpYnV0ZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1zZy5tZXNzYWdlcylcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBtZXNzYWdlcz0nICsgdG9TdHJpbmdBcnJheShtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzQXJyYXkobXNnLm1lc3NhZ2VzKSk7XG4gICAgICAgIGlmIChtc2cucHJlc2VuY2UpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgcHJlc2VuY2U9JyArIHRvU3RyaW5nQXJyYXkocHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzQXJyYXkobXNnLnByZXNlbmNlKSk7XG4gICAgICAgIGlmIChtc2cuZXJyb3IpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgZXJyb3I9JyArIGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyhtc2cuZXJyb3IpLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChtc2cuYXV0aCAmJiBtc2cuYXV0aC5hY2Nlc3NUb2tlbilcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyB0b2tlbj0nICsgbXNnLmF1dGguYWNjZXNzVG9rZW47XG4gICAgICAgIGlmIChtc2cuZmxhZ3MpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgZmxhZ3M9JyArIGZsYWdOYW1lcy5maWx0ZXIobXNnLmhhc0ZsYWcpLmpvaW4oJywnKTtcbiAgICAgICAgaWYgKG1zZy5wYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBzdHJpbmdpZmllZFBhcmFtc18xID0gJyc7XG4gICAgICAgICAgICBVdGlscy5mb3JJbk93bk5vbk51bGxQcm9wZXJ0aWVzKG1zZy5wYXJhbXMsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZ2lmaWVkUGFyYW1zXzEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZmllZFBhcmFtc18xICs9ICc7ICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVkUGFyYW1zXzEgKz0gcHJvcCArICc9JyArIG1zZy5wYXJhbXNbcHJvcF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzdHJpbmdpZmllZFBhcmFtc18xLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJzsgcGFyYW1zPVsnICsgc3RyaW5naWZpZWRQYXJhbXNfMSArICddJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJ10nO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFByb3RvY29sTWVzc2FnZTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQcm90b2NvbE1lc3NhZ2U7XG5cblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEJhc2U2NCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJhc2U2NCA9IENfZW5jLkJhc2U2NCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBiYXNlNjRTdHJpbmcgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciBtYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGJhc2U2NENoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUxID0gKHdvcmRzW2kgPj4+IDJdICAgICAgID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICAgICAgICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMiA9ICh3b3Jkc1soaSArIDEpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMSkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTMgPSAod29yZHNbKGkgKyAyKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDIpICUgNCkgKiA4KSkgJiAweGZmO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgdHJpcGxldCA9IChieXRlMSA8PCAxNikgfCAoYnl0ZTIgPDwgOCkgfCBieXRlMztcblxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IChqIDwgNCkgJiYgKGkgKyBqICogMC43NSA8IHNpZ0J5dGVzKTsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChtYXAuY2hhckF0KCh0cmlwbGV0ID4+PiAoNiAqICgzIC0gaikpKSAmIDB4M2YpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuXHQgICAgICAgICAgICBpZiAocGFkZGluZ0NoYXIpIHtcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChiYXNlNjRDaGFycy5sZW5ndGggJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChwYWRkaW5nQ2hhcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gYmFzZTY0Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgQmFzZTY0IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0U3RyIFRoZSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UoYmFzZTY0U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGJhc2U2NFN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGJhc2U2NFN0ckxlbmd0aCA9IGJhc2U2NFN0ci5sZW5ndGg7XG5cdCAgICAgICAgICAgIHZhciBtYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuXHQgICAgICAgICAgICB2YXIgcmV2ZXJzZU1hcCA9IHRoaXMuX3JldmVyc2VNYXA7XG5cblx0ICAgICAgICAgICAgaWYgKCFyZXZlcnNlTWFwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcCA9IHRoaXMuX3JldmVyc2VNYXAgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcC5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwW21hcC5jaGFyQ29kZUF0KGopXSA9IGo7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSWdub3JlIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdDaGFyID0gbWFwLmNoYXJBdCg2NCk7XG5cdCAgICAgICAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdJbmRleCA9IGJhc2U2NFN0ci5pbmRleE9mKHBhZGRpbmdDaGFyKTtcblx0ICAgICAgICAgICAgICAgIGlmIChwYWRkaW5nSW5kZXggIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0U3RyTGVuZ3RoID0gcGFkZGluZ0luZGV4O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICByZXR1cm4gcGFyc2VMb29wKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCByZXZlcnNlTWFwKTtcblxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIHBhcnNlTG9vcChiYXNlNjRTdHIsIGJhc2U2NFN0ckxlbmd0aCwgcmV2ZXJzZU1hcCkge1xuXHQgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgdmFyIG5CeXRlcyA9IDA7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZTY0U3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGlmIChpICUgNCkge1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzMSA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSAtIDEpXSA8PCAoKGkgJSA0KSAqIDIpO1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzMiA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSldID4+PiAoNiAtIChpICUgNCkgKiAyKTtcblx0ICAgICAgICAgICAgICB2YXIgYml0c0NvbWJpbmVkID0gYml0czEgfCBiaXRzMjtcblx0ICAgICAgICAgICAgICB3b3Jkc1tuQnl0ZXMgPj4+IDJdIHw9IGJpdHNDb21iaW5lZCA8PCAoMjQgLSAobkJ5dGVzICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgICBuQnl0ZXMrKztcblx0ICAgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgbkJ5dGVzKTtcblx0ICAgIH1cblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuQmFzZTY0O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIHByb3RvY29sbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxMCkpO1xudmFyIHRyYW5zcG9ydF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyNikpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgZGVmYXVsdHNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOCkpO1xudmFyIGNvbm5lY3Rpb25lcnJvcnNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjApKTtcbnZhciBhdXRoXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBYSFJTdGF0ZXNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjEpKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG4vKiBUT0RPOiBjYW4gcmVtb3ZlIG9uY2UgcmVhbHRpbWUgc2VuZHMgcHJvdG9jb2wgbWVzc2FnZSByZXNwb25zZXMgZm9yIGNvbWV0IGVycm9ycyAqL1xuZnVuY3Rpb24gc2hvdWxkQmVFcnJvckFjdGlvbihlcnIpIHtcbiAgICB2YXIgVU5SRVNPTFZBQkxFX0VSUk9SX0NPREVTID0gWzgwMDE1LCA4MDAxNywgODAwMzBdO1xuICAgIGlmIChlcnIuY29kZSkge1xuICAgICAgICBpZiAoYXV0aF8xLmRlZmF1bHQuaXNUb2tlbkVycihlcnIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoVXRpbHMuYXJySW4oVU5SRVNPTFZBQkxFX0VSUk9SX0NPREVTLCBlcnIuY29kZSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVyci5jb2RlID49IDQwMDAwICYmIGVyci5jb2RlIDwgNTAwMDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKiBMaWtlbHkgYSBuZXR3b3JrIG9yIHRyYW5zcG9ydCBlcnJvciBvZiBzb21lIGtpbmQuIENlcnRhaW5seSBub3QgZmF0YWwgdG8gdGhlIGNvbm5lY3Rpb24gKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpIHtcbiAgICAvKiBlcnIgd2lsbCBiZSBlaXRoZXIgYSBsZWdhY3kgKG5vbi1wcm90b2NvbG1lc3NhZ2UpIGNvbWV0IGVycm9yIHJlc3BvbnNlXG4gICAgICogKHdoaWNoIHdpbGwgaGF2ZSBhbiBlcnIuY29kZSksIG9yIGEgeGhyL25ldHdvcmsgZXJyb3IgKHdoaWNoIHdvbid0KS4gKi9cbiAgICBpZiAoc2hvdWxkQmVFcnJvckFjdGlvbihlcnIpKSB7XG4gICAgICAgIHJldHVybiBbcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHsgYWN0aW9uOiBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LkFjdGlvbi5FUlJPUiwgZXJyb3I6IGVyciB9KV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW3Byb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyh7IGFjdGlvbjogcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5BY3Rpb24uRElTQ09OTkVDVEVELCBlcnJvcjogZXJyIH0pXTtcbiAgICB9XG59XG4vKlxuICogQSBiYXNlIGNvbWV0IHRyYW5zcG9ydCBjbGFzc1xuICovXG52YXIgQ29tZXRUcmFuc3BvcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ29tZXRUcmFuc3BvcnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29tZXRUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zLCAvKiBiaW5hcnkgbm90IHN1cHBvcnRlZCBmb3IgY29tZXQgc28gZm9yY2UgSlNPTiBwcm90b2NvbCAqLyB0cnVlKSB8fCB0aGlzO1xuICAgICAgICAvKiBGb3IgY29tZXQsIHdlIGNvdWxkIGRvIHRoZSBhdXRoIHVwZGF0ZSBieSBhYm9ydGluZyB0aGUgY3VycmVudCByZWN2IGFuZFxuICAgICAgICAgKiBzdGFydGluZyBhIG5ldyBvbmUgd2l0aCB0aGUgbmV3IHRva2VuLCB0aGF0J2QgYmUgc3VmZmljaWVudCBmb3IgcmVhbHRpbWUuXG4gICAgICAgICAqIFByb2JsZW0gaXMgSlNPTlAgLSB5b3UgY2FuJ3QgY2FuY2VsIHRydWx5IGFib3J0IGEgcmVjdiBvbmNlIHN0YXJ0ZWQuIFNvXG4gICAgICAgICAqIHdlIG5lZWQgdG8gc2VuZCBhbiBBVVRIIGZvciBqc29ucC4gSW4gd2hpY2ggY2FzZSBpdCdzIHNpbXBsZXIgdG8ga2VlcCBhbGxcbiAgICAgICAgICogY29tZXQgdHJhbnNwb3J0cyB0aGUgc2FtZSBhbmQgZG8gaXQgZm9yIGFsbCBvZiB0aGVtLiBTbyB3ZSBzZW5kIHRoZSBBVVRIXG4gICAgICAgICAqIGluc3RlYWQsIGFuZCBkb24ndCBuZWVkIHRvIGFib3J0IHRoZSByZWN2ICovXG4gICAgICAgIF90aGlzLm9uQXV0aFVwZGF0ZWQgPSBmdW5jdGlvbiAodG9rZW5EZXRhaWxzKSB7XG4gICAgICAgICAgICBfdGhpcy5hdXRoUGFyYW1zID0geyBhY2Nlc3NfdG9rZW46IHRva2VuRGV0YWlscy50b2tlbiB9O1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zdHJlYW0gPSAnc3RyZWFtJyBpbiBwYXJhbXMgPyBwYXJhbXMuc3RyZWFtIDogdHJ1ZTtcbiAgICAgICAgX3RoaXMuc2VuZFJlcXVlc3QgPSBudWxsO1xuICAgICAgICBfdGhpcy5yZWN2UmVxdWVzdCA9IG51bGw7XG4gICAgICAgIF90aGlzLnBlbmRpbmdDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIF90aGlzLnBlbmRpbmdJdGVtcyA9IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29tZXRUcmFuc3BvcnQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29tZXRUcmFuc3BvcnQuY29ubmVjdCgpJywgJ3N0YXJ0aW5nJyk7XG4gICAgICAgIHRyYW5zcG9ydF8xLmRlZmF1bHQucHJvdG90eXBlLmNvbm5lY3QuY2FsbCh0aGlzKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zO1xuICAgICAgICB2YXIgaG9zdCA9IGRlZmF1bHRzXzEuZGVmYXVsdC5nZXRIb3N0KG9wdGlvbnMsIHBhcmFtcy5ob3N0KTtcbiAgICAgICAgdmFyIHBvcnQgPSBkZWZhdWx0c18xLmRlZmF1bHQuZ2V0UG9ydChvcHRpb25zKTtcbiAgICAgICAgdmFyIGNvbWV0U2NoZW1lID0gb3B0aW9ucy50bHMgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nO1xuICAgICAgICB0aGlzLmJhc2VVcmkgPSBjb21ldFNjaGVtZSArIGhvc3QgKyAnOicgKyBwb3J0ICsgJy9jb21ldC8nO1xuICAgICAgICB2YXIgY29ubmVjdFVyaSA9IHRoaXMuYmFzZVVyaSArICdjb25uZWN0JztcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5jb25uZWN0KCknLCAndXJpOiAnICsgY29ubmVjdFVyaSk7XG4gICAgICAgIHRoaXMuYXV0aC5nZXRBdXRoUGFyYW1zKGZ1bmN0aW9uIChlcnIsIGF1dGhQYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kaXNjb25uZWN0KGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5hdXRoUGFyYW1zID0gYXV0aFBhcmFtcztcbiAgICAgICAgICAgIHZhciBjb25uZWN0UGFyYW1zID0gX3RoaXMucGFyYW1zLmdldENvbm5lY3RQYXJhbXMoYXV0aFBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoJ3N0cmVhbScgaW4gY29ubmVjdFBhcmFtcylcbiAgICAgICAgICAgICAgICBfdGhpcy5zdHJlYW0gPSBjb25uZWN0UGFyYW1zLnN0cmVhbTtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29tZXRUcmFuc3BvcnQuY29ubmVjdCgpJywgJ2Nvbm5lY3RQYXJhbXM6JyArIFV0aWxzLnRvUXVlcnlTdHJpbmcoY29ubmVjdFBhcmFtcykpO1xuICAgICAgICAgICAgLyogdGhpcyB3aWxsIGJlIHRoZSAncmVjdlJlcXVlc3QnIHNvIHRoaXMgY29ubmVjdGlvbiBjYW4gc3RyZWFtIG1lc3NhZ2VzICovXG4gICAgICAgICAgICB2YXIgcHJlY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgY29ubmVjdFJlcXVlc3QgPSAoX3RoaXMucmVjdlJlcXVlc3QgPSBfdGhpcy5jcmVhdGVSZXF1ZXN0KGNvbm5lY3RVcmksIG51bGwsIGNvbm5lY3RQYXJhbXMsIG51bGwsIF90aGlzLnN0cmVhbSA/IFhIUlN0YXRlc18xLmRlZmF1bHQuUkVRX1JFQ1ZfU1RSRUFNIDogWEhSU3RhdGVzXzEuZGVmYXVsdC5SRVFfUkVDVikpO1xuICAgICAgICAgICAgY29ubmVjdFJlcXVlc3Qub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMucmVjdlJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogdGhlIHRyYW5zcG9ydCB3YXMgZGlzcG9zZWQgYmVmb3JlIHdlIGNvbm5lY3RlZCAqL1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcHJlY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3ByZWNvbm5lY3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMub25EYXRhKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25uZWN0UmVxdWVzdC5vbignY29tcGxldGUnLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5yZWN2UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAvKiB0aGUgdHJhbnNwb3J0IHdhcyBkaXNwb3NlZCBiZWZvcmUgd2UgY29ubmVjdGVkICovXG4gICAgICAgICAgICAgICAgICAgIGVyciA9IGVyciB8fCBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnUmVxdWVzdCBjYW5jZWxsZWQnLCA4MDAwMywgNDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8qIENvbm5lY3QgcmVxdWVzdCBtYXkgY29tcGxldGUgd2l0aG91dCBhIGVtaXR0aW5nICdkYXRhJyBldmVudCBzaW5jZSB0aGF0IGlzIG5vdFxuICAgICAgICAgICAgICAgICAqIGVtaXR0ZWQgZm9yIGUuZy4gYSBub24tc3RyZWFtZWQgZXJyb3IgcmVzcG9uc2UuIFN0aWxsIGltcGxpZXMgcHJlY29ubmVjdC4gKi9cbiAgICAgICAgICAgICAgICBpZiAoIXByZWNvbm5lY3RlZCAmJiAhZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3ByZWNvbm5lY3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMub25BY3Rpdml0eSgpO1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBBIHByb3RvY29sIGVycm9yIHJlY2VpdmVkIGZyb20gcmVhbHRpbWUuIFRPRE86IG9uY2UgcmVhbHRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGNvbnNpc3RlbmRseSBzZW5kcyBlcnJvcnMgd3JhcHBlZCBpbiBwcm90b2NvbCBtZXNzYWdlcywgc2hvdWxkIGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBhYmxlIHRvIHJlbW92ZSB0aGlzICovXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkRhdGEocHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogQSBuZXR3b3JrL3hociBlcnJvci4gRG9uJ3QgYm90aGVyIHdyYXBwaW5nIGluIGEgcHJvdG9jb2wgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGp1c3QgZGlzY29ubmVjdCB0aGUgdHJhbnNwb3J0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNjb25uZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVjdigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25uZWN0UmVxdWVzdC5leGVjKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnJlcXVlc3RDbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5yZXF1ZXN0Q2xvc2UoKScpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QodHJ1ZSk7XG4gICAgfTtcbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUucmVxdWVzdERpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29tZXRUcmFuc3BvcnQucmVxdWVzdERpc2Nvbm5lY3QoKScpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QoZmFsc2UpO1xuICAgIH07XG4gICAgQ29tZXRUcmFuc3BvcnQucHJvdG90eXBlLl9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoY2xvc2luZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2xvc2VPckRpc2Nvbm5lY3RVcmkgPSBjbG9zaW5nID8gdGhpcy5jbG9zZVVyaSA6IHRoaXMuZGlzY29ubmVjdFVyaTtcbiAgICAgICAgaWYgKGNsb3NlT3JEaXNjb25uZWN0VXJpKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChjbG9zZU9yRGlzY29ubmVjdFVyaSwgbnVsbCwgdGhpcy5hdXRoUGFyYW1zLCBudWxsLCBYSFJTdGF0ZXNfMS5kZWZhdWx0LlJFUV9TRU5EKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDb21ldFRyYW5zcG9ydC5yZXF1ZXN0JyArIChjbG9zaW5nID8gJ0Nsb3NlKCknIDogJ0Rpc2Nvbm5lY3QoKScpLCAncmVxdWVzdCByZXR1cm5lZCBlcnIgPSAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXF1ZXN0LmV4ZWMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tZXRUcmFuc3BvcnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29tZXRUcmFuc3BvcnQuZGlzcG9zZSgpJywgJycpO1xuICAgICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlY3ZSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5kaXNwb3NlKCknLCAnYWJvcnRpbmcgcmVjdiByZXF1ZXN0Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWN2UmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogSW4gYWxtb3N0IGFsbCBjYXNlcyB0aGUgdHJhbnNwb3J0IHdpbGwgYmUgZmluaXNoZWQgYmVmb3JlIGl0J3NcbiAgICAgICAgICAgICAqIGRpc3Bvc2VkLiBGaW5pc2ggaGVyZSBqdXN0IHRvIG1ha2Ugc3VyZS4gKi9cbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCdkaXNjb25uZWN0ZWQnLCBjb25uZWN0aW9uZXJyb3JzXzEuZGVmYXVsdC5kaXNjb25uZWN0ZWQoKSk7XG4gICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdkaXNwb3NlZCcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkNvbm5lY3QgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8qIGlmIHRoaXMgdHJhbnNwb3J0IGhhcyBiZWVuIGRpc3Bvc2VkIHdoaWxzdCBhd2FpdGluZyBjb25uZWN0aW9uLCBkbyBub3RoaW5nICovXG4gICAgICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiB0aGUgY29ubmVjdGlvbktleSBpbiBhIGNvbWV0IGNvbm5lY3RlZCByZXNwb25zZSBpcyByZWFsbHlcbiAgICAgICAgICogPGluc3RJZD4tPGNvbm5lY3Rpb25LZXk+ICovXG4gICAgICAgIHZhciBjb25uZWN0aW9uU3RyID0gKF9hID0gbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbm5lY3Rpb25LZXk7XG4gICAgICAgIHRyYW5zcG9ydF8xLmRlZmF1bHQucHJvdG90eXBlLm9uQ29ubmVjdC5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICB2YXIgYmFzZUNvbm5lY3Rpb25VcmkgPSB0aGlzLmJhc2VVcmkgKyBjb25uZWN0aW9uU3RyO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0NvbWV0VHJhbnNwb3J0Lm9uQ29ubmVjdCgpJywgJ2Jhc2VVcmkgPSAnICsgYmFzZUNvbm5lY3Rpb25VcmkpO1xuICAgICAgICB0aGlzLnNlbmRVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArICcvc2VuZCc7XG4gICAgICAgIHRoaXMucmVjdlVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgJy9yZWN2JztcbiAgICAgICAgdGhpcy5jbG9zZVVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgJy9jbG9zZSc7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdFVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgJy9kaXNjb25uZWN0JztcbiAgICB9O1xuICAgIENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VuZFJlcXVlc3QpIHtcbiAgICAgICAgICAgIC8qIHRoZXJlIGlzIGEgcGVuZGluZyBzZW5kLCBzbyBxdWV1ZSB0aGlzIG1lc3NhZ2UgKi9cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0l0ZW1zID0gdGhpcy5wZW5kaW5nSXRlbXMgfHwgW107XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdJdGVtcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIHNlbmQgdGhpcywgcGx1cyBhbnkgcGVuZGluZywgbm93ICovXG4gICAgICAgIHZhciBwZW5kaW5nSXRlbXMgPSB0aGlzLnBlbmRpbmdJdGVtcyB8fCBbXTtcbiAgICAgICAgcGVuZGluZ0l0ZW1zLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIHRoaXMucGVuZGluZ0l0ZW1zID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZW5kSXRlbXMocGVuZGluZ0l0ZW1zKTtcbiAgICB9O1xuICAgIENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kQW55UGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBlbmRpbmdJdGVtcyA9IHRoaXMucGVuZGluZ0l0ZW1zO1xuICAgICAgICBpZiAoIXBlbmRpbmdJdGVtcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ0l0ZW1zID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZW5kSXRlbXMocGVuZGluZ0l0ZW1zKTtcbiAgICB9O1xuICAgIENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kSXRlbXMgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNlbmRSZXF1ZXN0ID0gKHRoaXMuc2VuZFJlcXVlc3QgPSB0aGlzLmNyZWF0ZVJlcXVlc3QodGhpcy5zZW5kVXJpLCBudWxsLCB0aGlzLmF1dGhQYXJhbXMsIHRoaXMuZW5jb2RlUmVxdWVzdChpdGVtcyksIFhIUlN0YXRlc18xLmRlZmF1bHQuUkVRX1NFTkQpKTtcbiAgICAgICAgc2VuZFJlcXVlc3Qub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0NvbWV0VHJhbnNwb3J0LnNlbmRJdGVtcygpJywgJ29uIGNvbXBsZXRlOiBlcnIgPSAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuICAgICAgICAgICAgX3RoaXMuc2VuZFJlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgLyogdGhlIHJlc3VsdCBvZiB0aGUgcmVxdWVzdCwgZXZlbiBpZiBhIG5hY2ssIGlzIHVzdWFsbHkgYSBwcm90b2NvbCByZXNwb25zZVxuICAgICAgICAgICAgICogY29udGFpbmVkIGluIHRoZSBkYXRhLiBBbiBlcnIgaXMgYW5vbW9sb3VzLCBhbmQgaW5kaWNhdGVzIHNvbWUgaXNzdWUgd2l0aCB0aGVcbiAgICAgICAgICAgICAqIG5ldHdvcmssdHJhbnNwb3J0LCBvciBjb25uZWN0aW9uICovXG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIEEgcHJvdG9jb2wgZXJyb3IgcmVjZWl2ZWQgZnJvbSByZWFsdGltZS4gVE9ETzogb25jZSByZWFsdGltZVxuICAgICAgICAgICAgICAgICAgICAgKiBjb25zaXN0ZW5kbHkgc2VuZHMgZXJyb3JzIHdyYXBwZWQgaW4gcHJvdG9jb2wgbWVzc2FnZXMsIHNob3VsZCBiZVxuICAgICAgICAgICAgICAgICAgICAgKiBhYmxlIHRvIHJlbW92ZSB0aGlzICovXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uRGF0YShwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKiBBIG5ldHdvcmsveGhyIGVycm9yLiBEb24ndCBib3RoZXIgd3JhcHBpbmcgaW4gYSBwcm90b2NvbCBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgKiBqdXN0IGRpc2Nvbm5lY3QgdGhlIHRyYW5zcG9ydCAqL1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNjb25uZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25EYXRhKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLnBlbmRpbmdJdGVtcykge1xuICAgICAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvKiBJZiB0aGVyZSdzIGEgbmV3IHNlbmQgcmVxdWVzdCBieSBub3csIGFueSBwZW5kaW5nIGl0ZW1zIHdpbGwgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAgKiBiZWVuIHBpY2tlZCB1cCBieSB0aGF0OyBhbnkgbmV3IG9uZXMgYWRkZWQgc2luY2UgdGhlbiB3aWxsIGJlXG4gICAgICAgICAgICAgICAgICAgICAqIHBpY2tlZCB1cCBhZnRlciB0aGF0IG9uZSBjb21wbGV0ZXMgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5zZW5kUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VuZEFueVBlbmRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2VuZFJlcXVlc3QuZXhlYygpO1xuICAgIH07XG4gICAgQ29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnJlY3YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qIGRvIG5vdGhpbmcgaWYgdGhlcmUgaXMgYW4gYWN0aXZlIHJlcXVlc3QsIHdoaWNoIG1pZ2h0IGJlIHN0cmVhbWluZyAqL1xuICAgICAgICBpZiAodGhpcy5yZWN2UmVxdWVzdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLyogSWYgd2UncmUgbm8gbG9uZ2VyIGNvbm5lY3RlZCwgZG8gbm90aGluZyAqL1xuICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciByZWN2UmVxdWVzdCA9ICh0aGlzLnJlY3ZSZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KHRoaXMucmVjdlVyaSwgbnVsbCwgdGhpcy5hdXRoUGFyYW1zLCBudWxsLCB0aGlzLnN0cmVhbSA/IFhIUlN0YXRlc18xLmRlZmF1bHQuUkVRX1JFQ1ZfU1RSRUFNIDogWEhSU3RhdGVzXzEuZGVmYXVsdC5SRVFfUkVDVl9QT0xMKSk7XG4gICAgICAgIHJlY3ZSZXF1ZXN0Lm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIF90aGlzLm9uRGF0YShkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlY3ZSZXF1ZXN0Lm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIF90aGlzLnJlY3ZSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIC8qIEEgcmVxdWVzdCBjb21wbGV0aW5nIG11c3QgYmUgY29uc2lkZXJlZCBhY3Rpdml0eSwgYXMgcmVhbHRpbWUgc2VuZHNcbiAgICAgICAgICAgICAqIGhlYXJ0YmVhdHMgZXZlcnkgMTVzIHNpbmNlIGEgcmVxdWVzdCBiZWdhbiwgbm90IGV2ZXJ5IDE1cyBhYnNvbHV0ZWx5ICovXG4gICAgICAgICAgICBfdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIEEgcHJvdG9jb2wgZXJyb3IgcmVjZWl2ZWQgZnJvbSByZWFsdGltZS4gVE9ETzogb25jZSByZWFsdGltZVxuICAgICAgICAgICAgICAgICAgICAgKiBjb25zaXN0ZW50bHkgc2VuZHMgZXJyb3JzIHdyYXBwZWQgaW4gcHJvdG9jb2wgbWVzc2FnZXMsIHNob3VsZCBiZVxuICAgICAgICAgICAgICAgICAgICAgKiBhYmxlIHRvIHJlbW92ZSB0aGlzICovXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uRGF0YShwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKiBBIG5ldHdvcmsveGhyIGVycm9yLiBEb24ndCBib3RoZXIgd3JhcHBpbmcgaW4gYSBwcm90b2NvbCBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgKiBqdXN0IGRpc2Nvbm5lY3QgdGhlIHRyYW5zcG9ydCAqL1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNjb25uZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlY3YoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVjdlJlcXVlc3QuZXhlYygpO1xuICAgIH07XG4gICAgQ29tZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChyZXNwb25zZURhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHRoaXMuZGVjb2RlUmVzcG9uc2UocmVzcG9uc2VEYXRhKTtcbiAgICAgICAgICAgIGlmIChpdGVtcyAmJiBpdGVtcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblByb3RvY29sTWVzc2FnZShwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21EZXNlcmlhbGl6ZWQoaXRlbXNbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDb21ldFRyYW5zcG9ydC5vbkRhdGEoKScsICdVbmV4cGVjdGVkIGV4Y2VwdGlvbiBoYW5kaW5nIGNoYW5uZWwgZXZlbnQ6ICcgKyBlLnN0YWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tZXRUcmFuc3BvcnQucHJvdG90eXBlLmVuY29kZVJlcXVlc3QgPSBmdW5jdGlvbiAocmVxdWVzdEl0ZW1zKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0SXRlbXMpO1xuICAgIH07XG4gICAgQ29tZXRUcmFuc3BvcnQucHJvdG90eXBlLmRlY29kZVJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlRGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlRGF0YSA9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3BvbnNlRGF0YSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZURhdGE7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tZXRUcmFuc3BvcnQ7XG59KHRyYW5zcG9ydF8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENvbWV0VHJhbnNwb3J0O1xuXG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIGF1dGhfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTcpKTtcbnZhciBIdHRwTWV0aG9kc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxOCkpO1xudmFyIGVycm9yaW5mb18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbmZ1bmN0aW9uIHdpdGhBdXRoRGV0YWlscyhyZXN0LCBoZWFkZXJzLCBwYXJhbXMsIGVyckNhbGxiYWNrLCBvcENhbGxiYWNrKSB7XG4gICAgaWYgKHJlc3QuaHR0cC5zdXBwb3J0c0F1dGhIZWFkZXJzKSB7XG4gICAgICAgIHJlc3QuYXV0aC5nZXRBdXRoSGVhZGVycyhmdW5jdGlvbiAoZXJyLCBhdXRoSGVhZGVycykge1xuICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICBlcnJDYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9wQ2FsbGJhY2soVXRpbHMubWl4aW4oYXV0aEhlYWRlcnMsIGhlYWRlcnMpLCBwYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3QuYXV0aC5nZXRBdXRoUGFyYW1zKGZ1bmN0aW9uIChlcnIsIGF1dGhQYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgZXJyQ2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvcENhbGxiYWNrKGhlYWRlcnMsIFV0aWxzLm1peGluKGF1dGhQYXJhbXMsIHBhcmFtcykpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiB1bmVudmVsb3BlKGNhbGxiYWNrLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVyciwgYm9keSwgb3V0ZXJIZWFkZXJzLCB1bnBhY2tlZCwgb3V0ZXJTdGF0dXNDb2RlKSB7XG4gICAgICAgIGlmIChlcnIgJiYgIWJvZHkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1bnBhY2tlZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBib2R5ID0gVXRpbHMuZGVjb2RlQm9keShib2R5LCBmb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoVXRpbHMuaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm8oZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbyhVdGlscy5pbnNwZWN0RXJyb3IoZSksIG51bGwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYm9keSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ3VuZW52ZWxvcGUoKTogUmVzcG9uc2UgYm9keSBpcyBtaXNzaW5nJywgbnVsbCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IGJvZHksIHdyYXBwZWRTdGF0dXNDb2RlID0gX2Euc3RhdHVzQ29kZSwgcmVzcG9uc2UgPSBfYS5yZXNwb25zZSwgd3JhcHBlZEhlYWRlcnMgPSBfYS5oZWFkZXJzO1xuICAgICAgICBpZiAod3JhcHBlZFN0YXR1c0NvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLyogRW52ZWxvcGUgYWxyZWFkeSB1bndyYXBwZWQgYnkgdGhlIHRyYW5zcG9ydCAqL1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBib2R5LCBvdXRlckhlYWRlcnMsIHRydWUsIG91dGVyU3RhdHVzQ29kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBwZWRTdGF0dXNDb2RlIDwgMjAwIHx8IHdyYXBwZWRTdGF0dXNDb2RlID49IDMwMCkge1xuICAgICAgICAgICAgLyogaGFuZGxlIHdyYXBwZWQgZXJyb3JzICovXG4gICAgICAgICAgICB2YXIgd3JhcHBlZEVyciA9IChyZXNwb25zZSAmJiByZXNwb25zZS5lcnJvcikgfHwgZXJyO1xuICAgICAgICAgICAgaWYgKCF3cmFwcGVkRXJyKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlZEVyciA9IG5ldyBFcnJvcignRXJyb3IgaW4gdW5lbnZlbG9waW5nICcgKyBib2R5KTtcbiAgICAgICAgICAgICAgICB3cmFwcGVkRXJyLnN0YXR1c0NvZGUgPSB3cmFwcGVkU3RhdHVzQ29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKHdyYXBwZWRFcnIsIHJlc3BvbnNlLCB3cmFwcGVkSGVhZGVycywgdHJ1ZSwgd3JhcHBlZFN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIHdyYXBwZWRIZWFkZXJzLCB0cnVlLCB3cmFwcGVkU3RhdHVzQ29kZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhcmFtU3RyaW5nKHBhcmFtcykge1xuICAgIHZhciBwYXJhbVBhaXJzID0gW107XG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgICBmb3IgKHZhciBuZWVkbGUgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbVBhaXJzLnB1c2gobmVlZGxlICsgJz0nICsgcGFyYW1zW25lZWRsZV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJhbVBhaXJzLmpvaW4oJyYnKTtcbn1cbmZ1bmN0aW9uIHVybEZyb21QYXRoQW5kUGFyYW1zKHBhdGgsIHBhcmFtcykge1xuICAgIHJldHVybiBwYXRoICsgKHBhcmFtcyA/ICc/JyA6ICcnKSArIHBhcmFtU3RyaW5nKHBhcmFtcyk7XG59XG5mdW5jdGlvbiBsb2dSZXNwb25zZUhhbmRsZXIoY2FsbGJhY2ssIG1ldGhvZCwgcGF0aCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVzb3VyY2UuJyArIG1ldGhvZCArICcoKScsICdSZWNlaXZlZCBFcnJvcjsgJyArIHVybEZyb21QYXRoQW5kUGFyYW1zKHBhdGgsIHBhcmFtcykgKyAnOyBFcnJvcjogJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVzb3VyY2UuJyArIG1ldGhvZCArICcoKScsICdSZWNlaXZlZDsgJyArXG4gICAgICAgICAgICAgICAgdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSArXG4gICAgICAgICAgICAgICAgJzsgSGVhZGVyczogJyArXG4gICAgICAgICAgICAgICAgcGFyYW1TdHJpbmcoaGVhZGVycykgK1xuICAgICAgICAgICAgICAgICc7IFN0YXR1c0NvZGU6ICcgK1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgK1xuICAgICAgICAgICAgICAgICc7IEJvZHk6ICcgK1xuICAgICAgICAgICAgICAgIChwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuaXNCdWZmZXIoYm9keSkgPyBib2R5LnRvU3RyaW5nKCkgOiBib2R5KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG52YXIgUmVzb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzb3VyY2UoKSB7XG4gICAgfVxuICAgIFJlc291cmNlLmdldCA9IGZ1bmN0aW9uIChyZXN0LCBwYXRoLCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjaykge1xuICAgICAgICBSZXNvdXJjZS5kbyhIdHRwTWV0aG9kc18xLmRlZmF1bHQuR2V0LCByZXN0LCBwYXRoLCBudWxsLCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZXNvdXJjZS5kZWxldGUgPSBmdW5jdGlvbiAocmVzdCwgcGF0aCwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spIHtcbiAgICAgICAgUmVzb3VyY2UuZG8oSHR0cE1ldGhvZHNfMS5kZWZhdWx0LkRlbGV0ZSwgcmVzdCwgcGF0aCwgbnVsbCwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVzb3VyY2UucG9zdCA9IGZ1bmN0aW9uIChyZXN0LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjaykge1xuICAgICAgICBSZXNvdXJjZS5kbyhIdHRwTWV0aG9kc18xLmRlZmF1bHQuUG9zdCwgcmVzdCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVzb3VyY2UucGF0Y2ggPSBmdW5jdGlvbiAocmVzdCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spIHtcbiAgICAgICAgUmVzb3VyY2UuZG8oSHR0cE1ldGhvZHNfMS5kZWZhdWx0LlBhdGNoLCByZXN0LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZXNvdXJjZS5wdXQgPSBmdW5jdGlvbiAocmVzdCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spIHtcbiAgICAgICAgUmVzb3VyY2UuZG8oSHR0cE1ldGhvZHNfMS5kZWZhdWx0LlB1dCwgcmVzdCwgcGF0aCwgYm9keSwgaGVhZGVycywgcGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVzb3VyY2UuZG8gPSBmdW5jdGlvbiAobWV0aG9kLCByZXN0LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAobG9nZ2VyXzEuZGVmYXVsdC5zaG91bGRMb2cobG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGxvZ1Jlc3BvbnNlSGFuZGxlcihjYWxsYmFjaywgbWV0aG9kLCBwYXRoLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnZlbG9wZSkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB1bmVudmVsb3BlKGNhbGxiYWNrLCBlbnZlbG9wZSk7XG4gICAgICAgICAgICAocGFyYW1zID0gcGFyYW1zIHx8IHt9KVsnZW52ZWxvcGUnXSA9IGVudmVsb3BlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRvUmVxdWVzdChoZWFkZXJzLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChsb2dnZXJfMS5kZWZhdWx0LnNob3VsZExvZyhsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1Jlc291cmNlLicgKyBtZXRob2QgKyAnKCknLCAnU2VuZGluZzsgJyArIHVybEZyb21QYXRoQW5kUGFyYW1zKHBhdGgsIHBhcmFtcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvZ2dlcl8xLmRlZmF1bHQuc2hvdWxkTG9nKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWNvZGVkQm9keSA9IGJvZHk7XG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSBoZWFkZXJzWydjb250ZW50LXR5cGUnXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluZGV4T2YoJ21zZ3BhY2snKSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQm9keSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubXNncGFjay5kZWNvZGUoYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGRlY29kZUVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZXNvdXJjZS4nICsgbWV0aG9kICsgJygpJywgJ1NlbmRpbmcgTXNnUGFjayBEZWNvZGluZyBFcnJvcjogJyArIFV0aWxzLmluc3BlY3RFcnJvcihkZWNvZGVFcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1Jlc291cmNlLicgKyBtZXRob2QgKyAnKCknLCAnU2VuZGluZzsgJyArIHVybEZyb21QYXRoQW5kUGFyYW1zKHBhdGgsIHBhcmFtcykgKyAnOyBCb2R5OiAnICsgZGVjb2RlZEJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdC5odHRwLmRvKG1ldGhvZCwgcmVzdCwgcGF0aCwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBmdW5jdGlvbiAoZXJyLCByZXMsIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciAmJiBhdXRoXzEuZGVmYXVsdC5pc1Rva2VuRXJyKGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogdG9rZW4gaGFzIGV4cGlyZWQsIHNvIGdldCBhIG5ldyBvbmUgKi9cbiAgICAgICAgICAgICAgICAgICAgcmVzdC5hdXRoLmF1dGhvcml6ZShudWxsLCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiByZXRyeSAuLi4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhBdXRoRGV0YWlscyhyZXN0LCBoZWFkZXJzLCBwYXJhbXMsIGNhbGxiYWNrLCBkb1JlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlcywgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgd2l0aEF1dGhEZXRhaWxzKHJlc3QsIGhlYWRlcnMsIHBhcmFtcywgY2FsbGJhY2ssIGRvUmVxdWVzdCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVzb3VyY2U7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUmVzb3VyY2U7XG5cblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOSkpO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG5mdW5jdGlvbiB0b0FjdGlvblZhbHVlKGFjdGlvblN0cmluZykge1xuICAgIHJldHVybiBQcmVzZW5jZU1lc3NhZ2UuQWN0aW9ucy5pbmRleE9mKGFjdGlvblN0cmluZyk7XG59XG52YXIgUHJlc2VuY2VNZXNzYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByZXNlbmNlTWVzc2FnZSgpIHtcbiAgICB9XG4gICAgLyogUmV0dXJucyB3aGV0aGVyIHRoaXMgcHJlc2VuY2VNZXNzYWdlIGlzIHN5bnRoZXNpemVkLCBpLmUuIHdhcyBub3QgYWN0dWFsbHlcbiAgICAgKiBzZW50IGJ5IHRoZSBjb25uZWN0aW9uICh1c3VhbGx5IG1lYW5zIGEgbGVhdmUgZXZlbnQgc2VudCAxNXMgYWZ0ZXIgYVxuICAgICAqIGRpc2Nvbm5lY3Rpb24pLiBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIHN5bnRoZXNpemVkIG1lc3NhZ2VzIGNhbm5vdCBiZVxuICAgICAqIGNvbXBhcmVkIGZvciBuZXduZXNzIGJ5IGlkIGxleGljb2dyYXBoaWNhbGx5IC0gUlRQMmIxXG4gICAgICovXG4gICAgUHJlc2VuY2VNZXNzYWdlLnByb3RvdHlwZS5pc1N5bnRoZXNpemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaWQgfHwgIXRoaXMuY29ubmVjdGlvbklkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pZC5zdWJzdHJpbmcodGhpcy5jb25uZWN0aW9uSWQubGVuZ3RoLCAwKSAhPT0gdGhpcy5jb25uZWN0aW9uSWQ7XG4gICAgfTtcbiAgICAvKiBSVFAyYjIgKi9cbiAgICBQcmVzZW5jZU1lc3NhZ2UucHJvdG90eXBlLnBhcnNlSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFyc2VJZCgpOiBQcmVzZW5jZSBtZXNzYWdlIGRvZXMgbm90IGNvbnRhaW4gYW4gaWQnKTtcbiAgICAgICAgdmFyIHBhcnRzID0gdGhpcy5pZC5zcGxpdCgnOicpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29ubmVjdGlvbklkOiBwYXJ0c1swXSxcbiAgICAgICAgICAgIG1zZ1NlcmlhbDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICAgICAgICAgIGluZGV4OiBwYXJzZUludChwYXJ0c1syXSwgMTApLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT3ZlcmxvYWQgdG9KU09OKCkgdG8gaW50ZXJjZXB0IEpTT04uc3RyaW5naWZ5KClcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuICAgIFByZXNlbmNlTWVzc2FnZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiBlbmNvZGUgZGF0YSB0byBiYXNlNjQgaWYgcHJlc2VudCBhbmQgd2UncmUgcmV0dXJuaW5nIHJlYWwgSlNPTjtcbiAgICAgICAgICogYWx0aG91Z2ggbXNncGFjayBjYWxscyB0b0pTT04oKSwgd2Uga25vdyBpdCBpcyBhIHN0cmluZ2lmeSgpXG4gICAgICAgICAqIGNhbGwgaWYgaXQgaGFzIGEgbm9uLWVtcHR5IGFyZ3VtZW50cyBsaXN0ICovXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB2YXIgZW5jb2RpbmcgPSB0aGlzLmVuY29kaW5nO1xuICAgICAgICBpZiAoZGF0YSAmJiBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8qIHN0cmluZ2lmeSBjYWxsICovXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyA/IGVuY29kaW5nICsgJy9iYXNlNjQnIDogJ2Jhc2U2NCc7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBDYWxsZWQgYnkgbXNncGFjay4gdG9CdWZmZXIgcmV0dXJucyBhIGRhdGF0eXBlIHVuZGVyc3RhbmRhYmxlIGJ5XG4gICAgICAgICAgICAgICAgICogdGhhdCBwbGF0Zm9ybSdzIG1zZ3BhY2sgaW1wbGVtZW50YXRpb24gKEJ1ZmZlciBpbiBub2RlLCBVaW50OEFycmF5XG4gICAgICAgICAgICAgICAgICogaW4gYnJvd3NlcnMpICovXG4gICAgICAgICAgICAgICAgZGF0YSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy50b0J1ZmZlcihkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcbiAgICAgICAgICAgIC8qIENvbnZlcnQgcHJlc2VuY2UgYWN0aW9uIGJhY2sgdG8gYW4gaW50IGZvciBzZW5kaW5nIHRvIEFibHkgKi9cbiAgICAgICAgICAgIGFjdGlvbjogdG9BY3Rpb25WYWx1ZSh0aGlzLmFjdGlvbiksXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgICAgICAgZXh0cmFzOiB0aGlzLmV4dHJhcyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFByZXNlbmNlTWVzc2FnZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnW1ByZXNlbmNlTWVzc2FnZSc7XG4gICAgICAgIHJlc3VsdCArPSAnOyBhY3Rpb249JyArIHRoaXMuYWN0aW9uO1xuICAgICAgICBpZiAodGhpcy5pZClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBpZD0nICsgdGhpcy5pZDtcbiAgICAgICAgaWYgKHRoaXMudGltZXN0YW1wKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IHRpbWVzdGFtcD0nICsgdGhpcy50aW1lc3RhbXA7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudElkKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGNsaWVudElkPScgKyB0aGlzLmNsaWVudElkO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uSWQpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgY29ubmVjdGlvbklkPScgKyB0aGlzLmNvbm5lY3Rpb25JZDtcbiAgICAgICAgaWYgKHRoaXMuZW5jb2RpbmcpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgZW5jb2Rpbmc9JyArIHRoaXMuZW5jb2Rpbmc7XG4gICAgICAgIGlmICh0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5kYXRhID09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnOyBkYXRhPScgKyB0aGlzLmRhdGE7XG4gICAgICAgICAgICBlbHNlIGlmIChwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuaXNCdWZmZXIodGhpcy5kYXRhKSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJzsgZGF0YSAoYnVmZmVyKT0nICsgcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZSh0aGlzLmRhdGEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnOyBkYXRhIChqc29uKT0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leHRyYXMpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBleHRyYXM9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZXh0cmFzKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJ10nO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUHJlc2VuY2VNZXNzYWdlLmZyb21SZXNwb25zZUJvZHkgPSBmdW5jdGlvbiAoYm9keSwgb3B0aW9ucywgZm9ybWF0KSB7XG4gICAgICAgIHZhciBtZXNzYWdlcyA9IFtdO1xuICAgICAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBib2R5ID0gVXRpbHMuZGVjb2RlQm9keShib2R5LCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1zZyA9IChtZXNzYWdlc1tpXSA9IFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKGJvZHlbaV0sIHRydWUpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgUHJlc2VuY2VNZXNzYWdlLmRlY29kZShtc2csIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1ByZXNlbmNlTWVzc2FnZS5mcm9tUmVzcG9uc2VCb2R5KCknLCBlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICB9O1xuICAgIFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcywgc3RyaW5naWZ5QWN0aW9uKSB7XG4gICAgICAgIGlmIChzdHJpbmdpZnlBY3Rpb24pIHtcbiAgICAgICAgICAgIHZhbHVlcy5hY3Rpb24gPSBQcmVzZW5jZU1lc3NhZ2UuQWN0aW9uc1t2YWx1ZXMuYWN0aW9uXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgUHJlc2VuY2VNZXNzYWdlKCksIHZhbHVlcyk7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlc0FycmF5ID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICB2YXIgY291bnQgPSB2YWx1ZXMubGVuZ3RoLCByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspXG4gICAgICAgICAgICByZXN1bHRbaV0gPSBQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUHJlc2VuY2VNZXNzYWdlLmZyb21FbmNvZGVkID0gZnVuY3Rpb24gKGVuY29kZWQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1zZyA9IFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKGVuY29kZWQsIHRydWUpO1xuICAgICAgICAvKiBpZiBkZWNvZGluZyBmYWlscyBhdCBhbnkgcG9pbnQsIGNhdGNoIGFuZCByZXR1cm4gdGhlIG1lc3NhZ2UgZGVjb2RlZCB0b1xuICAgICAgICAgKiB0aGUgZnVsbGVzdCBleHRlbnQgcG9zc2libGUgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFByZXNlbmNlTWVzc2FnZS5kZWNvZGUobXNnLCBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnUHJlc2VuY2VNZXNzYWdlLmZyb21FbmNvZGVkKCknLCBlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1lc3NhZ2UuZnJvbUVuY29kZWRBcnJheSA9IGZ1bmN0aW9uIChlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZWRBcnJheS5tYXAoZnVuY3Rpb24gKGVuY29kZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcmVzZW5jZU1lc3NhZ2UuZnJvbUVuY29kZWQoZW5jb2RlZCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUHJlc2VuY2VNZXNzYWdlLmZyb21EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBQcmVzZW5jZU1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFByZXNlbmNlTWVzc2FnZS5BY3Rpb25zID0gWydhYnNlbnQnLCAncHJlc2VudCcsICdlbnRlcicsICdsZWF2ZScsICd1cGRhdGUnXTtcbiAgICBQcmVzZW5jZU1lc3NhZ2UuZW5jb2RlID0gbWVzc2FnZV8xLmRlZmF1bHQuZW5jb2RlO1xuICAgIFByZXNlbmNlTWVzc2FnZS5kZWNvZGUgPSBtZXNzYWdlXzEuZGVmYXVsdC5kZWNvZGU7XG4gICAgUHJlc2VuY2VNZXNzYWdlLmdldE1lc3NhZ2VzU2l6ZSA9IG1lc3NhZ2VfMS5kZWZhdWx0LmdldE1lc3NhZ2VzU2l6ZTtcbiAgICByZXR1cm4gUHJlc2VuY2VNZXNzYWdlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFByZXNlbmNlTWVzc2FnZTtcblxuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgZXZlbnRlbWl0dGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgZGVmYXVsdHNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOCkpO1xudmFyIFhIUlN0YXRlc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyMSkpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbmZ1bmN0aW9uIGlzQWJseUVycm9yKHJlc3BvbnNlQm9keSwgaGVhZGVycykge1xuICAgIHJldHVybiBVdGlscy5hcnJJbihVdGlscy5hbGxUb0xvd2VyQ2FzZShVdGlscy5rZXlzQXJyYXkoaGVhZGVycykpLCAneC1hYmx5LWVycm9yY29kZScpO1xufVxuZnVuY3Rpb24gZ2V0QWJseUVycm9yKHJlc3BvbnNlQm9keSwgaGVhZGVycykge1xuICAgIGlmIChpc0FibHlFcnJvcihyZXNwb25zZUJvZHksIGhlYWRlcnMpKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZUJvZHkuZXJyb3IgJiYgZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHJlc3BvbnNlQm9keS5lcnJvcik7XG4gICAgfVxufVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG52YXIgaWRDb3VudGVyID0gMDtcbnZhciBwZW5kaW5nUmVxdWVzdHMgPSB7fTtcbnZhciBpc0lFID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLlhEb21haW5SZXF1ZXN0O1xuZnVuY3Rpb24gaWVWZXJzaW9uKCkge1xuICAgIHZhciBtYXRjaCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9TdHJpbmcoKS5tYXRjaCgvTVNJRVxccyhbXFxkLl0rKS8pO1xuICAgIHJldHVybiBtYXRjaCAmJiBOdW1iZXIobWF0Y2hbMV0pO1xufVxuZnVuY3Rpb24gbmVlZEpzb25FbnZlbG9wZSgpIHtcbiAgICAvKiBJRSAxMCB4aHIgYnVnOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjMyMDMzOSAqL1xuICAgIHZhciB2ZXJzaW9uO1xuICAgIHJldHVybiBpc0lFICYmICh2ZXJzaW9uID0gaWVWZXJzaW9uKCkpICYmIHZlcnNpb24gPT09IDEwO1xufVxuZnVuY3Rpb24gZ2V0SGVhZGVyKHhociwgaGVhZGVyKSB7XG4gICAgcmV0dXJuIHhoci5nZXRSZXNwb25zZUhlYWRlciAmJiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoaGVhZGVyKTtcbn1cbi8qIFNhZmFyaSBteXN0ZXJpb3VzbHkgcmV0dXJucyAnSWRlbnRpdHknIGZvciB0cmFuc2Zlci1lbmNvZGluZyB3aGVuIGluIGZhY3RcbiAqIGl0IGlzICdjaHVua2VkJy4gU28gaW5zdGVhZCwgZGVjaWRlIHRoYXQgaXQgaXMgY2h1bmtlZCB3aGVuXG4gKiB0cmFuc2Zlci1lbmNvZGluZyBpcyBwcmVzZW50IG9yIGNvbnRlbnQtbGVuZ3RoIGlzIGFic2VudC4gICgnb3InIGJlY2F1c2VcbiAqIHdoZW4gdXNpbmcgaHR0cDIgc3RyZWFtaW5nLCB0aGVyZSdzIG5vIHRyYW5zZmVyLWVuY29kaW5nIGhlYWRlciwgYnV0IGNhblxuICogc3RpbGwgZGVkdWNlIHN0cmVhbWluZyBmcm9tIGxhY2sgb2YgY29udGVudC1sZW5ndGgpICovXG5mdW5jdGlvbiBpc0VuY29kaW5nQ2h1bmtlZCh4aHIpIHtcbiAgICByZXR1cm4gKHhoci5nZXRSZXNwb25zZUhlYWRlciAmJiAoeGhyLmdldFJlc3BvbnNlSGVhZGVyKCd0cmFuc2Zlci1lbmNvZGluZycpIHx8ICF4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJykpKTtcbn1cbmZ1bmN0aW9uIGdldEhlYWRlcnNBc09iamVjdCh4aHIpIHtcbiAgICB2YXIgaGVhZGVyUGFpcnMgPSBVdGlscy50cmltKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkuc3BsaXQoJ1xcclxcbicpO1xuICAgIHZhciBoZWFkZXJzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkZXJQYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGFydHMgPSBoZWFkZXJQYWlyc1tpXS5zcGxpdCgnOicpLm1hcChVdGlscy50cmltKTtcbiAgICAgICAgaGVhZGVyc1twYXJ0c1swXS50b0xvd2VyQ2FzZSgpXSA9IHBhcnRzWzFdO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cbnZhciBYSFJSZXF1ZXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFhIUlJlcXVlc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWEhSUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBtZXRob2QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICBwYXJhbXMucm5kID0gVXRpbHMuY2hlYXBSYW5kU3RyKCk7XG4gICAgICAgIGlmIChuZWVkSnNvbkVudmVsb3BlKCkgJiYgIXBhcmFtcy5lbnZlbG9wZSlcbiAgICAgICAgICAgIHBhcmFtcy5lbnZlbG9wZSA9ICdqc29uJztcbiAgICAgICAgX3RoaXMudXJpID0gdXJpICsgVXRpbHMudG9RdWVyeVN0cmluZyhwYXJhbXMpO1xuICAgICAgICBfdGhpcy5oZWFkZXJzID0gaGVhZGVycyB8fCB7fTtcbiAgICAgICAgX3RoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgIF90aGlzLm1ldGhvZCA9IG1ldGhvZCA/IG1ldGhvZC50b1VwcGVyQ2FzZSgpIDogVXRpbHMuaXNFbXB0eUFyZyhib2R5KSA/ICdHRVQnIDogJ1BPU1QnO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0TW9kZSA9IHJlcXVlc3RNb2RlO1xuICAgICAgICBfdGhpcy50aW1lb3V0cyA9IHRpbWVvdXRzO1xuICAgICAgICBfdGhpcy50aW1lZE91dCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0Q29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuaWQgPSBTdHJpbmcoKytpZENvdW50ZXIpO1xuICAgICAgICBwZW5kaW5nUmVxdWVzdHNbX3RoaXMuaWRdID0gX3RoaXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWEhSUmVxdWVzdC5jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCkge1xuICAgICAgICAvKiBYSFIgcmVxdWVzdHMgYXJlIHVzZWQgZWl0aGVyIHdpdGggdGhlIGNvbnRleHQgYmVpbmcgYSByZWFsdGltZVxuICAgICAgICAgKiB0cmFuc3BvcnQsIG9yIHdpdGggdGltZW91dHMgcGFzc2VkIGluIChmb3Igd2hlbiB1c2VkIGJ5IGEgcmVzdCBjbGllbnQpLFxuICAgICAgICAgKiBvciBjb21wbGV0ZWx5IHN0YW5kYWxvbmUuICBVc2UgdGhlIGFwcHJvcHJpYXRlIHRpbWVvdXRzIGluIGVhY2ggY2FzZSAqL1xuICAgICAgICB2YXIgX3RpbWVvdXRzID0gdGltZW91dHMgfHwgZGVmYXVsdHNfMS5kZWZhdWx0LlRJTUVPVVRTO1xuICAgICAgICByZXR1cm4gbmV3IFhIUlJlcXVlc3QodXJpLCBoZWFkZXJzLCBVdGlscy5jb3B5KHBhcmFtcyksIGJvZHksIHJlcXVlc3RNb2RlLCBfdGltZW91dHMsIG1ldGhvZCk7XG4gICAgfTtcbiAgICBYSFJSZXF1ZXN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uIChlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5yZXF1ZXN0Q29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdENvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghZXJyICYmIGJvZHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY29tcGxldGUnLCBlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBYSFJSZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICBYSFJSZXF1ZXN0LnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaGVhZGVycyA9IHRoaXMuaGVhZGVycztcbiAgICAgICAgdmFyIHRpbWVvdXQgPSB0aGlzLnJlcXVlc3RNb2RlID09IFhIUlN0YXRlc18xLmRlZmF1bHQuUkVRX1NFTkQgPyB0aGlzLnRpbWVvdXRzLmh0dHBSZXF1ZXN0VGltZW91dCA6IHRoaXMudGltZW91dHMucmVjdlRpbWVvdXQsIHRpbWVyID0gKHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICB9LCB0aW1lb3V0KSksIG1ldGhvZCA9IHRoaXMubWV0aG9kLCB4aHIgPSAodGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKSksIGFjY2VwdCA9IGhlYWRlcnNbJ2FjY2VwdCddO1xuICAgICAgICB2YXIgYm9keSA9IHRoaXMuYm9keTtcbiAgICAgICAgdmFyIHJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcbiAgICAgICAgaWYgKCFhY2NlcHQpIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gSlNPTlxuICAgICAgICAgICAgaGVhZGVyc1snYWNjZXB0J10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWNjZXB0LmluZGV4T2YoJ2FwcGxpY2F0aW9uL3gtbXNncGFjaycpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBNc2dwYWNrIHJlc3BvbnNlcyB3aWxsIGJlIHR5cGVkIGFzIEFycmF5QnVmZmVyXG4gICAgICAgICAgICByZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSBoZWFkZXJzWydjb250ZW50LXR5cGUnXSB8fCAoaGVhZGVyc1snY29udGVudC10eXBlJ10gPSAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xICYmIHR5cGVvZiBib2R5ICE9ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYW4gcHJvYmFibHkgcmVtb3ZlIHRoaXMgZGlyZWN0aXZlIGlmIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2Rlc2VjdXJpdHkvZXNsaW50LXBsdWdpbi1zZWN1cml0eS9pc3N1ZXMvMjYgaXMgcmVzb2x2ZWRcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNlY3VyaXR5L2RldGVjdC1ub24tbGl0ZXJhbC1mcy1maWxlbmFtZVxuICAgICAgICB4aHIub3BlbihtZXRob2QsIHRoaXMudXJpLCB0cnVlKTtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcbiAgICAgICAgaWYgKCdhdXRob3JpemF0aW9uJyBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBoIGluIGhlYWRlcnMpXG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoLCBoZWFkZXJzW2hdKTtcbiAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChlcnJvckV2ZW50LCBtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gbWVzc2FnZSArICcgKGV2ZW50IHR5cGU6ICcgKyBlcnJvckV2ZW50LnR5cGUgKyAnKSc7XG4gICAgICAgICAgICBpZiAoKF9hID0gX3RoaXMgPT09IG51bGwgfHwgX3RoaXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzLnhocikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXR1c1RleHQpXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9ICcsIGN1cnJlbnQgc3RhdHVzVGV4dCBpcyAnICsgX3RoaXMueGhyLnN0YXR1c1RleHQ7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1JlcXVlc3Qub24nICsgZXJyb3JFdmVudC50eXBlICsgJygpJywgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKGVycm9yTWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSkpO1xuICAgICAgICB9O1xuICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvckV2ZW50KSB7XG4gICAgICAgICAgICBlcnJvckhhbmRsZXIoZXJyb3JFdmVudCwgJ1hIUiBlcnJvciBvY2N1cnJlZCcsIG51bGwsIDQwMCk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24gKGVycm9yRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy50aW1lZE91dCkge1xuICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcihlcnJvckV2ZW50LCAnUmVxdWVzdCBhYm9ydGVkIGR1ZSB0byByZXF1ZXN0IHRpbWVvdXQgZXhwaXJpbmcnLCBudWxsLCA0MDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsICdSZXF1ZXN0IGNhbmNlbGxlZCcsIG51bGwsIDQwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoZXJyb3JFdmVudCkge1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsICdSZXF1ZXN0IHRpbWVkIG91dCcsIG51bGwsIDQwOCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHJlYW1pbmc7XG4gICAgICAgIHZhciBzdGF0dXNDb2RlO1xuICAgICAgICB2YXIgc3VjY2Vzc1Jlc3BvbnNlO1xuICAgICAgICB2YXIgc3RyZWFtUG9zID0gMDtcbiAgICAgICAgdmFyIHVucGFja2VkID0gZmFsc2U7XG4gICAgICAgIHZhciBvblJlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIHN1Y2Nlc3NSZXNwb25zZSA9IHN0YXR1c0NvZGUgPCA0MDA7XG4gICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PSAyMDQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb21wbGV0ZShudWxsLCBudWxsLCBudWxsLCBudWxsLCBzdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJlYW1pbmcgPSBfdGhpcy5yZXF1ZXN0TW9kZSA9PSBYSFJTdGF0ZXNfMS5kZWZhdWx0LlJFUV9SRUNWX1NUUkVBTSAmJiBzdWNjZXNzUmVzcG9uc2UgJiYgaXNFbmNvZGluZ0NodW5rZWQoeGhyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcnNlZFJlc3BvbnNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSBnZXRIZWFkZXIoeGhyLCAnY29udGVudC10eXBlJyk7XG4gICAgICAgICAgICAgICAgLyogQmUgbGliZXJhbCBpbiB3aGF0IHdlIGFjY2VwdDsgYnVnZ3kgYXV0aCBzZXJ2ZXJzIG1heSByZXNwb25kXG4gICAgICAgICAgICAgICAgICogd2l0aG91dCB0aGUgY29ycmVjdCBjb250ZW50dHlwZSwgYnV0IGFzc3VtZSB0aGV5J3JlIHN0aWxsXG4gICAgICAgICAgICAgICAgICogcmVzcG9uZGluZyB3aXRoIGpzb24gKi9cbiAgICAgICAgICAgICAgICB2YXIganNvbiA9IGNvbnRlbnRUeXBlID8gY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID49IDAgOiB4aHIucmVzcG9uc2VUeXBlID09ICd0ZXh0JztcbiAgICAgICAgICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgICAgICAgICAgICAvKiBJZiB3ZSByZXF1ZXN0ZWQgbXNncGFjayBidXQgc2VydmVyIHJlc3BvbmRlZCB3aXRoIGpzb24sIHRoZW4gc2luY2VcbiAgICAgICAgICAgICAgICAgICAgICogd2Ugc2V0IHRoZSByZXNwb25zZVR5cGUgZXhwZWN0aW5nIG1zZ3BhY2ssIHRoZSByZXNwb25zZSB3aWxsIGJlXG4gICAgICAgICAgICAgICAgICAgICAqIGFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcganNvbiAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIganNvblJlc3BvbnNlQm9keSA9IHhoci5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcidcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLnV0ZjhEZWNvZGUoeGhyLnJlc3BvbnNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBTdHJpbmcoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uUmVzcG9uc2VCb2R5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmVzcG9uc2UgPSBKU09OLnBhcnNlKGpzb25SZXNwb25zZUJvZHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmVzcG9uc2UgPSBqc29uUmVzcG9uc2VCb2R5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVucGFja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlID0geGhyLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkUmVzcG9uc2UucmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvKiB1bndyYXAgSlNPTiBlbnZlbG9wZSAqL1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlID0gcGFyc2VkUmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc1Jlc3BvbnNlID0gc3RhdHVzQ29kZSA8IDQwMDtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycyA9IHBhcnNlZFJlc3BvbnNlLmhlYWRlcnM7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlID0gcGFyc2VkUmVzcG9uc2UucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzID0gZ2V0SGVhZGVyc0FzT2JqZWN0KHhocik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb21wbGV0ZShuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygnTWFsZm9ybWVkIHJlc3BvbnNlIGJvZHkgZnJvbSBzZXJ2ZXI6ICcgKyBlLm1lc3NhZ2UsIG51bGwsIDQwMCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIElmIHJlc3BvbnNlIGlzIGFuIGFycmF5LCBpdCdzIGFuIGFycmF5IG9mIHByb3RvY29sIG1lc3NhZ2VzIC0tIGV2ZW4gaWZcbiAgICAgICAgICAgICAqIGlzIGNvbnRhaW5zIGFuIGVycm9yIGFjdGlvbiAoaGVuY2UgdGhlIG5vbnN1Y2Nlc3Mgc3RhdHVzY29kZSksIHdlIGNhblxuICAgICAgICAgICAgICogY29uc2lkZXIgdGhlIHJlcXVlc3QgdG8gaGF2ZSBzdWNjZWVkZWQsIGp1c3QgcGFzcyBpdCBvbiB0b1xuICAgICAgICAgICAgICogb25Qcm90b2NvbE1lc3NhZ2UgdG8gZGVjaWRlIHdoYXQgdG8gZG8gKi9cbiAgICAgICAgICAgIGlmIChzdWNjZXNzUmVzcG9uc2UgfHwgVXRpbHMuaXNBcnJheShwYXJzZWRSZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb21wbGV0ZShudWxsLCBwYXJzZWRSZXNwb25zZSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlcnIgPSBnZXRBYmx5RXJyb3IocGFyc2VkUmVzcG9uc2UsIGhlYWRlcnMpO1xuICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSBuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygnRXJyb3IgcmVzcG9uc2UgcmVjZWl2ZWQgZnJvbSBzZXJ2ZXI6ICcgK1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlICtcbiAgICAgICAgICAgICAgICAgICAgJyBib2R5IHdhczogJyArXG4gICAgICAgICAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChwYXJzZWRSZXNwb25zZSksIG51bGwsIHN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuY29tcGxldGUoZXJyLCBwYXJzZWRSZXNwb25zZSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBvblByb2dyZXNzKCkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlVGV4dCA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICB2YXIgYm9keUVuZCA9IHJlc3BvbnNlVGV4dC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdmFyIGlkeCwgY2h1bms7XG4gICAgICAgICAgICB3aGlsZSAoc3RyZWFtUG9zIDwgYm9keUVuZCAmJiAoaWR4ID0gcmVzcG9uc2VUZXh0LmluZGV4T2YoJ1xcbicsIHN0cmVhbVBvcykpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IHJlc3BvbnNlVGV4dC5zbGljZShzdHJlYW1Qb3MsIGlkeCk7XG4gICAgICAgICAgICAgICAgc3RyZWFtUG9zID0gaWR4ICsgMTtcbiAgICAgICAgICAgICAgICBvbkNodW5rKGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb25DaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IEpTT04ucGFyc2UoY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb21wbGV0ZShuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygnTWFsZm9ybWVkIHJlc3BvbnNlIGJvZHkgZnJvbSBzZXJ2ZXI6ICcgKyBlLm1lc3NhZ2UsIG51bGwsIDQwMCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvblN0cmVhbUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgIF90aGlzLnN0cmVhbUNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZWFkeVN0YXRlID0geGhyLnJlYWR5U3RhdGU7XG4gICAgICAgICAgICBpZiAocmVhZHlTdGF0ZSA8IDMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgPSB4aHIuc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICAvKiBJRSByZXR1cm5zIDEyMjMgZm9yIDIwNDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MCAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gMTIyMylcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgPSAyMDQ7XG4gICAgICAgICAgICAgICAgICAgIG9uUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlYWR5U3RhdGUgPT0gMyAmJiBzdHJlYW1pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Qcm9ncmVzcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmVhbWluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU3RyZWFtRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB4aHIuc2VuZChib2R5KTtcbiAgICB9O1xuICAgIFhIUlJlcXVlc3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB4aHIgPSB0aGlzLnhocjtcbiAgICAgICAgaWYgKHhocikge1xuICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID0gbm9vcDtcbiAgICAgICAgICAgIHRoaXMueGhyID0gbnVsbDtcbiAgICAgICAgICAgIHZhciB0aW1lciA9IHRoaXMudGltZXI7XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlcXVlc3RDb21wbGV0ZSlcbiAgICAgICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgcGVuZGluZ1JlcXVlc3RzW3RoaXMuaWRdO1xuICAgIH07XG4gICAgcmV0dXJuIFhIUlJlcXVlc3Q7XG59KGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFhIUlJlcXVlc3Q7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKSkpXG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgbXVsdGljYXN0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjMpKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIGhtYWNfc2hhMjU2XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KSk7XG52YXIgZW5jX2Jhc2U2NF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG52YXIgSHR0cE1ldGhvZHNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTgpKTtcbnZhciBIdHRwU3RhdHVzQ29kZXNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjUpKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgcmVzb3VyY2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTQpKTtcbnZhciBNQVhfVE9LRU5fTEVOR1RIID0gTWF0aC5wb3coMiwgMTcpO1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxuZnVuY3Rpb24gcmFuZG9tKCkge1xuICAgIHJldHVybiAoJzAwMDAwMCcgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTE2KSkuc2xpY2UoLTE2KTtcbn1cbmZ1bmN0aW9uIGlzUmVhbHRpbWUoY2xpZW50KSB7XG4gICAgcmV0dXJuICEhY2xpZW50LmNvbm5lY3Rpb247XG59XG4vKiBBIGNsaWVudCBhdXRoIGNhbGxiYWNrIG1heSBnaXZlIGVycm9ycyBpbiBhbnkgbnVtYmVyIG9mIGZvcm1hdHM7IG5vcm1hbGlzZSB0byBhbiBFcnJvckluZm8gb3IgUGFydGlhbEVycm9ySW5mbyAqL1xuZnVuY3Rpb24gbm9ybWFsaXNlQXV0aGNhbGxiYWNrRXJyb3IoZXJyKSB7XG4gICAgaWYgKCFVdGlscy5pc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbyhlcnIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSwgZXJyLmNvZGUgfHwgNDAxNzAsIGVyci5zdGF0dXNDb2RlIHx8IDQwMSk7XG4gICAgfVxuICAgIC8qIG5ldHdvcmsgZXJyb3JzIHdpbGwgbm90IGhhdmUgYW4gaW5oZXJlbnQgZXJyb3IgY29kZSAqL1xuICAgIGlmICghZXJyLmNvZGUpIHtcbiAgICAgICAgaWYgKGVyci5zdGF0dXNDb2RlID09PSA0MDMpIHtcbiAgICAgICAgICAgIGVyci5jb2RlID0gNDAzMDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnIuY29kZSA9IDQwMTcwO1xuICAgICAgICAgICAgLyogbm9ybWFsaXNlIHN0YXR1c0NvZGUgdG8gNDAxIHBlciBSU0E0ZSAqL1xuICAgICAgICAgICAgZXJyLnN0YXR1c0NvZGUgPSA0MDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycjtcbn1cbnZhciBobWFjID0gZnVuY3Rpb24gKHRleHQsIGtleSkge1xuICAgIGlmIChwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmNyZWF0ZUhtYWMpIHtcbiAgICAgICAgdmFyIGluc3QgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmNyZWF0ZUhtYWMoJ1NIQTI1NicsIGtleSk7XG4gICAgICAgIGluc3QudXBkYXRlKHRleHQpO1xuICAgICAgICByZXR1cm4gaW5zdC5kaWdlc3QoJ2Jhc2U2NCcpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGVuY19iYXNlNjRfMS5zdHJpbmdpZnkpKCgwLCBobWFjX3NoYTI1Nl8xLmRlZmF1bHQpKHRleHQsIGtleSkpO1xufTtcbmZ1bmN0aW9uIGMxNG4oY2FwYWJpbGl0eSkge1xuICAgIGlmICghY2FwYWJpbGl0eSlcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGlmICh0eXBlb2YgY2FwYWJpbGl0eSA9PSAnc3RyaW5nJylcbiAgICAgICAgY2FwYWJpbGl0eSA9IEpTT04ucGFyc2UoY2FwYWJpbGl0eSk7XG4gICAgdmFyIGMxNG5DYXBhYmlsaXR5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5cyA9IFV0aWxzLmtleXNBcnJheShjYXBhYmlsaXR5LCB0cnVlKTtcbiAgICBpZiAoIWtleXMpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBrZXlzLnNvcnQoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYzE0bkNhcGFiaWxpdHlba2V5c1tpXV0gPSBjYXBhYmlsaXR5W2tleXNbaV1dLnNvcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGMxNG5DYXBhYmlsaXR5KTtcbn1cbmZ1bmN0aW9uIGxvZ0FuZFZhbGlkYXRlVG9rZW5BdXRoTWV0aG9kKGF1dGhPcHRpb25zKSB7XG4gICAgaWYgKGF1dGhPcHRpb25zLmF1dGhDYWxsYmFjaykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGgoKScsICd1c2luZyB0b2tlbiBhdXRoIHdpdGggYXV0aENhbGxiYWNrJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF1dGhPcHRpb25zLmF1dGhVcmwpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdBdXRoKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhVcmwnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXV0aE9wdGlvbnMua2V5KSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQXV0aCgpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBjbGllbnQtc2lkZSBzaWduaW5nJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF1dGhPcHRpb25zLnRva2VuRGV0YWlscykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGgoKScsICd1c2luZyB0b2tlbiBhdXRoIHdpdGggc3VwcGxpZWQgdG9rZW4gb25seScpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG1zZyA9ICdhdXRoT3B0aW9ucyBtdXN0IGluY2x1ZGUgdmFsaWQgYXV0aGVudGljYXRpb24gcGFyYW1ldGVycyc7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQXV0aCgpJywgbXNnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYmFzaWNBdXRoRm9yY2VkKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gJ3VzZVRva2VuQXV0aCcgaW4gb3B0aW9ucyAmJiAhb3B0aW9ucy51c2VUb2tlbkF1dGg7XG59XG4vKiBSU0E0ICovXG5mdW5jdGlvbiB1c2VUb2tlbkF1dGgob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucy51c2VUb2tlbkF1dGggfHxcbiAgICAgICAgKCFiYXNpY0F1dGhGb3JjZWQob3B0aW9ucykgJiYgKG9wdGlvbnMuYXV0aENhbGxiYWNrIHx8IG9wdGlvbnMuYXV0aFVybCB8fCBvcHRpb25zLnRva2VuIHx8IG9wdGlvbnMudG9rZW5EZXRhaWxzKSkpO1xufVxuLyogUlNBNGEgKi9cbmZ1bmN0aW9uIG5vV2F5VG9SZW5ldyhvcHRpb25zKSB7XG4gICAgcmV0dXJuICFvcHRpb25zLmtleSAmJiAhb3B0aW9ucy5hdXRoQ2FsbGJhY2sgJiYgIW9wdGlvbnMuYXV0aFVybDtcbn1cbnZhciB0cklkID0gMDtcbmZ1bmN0aW9uIGdldFRva2VuUmVxdWVzdElkKCkge1xuICAgIHJldHVybiB0cklkKys7XG59XG52YXIgQXV0aCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdXRoKGNsaWVudCwgb3B0aW9ucykge1xuICAgICAgICAvLyBUaGlzIGluaXRpYWxpemF0aW9uIGlzIGFsd2F5cyBvdmVyd3JpdHRlbiBhbmQgb25seSB1c2VkIHRvIHByZXZlbnQgYSBUeXBlU2NyaXB0IGNvbXBpbGVyIGVycm9yXG4gICAgICAgIHRoaXMuYXV0aE9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMudG9rZW5QYXJhbXMgPSBvcHRpb25zLmRlZmF1bHRUb2tlblBhcmFtcyB8fCB7fTtcbiAgICAgICAgLyogVGhlIGlkIG9mIHRoZSBjdXJyZW50IHRva2VuIHJlcXVlc3QgaWYgb25lIGlzIGluIHByb2dyZXNzLCBlbHNlIG51bGwgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgPSBudWxsO1xuICAgICAgICB0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBudWxsO1xuICAgICAgICBpZiAodXNlVG9rZW5BdXRoKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAvKiBUb2tlbiBhdXRoICovXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5rZXkgJiYgIWhtYWMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ2NsaWVudC1zaWRlIHRva2VuIHJlcXVlc3Qgc2lnbmluZyBub3Qgc3VwcG9ydGVkJztcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0F1dGgoKScsIG1zZyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9XYXlUb1JlbmV3KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdBdXRoKCknLCAnV2FybmluZzogbGlicmFyeSBpbml0aWFsaXplZCB3aXRoIGEgdG9rZW4gbGl0ZXJhbCB3aXRob3V0IGFueSB3YXkgdG8gcmVuZXcgdGhlIHRva2VuIHdoZW4gaXQgZXhwaXJlcyAobm8gYXV0aFVybCwgYXV0aENhbGxiYWNrLCBvciBrZXkpLiBTZWUgaHR0cHM6Ly9oZWxwLmFibHkuaW8vZXJyb3IvNDAxNzEgZm9yIGhlbHAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NhdmVUb2tlbk9wdGlvbnMob3B0aW9ucy5kZWZhdWx0VG9rZW5QYXJhbXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgbG9nQW5kVmFsaWRhdGVUb2tlbkF1dGhNZXRob2QodGhpcy5hdXRoT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBCYXNpYyBhdXRoICovXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMua2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdObyBhdXRoZW50aWNhdGlvbiBvcHRpb25zIHByb3ZpZGVkOyBuZWVkIG9uZSBvZjoga2V5LCBhdXRoVXJsLCBvciBhdXRoQ2FsbGJhY2sgKG9yIGZvciB0ZXN0aW5nIG9ubHksIHRva2VuIG9yIHRva2VuRGV0YWlscyknO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQXV0aCgpJywgbXNnKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDQwMTYwLCA0MDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdBdXRoKCknLCAnYW5vbnltb3VzLCB1c2luZyBiYXNpYyBhdXRoJyk7XG4gICAgICAgICAgICB0aGlzLl9zYXZlQmFzaWNPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEF1dGgucHJvdG90eXBlLmF1dGhvcml6ZSA9IGZ1bmN0aW9uICh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYXV0aE9wdGlvbnM7XG4gICAgICAgIC8qIHNodWZmbGUgYW5kIG5vcm1hbGlzZSBhcmd1bWVudHMgYXMgbmVjZXNzYXJ5ICovXG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW5QYXJhbXMgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdG9rZW5QYXJhbXM7XG4gICAgICAgICAgICBfYXV0aE9wdGlvbnMgPSB0b2tlblBhcmFtcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGF1dGhPcHRpb25zID09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGF1dGhPcHRpb25zO1xuICAgICAgICAgICAgX2F1dGhPcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9hdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnYXV0aG9yaXplJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBSU0ExMGE6IGF1dGhvcml6ZSgpIGNhbGwgaW1wbGllcyB0b2tlbiBhdXRoLiBJZiBhIGtleSBpcyBwYXNzZWQgaXQsIHdlXG4gICAgICAgICAqIGp1c3QgY2hlY2sgaWYgaXQgZG9lc24ndCBjbGFzaCBhbmQgYXNzdW1lIHdlJ3JlIGdlbmVyYXRpbmcgYSB0b2tlbiBmcm9tIGl0ICovXG4gICAgICAgIGlmIChfYXV0aE9wdGlvbnMgJiYgX2F1dGhPcHRpb25zLmtleSAmJiB0aGlzLmF1dGhPcHRpb25zLmtleSAhPT0gX2F1dGhPcHRpb25zLmtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1VuYWJsZSB0byB1cGRhdGUgYXV0aCBvcHRpb25zIHdpdGggaW5jb21wYXRpYmxlIGtleScsIDQwMTAyLCA0MDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfYXV0aE9wdGlvbnMgJiYgJ2ZvcmNlJyBpbiBfYXV0aE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQXV0aC5hdXRob3JpemUnLCAnRGVwcmVjYXRpb24gd2FybmluZzogc3BlY2lmeWluZyB7Zm9yY2U6IHRydWV9IGluIGF1dGhPcHRpb25zIGlzIG5vIGxvbmdlciBuZWNlc3NhcnksIGF1dGhvcml6ZSgpIG5vdyBhbHdheXMgZ2V0cyBhIG5ldyB0b2tlbi4gUGxlYXNlIHJlbW92ZSB0aGlzLCBhcyBpbiB2ZXJzaW9uIDEuMCBhbmQgbGF0ZXIsIGhhdmluZyBhIG5vbi1udWxsIGF1dGhPcHRpb25zIHdpbGwgb3ZlcndyaXRlIHN0b3JlZCBsaWJyYXJ5IGF1dGhPcHRpb25zLCB3aGljaCBtYXkgbm90IGJlIHdoYXQgeW91IHdhbnQnKTtcbiAgICAgICAgICAgIC8qIEVtdWxhdGUgdGhlIG9sZCBiZWhhdmlvdXI6IGlmICdmb3JjZScgd2FzIHRoZSBvbmx5IG1lbWJlciBvZiBhdXRoT3B0aW9ucyxcbiAgICAgICAgICAgICAqIHNldCBpdCB0byBudWxsIHNvIGl0IGRvZXNuJ3Qgb3ZlcndyaXRlIHN0b3JlZC4gVE9ETzogcmVtb3ZlIGluIHZlcnNpb24gMS4wICovXG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNPbmx5UHJvcEluKF9hdXRoT3B0aW9ucywgJ2ZvcmNlJykpIHtcbiAgICAgICAgICAgICAgICBfYXV0aE9wdGlvbnMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZvcmNlTmV3VG9rZW4odG9rZW5QYXJhbXMsIF9hdXRoT3B0aW9ucywgZnVuY3Rpb24gKGVyciwgdG9rZW5EZXRhaWxzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmNsaWVudC5jb25uZWN0aW9uICYmIGVyci5zdGF0dXNDb2RlID09PSBIdHRwU3RhdHVzQ29kZXNfMS5kZWZhdWx0LkZvcmJpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICAvKiBQZXIgUlNBNGQgJiBSU0E0ZDEsIGlmIHRoZSBhdXRoIHNlcnZlciBleHBsaWNpdGx5IHJlcHVkaWF0ZXMgb3VyIHJpZ2h0IHRvXG4gICAgICAgICAgICAgICAgICAgICAqIHN0YXkgY29ubmVjdGljZWQgYnkgcmV0dXJuaW5nIGEgNDAzLCB3ZSBhY3RpdmVseSBkaXNjb25uZWN0IHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAqIGV2ZW4gdGhvdWdoIHdlIG1heSB3ZWxsIHN0aWxsIGhhdmUgdGltZSBsZWZ0IGluIHRoZSBvbGQgdG9rZW4uICovXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNsaWVudC5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFJUQzhcbiAgICAgICAgICAgICAqIC0gV2hlbiBhdXRob3JpemUgY2FsbGVkIGJ5IGFuIGVuZCB1c2VyIGFuZCBoYXZlIGEgcmVhbHRpbWUgY29ubmVjdGlvbixcbiAgICAgICAgICAgICAqIGRvbid0IGNhbGwgYmFjayB0aWxsIG5ldyB0b2tlbiBoYXMgdGFrZW4gZWZmZWN0LlxuICAgICAgICAgICAgICogLSBVc2UgdGhpcy5jbGllbnQuY29ubmVjdGlvbiBhcyBhIHByb3h5IGZvciAodGhpcy5jbGllbnQgaW5zdGFuY2VvZiBSZWFsdGltZSksXG4gICAgICAgICAgICAgKiB3aGljaCBkb2Vzbid0IHdvcmsgaW4gbm9kZSBhcyBSZWFsdGltZSBpc24ndCBwYXJ0IG9mIHRoZSB2bSBjb250ZXh0IGZvciBSZXN0IGNsaWVudHMgKi9cbiAgICAgICAgICAgIGlmIChpc1JlYWx0aW1lKF90aGlzLmNsaWVudCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jbGllbnQuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKHRva2VuRGV0YWlscywgY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2sobnVsbCwgdG9rZW5EZXRhaWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBdXRoLnByb3RvdHlwZS5hdXRob3Jpc2UgPSBmdW5jdGlvbiAodG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlcHJlY2F0ZWQoJ0F1dGguYXV0aG9yaXNlJywgJ0F1dGguYXV0aG9yaXplJyk7XG4gICAgICAgIHRoaXMuYXV0aG9yaXplKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgLyogRm9yIGludGVybmFsIHVzZSwgZWcgYnkgY29ubmVjdGlvbk1hbmFnZXIgLSB1c2VmdWwgd2hlbiB3YW50IHRvIGNhbGwgYmFja1xuICAgICAqIGFzIHNvb24gYXMgd2UgaGF2ZSB0aGUgbmV3IHRva2VuLCByYXRoZXIgdGhhbiB3YWl0aW5nIGZvciBpdCB0byB0YWtlXG4gICAgICogZWZmZWN0IG9uIHRoZSBjb25uZWN0aW9uIGFzICNhdXRob3JpemUgZG9lcyAqL1xuICAgIEF1dGgucHJvdG90eXBlLl9mb3JjZU5ld1Rva2VuID0gZnVuY3Rpb24gKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyogZ2V0IHJpZCBvZiBjdXJyZW50IHRva2VuIGV2ZW4gaWYgc3RpbGwgdmFsaWQgKi9cbiAgICAgICAgdGhpcy50b2tlbkRldGFpbHMgPSBudWxsO1xuICAgICAgICAvKiBfc2F2ZSBub3JtYWxpc2VzIHRoZSB0b2tlblBhcmFtcyBhbmQgYXV0aE9wdGlvbnMgYW5kIHVwZGF0ZXMgdGhlIGF1dGhcbiAgICAgICAgICogb2JqZWN0LiBBbGwgc3Vic2VxdWVudCBvcGVyYXRpb25zIHNob3VsZCB1c2UgdGhlIHZhbHVlcyBvbiBgdGhpc2AsXG4gICAgICAgICAqIG5vdCB0aGUgcGFzc2VkIGluIG9uZXMuICovXG4gICAgICAgIHRoaXMuX3NhdmVUb2tlbk9wdGlvbnModG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zKTtcbiAgICAgICAgbG9nQW5kVmFsaWRhdGVUb2tlbkF1dGhNZXRob2QodGhpcy5hdXRoT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKHRydWUsIGZ1bmN0aW9uIChlcnIsIHRva2VuRGV0YWlscykge1xuICAgICAgICAgICAgLyogUlNBMTBnICovXG4gICAgICAgICAgICBkZWxldGUgX3RoaXMudG9rZW5QYXJhbXMudGltZXN0YW1wO1xuICAgICAgICAgICAgZGVsZXRlIF90aGlzLmF1dGhPcHRpb25zLnF1ZXJ5VGltZTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgdG9rZW5EZXRhaWxzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBdXRoLnByb3RvdHlwZS5yZXF1ZXN0VG9rZW4gPSBmdW5jdGlvbiAodG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiBzaHVmZmxlIGFuZCBub3JtYWxpc2UgYXJndW1lbnRzIGFzIG5lY2Vzc2FyeSAqL1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuUGFyYW1zID09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHRva2VuUGFyYW1zO1xuICAgICAgICAgICAgYXV0aE9wdGlvbnMgPSB0b2tlblBhcmFtcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGF1dGhPcHRpb25zID09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGF1dGhPcHRpb25zO1xuICAgICAgICAgICAgYXV0aE9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FsbGJhY2sgJiYgdGhpcy5jbGllbnQub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAncmVxdWVzdFRva2VuJywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBSU0E4ZTogaWYgYXV0aE9wdGlvbnMgcGFzc2VkIGluLCB0aGV5J3JlIHVzZWQgaW5zdGVhZCBvZiBzdG9yZWQsIGRvbid0IG1lcmdlIHRoZW0gKi9cbiAgICAgICAgYXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucyB8fCB0aGlzLmF1dGhPcHRpb25zO1xuICAgICAgICB0b2tlblBhcmFtcyA9IHRva2VuUGFyYW1zIHx8IFV0aWxzLmNvcHkodGhpcy50b2tlblBhcmFtcyk7XG4gICAgICAgIHZhciBfY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICAgICAgICAvKiBmaXJzdCBzZXQgdXAgd2hhdGV2ZXIgY2FsbGJhY2sgd2lsbCBiZSB1c2VkIHRvIGdldCBzaWduZWRcbiAgICAgICAgICogdG9rZW4gcmVxdWVzdHMgKi9cbiAgICAgICAgdmFyIHRva2VuUmVxdWVzdENhbGxiYWNrLCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICAgICAgaWYgKGF1dGhPcHRpb25zLmF1dGhDYWxsYmFjaykge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoQ2FsbGJhY2snKTtcbiAgICAgICAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrID0gYXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGF1dGhPcHRpb25zLmF1dGhVcmwpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsICd1c2luZyB0b2tlbiBhdXRoIHdpdGggYXV0aFVybCcpO1xuICAgICAgICAgICAgdG9rZW5SZXF1ZXN0Q2FsbGJhY2sgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgICAgICAgICAgICAgIHZhciBhdXRoSGVhZGVycyA9IFV0aWxzLm1peGluKHsgYWNjZXB0OiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbicgfSwgYXV0aE9wdGlvbnMuYXV0aEhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIHZhciB1c2VQb3N0ID0gYXV0aE9wdGlvbnMuYXV0aE1ldGhvZCAmJiBhdXRoT3B0aW9ucy5hdXRoTWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09ICdwb3N0JztcbiAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZWRRc1BhcmFtcztcbiAgICAgICAgICAgICAgICAvKiBDb21iaW5lIGF1dGhQYXJhbXMgd2l0aCBhbnkgcXMgcGFyYW1zIGdpdmVuIGluIHRoZSBhdXRoVXJsICovXG4gICAgICAgICAgICAgICAgdmFyIHF1ZXJ5SWR4ID0gYXV0aE9wdGlvbnMuYXV0aFVybC5pbmRleE9mKCc/Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5SWR4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWRRc1BhcmFtcyA9IFV0aWxzLnBhcnNlUXVlcnlTdHJpbmcoYXV0aE9wdGlvbnMuYXV0aFVybC5zbGljZShxdWVyeUlkeCkpO1xuICAgICAgICAgICAgICAgICAgICBhdXRoT3B0aW9ucy5hdXRoVXJsID0gYXV0aE9wdGlvbnMuYXV0aFVybC5zbGljZSgwLCBxdWVyeUlkeCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXNlUG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogSW4gY2FzZSBvZiBjb25mbGljdCwgYXV0aFBhcmFtcyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBxcyBwYXJhbXMgaW4gdGhlIGF1dGhVcmwgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhPcHRpb25zLmF1dGhQYXJhbXMgPSBVdGlscy5taXhpbihwcm92aWRlZFFzUGFyYW1zLCBhdXRoT3B0aW9ucy5hdXRoUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBSU0E4YzIgKi9cbiAgICAgICAgICAgICAgICB2YXIgYXV0aFBhcmFtcyA9IFV0aWxzLm1peGluKHt9LCBhdXRoT3B0aW9ucy5hdXRoUGFyYW1zIHx8IHt9LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIHZhciBhdXRoVXJsUmVxdWVzdENhbGxiYWNrID0gZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0F1dGgucmVxdWVzdFRva2VuKCkudG9rZW5SZXF1ZXN0Q2FsbGJhY2snLCAnUmVjZWl2ZWQgRXJyb3I6ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdBdXRoLnJlcXVlc3RUb2tlbigpLnRva2VuUmVxdWVzdENhbGxiYWNrJywgJ1JlY2VpdmVkOyBjb250ZW50LXR5cGU6ICcgKyBjb250ZW50VHlwZSArICc7IGJvZHk6ICcgKyBVdGlscy5pbnNwZWN0Qm9keShib2R5KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyciB8fCB1bnBhY2tlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnIsIGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGJvZHkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ2F1dGhVcmwgcmVzcG9uc2UgaXMgbWlzc2luZyBhIGNvbnRlbnQtdHlwZSBoZWFkZXInLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGpzb24gPSBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPiAtMSwgdGV4dCA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ3RleHQvcGxhaW4nKSA+IC0xIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2p3dCcpID4gLTE7XG4gICAgICAgICAgICAgICAgICAgIGlmICghanNvbiAmJiAhdGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ2F1dGhVcmwgcmVzcG9uZGVkIHdpdGggdW5hY2NlcHRhYmxlIGNvbnRlbnQtdHlwZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJywgc2hvdWxkIGJlIGVpdGhlciB0ZXh0L3BsYWluLCBhcHBsaWNhdGlvbi9qd3Qgb3IgYXBwbGljYXRpb24vanNvbicsIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkubGVuZ3RoID4gTUFYX1RPS0VOX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdhdXRoVXJsIHJlc3BvbnNlIGV4Y2VlZGVkIG1heCBwZXJtaXR0ZWQgbGVuZ3RoJywgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdVbmV4cGVjdGVkIGVycm9yIHByb2Nlc3NpbmcgYXV0aFVSTCByZXNwb25zZTsgZXJyID0gJyArIGUubWVzc2FnZSwgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYihudWxsLCBib2R5LCBjb250ZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0F1dGgucmVxdWVzdFRva2VuKCkudG9rZW5SZXF1ZXN0Q2FsbGJhY2snLCAnUmVxdWVzdGluZyB0b2tlbiBmcm9tICcgK1xuICAgICAgICAgICAgICAgICAgICBhdXRoT3B0aW9ucy5hdXRoVXJsICtcbiAgICAgICAgICAgICAgICAgICAgJzsgUGFyYW1zOiAnICtcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoYXV0aFBhcmFtcykgK1xuICAgICAgICAgICAgICAgICAgICAnOyBtZXRob2Q6ICcgK1xuICAgICAgICAgICAgICAgICAgICAodXNlUG9zdCA/ICdQT1NUJyA6ICdHRVQnKSk7XG4gICAgICAgICAgICAgICAgaWYgKHVzZVBvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogc2VuZCBib2R5IGZvcm0tZW5jb2RlZCAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IGF1dGhIZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keSA9IFV0aWxzLnRvUXVlcnlTdHJpbmcoYXV0aFBhcmFtcykuc2xpY2UoMSk7IC8qIHNsaWNlIGlzIHRvIHJlbW92ZSB0aGUgaW5pdGlhbCAnPycgKi9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xpZW50Lmh0dHAuZG9VcmkoSHR0cE1ldGhvZHNfMS5kZWZhdWx0LlBvc3QsIGNsaWVudCwgYXV0aE9wdGlvbnMuYXV0aFVybCwgaGVhZGVycywgYm9keSwgcHJvdmlkZWRRc1BhcmFtcywgYXV0aFVybFJlcXVlc3RDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbGllbnQuaHR0cC5kb1VyaShIdHRwTWV0aG9kc18xLmRlZmF1bHQuR2V0LCBjbGllbnQsIGF1dGhPcHRpb25zLmF1dGhVcmwsIGF1dGhIZWFkZXJzIHx8IHt9LCBudWxsLCBhdXRoUGFyYW1zLCBhdXRoVXJsUmVxdWVzdENhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGF1dGhPcHRpb25zLmtleSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBjbGllbnQtc2lkZSBzaWduaW5nJyk7XG4gICAgICAgICAgICB0b2tlblJlcXVlc3RDYWxsYmFjayA9IGZ1bmN0aW9uIChwYXJhbXMsIGNiKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY3JlYXRlVG9rZW5SZXF1ZXN0KHBhcmFtcywgYXV0aE9wdGlvbnMsIGNiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ05lZWQgYSBuZXcgdG9rZW4sIGJ1dCBhdXRoT3B0aW9ucyBkb2VzIG5vdCBpbmNsdWRlIGFueSB3YXkgdG8gcmVxdWVzdCBvbmUgKG5vIGF1dGhVcmwsIGF1dGhDYWxsYmFjaywgb3Iga2V5KSc7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0F1dGgoKScsICdsaWJyYXJ5IGluaXRpYWxpemVkIHdpdGggYSB0b2tlbiBsaXRlcmFsIHdpdGhvdXQgYW55IHdheSB0byByZW5ldyB0aGUgdG9rZW4gd2hlbiBpdCBleHBpcmVzIChubyBhdXRoVXJsLCBhdXRoQ2FsbGJhY2ssIG9yIGtleSkuIFNlZSBodHRwczovL2hlbHAuYWJseS5pby9lcnJvci80MDE3MSBmb3IgaGVscCcpO1xuICAgICAgICAgICAgX2NhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgNDAxNzEsIDQwMykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIG5vcm1hbGlzZSB0b2tlbiBwYXJhbXMgKi9cbiAgICAgICAgaWYgKCdjYXBhYmlsaXR5JyBpbiB0b2tlblBhcmFtcylcbiAgICAgICAgICAgIHRva2VuUGFyYW1zLmNhcGFiaWxpdHkgPSBjMTRuKHRva2VuUGFyYW1zLmNhcGFiaWxpdHkpO1xuICAgICAgICB2YXIgdG9rZW5SZXF1ZXN0ID0gZnVuY3Rpb24gKHNpZ25lZFRva2VuUGFyYW1zLCB0b2tlbkNiKSB7XG4gICAgICAgICAgICB2YXIga2V5TmFtZSA9IHNpZ25lZFRva2VuUGFyYW1zLmtleU5hbWUsIHBhdGggPSAnL2tleXMvJyArIGtleU5hbWUgKyAnL3JlcXVlc3RUb2tlbicsIHRva2VuVXJpID0gZnVuY3Rpb24gKGhvc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50LmJhc2VVcmkoaG9zdCkgKyBwYXRoO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IFV0aWxzLmRlZmF1bHRQb3N0SGVhZGVycyhfdGhpcy5jbGllbnQub3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoYXV0aE9wdGlvbnMucmVxdWVzdEhlYWRlcnMpXG4gICAgICAgICAgICAgICAgVXRpbHMubWl4aW4ocmVxdWVzdEhlYWRlcnMsIGF1dGhPcHRpb25zLnJlcXVlc3RIZWFkZXJzKTtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKS5yZXF1ZXN0VG9rZW4nLCAnU2VuZGluZyBQT1NUIHRvICcgKyBwYXRoICsgJzsgVG9rZW4gcGFyYW1zOiAnICsgSlNPTi5zdHJpbmdpZnkoc2lnbmVkVG9rZW5QYXJhbXMpKTtcbiAgICAgICAgICAgIF90aGlzLmNsaWVudC5odHRwLmRvKEh0dHBNZXRob2RzXzEuZGVmYXVsdC5Qb3N0LCBjbGllbnQsIHRva2VuVXJpLCByZXF1ZXN0SGVhZGVycywgSlNPTi5zdHJpbmdpZnkoc2lnbmVkVG9rZW5QYXJhbXMpLCBudWxsLCB0b2tlbkNiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQgPSBmYWxzZSwgdGltZW91dExlbmd0aCA9IHRoaXMuY2xpZW50Lm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCwgdG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXRFeHBpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnVG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0aW1lZCBvdXQgYWZ0ZXIgJyArIHRpbWVvdXRMZW5ndGggLyAxMDAwICsgJyBzZWNvbmRzJztcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsIG1zZyk7XG4gICAgICAgICAgICBfY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgIH0sIHRpbWVvdXRMZW5ndGgpO1xuICAgICAgICB0b2tlblJlcXVlc3RDYWxsYmFjayh0b2tlblBhcmFtcywgZnVuY3Rpb24gKGVyciwgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzLCBjb250ZW50VHlwZSkge1xuICAgICAgICAgICAgaWYgKHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dCk7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgJ3Rva2VuIHJlcXVlc3Qgc2lnbmluZyBjYWxsIHJldHVybmVkIGVycm9yOyBlcnIgPSAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIF9jYWxsYmFjayhub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgY2FsbGJhY2sgbWlnaHQgYmUgYSB0b2tlbiBzdHJpbmcsIGEgc2lnbmVkIHJlcXVlc3Qgb3IgYSB0b2tlbiBkZXRhaWxzICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuUmVxdWVzdE9yRGV0YWlscyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBfY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1Rva2VuIHN0cmluZyBpcyBlbXB0eScsIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLmxlbmd0aCA+IE1BWF9UT0tFTl9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdUb2tlbiBzdHJpbmcgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBsZW5ndGggKHdhcyAnICsgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzLmxlbmd0aCArICcgYnl0ZXMpJywgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlblJlcXVlc3RPckRldGFpbHMgPT09ICd1bmRlZmluZWQnIHx8IHRva2VuUmVxdWVzdE9yRGV0YWlscyA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGNvbW1vbiBmYWlsdXJlIG1vZGUgd2l0aCBwb29ybHktaW1wbGVtZW50ZWQgYXV0aENhbGxiYWNrcyAqL1xuICAgICAgICAgICAgICAgICAgICBfY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1Rva2VuIHN0cmluZyB3YXMgbGl0ZXJhbCBudWxsL3VuZGVmaW5lZCcsIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW5SZXF1ZXN0T3JEZXRhaWxzWzBdID09PSAneycgJiYgIShjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qd3QnKSA+IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICBfY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoXCJUb2tlbiB3YXMgZG91YmxlLWVuY29kZWQ7IG1ha2Ugc3VyZSB5b3UncmUgbm90IEpTT04tZW5jb2RpbmcgYW4gYWxyZWFkeSBlbmNvZGVkIHRva2VuIHJlcXVlc3Qgb3IgZGV0YWlsc1wiLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfY2FsbGJhY2sobnVsbCwgeyB0b2tlbjogdG9rZW5SZXF1ZXN0T3JEZXRhaWxzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuUmVxdWVzdE9yRGV0YWlscyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ0V4cGVjdGVkIHRva2VuIHJlcXVlc3QgY2FsbGJhY2sgdG8gY2FsbCBiYWNrIHdpdGggYSB0b2tlbiBzdHJpbmcgb3IgdG9rZW4gcmVxdWVzdC9kZXRhaWxzIG9iamVjdCwgYnV0IGdvdCBhICcgK1xuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsIG1zZyk7XG4gICAgICAgICAgICAgICAgX2NhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvYmplY3RTaXplID0gSlNPTi5zdHJpbmdpZnkodG9rZW5SZXF1ZXN0T3JEZXRhaWxzKS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAob2JqZWN0U2l6ZSA+IE1BWF9UT0tFTl9MRU5HVEggJiYgIWF1dGhPcHRpb25zLnN1cHByZXNzTWF4TGVuZ3RoQ2hlY2spIHtcbiAgICAgICAgICAgICAgICBfY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1Rva2VuIHJlcXVlc3QvZGV0YWlscyBvYmplY3QgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBzdHJpbmdpZmllZCBzaXplICh3YXMgJyArIG9iamVjdFNpemUgKyAnIGJ5dGVzKScsIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ2lzc3VlZCcgaW4gdG9rZW5SZXF1ZXN0T3JEZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgLyogYSB0b2tlbkRldGFpbHMgb2JqZWN0ICovXG4gICAgICAgICAgICAgICAgX2NhbGxiYWNrKG51bGwsIHRva2VuUmVxdWVzdE9yRGV0YWlscyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoJ2tleU5hbWUnIGluIHRva2VuUmVxdWVzdE9yRGV0YWlscykpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ0V4cGVjdGVkIHRva2VuIHJlcXVlc3QgY2FsbGJhY2sgdG8gY2FsbCBiYWNrIHdpdGggYSB0b2tlbiBzdHJpbmcsIHRva2VuIHJlcXVlc3Qgb2JqZWN0LCBvciB0b2tlbiBkZXRhaWxzIG9iamVjdCc7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgbXNnKTtcbiAgICAgICAgICAgICAgICBfY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXQncyBhIHRva2VuIHJlcXVlc3QsIHNvIG1ha2UgdGhlIHJlcXVlc3QgKi9cbiAgICAgICAgICAgIHRva2VuUmVxdWVzdCh0b2tlblJlcXVlc3RPckRldGFpbHMsIGZ1bmN0aW9uIChlcnIsIHRva2VuUmVzcG9uc2UsIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCAndG9rZW4gcmVxdWVzdCBBUEkgY2FsbCByZXR1cm5lZCBlcnJvcjsgZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgX2NhbGxiYWNrKG5vcm1hbGlzZUF1dGhjYWxsYmFja0Vycm9yKGVycikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdW5wYWNrZWQpXG4gICAgICAgICAgICAgICAgICAgIHRva2VuUmVzcG9uc2UgPSBKU09OLnBhcnNlKHRva2VuUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQXV0aC5nZXRUb2tlbigpJywgJ3Rva2VuIHJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgX2NhbGxiYWNrKG51bGwsIHRva2VuUmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBzaWduIGEgdG9rZW4gcmVxdWVzdCBiYXNlZCBvbiB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICAgKiBOT1RFIHRoaXMgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIHRoZSBrZXkgdmFsdWUgaXMgYXZhaWxhYmxlIGxvY2FsbHkuXG4gICAgICogT3RoZXJ3aXNlLCBzaWduZWQgdG9rZW4gcmVxdWVzdHMgbXVzdCBiZSBvYnRhaW5lZCBmcm9tIHRoZSBrZXlcbiAgICAgKiBvd25lciAoZWl0aGVyIHVzaW5nIHRoZSB0b2tlbiByZXF1ZXN0IGNhbGxiYWNrIG9yIHVybCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXV0aE9wdGlvbnNcbiAgICAgKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVxdWVzdCBvcHRpb25zOlxuICAgICAqIC0ga2V5OiAgICAgICAgICAgdGhlIGtleSB0byB1c2UuIElmIG5vdCBzcGVjaWZpZWQsIGEga2V5IHBhc3NlZCBpbiBjb25zdHJ1Y3RpbmdcbiAgICAgKiAgICAgICAgICAgICAgICAgIHRoZSBSZXN0IGludGVyZmFjZSB3aWxsIGJlIHVzZWRcbiAgICAgKlxuICAgICAqIC0gcXVlcnlUaW1lICAgICAgKG9wdGlvbmFsKSBib29sZWFuIGluZGljYXRpbmcgdGhhdCB0aGUgYWJseSBzeXN0ZW0gc2hvdWxkIGJlXG4gICAgICogICAgICAgICAgICAgICAgICBxdWVyaWVkIGZvciB0aGUgY3VycmVudCB0aW1lIHdoZW4gbm9uZSBpcyBzcGVjaWZpZWQgZXhwbGljaXRseVxuICAgICAqXG4gICAgICogLSByZXF1ZXN0SGVhZGVycyAob3B0aW9uYWwsIHVuc3VwcG9ydGVkLCBmb3IgdGVzdGluZyBvbmx5KSBleHRyYSBoZWFkZXJzIHRvIGFkZCB0byB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbiByZXF1ZXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW5QYXJhbXNcbiAgICAgKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyYW1ldGVycyBmb3IgdGhlIHJlcXVlc3RlZCB0b2tlbjpcbiAgICAgKiAtIHR0bDogICAgICAgKG9wdGlvbmFsKSB0aGUgcmVxdWVzdGVkIGxpZmUgb2YgdGhlIHRva2VuIGluIG1zLiBJZiBub25lIGlzIHNwZWNpZmllZFxuICAgICAqICAgICAgICAgICAgICAgICAgYSBkZWZhdWx0IG9mIDEgaG91ciBpcyBwcm92aWRlZC4gVGhlIG1heGltdW0gbGlmZXRpbWUgaXMgMjRob3VyczsgYW55IHJlcXVlc3RcbiAgICAgKiAgICAgICAgICAgICAgICAgIGV4Y2VlZGluZyB0aGF0IGxpZmV0aW1lIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIC0gY2FwYWJpbGl0eTogICAgKG9wdGlvbmFsKSB0aGUgY2FwYWJpbGl0eSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgYWNjZXNzIHRva2VuLlxuICAgICAqICAgICAgICAgICAgICAgICAgSWYgbm9uZSBpcyBzcGVjaWZpZWQsIGEgdG9rZW4gd2lsbCBiZSByZXF1ZXN0ZWQgd2l0aCBhbGwgb2YgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICBjYXBhYmlsaXRpZXMgb2YgdGhlIHNwZWNpZmllZCBrZXkuXG4gICAgICpcbiAgICAgKiAtIGNsaWVudElkOiAgICAgIChvcHRpb25hbCkgYSBjbGllbnQgSUQgdG8gYXNzb2NpYXRlIHdpdGggdGhlIHRva2VuOyBpZiBub3RcbiAgICAgKiAgICAgICAgICAgICAgICAgIHNwZWNpZmllZCwgYSBjbGllbnRJZCBwYXNzZWQgaW4gY29uc3RydWN0aW5nIHRoZSBSZXN0IGludGVyZmFjZSB3aWxsIGJlIHVzZWRcbiAgICAgKlxuICAgICAqIC0gdGltZXN0YW1wOiAgICAgKG9wdGlvbmFsKSB0aGUgdGltZSBpbiBtcyBzaW5jZSB0aGUgZXBvY2guIElmIG5vbmUgaXMgc3BlY2lmaWVkLFxuICAgICAqICAgICAgICAgICAgICAgICAgdGhlIHN5c3RlbSB3aWxsIGJlIHF1ZXJpZWQgZm9yIGEgdGltZSB2YWx1ZSB0byB1c2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBBdXRoLnByb3RvdHlwZS5jcmVhdGVUb2tlblJlcXVlc3QgPSBmdW5jdGlvbiAodG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiBzaHVmZmxlIGFuZCBub3JtYWxpc2UgYXJndW1lbnRzIGFzIG5lY2Vzc2FyeSAqL1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuUGFyYW1zID09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHRva2VuUGFyYW1zO1xuICAgICAgICAgICAgYXV0aE9wdGlvbnMgPSB0b2tlblBhcmFtcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGF1dGhPcHRpb25zID09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGF1dGhPcHRpb25zO1xuICAgICAgICAgICAgYXV0aE9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FsbGJhY2sgJiYgdGhpcy5jbGllbnQub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnY3JlYXRlVG9rZW5SZXF1ZXN0JywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBSU0E5aDogaWYgYXV0aE9wdGlvbnMgcGFzc2VkIGluLCB0aGV5J3JlIHVzZWQgaW5zdGVhZCBvZiBzdG9yZWQsIGRvbid0IG1lcmdlIHRoZW0gKi9cbiAgICAgICAgYXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucyB8fCB0aGlzLmF1dGhPcHRpb25zO1xuICAgICAgICB0b2tlblBhcmFtcyA9IHRva2VuUGFyYW1zIHx8IFV0aWxzLmNvcHkodGhpcy50b2tlblBhcmFtcyk7XG4gICAgICAgIHZhciBrZXkgPSBhdXRoT3B0aW9ucy5rZXk7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnTm8ga2V5IHNwZWNpZmllZCcsIDQwMTAxLCA0MDMpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5UGFydHMgPSBrZXkuc3BsaXQoJzonKSwga2V5TmFtZSA9IGtleVBhcnRzWzBdLCBrZXlTZWNyZXQgPSBrZXlQYXJ0c1sxXTtcbiAgICAgICAgaWYgKCFrZXlTZWNyZXQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdJbnZhbGlkIGtleSBzcGVjaWZpZWQnLCA0MDEwMSwgNDAzKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuUGFyYW1zLmNsaWVudElkID09PSAnJykge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ2NsaWVudElkIGNhbuKAmXQgYmUgYW4gZW1wdHkgc3RyaW5nJywgNDAwMTIsIDQwMCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnY2FwYWJpbGl0eScgaW4gdG9rZW5QYXJhbXMpIHtcbiAgICAgICAgICAgIHRva2VuUGFyYW1zLmNhcGFiaWxpdHkgPSBjMTRuKHRva2VuUGFyYW1zLmNhcGFiaWxpdHkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXF1ZXN0ID0gVXRpbHMubWl4aW4oeyBrZXlOYW1lOiBrZXlOYW1lIH0sIHRva2VuUGFyYW1zKSwgY2xpZW50SWQgPSB0b2tlblBhcmFtcy5jbGllbnRJZCB8fCAnJywgdHRsID0gdG9rZW5QYXJhbXMudHRsIHx8ICcnLCBjYXBhYmlsaXR5ID0gdG9rZW5QYXJhbXMuY2FwYWJpbGl0eSB8fCAnJztcbiAgICAgICAgKGZ1bmN0aW9uIChhdXRob3Jpc2VDYikge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QudGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgYXV0aG9yaXNlQ2IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5nZXRUaW1lc3RhbXAoYXV0aE9wdGlvbnMgJiYgYXV0aE9wdGlvbnMucXVlcnlUaW1lLCBmdW5jdGlvbiAoZXJyLCB0aW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcXVlc3QudGltZXN0YW1wID0gdGltZTtcbiAgICAgICAgICAgICAgICBhdXRob3Jpc2VDYigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8qIG5vbmNlICovXG4gICAgICAgICAgICAvKiBOT1RFOiB0aGVyZSBpcyBubyBleHBlY3RhdGlvbiB0aGF0IHRoZSBjbGllbnRcbiAgICAgICAgICAgICAqIHNwZWNpZmllcyB0aGUgbm9uY2U7IHRoaXMgaXMgZG9uZSBieSB0aGUgbGlicmFyeVxuICAgICAgICAgICAgICogSG93ZXZlciwgdGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgY2xpZW50XG4gICAgICAgICAgICAgKiBzaW1wbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuICovXG4gICAgICAgICAgICB2YXIgbm9uY2UgPSByZXF1ZXN0Lm5vbmNlIHx8IChyZXF1ZXN0Lm5vbmNlID0gcmFuZG9tKCkpLCB0aW1lc3RhbXAgPSByZXF1ZXN0LnRpbWVzdGFtcDtcbiAgICAgICAgICAgIHZhciBzaWduVGV4dCA9IHJlcXVlc3Qua2V5TmFtZSArICdcXG4nICsgdHRsICsgJ1xcbicgKyBjYXBhYmlsaXR5ICsgJ1xcbicgKyBjbGllbnRJZCArICdcXG4nICsgdGltZXN0YW1wICsgJ1xcbicgKyBub25jZSArICdcXG4nO1xuICAgICAgICAgICAgLyogbWFjICovXG4gICAgICAgICAgICAvKiBOT1RFOiB0aGVyZSBpcyBubyBleHBlY3RhdGlvbiB0aGF0IHRoZSBjbGllbnRcbiAgICAgICAgICAgICAqIHNwZWNpZmllcyB0aGUgbWFjOyB0aGlzIGlzIGRvbmUgYnkgdGhlIGxpYnJhcnlcbiAgICAgICAgICAgICAqIEhvd2V2ZXIsIHRoaXMgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGNsaWVudFxuICAgICAgICAgICAgICogc2ltcGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLiAqL1xuICAgICAgICAgICAgcmVxdWVzdC5tYWMgPSByZXF1ZXN0Lm1hYyB8fCBobWFjKHNpZ25UZXh0LCBrZXlTZWNyZXQpO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdBdXRoLmdldFRva2VuUmVxdWVzdCgpJywgJ2dlbmVyYXRlZCBzaWduZWQgcmVxdWVzdCcpO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVxdWVzdCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhdXRoIHF1ZXJ5IHBhcmFtcyB0byB1c2UgZm9yIGEgd2Vic29ja2V0IGNvbm5lY3Rpb24sXG4gICAgICogYmFzZWQgb24gdGhlIGN1cnJlbnQgYXV0aCBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgQXV0aC5wcm90b3R5cGUuZ2V0QXV0aFBhcmFtcyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5tZXRob2QgPT0gJ2Jhc2ljJylcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsga2V5OiB0aGlzLmtleSB9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZmFsc2UsIGZ1bmN0aW9uIChlcnIsIHRva2VuRGV0YWlscykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuRGV0YWlscykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGguZ2V0QXV0aFBhcmFtcygpOiBfZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMgcmV0dXJuZWQgbm8gZXJyb3Igb3IgdG9rZW5EZXRhaWxzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsgYWNjZXNzX3Rva2VuOiB0b2tlbkRldGFpbHMudG9rZW4gfSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXV0aG9yaXphdGlvbiBoZWFkZXIgdG8gdXNlIGZvciBhIFJFU1Qgb3IgY29tZXQgcmVxdWVzdCxcbiAgICAgKiBiYXNlZCBvbiB0aGUgY3VycmVudCBhdXRoIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICBBdXRoLnByb3RvdHlwZS5nZXRBdXRoSGVhZGVycyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5tZXRob2QgPT0gJ2Jhc2ljJykge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeyBhdXRob3JpemF0aW9uOiAnQmFzaWMgJyArIHRoaXMuYmFzaWNLZXkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmYWxzZSwgZnVuY3Rpb24gKGVyciwgdG9rZW5EZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdG9rZW5EZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0aC5nZXRBdXRoUGFyYW1zKCk6IF9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyByZXR1cm5lZCBubyBlcnJvciBvciB0b2tlbkRldGFpbHMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeyBhdXRob3JpemF0aW9uOiAnQmVhcmVyICcgKyBVdGlscy50b0Jhc2U2NCh0b2tlbkRldGFpbHMudG9rZW4pIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCB0aW1lIGJhc2VkIG9uIHRoZSBsb2NhbCBjbG9jayxcbiAgICAgKiBvciBpZiB0aGUgb3B0aW9uIHF1ZXJ5VGltZSBpcyB0cnVlLCByZXR1cm4gdGhlIHNlcnZlciB0aW1lLlxuICAgICAqIFRoZSBzZXJ2ZXIgdGltZSBvZmZzZXQgZnJvbSB0aGUgbG9jYWwgdGltZSBpcyBzdG9yZWQgc28gdGhhdFxuICAgICAqIG9ubHkgb25lIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB0byBnZXQgdGhlIHRpbWUgaXMgZXZlciBuZWVkZWRcbiAgICAgKi9cbiAgICBBdXRoLnByb3RvdHlwZS5nZXRUaW1lc3RhbXAgPSBmdW5jdGlvbiAocXVlcnlUaW1lLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuaXNUaW1lT2Zmc2V0U2V0KCkgJiYgKHF1ZXJ5VGltZSB8fCB0aGlzLmF1dGhPcHRpb25zLnF1ZXJ5VGltZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50LnRpbWUoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdGhpcy5nZXRUaW1lc3RhbXBVc2luZ09mZnNldCgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXV0aC5wcm90b3R5cGUuZ2V0VGltZXN0YW1wVXNpbmdPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBVdGlscy5ub3coKSArICh0aGlzLmNsaWVudC5zZXJ2ZXJUaW1lT2Zmc2V0IHx8IDApO1xuICAgIH07XG4gICAgQXV0aC5wcm90b3R5cGUuaXNUaW1lT2Zmc2V0U2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuc2VydmVyVGltZU9mZnNldCAhPT0gbnVsbDtcbiAgICB9O1xuICAgIEF1dGgucHJvdG90eXBlLl9zYXZlQmFzaWNPcHRpb25zID0gZnVuY3Rpb24gKGF1dGhPcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gJ2Jhc2ljJztcbiAgICAgICAgdGhpcy5rZXkgPSBhdXRoT3B0aW9ucy5rZXk7XG4gICAgICAgIHRoaXMuYmFzaWNLZXkgPSBVdGlscy50b0Jhc2U2NChhdXRoT3B0aW9ucy5rZXkpO1xuICAgICAgICB0aGlzLmF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICgnY2xpZW50SWQnIGluIGF1dGhPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl91c2VyU2V0Q2xpZW50SWQoYXV0aE9wdGlvbnMuY2xpZW50SWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdXRoLnByb3RvdHlwZS5fc2F2ZVRva2VuT3B0aW9ucyA9IGZ1bmN0aW9uICh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSAndG9rZW4nO1xuICAgICAgICBpZiAodG9rZW5QYXJhbXMpIHtcbiAgICAgICAgICAgIC8qIFdlIHRlbXBvcmFyaWx5IHBlcnNpc3QgdG9rZW5QYXJhbXMudGltZXN0YW1wIGluIGNhc2UgYSBuZXcgdG9rZW4gbmVlZHNcbiAgICAgICAgICAgICAqIHRvIGJlIHJlcXVlc3RlZCwgdGhlbiBudWxsIGl0IG91dCBpbiB0aGUgY2FsbGJhY2sgb2ZcbiAgICAgICAgICAgICAqIF9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyBmb3IgUlNBMTBnIGNvbXBsaWFuY2UgKi9cbiAgICAgICAgICAgIHRoaXMudG9rZW5QYXJhbXMgPSB0b2tlblBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0aE9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8qIG5vcm1hbGlzZSAqL1xuICAgICAgICAgICAgaWYgKGF1dGhPcHRpb25zLnRva2VuKSB7XG4gICAgICAgICAgICAgICAgLyogb3B0aW9ucy50b2tlbiBtYXkgY29udGFpbiBhIHRva2VuIHN0cmluZyBvciwgZm9yIGNvbnZlbmllbmNlLCBhIFRva2VuRGV0YWlscyAqL1xuICAgICAgICAgICAgICAgIGF1dGhPcHRpb25zLnRva2VuRGV0YWlscyA9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBhdXRoT3B0aW9ucy50b2tlbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyB0b2tlbjogYXV0aE9wdGlvbnMudG9rZW4gfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBhdXRoT3B0aW9ucy50b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdXRoT3B0aW9ucy50b2tlbkRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2VuRGV0YWlscyA9IGF1dGhPcHRpb25zLnRva2VuRGV0YWlscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnY2xpZW50SWQnIGluIGF1dGhPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXNlclNldENsaWVudElkKGF1dGhPcHRpb25zLmNsaWVudElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyogQHBhcmFtIGZvcmNlU3VwZXJzZWRlOiBmb3JjZSBhIG5ldyB0b2tlbiByZXF1ZXN0IGV2ZW4gaWYgdGhlcmUncyBvbmUgaW5cbiAgICAgKiBwcm9ncmVzcywgbWFraW5nIGFsbCBwZW5kaW5nIGNhbGxiYWNrcyB3YWl0IGZvciB0aGUgbmV3IG9uZSAqL1xuICAgIEF1dGgucHJvdG90eXBlLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyA9IGZ1bmN0aW9uIChmb3JjZVN1cGVyc2VkZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRva2VuID0gdGhpcy50b2tlbkRldGFpbHM7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Rva2VuQ2xpZW50SWRNaXNtYXRjaCh0b2tlbi5jbGllbnRJZCkpIHtcbiAgICAgICAgICAgICAgICAvKiA0MDMgdG8gdHJpZ2dlciBhIHBlcm1hbmVudGx5IGZhaWxlZCBjbGllbnQgLSBSU0ExNWMgKi9cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnTWlzbWF0Y2ggYmV0d2VlbiBjbGllbnRJZCBpbiB0b2tlbiAoJyArIHRva2VuLmNsaWVudElkICsgJykgYW5kIGN1cnJlbnQgY2xpZW50SWQgKCcgKyB0aGlzLmNsaWVudElkICsgJyknLCA0MDEwMiwgNDAzKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogUlNBNGIxIC0tIGlmIHdlIGhhdmUgYSBzZXJ2ZXIgdGltZSBvZmZzZXQgc2V0IGFscmVhZHksIHdlIGNhblxuICAgICAgICAgICAgICogYXV0b21hdGljYWxseSByZW1vdmUgZXhwaXJlZCB0b2tlbnMuIEVsc2UganVzdCB1c2UgdGhlIGNhY2hlZCB0b2tlbi4gSWYgaXQgaXNcbiAgICAgICAgICAgICAqIGV4cGlyZWQgQWJseSB3aWxsIHRlbGwgdXMgYW5kIHdlJ2xsIGRpc2NhcmQgaXQgdGhlbi4gKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5pc1RpbWVPZmZzZXRTZXQoKSB8fCAhdG9rZW4uZXhwaXJlcyB8fCB0b2tlbi5leHBpcmVzID49IHRoaXMuZ2V0VGltZXN0YW1wVXNpbmdPZmZzZXQoKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQXV0aC5nZXRUb2tlbigpJywgJ3VzaW5nIGNhY2hlZCB0b2tlbjsgZXhwaXJlcyA9ICcgKyB0b2tlbi5leHBpcmVzKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZXhwaXJlZCwgc28gcmVtb3ZlIGFuZCBmYWxsdGhyb3VnaCB0byBnZXR0aW5nIGEgbmV3IG9uZSAqL1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdBdXRoLmdldFRva2VuKCknLCAnZGVsZXRpbmcgZXhwaXJlZCB0b2tlbicpO1xuICAgICAgICAgICAgdGhpcy50b2tlbkRldGFpbHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgICh0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgfHwgKHRoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdCA9IG11bHRpY2FzdGVyXzEuZGVmYXVsdC5jcmVhdGUoKSkpLnB1c2goY2FsbGJhY2spO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgIT09IG51bGwgJiYgIWZvcmNlU3VwZXJzZWRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyogUmVxdWVzdCBhIG5ldyB0b2tlbiAqL1xuICAgICAgICB2YXIgdG9rZW5SZXF1ZXN0SWQgPSAodGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgPSBnZXRUb2tlblJlcXVlc3RJZCgpKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0VG9rZW4odGhpcy50b2tlblBhcmFtcywgdGhpcy5hdXRoT3B0aW9ucywgZnVuY3Rpb24gKGVyciwgdG9rZW5SZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA+IHRva2VuUmVxdWVzdElkKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdBdXRoLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscygpJywgJ0Rpc2NhcmRpbmcgdG9rZW4gcmVxdWVzdCByZXNwb25zZTsgb3ZlcnRha2VuIGJ5IG5ld2VyIG9uZScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gX3RoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdCB8fCBub29wO1xuICAgICAgICAgICAgX3RoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2tzKG51bGwsIChfdGhpcy50b2tlbkRldGFpbHMgPSB0b2tlblJlc3BvbnNlKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyogVXNlci1zZXQ6IGNoZWNrIHR5cGVzLCAnKicgaXMgZGlzYWxsb3dlZCwgdGhyb3cgYW55IGVycm9ycyAqL1xuICAgIEF1dGgucHJvdG90eXBlLl91c2VyU2V0Q2xpZW50SWQgPSBmdW5jdGlvbiAoY2xpZW50SWQpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIGNsaWVudElkID09PSAnc3RyaW5nJyB8fCBjbGllbnRJZCA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdjbGllbnRJZCBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBudWxsJywgNDAwMTIsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xpZW50SWQgPT09ICcqJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0NhbuKAmXQgdXNlIFwiKlwiIGFzIGEgY2xpZW50SWQgYXMgdGhhdCBzdHJpbmcgaXMgcmVzZXJ2ZWQuIChUbyBjaGFuZ2UgdGhlIGRlZmF1bHQgdG9rZW4gcmVxdWVzdCBiZWhhdmlvdXIgdG8gdXNlIGEgd2lsZGNhcmQgY2xpZW50SWQsIGluc3RhbnRpYXRlIHRoZSBsaWJyYXJ5IHdpdGgge2RlZmF1bHRUb2tlblBhcmFtczoge2NsaWVudElkOiBcIipcIn19KSwgb3IgaWYgY2FsbGluZyBhdXRob3JpemUoKSwgcGFzcyBpdCBpbiBhcyBhIHRva2VuUGFyYW06IGF1dGhvcml6ZSh7Y2xpZW50SWQ6IFwiKlwifSwgYXV0aE9wdGlvbnMpJywgNDAwMTIsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gdGhpcy5fdW5jaGVja2VkU2V0Q2xpZW50SWQoY2xpZW50SWQpO1xuICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qIEFibHktc2V0OiBubyB0eXBlY2hlY2tpbmcsICcqJyBpcyBhbGxvd2VkIGJ1dCBub3Qgc2V0IG9uIHRoaXMuY2xpZW50SWQpLCByZXR1cm4gZXJyb3JzIHRvIHRoZSBjYWxsZXIgKi9cbiAgICBBdXRoLnByb3RvdHlwZS5fdW5jaGVja2VkU2V0Q2xpZW50SWQgPSBmdW5jdGlvbiAoY2xpZW50SWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Rva2VuQ2xpZW50SWRNaXNtYXRjaChjbGllbnRJZCkpIHtcbiAgICAgICAgICAgIC8qIFNob3VsZCBuZXZlciBoYXBwZW4gaW4gbm9ybWFsIGNpcmN1bXN0YW5jZXMgYXMgcmVhbHRpbWUgc2hvdWxkXG4gICAgICAgICAgICAgKiByZWNvZ25pc2UgbWlzbWF0Y2ggYW5kIHJldHVybiBhbiBlcnJvciAqL1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdVbmV4cGVjdGVkIGNsaWVudElkIG1pc21hdGNoOiBjbGllbnQgaGFzICcgKyB0aGlzLmNsaWVudElkICsgJywgcmVxdWVzdGVkICcgKyBjbGllbnRJZDtcbiAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDQwMTAyLCA0MDEpO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdBdXRoLl91bmNoZWNrZWRTZXRDbGllbnRJZCgpJywgbXNnKTtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBSU0E3YTQ6IGlmIG9wdGlvbnMuY2xpZW50SWQgaXMgcHJvdmlkZWQgYW5kIGlzIG5vdFxuICAgICAgICAgICAgICogbnVsbCwgaXQgb3ZlcnJpZGVzIGRlZmF1bHRUb2tlblBhcmFtcy5jbGllbnRJZCAqL1xuICAgICAgICAgICAgdGhpcy5jbGllbnRJZCA9IHRoaXMudG9rZW5QYXJhbXMuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdXRoLnByb3RvdHlwZS5fdG9rZW5DbGllbnRJZE1pc21hdGNoID0gZnVuY3Rpb24gKHRva2VuQ2xpZW50SWQpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuY2xpZW50SWQgJiZcbiAgICAgICAgICAgIHRoaXMuY2xpZW50SWQgIT09ICcqJyAmJlxuICAgICAgICAgICAgdG9rZW5DbGllbnRJZCAmJlxuICAgICAgICAgICAgdG9rZW5DbGllbnRJZCAhPT0gJyonICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudElkICE9PSB0b2tlbkNsaWVudElkKTtcbiAgICB9O1xuICAgIEF1dGguaXNUb2tlbkVyciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3IuY29kZSAmJiBlcnJvci5jb2RlID49IDQwMTQwICYmIGVycm9yLmNvZGUgPCA0MDE1MDtcbiAgICB9O1xuICAgIEF1dGgucHJvdG90eXBlLnJldm9rZVRva2VucyA9IGZ1bmN0aW9uIChzcGVjaWZpZXJzLCBvcHRpb25zT3JDYWxsYmFja0FyZywgY2FsbGJhY2tBcmcpIHtcbiAgICAgICAgaWYgKHVzZVRva2VuQXV0aCh0aGlzLmNsaWVudC5vcHRpb25zKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0Nhbm5vdCByZXZva2UgdG9rZW5zIHdoZW4gdXNpbmcgdG9rZW4gYXV0aCcsIDQwMTYyLCA0MDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlOYW1lID0gdGhpcy5jbGllbnQub3B0aW9ucy5rZXlOYW1lO1xuICAgICAgICB2YXIgcmVzb2x2ZWRPcHRpb25zO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNPckNhbGxiYWNrQXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFja0FyZyA9IG9wdGlvbnNPckNhbGxiYWNrQXJnO1xuICAgICAgICAgICAgcmVzb2x2ZWRPcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlZE9wdGlvbnMgPSBvcHRpb25zT3JDYWxsYmFja0FyZyAhPT0gbnVsbCAmJiBvcHRpb25zT3JDYWxsYmFja0FyZyAhPT0gdm9pZCAwID8gb3B0aW9uc09yQ2FsbGJhY2tBcmcgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2tBcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xpZW50Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdyZXZva2VUb2tlbnMnLCBbc3BlY2lmaWVycywgcmVzb2x2ZWRPcHRpb25zXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFja0FyZyA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tBcmc7XG4gICAgICAgIHZhciByZXF1ZXN0Qm9keURUTyA9IHRzbGliXzEuX19hc3NpZ24oeyB0YXJnZXRzOiBzcGVjaWZpZXJzLm1hcChmdW5jdGlvbiAoc3BlY2lmaWVyKSB7IHJldHVybiBcIlwiLmNvbmNhdChzcGVjaWZpZXIudHlwZSwgXCI6XCIpLmNvbmNhdChzcGVjaWZpZXIudmFsdWUpOyB9KSB9LCByZXNvbHZlZE9wdGlvbnMpO1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5jbGllbnQub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0UG9zdEhlYWRlcnModGhpcy5jbGllbnQub3B0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHRoaXMuY2xpZW50Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIHZhciByZXF1ZXN0Qm9keSA9IFV0aWxzLmVuY29kZUJvZHkocmVxdWVzdEJvZHlEVE8sIGZvcm1hdCk7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdC5wb3N0KHRoaXMuY2xpZW50LCBcIi9rZXlzL1wiLmNvbmNhdChrZXlOYW1lLCBcIi9yZXZva2VUb2tlbnNcIiksIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCB7IG5ld0JhdGNoUmVzcG9uc2U6ICd0cnVlJyB9LCBudWxsLCBmdW5jdGlvbiAoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgdHlwZSBhc3NlcnRpb24gYWZ0ZXIgZml4aW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5L2FibHktanMvaXNzdWVzLzE0MDVcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiYXRjaFJlc3VsdCA9ICh1bnBhY2tlZCA/IGJvZHkgOiBVdGlscy5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCkpO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYmF0Y2hSZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBBdXRoO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEF1dGg7XG5cblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEh0dHBNZXRob2RzO1xuKGZ1bmN0aW9uIChIdHRwTWV0aG9kcykge1xuICAgIEh0dHBNZXRob2RzW1wiR2V0XCJdID0gXCJnZXRcIjtcbiAgICBIdHRwTWV0aG9kc1tcIkRlbGV0ZVwiXSA9IFwiZGVsZXRlXCI7XG4gICAgSHR0cE1ldGhvZHNbXCJQb3N0XCJdID0gXCJwb3N0XCI7XG4gICAgSHR0cE1ldGhvZHNbXCJQdXRcIl0gPSBcInB1dFwiO1xuICAgIEh0dHBNZXRob2RzW1wiUGF0Y2hcIl0gPSBcInBhdGNoXCI7XG59KShIdHRwTWV0aG9kcyB8fCAoSHR0cE1ldGhvZHMgPSB7fSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSHR0cE1ldGhvZHM7XG5cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IdHRwUGFnaW5hdGVkUmVzcG9uc2UgPSBleHBvcnRzLlBhZ2luYXRlZFJlc3VsdCA9IHZvaWQgMDtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgcmVzb3VyY2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTQpKTtcbmZ1bmN0aW9uIGdldFJlbFBhcmFtcyhsaW5rVXJsKSB7XG4gICAgdmFyIHVybE1hdGNoID0gbGlua1VybC5tYXRjaCgvXlxcLlxcLyhcXHcrKVxcPyguKikkLyk7XG4gICAgcmV0dXJuIHVybE1hdGNoICYmIHVybE1hdGNoWzJdICYmIFV0aWxzLnBhcnNlUXVlcnlTdHJpbmcodXJsTWF0Y2hbMl0pO1xufVxuZnVuY3Rpb24gcGFyc2VSZWxMaW5rcyhsaW5rSGVhZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaW5rSGVhZGVyID09ICdzdHJpbmcnKVxuICAgICAgICBsaW5rSGVhZGVyID0gbGlua0hlYWRlci5zcGxpdCgnLCcpO1xuICAgIHZhciByZWxQYXJhbXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmtIZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmtNYXRjaCA9IGxpbmtIZWFkZXJbaV0ubWF0Y2goL15cXHMqPCguKyk+O1xccypyZWw9XCIoXFx3KylcIiQvKTtcbiAgICAgICAgaWYgKGxpbmtNYXRjaCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IGdldFJlbFBhcmFtcyhsaW5rTWF0Y2hbMV0pO1xuICAgICAgICAgICAgaWYgKHBhcmFtcylcbiAgICAgICAgICAgICAgICByZWxQYXJhbXNbbGlua01hdGNoWzJdXSA9IHBhcmFtcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVsUGFyYW1zO1xufVxuZnVuY3Rpb24gcmV0dXJuRXJyT25seShlcnIsIGJvZHksIHVzZUhQUikge1xuICAgIC8qIElmIHVzaW5nIGh0dHBQYWdpbmF0ZWRSZXNwb25zZSwgZXJyb3JzIGZyb20gQWJseSBhcmUgcmV0dXJuZWQgYXMgcGFydCBvZlxuICAgICAqIHRoZSBIUFIsIG9ubHkgZG8gY2FsbGJhY2soZXJyKSBmb3IgbmV0d29yayBlcnJvcnMgZXRjLiB3aGljaCBkb24ndFxuICAgICAqIHJldHVybiBhIGJvZHkgYW5kL29yIGhhdmUgbm8gYWJseS1vcmlnaW5hdGVkIGVycm9yIGNvZGUgKG5vbi1udW1lcmljXG4gICAgICogZXJyb3IgY29kZXMgb3JpZ2luYXRlIGZyb20gbm9kZSkgKi9cbiAgICByZXR1cm4gISh1c2VIUFIgJiYgKGJvZHkgfHwgdHlwZW9mIGVyci5jb2RlID09PSAnbnVtYmVyJykpO1xufVxudmFyIFBhZ2luYXRlZFJlc291cmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhZ2luYXRlZFJlc291cmNlKHJlc3QsIHBhdGgsIGhlYWRlcnMsIGVudmVsb3BlLCBib2R5SGFuZGxlciwgdXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMucmVzdCA9IHJlc3Q7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIHRoaXMuZW52ZWxvcGUgPSBlbnZlbG9wZSAhPT0gbnVsbCAmJiBlbnZlbG9wZSAhPT0gdm9pZCAwID8gZW52ZWxvcGUgOiBudWxsO1xuICAgICAgICB0aGlzLmJvZHlIYW5kbGVyID0gYm9keUhhbmRsZXI7XG4gICAgICAgIHRoaXMudXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlID0gdXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlIHx8IGZhbHNlO1xuICAgIH1cbiAgICBQYWdpbmF0ZWRSZXNvdXJjZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LmdldCh0aGlzLnJlc3QsIHRoaXMucGF0aCwgdGhpcy5oZWFkZXJzLCBwYXJhbXMsIHRoaXMuZW52ZWxvcGUsIGZ1bmN0aW9uIChlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVQYWdlKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQYWdpbmF0ZWRSZXNvdXJjZS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LmRlbGV0ZSh0aGlzLnJlc3QsIHRoaXMucGF0aCwgdGhpcy5oZWFkZXJzLCBwYXJhbXMsIHRoaXMuZW52ZWxvcGUsIGZ1bmN0aW9uIChlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVQYWdlKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQYWdpbmF0ZWRSZXNvdXJjZS5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uIChwYXJhbXMsIGJvZHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdC5wb3N0KHRoaXMucmVzdCwgdGhpcy5wYXRoLCBib2R5LCB0aGlzLmhlYWRlcnMsIHBhcmFtcywgdGhpcy5lbnZlbG9wZSwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2VCb2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlUGFnZShlcnIsIHJlc3BvbnNlQm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQYWdpbmF0ZWRSZXNvdXJjZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKHBhcmFtcywgYm9keSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LnB1dCh0aGlzLnJlc3QsIHRoaXMucGF0aCwgYm9keSwgdGhpcy5oZWFkZXJzLCBwYXJhbXMsIHRoaXMuZW52ZWxvcGUsIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlQm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVBhZ2UoZXJyLCByZXNwb25zZUJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUGFnaW5hdGVkUmVzb3VyY2UucHJvdG90eXBlLnBhdGNoID0gZnVuY3Rpb24gKHBhcmFtcywgYm9keSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LnBhdGNoKHRoaXMucmVzdCwgdGhpcy5wYXRoLCBib2R5LCB0aGlzLmhlYWRlcnMsIHBhcmFtcywgdGhpcy5lbnZlbG9wZSwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2VCb2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlUGFnZShlcnIsIHJlc3BvbnNlQm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQYWdpbmF0ZWRSZXNvdXJjZS5wcm90b3R5cGUuaGFuZGxlUGFnZSA9IGZ1bmN0aW9uIChlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoZXJyICYmIHJldHVybkVyck9ubHkoZXJyLCBib2R5LCB0aGlzLnVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSkpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnUGFnaW5hdGVkUmVzb3VyY2UuaGFuZGxlUGFnZSgpJywgJ1VuZXhwZWN0ZWQgZXJyb3IgZ2V0dGluZyByZXNvdXJjZTogZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpdGVtcywgbGlua0hlYWRlciwgcmVsUGFyYW1zO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaXRlbXMgPSB0aGlzLmJvZHlIYW5kbGVyKGJvZHksIGhlYWRlcnMgfHwge30sIHVucGFja2VkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogSWYgd2UgZ290IGFuIGVycm9yLCB0aGUgZmFpbHVyZSB0byBwYXJzZSB0aGUgYm9keSBpcyBhbG1vc3QgY2VydGFpbmx5XG4gICAgICAgICAgICAgKiBkdWUgdG8gdGhhdCwgc28gY2FsbGJhY2sgd2l0aCB0aGF0IGluIHByZWZlcmVuY2Ugb3ZlciB0aGUgcGFyc2UgZXJyb3IgKi9cbiAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhlcnIgfHwgZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlYWRlcnMgJiYgKGxpbmtIZWFkZXIgPSBoZWFkZXJzWydMaW5rJ10gfHwgaGVhZGVyc1snbGluayddKSkge1xuICAgICAgICAgICAgcmVsUGFyYW1zID0gcGFyc2VSZWxMaW5rcyhsaW5rSGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG5ldyBIdHRwUGFnaW5hdGVkUmVzcG9uc2UodGhpcywgaXRlbXMsIGhlYWRlcnMgfHwge30sIHN0YXR1c0NvZGUsIHJlbFBhcmFtcywgZXJyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBuZXcgUGFnaW5hdGVkUmVzdWx0KHRoaXMsIGl0ZW1zLCByZWxQYXJhbXMpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFBhZ2luYXRlZFJlc291cmNlO1xufSgpKTtcbnZhciBQYWdpbmF0ZWRSZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFnaW5hdGVkUmVzdWx0KHJlc291cmNlLCBpdGVtcywgcmVsUGFyYW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChyZWxQYXJhbXMpIHtcbiAgICAgICAgICAgIGlmICgnZmlyc3QnIGluIHJlbFBhcmFtcykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3QgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFjayAmJiBzZWxmLnJlc291cmNlLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeShzZWxmLCAnZmlyc3QnLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5nZXQocmVsUGFyYW1zLmZpcnN0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnY3VycmVudCcgaW4gcmVsUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FsbGJhY2sgJiYgc2VsZi5yZXNvdXJjZS5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkoc2VsZiwgJ2N1cnJlbnQnLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5nZXQocmVsUGFyYW1zLmN1cnJlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uZXh0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFjayAmJiBzZWxmLnJlc291cmNlLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHNlbGYsICduZXh0JywgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJ25leHQnIGluIHJlbFBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmdldChyZWxQYXJhbXMubmV4dCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuaGFzTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25leHQnIGluIHJlbFBhcmFtcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmlzTGFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEoKF9hID0gX3RoaXMuaGFzTmV4dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoX3RoaXMpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogV2UgYXNzdW1lIHRoYXQgb25seSB0aGUgaW5pdGlhbCByZXF1ZXN0IGNhbiBiZSBhIFBPU1QsIGFuZCB0aGF0IGFjY2Vzc2luZ1xuICAgICAqIHRoZSByZXN0IG9mIGEgbXVsdGlwYWdlIHNldCBvZiByZXN1bHRzIGNhbiBhbHdheXMgYmUgZG9uZSB3aXRoIEdFVCAqL1xuICAgIFBhZ2luYXRlZFJlc3VsdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMucmVzb3VyY2U7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdC5nZXQocmVzLnJlc3QsIHJlcy5wYXRoLCByZXMuaGVhZGVycywgcGFyYW1zLCByZXMuZW52ZWxvcGUsIGZ1bmN0aW9uIChlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICByZXMuaGFuZGxlUGFnZShlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFBhZ2luYXRlZFJlc3VsdDtcbn0oKSk7XG5leHBvcnRzLlBhZ2luYXRlZFJlc3VsdCA9IFBhZ2luYXRlZFJlc3VsdDtcbnZhciBIdHRwUGFnaW5hdGVkUmVzcG9uc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSHR0cFBhZ2luYXRlZFJlc3BvbnNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEh0dHBQYWdpbmF0ZWRSZXNwb25zZShyZXNvdXJjZSwgaXRlbXMsIGhlYWRlcnMsIHN0YXR1c0NvZGUsIHJlbFBhcmFtcywgZXJyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJlc291cmNlLCBpdGVtcywgcmVsUGFyYW1zKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICAgICAgX3RoaXMuc3VjY2VzcyA9IHN0YXR1c0NvZGUgPCAzMDAgJiYgc3RhdHVzQ29kZSA+PSAyMDA7XG4gICAgICAgIF90aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICBfdGhpcy5lcnJvckNvZGUgPSBlcnIgJiYgZXJyLmNvZGU7XG4gICAgICAgIF90aGlzLmVycm9yTWVzc2FnZSA9IGVyciAmJiBlcnIubWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBIdHRwUGFnaW5hdGVkUmVzcG9uc2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGl0ZW1zOiB0aGlzLml0ZW1zLFxuICAgICAgICAgICAgc3RhdHVzQ29kZTogdGhpcy5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgc3VjY2VzczogdGhpcy5zdWNjZXNzLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgZXJyb3JDb2RlOiB0aGlzLmVycm9yQ29kZSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZTogdGhpcy5lcnJvck1lc3NhZ2UsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gSHR0cFBhZ2luYXRlZFJlc3BvbnNlO1xufShQYWdpbmF0ZWRSZXN1bHQpKTtcbmV4cG9ydHMuSHR0cFBhZ2luYXRlZFJlc3BvbnNlID0gSHR0cFBhZ2luYXRlZFJlc3BvbnNlO1xuZXhwb3J0cy5kZWZhdWx0ID0gUGFnaW5hdGVkUmVzb3VyY2U7XG5cblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1JldHJpYWJsZSA9IHZvaWQgMDtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIENvbm5lY3Rpb25FcnJvckNvZGVzID0ge1xuICAgIERJU0NPTk5FQ1RFRDogODAwMDMsXG4gICAgU1VTUEVOREVEOiA4MDAwMixcbiAgICBGQUlMRUQ6IDgwMDAwLFxuICAgIENMT1NJTkc6IDgwMDE3LFxuICAgIENMT1NFRDogODAwMTcsXG4gICAgVU5LTk9XTl9DT05ORUNUSU9OX0VSUjogNTAwMDIsXG4gICAgVU5LTk9XTl9DSEFOTkVMX0VSUjogNTAwMDEsXG59O1xudmFyIENvbm5lY3Rpb25FcnJvcnMgPSB7XG4gICAgZGlzY29ubmVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogNDAwLFxuICAgICAgICAgICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuRElTQ09OTkVDVEVELFxuICAgICAgICAgICAgbWVzc2FnZTogJ0Nvbm5lY3Rpb24gdG8gc2VydmVyIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlJyxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBzdXNwZW5kZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgICAgICAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5TVVNQRU5ERUQsXG4gICAgICAgICAgICBtZXNzYWdlOiAnQ29ubmVjdGlvbiB0byBzZXJ2ZXIgdW5hdmFpbGFibGUnLFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGZhaWxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICAgICAgICAgIGNvZGU6IENvbm5lY3Rpb25FcnJvckNvZGVzLkZBSUxFRCxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdDb25uZWN0aW9uIGZhaWxlZCBvciBkaXNjb25uZWN0ZWQgYnkgc2VydmVyJyxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBjbG9zaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogNDAwLFxuICAgICAgICAgICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuQ0xPU0lORyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdDb25uZWN0aW9uIGNsb3NpbmcnLFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGNsb3NlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICAgICAgICAgIGNvZGU6IENvbm5lY3Rpb25FcnJvckNvZGVzLkNMT1NFRCxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdDb25uZWN0aW9uIGNsb3NlZCcsXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgdW5rbm93bkNvbm5lY3Rpb25FcnI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICBzdGF0dXNDb2RlOiA1MDAsXG4gICAgICAgICAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5VTktOT1dOX0NPTk5FQ1RJT05fRVJSLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0ludGVybmFsIGNvbm5lY3Rpb24gZXJyb3InLFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHVua25vd25DaGFubmVsRXJyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogNTAwLFxuICAgICAgICAgICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuVU5LTk9XTl9DT05ORUNUSU9OX0VSUixcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdJbnRlcm5hbCBjaGFubmVsIGVycm9yJyxcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBpc1JldHJpYWJsZShlcnIpIHtcbiAgICBpZiAoIWVyci5zdGF0dXNDb2RlIHx8ICFlcnIuY29kZSB8fCBlcnIuc3RhdHVzQ29kZSA+PSA1MDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKENvbm5lY3Rpb25FcnJvckNvZGVzKS5pbmNsdWRlcyhlcnIuY29kZSk7XG59XG5leHBvcnRzLmlzUmV0cmlhYmxlID0gaXNSZXRyaWFibGU7XG5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uRXJyb3JzO1xuXG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBYSFJTdGF0ZXM7XG4oZnVuY3Rpb24gKFhIUlN0YXRlcykge1xuICAgIFhIUlN0YXRlc1tYSFJTdGF0ZXNbXCJSRVFfU0VORFwiXSA9IDBdID0gXCJSRVFfU0VORFwiO1xuICAgIFhIUlN0YXRlc1tYSFJTdGF0ZXNbXCJSRVFfUkVDVlwiXSA9IDFdID0gXCJSRVFfUkVDVlwiO1xuICAgIFhIUlN0YXRlc1tYSFJTdGF0ZXNbXCJSRVFfUkVDVl9QT0xMXCJdID0gMl0gPSBcIlJFUV9SRUNWX1BPTExcIjtcbiAgICBYSFJTdGF0ZXNbWEhSU3RhdGVzW1wiUkVRX1JFQ1ZfU1RSRUFNXCJdID0gM10gPSBcIlJFUV9SRUNWX1NUUkVBTVwiO1xufSkoWEhSU3RhdGVzIHx8IChYSFJTdGF0ZXMgPSB7fSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gWEhSU3RhdGVzO1xuXG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMSksIF9fd2VicGFja19yZXF1aXJlX18oNDApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKSwgX193ZWJwYWNrX3JlcXVpcmVfXygyNCksIF9fd2VicGFja19yZXF1aXJlX18oMjcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg1OSksIF9fd2VicGFja19yZXF1aXJlX18oNjApKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdHJldHVybiBDcnlwdG9KUztcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBNdWx0aWNhc3RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBQcml2YXRlIGNvbnN0cnVjdG9yOyB1c2Ugc3RhdGljIE11bHRpY2FzdGVyLmNyZWF0ZSBpbnN0ZWFkXG4gICAgZnVuY3Rpb24gTXVsdGljYXN0ZXIobWVtYmVycykge1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSBtZW1iZXJzIHx8IFtdO1xuICAgIH1cbiAgICBNdWx0aWNhc3Rlci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gdGhpcy5tZW1iZXJzOyBfYSA8IF9iLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIG1lbWJlciA9IF9iW19hXTtcbiAgICAgICAgICAgIGlmIChtZW1iZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtZW1iZXIuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdNdWx0aWNhc3RlciBtdWx0aXBsZSBjYWxsYmFjayBoYW5kbGVyJywgJ1VuZXhwZWN0ZWQgZXhjZXB0aW9uOiAnICsgZSArICc7IHN0YWNrID0gJyArIGUuc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTXVsdGljYXN0ZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLm1lbWJlcnMpLnB1c2guYXBwbHkoX2EsIGFyZ3MpO1xuICAgIH07XG4gICAgTXVsdGljYXN0ZXIuY3JlYXRlID0gZnVuY3Rpb24gKG1lbWJlcnMpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IE11bHRpY2FzdGVyKG1lbWJlcnMpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UuY2FsbC5hcHBseShpbnN0YW5jZSwgYXJncyk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gaW5zdGFuY2UucHVzaChmbik7IH0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpY2FzdGVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE11bHRpY2FzdGVyO1xuXG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDYpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBITUFDIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEhNQUMgPSBDX2FsZ28uSE1BQyA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgSE1BQy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2ggYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWNIYXNoZXIgPSBDcnlwdG9KUy5hbGdvLkhNQUMuY3JlYXRlKENyeXB0b0pTLmFsZ28uU0hBMjU2LCBrZXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChoYXNoZXIsIGtleSkge1xuXHQgICAgICAgICAgICAvLyBJbml0IGhhc2hlclxuXHQgICAgICAgICAgICBoYXNoZXIgPSB0aGlzLl9oYXNoZXIgPSBuZXcgaGFzaGVyLmluaXQoKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBXb3JkQXJyYXksIGVsc2UgYXNzdW1lIFdvcmRBcnJheSBhbHJlYWR5XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICBrZXkgPSBVdGY4LnBhcnNlKGtleSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGhhc2hlckJsb2NrU2l6ZSA9IGhhc2hlci5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXJCbG9ja1NpemVCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQWxsb3cgYXJiaXRyYXJ5IGxlbmd0aCBrZXlzXG5cdCAgICAgICAgICAgIGlmIChrZXkuc2lnQnl0ZXMgPiBoYXNoZXJCbG9ja1NpemVCeXRlcykge1xuXHQgICAgICAgICAgICAgICAga2V5ID0gaGFzaGVyLmZpbmFsaXplKGtleSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICBrZXkuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDbG9uZSBrZXkgZm9yIGlubmVyIGFuZCBvdXRlciBwYWRzXG5cdCAgICAgICAgICAgIHZhciBvS2V5ID0gdGhpcy5fb0tleSA9IGtleS5jbG9uZSgpO1xuXHQgICAgICAgICAgICB2YXIgaUtleSA9IHRoaXMuX2lLZXkgPSBrZXkuY2xvbmUoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIG9LZXlXb3JkcyA9IG9LZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBpS2V5V29yZHMgPSBpS2V5LndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFhPUiBrZXlzIHdpdGggcGFkIGNvbnN0YW50c1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhc2hlckJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBvS2V5V29yZHNbaV0gXj0gMHg1YzVjNWM1Yztcblx0ICAgICAgICAgICAgICAgIGlLZXlXb3Jkc1tpXSBePSAweDM2MzYzNjM2O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9LZXkuc2lnQnl0ZXMgPSBpS2V5LnNpZ0J5dGVzID0gaGFzaGVyQmxvY2tTaXplQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgSE1BQyB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaG1hY0hhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSB0aGlzLl9oYXNoZXI7XG5cblx0ICAgICAgICAgICAgLy8gUmVzZXRcblx0ICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICAgIGhhc2hlci51cGRhdGUodGhpcy5faUtleSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVwZGF0ZXMgdGhpcyBITUFDIHdpdGggYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0hNQUN9IFRoaXMgSE1BQyBpbnN0YW5jZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaG1hY0hhc2hlci51cGRhdGUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgaG1hY0hhc2hlci51cGRhdGUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2hlci51cGRhdGUobWVzc2FnZVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIEhNQUMgY29tcHV0YXRpb24uXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaGFzaGVyID0gdGhpcy5faGFzaGVyO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgSE1BQ1xuXHQgICAgICAgICAgICB2YXIgaW5uZXJIYXNoID0gaGFzaGVyLmZpbmFsaXplKG1lc3NhZ2VVcGRhdGUpO1xuXHQgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgICAgdmFyIGhtYWMgPSBoYXNoZXIuZmluYWxpemUodGhpcy5fb0tleS5jbG9uZSgpLmNvbmNhdChpbm5lckhhc2gpKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gaG1hYztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0fSgpKTtcblxuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNTdWNjZXNzQ29kZSA9IHZvaWQgMDtcbnZhciBIdHRwU3RhdHVzQ29kZXM7XG4oZnVuY3Rpb24gKEh0dHBTdGF0dXNDb2Rlcykge1xuICAgIEh0dHBTdGF0dXNDb2Rlc1tIdHRwU3RhdHVzQ29kZXNbXCJTdWNjZXNzXCJdID0gMjAwXSA9IFwiU3VjY2Vzc1wiO1xuICAgIEh0dHBTdGF0dXNDb2Rlc1tIdHRwU3RhdHVzQ29kZXNbXCJOb0NvbnRlbnRcIl0gPSAyMDRdID0gXCJOb0NvbnRlbnRcIjtcbiAgICBIdHRwU3RhdHVzQ29kZXNbSHR0cFN0YXR1c0NvZGVzW1wiQmFkUmVxdWVzdFwiXSA9IDQwMF0gPSBcIkJhZFJlcXVlc3RcIjtcbiAgICBIdHRwU3RhdHVzQ29kZXNbSHR0cFN0YXR1c0NvZGVzW1wiVW5hdXRob3JpemVkXCJdID0gNDAxXSA9IFwiVW5hdXRob3JpemVkXCI7XG4gICAgSHR0cFN0YXR1c0NvZGVzW0h0dHBTdGF0dXNDb2Rlc1tcIkZvcmJpZGRlblwiXSA9IDQwM10gPSBcIkZvcmJpZGRlblwiO1xuICAgIEh0dHBTdGF0dXNDb2Rlc1tIdHRwU3RhdHVzQ29kZXNbXCJSZXF1ZXN0VGltZW91dFwiXSA9IDQwOF0gPSBcIlJlcXVlc3RUaW1lb3V0XCI7XG4gICAgSHR0cFN0YXR1c0NvZGVzW0h0dHBTdGF0dXNDb2Rlc1tcIkludGVybmFsU2VydmVyRXJyb3JcIl0gPSA1MDBdID0gXCJJbnRlcm5hbFNlcnZlckVycm9yXCI7XG59KShIdHRwU3RhdHVzQ29kZXMgfHwgKEh0dHBTdGF0dXNDb2RlcyA9IHt9KSk7XG5mdW5jdGlvbiBpc1N1Y2Nlc3NDb2RlKHN0YXR1c0NvZGUpIHtcbiAgICByZXR1cm4gc3RhdHVzQ29kZSA+PSBIdHRwU3RhdHVzQ29kZXMuU3VjY2VzcyAmJiBzdGF0dXNDb2RlIDwgSHR0cFN0YXR1c0NvZGVzLkJhZFJlcXVlc3Q7XG59XG5leHBvcnRzLmlzU3VjY2Vzc0NvZGUgPSBpc1N1Y2Nlc3NDb2RlO1xuZXhwb3J0cy5kZWZhdWx0ID0gSHR0cFN0YXR1c0NvZGVzO1xuXG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBwcm90b2NvbG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTApKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGV2ZW50ZW1pdHRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBjb25uZWN0aW9uZXJyb3JzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgYWN0aW9ucyA9IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuQWN0aW9uO1xudmFyIGNsb3NlTWVzc2FnZSA9IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyh7IGFjdGlvbjogYWN0aW9ucy5DTE9TRSB9KTtcbnZhciBkaXNjb25uZWN0TWVzc2FnZSA9IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyh7IGFjdGlvbjogYWN0aW9ucy5ESVNDT05ORUNUIH0pO1xuLypcbiAqIFRyYW5zcG9ydCBpbnN0YW5jZXMgaW5oZXJpdCBmcm9tIEV2ZW50RW1pdHRlciBhbmQgZW1pdCB0aGUgZm9sbG93aW5nIGV2ZW50czpcbiAqXG4gKiBldmVudCBuYW1lICAgICAgIGRhdGFcbiAqIGNsb3NlZCAgICAgICAgICAgZXJyb3JcbiAqIGZhaWxlZCAgICAgICAgICAgZXJyb3JcbiAqIGRpc3Bvc2VkXG4gKiBjb25uZWN0ZWQgICAgICAgIG51bGwgZXJyb3IsIGNvbm5lY3Rpb25TZXJpYWwsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHNcbiAqIGV2ZW50ICAgICAgICAgICAgY2hhbm5lbCBtZXNzYWdlIG9iamVjdFxuICovXG52YXIgVHJhbnNwb3J0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFRyYW5zcG9ydCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcywgZm9yY2VKc29uUHJvdG9jb2wpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgaWYgKGZvcmNlSnNvblByb3RvY29sKSB7XG4gICAgICAgICAgICBwYXJhbXMuZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcGFyYW1zLmhlYXJ0YmVhdHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLnJlZ2lzdGVyUHJvcG9zZWRUcmFuc3BvcnQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgX3RoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICBfdGhpcy50aW1lb3V0cyA9IHBhcmFtcy5vcHRpb25zLnRpbWVvdXRzO1xuICAgICAgICBfdGhpcy5mb3JtYXQgPSBwYXJhbXMuZm9ybWF0O1xuICAgICAgICBfdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5pc0ZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubWF4SWRsZUludGVydmFsID0gbnVsbDtcbiAgICAgICAgX3RoaXMuaWRsZVRpbWVyID0gbnVsbDtcbiAgICAgICAgX3RoaXMubGFzdEFjdGl2aXR5ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdENsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5pc2goJ2Nsb3NlZCcsIGNvbm5lY3Rpb25lcnJvcnNfMS5kZWZhdWx0LmNsb3NlZCgpKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgLyogVXNlZCBmb3IgbmV0d29yay90cmFuc3BvcnQgaXNzdWVzIHRoYXQgbmVlZCB0byByZXN1bHQgaW4gdGhlIHRyYW5zcG9ydFxuICAgICAgICAgKiBiZWluZyBkaXNjb25uZWN0ZWQsIGJ1dCBzaG91bGQgbm90IHRyYW5zaXRpb24gdGhlIGNvbm5lY3Rpb24gdG8gJ2ZhaWxlZCcgKi9cbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdERpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgZXJyIHx8IGNvbm5lY3Rpb25lcnJvcnNfMS5kZWZhdWx0LmRpc2Nvbm5lY3RlZCgpKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuZmFpbCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgLyogVXNlZCBmb3IgY2xpZW50LXNpZGUtZGV0ZWN0ZWQgZmF0YWwgY29ubmVjdGlvbiBpc3N1ZXMgKi9cbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdERpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmlzaCgnZmFpbGVkJywgZXJyIHx8IGNvbm5lY3Rpb25lcnJvcnNfMS5kZWZhdWx0LmZhaWxlZCgpKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKGV2ZW50LCBlcnIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1heElkbGVJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIGNsZWFyVGltZW91dCgoX2EgPSB0aGlzLmlkbGVUaW1lcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXQoZXZlbnQsIGVycik7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vblByb3RvY29sTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmIChsb2dnZXJfMS5kZWZhdWx0LnNob3VsZExvZyhsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKCknLCAncmVjZWl2ZWQgb24gJyArXG4gICAgICAgICAgICAgICAgdGhpcy5zaG9ydE5hbWUgK1xuICAgICAgICAgICAgICAgICc6ICcgK1xuICAgICAgICAgICAgICAgIHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuc3RyaW5naWZ5KG1lc3NhZ2UpICtcbiAgICAgICAgICAgICAgICAnOyBjb25uZWN0aW9uSWQgPSAnICtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS5hY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5IRUFSVEJFQVQ6XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKScsIHRoaXMuc2hvcnROYW1lICsgJyBoZWFydGJlYXQ7IGNvbm5lY3Rpb25JZCA9ICcgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdoZWFydGJlYXQnLCBtZXNzYWdlLmlkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5DT05ORUNURUQ6XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3QobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0ZWQnLCBtZXNzYWdlLmVycm9yLCBtZXNzYWdlLmNvbm5lY3Rpb25JZCwgbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGFjdGlvbnMuQ0xPU0VEOlxuICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5ESVNDT05ORUNURUQ6XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGFjdGlvbnMuQUNLOlxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnYWNrJywgbWVzc2FnZS5tc2dTZXJpYWwsIG1lc3NhZ2UuY291bnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLk5BQ0s6XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCduYWNrJywgbWVzc2FnZS5tc2dTZXJpYWwsIG1lc3NhZ2UuY291bnQsIG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLlNZTkM6XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLkFDVElWQVRFOlxuICAgICAgICAgICAgICAgIC8vIElnbm9yZWQuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGFjdGlvbnMuQVVUSDpcbiAgICAgICAgICAgICAgICB0aGlzLmF1dGguYXV0aG9yaXplKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKScsICdBYmx5IHJlcXVlc3RlZCByZS1hdXRoZW50aWNhdGlvbiwgYnV0IHVuYWJsZSB0byBvYnRhaW4gYSBuZXcgdG9rZW46ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5FUlJPUjpcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpJywgJ3JlY2VpdmVkIGVycm9yIGFjdGlvbjsgY29ubmVjdGlvbklkID0gJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkICtcbiAgICAgICAgICAgICAgICAgICAgJzsgZXJyID0gJyArXG4gICAgICAgICAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChtZXNzYWdlLmVycm9yKSArXG4gICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLmNoYW5uZWwgPyAnLCBjaGFubmVsOiAnICsgbWVzc2FnZS5jaGFubmVsIDogJycpKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5jaGFubmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkZhdGFsRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBvdGhlcndpc2UgaXQncyBhIGNoYW5uZWwtc3BlY2lmaWMgZXJyb3IsIHNvIGhhbmRsZSBpdCBpbiB0aGUgY2hhbm5lbCAqL1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZShtZXNzYWdlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLyogYWxsIG90aGVyIGFjdGlvbnMgYXJlIGNoYW5uZWwtc3BlY2lmaWMgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUub25Db25uZWN0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIGlmICghbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQub25Db25uZWN0KCk6IENvbm5lY3QgbWVzc2FnZSByZWNpZXZlZCB3aXRob3V0IGNvbm5lY3Rpb25EZXRhaWxzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heFByb21pc2VkSWRsZSA9IG1lc3NhZ2UuY29ubmVjdGlvbkRldGFpbHMubWF4SWRsZUludGVydmFsO1xuICAgICAgICBpZiAobWF4UHJvbWlzZWRJZGxlKSB7XG4gICAgICAgICAgICB0aGlzLm1heElkbGVJbnRlcnZhbCA9IG1heFByb21pc2VkSWRsZSArIHRoaXMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dDtcbiAgICAgICAgICAgIHRoaXMub25BY3Rpdml0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGVsc2UgUmVhbHRpbWUgZGVjbGluZXMgdG8gZ3VhcmFudGVlIGFueSBtYXhpbXVtIGlkbGUgaW50ZXJ2YWwgLSBDRDJoICovXG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uRGlzY29ubmVjdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIC8qIFVzZWQgZm9yIHdoZW4gdGhlIHNlcnZlciBoYXMgZGlzY29ubmVjdGVkIHRoZSBjbGllbnQgKHVzdWFsbHkgd2l0aCBhXG4gICAgICAgICAqIERJU0NPTk5FQ1RFRCBhY3Rpb24pICovXG4gICAgICAgIHZhciBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnVHJhbnNwb3J0Lm9uRGlzY29ubmVjdCgpJywgJ2VyciA9ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgICAgIHRoaXMuZmluaXNoKCdkaXNjb25uZWN0ZWQnLCBlcnIpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkZhdGFsRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAvKiBPbiByZWNlaXB0IG9mIGEgZmF0YWwgY29ubmVjdGlvbiBlcnJvciwgd2UgY2FuIGFzc3VtZSB0aGF0IHRoZSBzZXJ2ZXJcbiAgICAgICAgICogd2lsbCBjbG9zZSB0aGUgY29ubmVjdGlvbiBhbmQgdGhlIHRyYW5zcG9ydCwgYW5kIGRvIG5vdCBuZWVkIHRvIHJlcXVlc3RcbiAgICAgICAgICogYSBkaXNjb25uZWN0aW9uIC0gUlROMTVpICovXG4gICAgICAgIHZhciBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnVHJhbnNwb3J0Lm9uRmF0YWxFcnJvcigpJywgJ2VyciA9ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgICAgIHRoaXMuZmluaXNoKCdmYWlsZWQnLCBlcnIpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIGVyciA9IG1lc3NhZ2UgJiYgbWVzc2FnZS5lcnJvcjtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdUcmFuc3BvcnQub25DbG9zZSgpJywgJ2VyciA9ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgICAgIHRoaXMuZmluaXNoKCdjbG9zZWQnLCBlcnIpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5yZXF1ZXN0Q2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnVHJhbnNwb3J0LnJlcXVlc3RDbG9zZSgpJywgJycpO1xuICAgICAgICB0aGlzLnNlbmQoY2xvc2VNZXNzYWdlKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUucmVxdWVzdERpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnVHJhbnNwb3J0LnJlcXVlc3REaXNjb25uZWN0KCknLCAnJyk7XG4gICAgICAgIHRoaXMuc2VuZChkaXNjb25uZWN0TWVzc2FnZSk7XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIG1zZyA9IHsgYWN0aW9uOiBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LkFjdGlvbi5IRUFSVEJFQVQgfTtcbiAgICAgICAgaWYgKGlkKVxuICAgICAgICAgICAgbXNnLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuc2VuZChwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMobXNnKSk7XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnVHJhbnNwb3J0LmRpc3Bvc2UoKScsICcnKTtcbiAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vZmYoKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUub25BY3Rpdml0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1heElkbGVJbnRlcnZhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdEFjdGl2aXR5ID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5sYXN0QWN0aXZpdHkgPSBVdGlscy5ub3coKTtcbiAgICAgICAgdGhpcy5zZXRJZGxlVGltZXIodGhpcy5tYXhJZGxlSW50ZXJ2YWwgKyAxMDApO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5zZXRJZGxlVGltZXIgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuaWRsZVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLmlkbGVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uSWRsZVRpbWVyRXhwaXJlKCk7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbklkbGVUaW1lckV4cGlyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxhc3RBY3Rpdml0eSB8fCAhdGhpcy5tYXhJZGxlSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0Lm9uSWRsZVRpbWVyRXhwaXJlKCk6IGxhc3RBY3Rpdml0eS9tYXhJZGxlSW50ZXJ2YWwgbm90IHNldCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcbiAgICAgICAgdmFyIHNpbmNlTGFzdCA9IFV0aWxzLm5vdygpIC0gdGhpcy5sYXN0QWN0aXZpdHk7XG4gICAgICAgIHZhciB0aW1lUmVtYWluaW5nID0gdGhpcy5tYXhJZGxlSW50ZXJ2YWwgLSBzaW5jZUxhc3Q7XG4gICAgICAgIGlmICh0aW1lUmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnTm8gYWN0aXZpdHkgc2VlbiBmcm9tIHJlYWx0aW1lIGluICcgKyBzaW5jZUxhc3QgKyAnbXM7IGFzc3VtaW5nIGNvbm5lY3Rpb24gaGFzIGRyb3BwZWQnO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdUcmFuc3BvcnQub25JZGxlVGltZXJFeHBpcmUoKScsIG1zZyk7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QobmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA4MDAwMywgNDA4KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldElkbGVUaW1lcih0aW1lUmVtYWluaW5nICsgMTAwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJhbnNwb3J0LnRyeUNvbm5lY3QgPSBmdW5jdGlvbiAodHJhbnNwb3J0Q3RvciwgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHRyYW5zcG9ydFBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRDdG9yKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCB0cmFuc3BvcnRQYXJhbXMpO1xuICAgICAgICB2YXIgdHJhbnNwb3J0QXR0ZW1wdFRpbWVyO1xuICAgICAgICB2YXIgZXJyb3JDYiA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0cmFuc3BvcnRBdHRlbXB0VGltZXIpO1xuICAgICAgICAgICAgY2FsbGJhY2soeyBldmVudDogdGhpcy5ldmVudCwgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlYWx0aW1lUmVxdWVzdFRpbWVvdXQgPSBjb25uZWN0aW9uTWFuYWdlci5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQ7XG4gICAgICAgIHRyYW5zcG9ydEF0dGVtcHRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0Lm9mZihbJ3ByZWNvbm5lY3QnLCAnZGlzY29ubmVjdGVkJywgJ2ZhaWxlZCddKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5kaXNwb3NlKCk7XG4gICAgICAgICAgICBlcnJvckNiLmNhbGwoeyBldmVudDogJ2Rpc2Nvbm5lY3RlZCcgfSwgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1RpbWVvdXQgd2FpdGluZyBmb3IgdHJhbnNwb3J0IHRvIGluZGljYXRlIGl0c2VsZiB2aWFibGUnLCA1MDAwMCwgNTAwKSk7XG4gICAgICAgIH0sIHJlYWx0aW1lUmVxdWVzdFRpbWVvdXQpO1xuICAgICAgICB0cmFuc3BvcnQub24oWydmYWlsZWQnLCAnZGlzY29ubmVjdGVkJ10sIGVycm9yQ2IpO1xuICAgICAgICB0cmFuc3BvcnQub24oJ3ByZWNvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1RyYW5zcG9ydC50cnlDb25uZWN0KCknLCAndmlhYmxlIHRyYW5zcG9ydCAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0cmFuc3BvcnRBdHRlbXB0VGltZXIpO1xuICAgICAgICAgICAgdHJhbnNwb3J0Lm9mZihbJ2ZhaWxlZCcsICdkaXNjb25uZWN0ZWQnXSwgZXJyb3JDYik7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB0cmFuc3BvcnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNwb3J0LmNvbm5lY3QoKTtcbiAgICB9O1xuICAgIHJldHVybiBUcmFuc3BvcnQ7XG59KGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRyYW5zcG9ydDtcblxuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0MCksIF9fd2VicGFja19yZXF1aXJlX18oMjQpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXHQgICAgdmFyIE1ENSA9IENfYWxnby5NRDU7XG5cblx0ICAgIC8qKlxuXHQgICAgICogVGhpcyBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBpcyBtZWFudCB0byBjb25mb3JtIHdpdGggRVZQX0J5dGVzVG9LZXkuXG5cdCAgICAgKiB3d3cub3BlbnNzbC5vcmcvZG9jcy9jcnlwdG8vRVZQX0J5dGVzVG9LZXkuaHRtbFxuXHQgICAgICovXG5cdCAgICB2YXIgRXZwS0RGID0gQ19hbGdvLkV2cEtERiA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGUga2V5IHNpemUgaW4gd29yZHMgdG8gZ2VuZXJhdGUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2ggYWxnb3JpdGhtIHRvIHVzZS4gRGVmYXVsdDogTUQ1XG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl0ZXJhdGlvbnMgVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm0uIERlZmF1bHQ6IDFcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAga2V5U2l6ZTogMTI4LzMyLFxuXHQgICAgICAgICAgICBoYXNoZXI6IE1ENSxcblx0ICAgICAgICAgICAgaXRlcmF0aW9uczogMVxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGUgZGVyaXZhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZXJpdmVzIGEga2V5IGZyb20gYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGtleSA9IGtkZi5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjb21wdXRlOiBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQpIHtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBjZmcgPSB0aGlzLmNmZztcblxuXHQgICAgICAgICAgICAvLyBJbml0IGhhc2hlclxuXHQgICAgICAgICAgICB2YXIgaGFzaGVyID0gY2ZnLmhhc2hlci5jcmVhdGUoKTtcblxuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZEtleSA9IFdvcmRBcnJheS5jcmVhdGUoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRLZXlXb3JkcyA9IGRlcml2ZWRLZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBrZXlTaXplID0gY2ZnLmtleVNpemU7XG5cdCAgICAgICAgICAgIHZhciBpdGVyYXRpb25zID0gY2ZnLml0ZXJhdGlvbnM7XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUga2V5XG5cdCAgICAgICAgICAgIHdoaWxlIChkZXJpdmVkS2V5V29yZHMubGVuZ3RoIDwga2V5U2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZShibG9jayk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBibG9jayA9IGhhc2hlci51cGRhdGUocGFzc3dvcmQpLmZpbmFsaXplKHNhbHQpO1xuXHQgICAgICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGlvbnNcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBoYXNoZXIuZmluYWxpemUoYmxvY2spO1xuXHQgICAgICAgICAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBkZXJpdmVkS2V5LmNvbmNhdChibG9jayk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZGVyaXZlZEtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIHJldHVybiBkZXJpdmVkS2V5O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBjb21wdXRhdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCk7XG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4IH0pO1xuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcblx0ICAgICAqL1xuXHQgICAgQy5FdnBLREYgPSBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQsIGNmZykge1xuXHQgICAgICAgIHJldHVybiBFdnBLREYuY3JlYXRlKGNmZykuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cdCAgICB9O1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLkV2cEtERjtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyNykpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIENpcGhlciBjb3JlIGNvbXBvbmVudHMuXG5cdCAqL1xuXHRDcnlwdG9KUy5saWIuQ2lwaGVyIHx8IChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG07XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmODtcblx0ICAgIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQ7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXHQgICAgdmFyIEV2cEtERiA9IENfYWxnby5FdnBLREY7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhpcyBjaXBoZXIncyBrZXkgc2l6ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXZTaXplIFRoaXMgY2lwaGVyJ3MgSVYgc2l6ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX0VOQ19YRk9STV9NT0RFIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGVuY3J5cHRpb24gbW9kZS5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfREVDX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZGVjcnlwdGlvbiBtb2RlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ2lwaGVyID0gQ19saWIuQ2lwaGVyID0gQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKCksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGVuY3J5cHRpb24gbW9kZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZUVuY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZUVuY3J5cHRvcjogZnVuY3Rpb24gKGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9FTkNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGRlY3J5cHRpb24gbW9kZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZURlY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZURlY3J5cHRvcjogZnVuY3Rpb24gKGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9ERUNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhmb3JtTW9kZSBFaXRoZXIgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiB0cmFuc29ybWF0aW9uIG1vZGUgY29uc3RhbnQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGUoQ3J5cHRvSlMuYWxnby5BRVMuX0VOQ19YRk9STV9NT0RFLCBrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uICh4Zm9ybU1vZGUsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIFN0b3JlIHRyYW5zZm9ybSBtb2RlIGFuZCBrZXlcblx0ICAgICAgICAgICAgdGhpcy5feGZvcm1Nb2RlID0geGZvcm1Nb2RlO1xuXHQgICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgY2lwaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBjaXBoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxuXHQgICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1jaXBoZXIgbG9naWNcblx0ICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIGRhdGEgdG8gYmUgZW5jcnlwdGVkIG9yIGRlY3J5cHRlZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVVwZGF0ZSBUaGUgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkYXRhIGFmdGVyIHByb2Nlc3NpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2VzcygnZGF0YScpO1xuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLnByb2Nlc3Mod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoZGF0YVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgYXZhaWxhYmxlIGJsb2Nrc1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2VzcygpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBwcm9jZXNzLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGFVcGRhdGUgVGhlIGZpbmFsIGRhdGEgdG8gZW5jcnlwdCBvciBkZWNyeXB0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBmaW5hbCBwcm9jZXNzaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCk7XG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoZGF0YVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBGaW5hbCBkYXRhIHVwZGF0ZVxuXHQgICAgICAgICAgICBpZiAoZGF0YVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1jaXBoZXIgbG9naWNcblx0ICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkRGF0YSA9IHRoaXMuX2RvRmluYWxpemUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWREYXRhO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBrZXlTaXplOiAxMjgvMzIsXG5cblx0ICAgICAgICBpdlNpemU6IDEyOC8zMixcblxuXHQgICAgICAgIF9FTkNfWEZPUk1fTU9ERTogMSxcblxuXHQgICAgICAgIF9ERUNfWEZPUk1fTU9ERTogMixcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgc2hvcnRjdXQgZnVuY3Rpb25zIHRvIGEgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBlbmNyeXB0IGFuZCBkZWNyeXB0IHNob3J0Y3V0IGZ1bmN0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIEFFUyA9IENyeXB0b0pTLmxpYi5DaXBoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLkFFUyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhlbHBlcjogKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBQYXNzd29yZEJhc2VkQ2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2VyaWFsaXphYmxlQ2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjaXBoZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpLmVuY3J5cHQoY2lwaGVyLCBtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXJ0ZXh0LCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5kZWNyeXB0KGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSgpKVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBzdHJlYW0gY2lwaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBjaXBoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDEgKDMyIGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBTdHJlYW1DaXBoZXIgPSBDX2xpYi5TdHJlYW1DaXBoZXIgPSBDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBQcm9jZXNzIHBhcnRpYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3M7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogMVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogTW9kZSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX21vZGUgPSBDLm1vZGUgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGJsb2NrIGNpcGhlciBtb2RlIHRlbXBsYXRlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQmxvY2tDaXBoZXJNb2RlID0gQ19saWIuQmxvY2tDaXBoZXJNb2RlID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBtb2RlIGZvciBlbmNyeXB0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuY3JlYXRlRW5jcnlwdG9yKGNpcGhlciwgaXYud29yZHMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZUVuY3J5cHRvcjogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGRlY3J5cHRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVEZWNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRGVjcnlwdG9yOiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5EZWNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgbW9kZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdi53b3Jkcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2lwaGVyID0gY2lwaGVyO1xuXHQgICAgICAgICAgICB0aGlzLl9pdiA9IGl2O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIENpcGhlciBCbG9jayBDaGFpbmluZyBtb2RlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ0JDID0gQ19tb2RlLkNCQyA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWJzdHJhY3QgYmFzZSBDQkMgbW9kZS5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICB2YXIgQ0JDID0gQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO1xuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ0JDIGVuY3J5cHRvci5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBDQkMuRW5jcnlwdG9yID0gQ0JDLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gWE9SIGFuZCBlbmNyeXB0XG5cdCAgICAgICAgICAgICAgICB4b3JCbG9jay5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSk7XG5cdCAgICAgICAgICAgICAgICBjaXBoZXIuZW5jcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ0JDIGRlY3J5cHRvci5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBDQkMuRGVjcnlwdG9yID0gQ0JDLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgICAgICB2YXIgdGhpc0Jsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBEZWNyeXB0IGFuZCBYT1Jcblx0ICAgICAgICAgICAgICAgIGNpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICB4b3JCbG9jay5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFRoaXMgYmxvY2sgYmVjb21lcyB0aGUgcHJldmlvdXMgYmxvY2tcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHRoaXNCbG9jaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgZnVuY3Rpb24geG9yQmxvY2sod29yZHMsIG9mZnNldCwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgIHZhciBibG9jaztcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaXYgPSB0aGlzLl9pdjtcblxuXHQgICAgICAgICAgICAvLyBDaG9vc2UgbWl4aW5nIGJsb2NrXG5cdCAgICAgICAgICAgIGlmIChpdikge1xuXHQgICAgICAgICAgICAgICAgYmxvY2sgPSBpdjtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBibG9jayA9IHRoaXMuX3ByZXZCbG9jaztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFhPUiBibG9ja3Ncblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0gYmxvY2tbaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gQ0JDO1xuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBQYWRkaW5nIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfcGFkID0gQy5wYWQgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBQS0NTICM1LzcgcGFkZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFBrY3M3ID0gQ19wYWQuUGtjczcgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUGFkcyBkYXRhIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byBwYWQuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbXVsdGlwbGUgdGhhdCB0aGUgZGF0YSBzaG91bGQgYmUgcGFkZGVkIHRvLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcucGFkKHdvcmRBcnJheSwgNCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFkOiBmdW5jdGlvbiAoZGF0YSwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgcGFkZGluZyBieXRlc1xuXHQgICAgICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGJsb2NrU2l6ZUJ5dGVzIC0gZGF0YS5zaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBwYWRkaW5nIHdvcmRcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdXb3JkID0gKG5QYWRkaW5nQnl0ZXMgPDwgMjQpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgMTYpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgOCkgfCBuUGFkZGluZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nV29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGFkZGluZ0J5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmdXb3Jkcy5wdXNoKHBhZGRpbmdXb3JkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgcGFkZGluZyA9IFdvcmRBcnJheS5jcmVhdGUocGFkZGluZ1dvcmRzLCBuUGFkZGluZ0J5dGVzKTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhLmNvbmNhdChwYWRkaW5nKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVW5wYWRzIGRhdGEgdGhhdCBoYWQgYmVlbiBwYWRkZWQgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHVucGFkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcudW5wYWQod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgICAgLy8gR2V0IG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIGZyb20gbGFzdCBieXRlXG5cdCAgICAgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gZGF0YS53b3Jkc1soZGF0YS5zaWdCeXRlcyAtIDEpID4+PiAyXSAmIDB4ZmY7XG5cblx0ICAgICAgICAgICAgLy8gUmVtb3ZlIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuUGFkZGluZ0J5dGVzO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyID0gQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtNb2RlfSBtb2RlIFRoZSBibG9jayBtb2RlIHRvIHVzZS4gRGVmYXVsdDogQ0JDXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogUGtjczdcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IENpcGhlci5jZmcuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgbW9kZTogQ0JDLFxuXHQgICAgICAgICAgICBwYWRkaW5nOiBQa2NzN1xuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG1vZGVDcmVhdG9yO1xuXG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGNpcGhlclxuXHQgICAgICAgICAgICBDaXBoZXIucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xuXHQgICAgICAgICAgICB2YXIgaXYgPSBjZmcuaXY7XG5cdCAgICAgICAgICAgIHZhciBtb2RlID0gY2ZnLm1vZGU7XG5cblx0ICAgICAgICAgICAgLy8gUmVzZXQgYmxvY2sgbW9kZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0VOQ19YRk9STV9NT0RFKSB7XG5cdCAgICAgICAgICAgICAgICBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRW5jcnlwdG9yO1xuXHQgICAgICAgICAgICB9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi8ge1xuXHQgICAgICAgICAgICAgICAgbW9kZUNyZWF0b3IgPSBtb2RlLmNyZWF0ZURlY3J5cHRvcjtcblx0ICAgICAgICAgICAgICAgIC8vIEtlZXAgYXQgbGVhc3Qgb25lIGJsb2NrIGluIHRoZSBidWZmZXIgZm9yIHVucGFkZGluZ1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbWluQnVmZmVyU2l6ZSA9IDE7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAodGhpcy5fbW9kZSAmJiB0aGlzLl9tb2RlLl9fY3JlYXRvciA9PSBtb2RlQ3JlYXRvcikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbW9kZS5pbml0KHRoaXMsIGl2ICYmIGl2LndvcmRzKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21vZGUgPSBtb2RlQ3JlYXRvci5jYWxsKG1vZGUsIHRoaXMsIGl2ICYmIGl2LndvcmRzKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21vZGUuX19jcmVhdG9yID0gbW9kZUNyZWF0b3I7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9tb2RlLnByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5jZmcucGFkZGluZztcblxuXHQgICAgICAgICAgICAvLyBGaW5hbGl6ZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0VOQ19YRk9STV9NT0RFKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBQYWQgZGF0YVxuXHQgICAgICAgICAgICAgICAgcGFkZGluZy5wYWQodGhpcy5fZGF0YSwgdGhpcy5ibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqLyB7XG5cdCAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFVucGFkIGRhdGFcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmcudW5wYWQoZmluYWxQcm9jZXNzZWRCbG9ja3MpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDEyOC8zMlxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBjb2xsZWN0aW9uIG9mIGNpcGhlciBwYXJhbWV0ZXJzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBjaXBoZXJ0ZXh0IFRoZSByYXcgY2lwaGVydGV4dC5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBrZXkgVGhlIGtleSB0byB0aGlzIGNpcGhlcnRleHQuXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gaXYgVGhlIElWIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gc2FsdCBUaGUgc2FsdCB1c2VkIHdpdGggYSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7Q2lwaGVyfSBhbGdvcml0aG0gVGhlIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7UGFkZGluZ30gcGFkZGluZyBUaGUgcGFkZGluZyBzY2hlbWUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIGJsb2NrIHNpemUgb2YgdGhlIGNpcGhlci5cblx0ICAgICAqIEBwcm9wZXJ0eSB7Rm9ybWF0fSBmb3JtYXR0ZXIgVGhlIGRlZmF1bHQgZm9ybWF0dGluZyBzdHJhdGVneSB0byBjb252ZXJ0IHRoaXMgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBzdHJpbmcuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDaXBoZXJQYXJhbXMgPSBDX2xpYi5DaXBoZXJQYXJhbXMgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNpcGhlclBhcmFtcyBBbiBvYmplY3Qgd2l0aCBhbnkgb2YgdGhlIHBvc3NpYmxlIGNpcGhlciBwYXJhbWV0ZXJzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMubGliLkNpcGhlclBhcmFtcy5jcmVhdGUoe1xuXHQgICAgICAgICAqICAgICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dFdvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIGtleToga2V5V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAgaXY6IGl2V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAgc2FsdDogc2FsdFdvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIGFsZ29yaXRobTogQ3J5cHRvSlMuYWxnby5BRVMsXG5cdCAgICAgICAgICogICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNCQyxcblx0ICAgICAgICAgKiAgICAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5QS0NTNyxcblx0ICAgICAgICAgKiAgICAgICAgIGJsb2NrU2l6ZTogNCxcblx0ICAgICAgICAgKiAgICAgICAgIGZvcm1hdHRlcjogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0xcblx0ICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuXHQgICAgICAgICAgICB0aGlzLm1peEluKGNpcGhlclBhcmFtcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoaXMgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0Zvcm1hdH0gZm9ybWF0dGVyIChPcHRpb25hbCkgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5naWZpZWQgY2lwaGVyIHBhcmFtcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEB0aHJvd3MgRXJyb3IgSWYgbmVpdGhlciB0aGUgZm9ybWF0dGVyIG5vciB0aGUgZGVmYXVsdCBmb3JtYXR0ZXIgaXMgc2V0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zICsgJyc7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMudG9TdHJpbmcoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZyhDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChmb3JtYXR0ZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChmb3JtYXR0ZXIgfHwgdGhpcy5mb3JtYXR0ZXIpLnN0cmluZ2lmeSh0aGlzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBGb3JtYXQgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19mb3JtYXQgPSBDLmZvcm1hdCA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIE9wZW5TU0wgZm9ybWF0dGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIE9wZW5TU0xGb3JtYXR0ZXIgPSBDX2Zvcm1hdC5PcGVuU1NMID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfSBjaXBoZXJQYXJhbXMgVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG9wZW5TU0xTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTC5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcblx0ICAgICAgICAgICAgdmFyIHdvcmRBcnJheTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dDtcblx0ICAgICAgICAgICAgdmFyIHNhbHQgPSBjaXBoZXJQYXJhbXMuc2FsdDtcblxuXHQgICAgICAgICAgICAvLyBGb3JtYXRcblx0ICAgICAgICAgICAgaWYgKHNhbHQpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRBcnJheSA9IFdvcmRBcnJheS5jcmVhdGUoWzB4NTM2MTZjNzQsIDB4NjU2NDVmNWZdKS5jb25jYXQoc2FsdCkuY29uY2F0KGNpcGhlcnRleHQpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgd29yZEFycmF5ID0gY2lwaGVydGV4dDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB3b3JkQXJyYXkudG9TdHJpbmcoQmFzZTY0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZW5TU0xTdHIgVGhlIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnBhcnNlKG9wZW5TU0xTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAob3BlblNTTFN0cikge1xuXHQgICAgICAgICAgICB2YXIgc2FsdDtcblxuXHQgICAgICAgICAgICAvLyBQYXJzZSBiYXNlNjRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBCYXNlNjQucGFyc2Uob3BlblNTTFN0cik7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHRXb3JkcyA9IGNpcGhlcnRleHQud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gVGVzdCBmb3Igc2FsdFxuXHQgICAgICAgICAgICBpZiAoY2lwaGVydGV4dFdvcmRzWzBdID09IDB4NTM2MTZjNzQgJiYgY2lwaGVydGV4dFdvcmRzWzFdID09IDB4NjU2NDVmNWYpIHtcblx0ICAgICAgICAgICAgICAgIC8vIEV4dHJhY3Qgc2FsdFxuXHQgICAgICAgICAgICAgICAgc2FsdCA9IFdvcmRBcnJheS5jcmVhdGUoY2lwaGVydGV4dFdvcmRzLnNsaWNlKDIsIDQpKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHNhbHQgZnJvbSBjaXBoZXJ0ZXh0XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0V29yZHMuc3BsaWNlKDAsIDQpO1xuXHQgICAgICAgICAgICAgICAgY2lwaGVydGV4dC5zaWdCeXRlcyAtPSAxNjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsgY2lwaGVydGV4dDogY2lwaGVydGV4dCwgc2FsdDogc2FsdCB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgY2lwaGVyIHdyYXBwZXIgdGhhdCByZXR1cm5zIGNpcGhlcnRleHQgYXMgYSBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgKi9cblx0ICAgIHZhciBTZXJpYWxpemFibGVDaXBoZXIgPSBDX2xpYi5TZXJpYWxpemFibGVDaXBoZXIgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtGb3JtYXR0ZXJ9IGZvcm1hdCBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byBjb252ZXJ0IGNpcGhlciBwYXJhbSBvYmplY3RzIHRvIGFuZCBmcm9tIGEgc3RyaW5nLiBEZWZhdWx0OiBPcGVuU1NMXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGZvcm1hdDogT3BlblNTTEZvcm1hdHRlclxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRW5jcnlwdHMgYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXkpO1xuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgdmFyIGVuY3J5cHRvciA9IGNpcGhlci5jcmVhdGVFbmNyeXB0b3Ioa2V5LCBjZmcpO1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGVuY3J5cHRvci5maW5hbGl6ZShtZXNzYWdlKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVyQ2ZnID0gZW5jcnlwdG9yLmNmZztcblxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgYW5kIHJldHVybiBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtc1xuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LFxuXHQgICAgICAgICAgICAgICAga2V5OiBrZXksXG5cdCAgICAgICAgICAgICAgICBpdjogY2lwaGVyQ2ZnLml2LFxuXHQgICAgICAgICAgICAgICAgYWxnb3JpdGhtOiBjaXBoZXIsXG5cdCAgICAgICAgICAgICAgICBtb2RlOiBjaXBoZXJDZmcubW9kZSxcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmc6IGNpcGhlckNmZy5wYWRkaW5nLFxuXHQgICAgICAgICAgICAgICAgYmxvY2tTaXplOiBjaXBoZXIuYmxvY2tTaXplLFxuXHQgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBjZmcuZm9ybWF0XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHBsYWludGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gQ2lwaGVyUGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcblxuXHQgICAgICAgICAgICAvLyBEZWNyeXB0XG5cdCAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBjaXBoZXIuY3JlYXRlRGVjcnlwdG9yKGtleSwgY2ZnKS5maW5hbGl6ZShjaXBoZXJ0ZXh0LmNpcGhlcnRleHQpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB0byBDaXBoZXJQYXJhbXMsXG5cdCAgICAgICAgICogZWxzZSBhc3N1bWVkIENpcGhlclBhcmFtcyBhbHJlYWR5IGFuZCByZXR1cm5zIGNpcGhlcnRleHQgdW5jaGFuZ2VkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7Rm9ybWF0dGVyfSBmb3JtYXQgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlIHRvIHBhcnNlIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIHVuc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuX3BhcnNlKGNpcGhlcnRleHRTdHJpbmdPclBhcmFtcywgZm9ybWF0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfcGFyc2U6IGZ1bmN0aW9uIChjaXBoZXJ0ZXh0LCBmb3JtYXQpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjaXBoZXJ0ZXh0ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0LnBhcnNlKGNpcGhlcnRleHQsIHRoaXMpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBLZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2tkZiA9IEMua2RmID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogT3BlblNTTCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgdmFyIE9wZW5TU0xLZGYgPSBDX2tkZi5PcGVuU1NMID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlcml2ZXMgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgdG8gZGVyaXZlIGZyb20uXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtleVNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIGtleSB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaXZTaXplIFRoZSBzaXplIGluIHdvcmRzIG9mIHRoZSBJViB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgKE9wdGlvbmFsKSBBIDY0LWJpdCBzYWx0IHRvIHVzZS4gSWYgb21pdHRlZCwgYSBzYWx0IHdpbGwgYmUgZ2VuZXJhdGVkIHJhbmRvbWx5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0IHdpdGggdGhlIGtleSwgSVYsIGFuZCBzYWx0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IENyeXB0b0pTLmtkZi5PcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIpO1xuXHQgICAgICAgICAqICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IENyeXB0b0pTLmtkZi5PcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIsICdzYWx0c2FsdCcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwga2V5U2l6ZSwgaXZTaXplLCBzYWx0KSB7XG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBzYWx0XG5cdCAgICAgICAgICAgIGlmICghc2FsdCkge1xuXHQgICAgICAgICAgICAgICAgc2FsdCA9IFdvcmRBcnJheS5yYW5kb20oNjQvOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBJVlxuXHQgICAgICAgICAgICB2YXIga2V5ID0gRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IGtleVNpemUgKyBpdlNpemUgfSkuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cblx0ICAgICAgICAgICAgLy8gU2VwYXJhdGUga2V5IGFuZCBJVlxuXHQgICAgICAgICAgICB2YXIgaXYgPSBXb3JkQXJyYXkuY3JlYXRlKGtleS53b3Jkcy5zbGljZShrZXlTaXplKSwgaXZTaXplICogNCk7XG5cdCAgICAgICAgICAgIGtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBwYXJhbXNcblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBrZXk6IGtleSwgaXY6IGl2LCBzYWx0OiBzYWx0IH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBzZXJpYWxpemFibGUgY2lwaGVyIHdyYXBwZXIgdGhhdCBkZXJpdmVzIHRoZSBrZXkgZnJvbSBhIHBhc3N3b3JkLFxuXHQgICAgICogYW5kIHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAqL1xuXHQgICAgdmFyIFBhc3N3b3JkQmFzZWRDaXBoZXIgPSBDX2xpYi5QYXNzd29yZEJhc2VkQ2lwaGVyID0gU2VyaWFsaXphYmxlQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtLREZ9IGtkZiBUaGUga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gdG8gdXNlIHRvIGdlbmVyYXRlIGEga2V5IGFuZCBJViBmcm9tIGEgcGFzc3dvcmQuIERlZmF1bHQ6IE9wZW5TU0xcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IFNlcmlhbGl6YWJsZUNpcGhlci5jZmcuZXh0ZW5kKHtcblx0ICAgICAgICAgICAga2RmOiBPcGVuU1NMS2RmXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UgdXNpbmcgYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwgcGFzc3dvcmQsIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkUGFyYW1zID0gY2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSk7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIElWIHRvIGNvbmZpZ1xuXHQgICAgICAgICAgICBjZmcuaXYgPSBkZXJpdmVkUGFyYW1zLml2O1xuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgbWVzc2FnZSwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gTWl4IGluIGRlcml2ZWQgcGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQubWl4SW4oZGVyaXZlZFBhcmFtcyk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB1c2luZyBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIHBhc3N3b3JkLCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIENpcGhlclBhcmFtc1xuXHQgICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gdGhpcy5fcGFyc2UoY2lwaGVydGV4dCwgY2ZnLmZvcm1hdCk7XG5cblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkUGFyYW1zID0gY2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSwgY2lwaGVydGV4dC5zYWx0KTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgSVYgdG8gY29uZmlnXG5cdCAgICAgICAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XG5cblx0ICAgICAgICAgICAgLy8gRGVjcnlwdFxuXHQgICAgICAgICAgICB2YXIgcGxhaW50ZXh0ID0gU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQuY2FsbCh0aGlzLCBjaXBoZXIsIGNpcGhlcnRleHQsIGRlcml2ZWRQYXJhbXMua2V5LCBjZmcpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdH0oKSk7XG5cblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlcXVlc3QgPSBleHBvcnRzLmNyZWF0ZVJlcXVlc3QgPSB2b2lkIDA7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBjb21ldHRyYW5zcG9ydF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxMikpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciBldmVudGVtaXR0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNykpO1xudmFyIGVycm9yaW5mb18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBkZWZhdWx0c18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg4KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBYSFJTdGF0ZXNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjEpKTtcbi8vIFdvcmthcm91bmQgZm9yIHNhbGVzZm9yY2UgbGlnaHRuaW5nIGxvY2tlciBjb21wYXRpYmlsaXR5XG52YXIgZ2xvYmFsT2JqZWN0ID0gVXRpbHMuZ2V0R2xvYmFsT2JqZWN0KCk7XG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcbi8qIENhbid0IGp1c3QgdXNlIHdpbmRvdy5BYmx5LCBhcyB0aGF0IHdvbid0IGV4aXN0IGlmIHVzaW5nIHRoZSBjb21tb25qcyB2ZXJzaW9uLiAqL1xudmFyIF8gPSAoZ2xvYmFsT2JqZWN0Ll9hYmx5anNfanNvbnAgPSB7fSk7XG4vKiBleHByZXNzIHN0cmlwcyBvdXQgcGFyYW50aGVzZXMgZnJvbSB0aGUgY2FsbGJhY2shXG4gKiBLbHVkZ2UgdG8gc3RpbGwgYWxvdyBpdHMgcmVzcG9uc2VzIHRvIHdvcmssIHdoaWxlIG5vdCBrZWVwaW5nIHRoZVxuICogZnVuY3Rpb24gZm9ybSBmb3Igbm9ybWFsIHVzZSBhbmQgbm90IGNsdXR0ZXJpbmcgd2luZG93LkFibHlcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9leHByZXNzanMvZXhwcmVzcy9ibG9iLzViNGQ0YjRhYjEzMjQ3NDM1MzRmYmNkNDcwOWY0ZTc1YmI0YjRlOWQvbGliL3Jlc3BvbnNlLmpzI0wzMDVcbiAqL1xuXy5fID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIF9bJ18nICsgaWRdIHx8IG5vb3A7XG59O1xudmFyIGlkQ291bnRlciA9IDE7XG52YXIgc2hvcnROYW1lID0gJ2pzb25wJztcbmZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbWV0aG9kKSB7XG4gICAgLyogSlNPTlAgcmVxdWVzdHMgYXJlIHVzZWQgZWl0aGVyIHdpdGggdGhlIGNvbnRleHQgYmVpbmcgYSByZWFsdGltZVxuICAgICAqIHRyYW5zcG9ydCwgb3Igd2l0aCB0aW1lb3V0cyBwYXNzZWQgaW4gKGZvciB3aGVuIHVzZWQgYnkgYSByZXN0IGNsaWVudCksXG4gICAgICogb3IgY29tcGxldGVseSBzdGFuZGFsb25lLiAgVXNlIHRoZSBhcHByb3ByaWF0ZSB0aW1lb3V0cyBpbiBlYWNoIGNhc2UgKi9cbiAgICB0aW1lb3V0cyA9IHRpbWVvdXRzIHx8IGRlZmF1bHRzXzEuZGVmYXVsdC5USU1FT1VUUztcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QodW5kZWZpbmVkLCB1cmksIGhlYWRlcnMsIFV0aWxzLmNvcHkocGFyYW1zKSwgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBtZXRob2QpO1xufVxuZXhwb3J0cy5jcmVhdGVSZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdDtcbnZhciBKU09OUFRyYW5zcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhKU09OUFRyYW5zcG9ydCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBKU09OUFRyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNob3J0TmFtZSA9IHNob3J0TmFtZTtcbiAgICAgICAgcGFyYW1zLnN0cmVhbSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEpTT05QVHJhbnNwb3J0LmlzQXZhaWxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5qc29ucFN1cHBvcnRlZCAmJiBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmFsbG93Q29tZXQ7XG4gICAgfTtcbiAgICBKU09OUFRyYW5zcG9ydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnSlNPTlBUcmFuc3BvcnQ7IHVyaT0nICsgdGhpcy5iYXNlVXJpICsgJzsgaXNDb25uZWN0ZWQ9JyArIHRoaXMuaXNDb25uZWN0ZWQ7XG4gICAgfTtcbiAgICBKU09OUFRyYW5zcG9ydC5wcm90b3R5cGUuY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uICh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBtZXRob2QpIHtcbiAgICAgICAgLyogSlNPTlAgcmVxdWVzdHMgYXJlIHVzZWQgZWl0aGVyIHdpdGggdGhlIGNvbnRleHQgYmVpbmcgYSByZWFsdGltZVxuICAgICAgICAgKiB0cmFuc3BvcnQsIG9yIHdpdGggdGltZW91dHMgcGFzc2VkIGluIChmb3Igd2hlbiB1c2VkIGJ5IGEgcmVzdCBjbGllbnQpLFxuICAgICAgICAgKiBvciBjb21wbGV0ZWx5IHN0YW5kYWxvbmUuICBVc2UgdGhlIGFwcHJvcHJpYXRlIHRpbWVvdXRzIGluIGVhY2ggY2FzZSAqL1xuICAgICAgICB0aW1lb3V0cyA9ICh0aGlzID09PSBudWxsIHx8IHRoaXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRoaXMudGltZW91dHMpIHx8IHRpbWVvdXRzIHx8IGRlZmF1bHRzXzEuZGVmYXVsdC5USU1FT1VUUztcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbWV0aG9kKTtcbiAgICB9O1xuICAgIHJldHVybiBKU09OUFRyYW5zcG9ydDtcbn0oY29tZXR0cmFuc3BvcnRfMS5kZWZhdWx0KSk7XG52YXIgUmVxdWVzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZXF1ZXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlcXVlc3QoaWQsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGlkID0gaWRDb3VudGVyKys7XG4gICAgICAgIF90aGlzLmlkID0gaWQ7XG4gICAgICAgIF90aGlzLnVyaSA9IHVyaTtcbiAgICAgICAgX3RoaXMucGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICBfdGhpcy5wYXJhbXMucm5kID0gVXRpbHMuY2hlYXBSYW5kU3RyKCk7XG4gICAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgICAgICAvKiBKU09OUCBkb2Vzbid0IGFsbG93IGhlYWRlcnMuIENoZXJyeS1waWNrIGEgY291cGxlIHRvIHR1cm4gaW50byBxcyBwYXJhbXMgKi9cbiAgICAgICAgICAgIGlmIChoZWFkZXJzWydYLUFibHktVmVyc2lvbiddKVxuICAgICAgICAgICAgICAgIF90aGlzLnBhcmFtcy52ID0gaGVhZGVyc1snWC1BYmx5LVZlcnNpb24nXTtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzWydYLUFibHktTGliJ10pXG4gICAgICAgICAgICAgICAgX3RoaXMucGFyYW1zLmxpYiA9IGhlYWRlcnNbJ1gtQWJseS1MaWInXTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgX3RoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0TW9kZSA9IHJlcXVlc3RNb2RlO1xuICAgICAgICBfdGhpcy50aW1lb3V0cyA9IHRpbWVvdXRzO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0Q29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZXF1ZXN0LnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmlkLCBib2R5ID0gdGhpcy5ib2R5LCBtZXRob2QgPSB0aGlzLm1ldGhvZCwgdXJpID0gdGhpcy51cmksIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAgICAgICBwYXJhbXMuY2FsbGJhY2sgPSAnX2FibHlqc19qc29ucC5fKCcgKyBpZCArICcpJztcbiAgICAgICAgcGFyYW1zLmVudmVsb3BlID0gJ2pzb25wJztcbiAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5ib2R5ID0gYm9keTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kICYmIG1ldGhvZCAhPT0gJ2dldCcpIHtcbiAgICAgICAgICAgIHBhcmFtcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcmlwdCA9ICh0aGlzLnNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKTtcbiAgICAgICAgdmFyIHNyYyA9IHVyaSArIFV0aWxzLnRvUXVlcnlTdHJpbmcocGFyYW1zKTtcbiAgICAgICAgc2NyaXB0LnNyYyA9IHNyYztcbiAgICAgICAgaWYgKHNjcmlwdC5zcmMuc3BsaXQoJy8nKS5zbGljZSgtMSlbMF0gIT09IHNyYy5zcGxpdCgnLycpLnNsaWNlKC0xKVswXSkge1xuICAgICAgICAgICAgLyogVGhlIHNyYyBoYXMgYmVlbiB0cnVuY2F0ZWQuIENhbid0IGFib3J0LCBidXQgY2FuIGF0IGxlYXN0IGVtaXQgYW5cbiAgICAgICAgICAgICAqIGVycm9yIHNvIHRoZSB1c2VyIGtub3dzIHdoYXQncyBnb25lIHdyb25nLiAoQ2FuJ3QgY29tcGFyZSBzdHJpbmdzXG4gICAgICAgICAgICAgKiBkaXJlY3RseSBhcyBzcmMgbWF5IGhhdmUgYSBwb3J0LCBzY3JpcHQuc3JjIHdvbid0KSAqL1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdKU09OUCBSZXF1ZXN0LmV4ZWMoKScsICdXYXJuaW5nOiB0aGUgYnJvd3NlciBhcHBlYXJzIHRvIGhhdmUgdHJ1bmNhdGVkIHRoZSBzY3JpcHQgVVJJLiBUaGlzIHdpbGwgbGlrZWx5IHJlc3VsdCBpbiB0aGUgcmVxdWVzdCBmYWlsaW5nIGR1ZSB0byBhbiB1bnBhcnNlYWJsZSBib2R5IHBhcmFtJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgc2NyaXB0LmNoYXJzZXQgPSAnVVRGLTgnO1xuICAgICAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdKU09OUCBzY3JpcHQgZXJyb3IgKGV2ZW50OiAnICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KGVycikgKyAnKScsIG51bGwsIDQwMCkpO1xuICAgICAgICB9O1xuICAgICAgICBfWydfJyArIGlkXSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICAgICAgLyogSGFuZGxlIGFzIGVudmVsb3BlZCBqc29ucCwgYXMgYWxsIGpzb25wIHRyYW5zcG9ydCB1c2VzIHNob3VsZCBiZSAqL1xuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IG1lc3NhZ2UucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RhdHVzQ29kZSA9PSAyMDQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcGxldGUobnVsbCwgbnVsbCwgbnVsbCwgbWVzc2FnZS5zdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdJbnZhbGlkIHNlcnZlciByZXNwb25zZTogbm8gZW52ZWxvcGUgZGV0ZWN0ZWQnLCBudWxsLCA1MDApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZS5zdGF0dXNDb2RlIDwgNDAwIHx8IFV0aWxzLmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIElmIHJlc3BvbnNlIGlzIGFuIGFycmF5LCBpdCdzIGFuIGFycmF5IG9mIHByb3RvY29sIG1lc3NhZ2VzIC0tIGV2ZW4gaWZcbiAgICAgICAgICAgICAgICAgICAgICogaXQgY29udGFpbnMgYW4gZXJyb3IgYWN0aW9uIChoZW5jZSB0aGUgbm9uc3VjY2VzcyBzdGF0dXNjb2RlKSwgd2UgY2FuXG4gICAgICAgICAgICAgICAgICAgICAqIGNvbnNpZGVyIHRoZSByZXF1ZXN0IHRvIGhhdmUgc3VjY2VlZGVkLCBqdXN0IHBhc3MgaXQgb24gdG9cbiAgICAgICAgICAgICAgICAgICAgICogb25Qcm90b2NvbE1lc3NhZ2UgdG8gZGVjaWRlIHdoYXQgdG8gZG8gKi9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcGxldGUobnVsbCwgcmVzcG9uc2UsIG1lc3NhZ2UuaGVhZGVycywgbWVzc2FnZS5zdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSByZXNwb25zZS5lcnJvciB8fCBuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygnRXJyb3IgcmVzcG9uc2UgcmVjZWl2ZWQgZnJvbSBzZXJ2ZXInLCBudWxsLCBtZXNzYWdlLnN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wbGV0ZShlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIEhhbmRsZSBhcyBub24tZW52ZWxvcGVkIC0tIGFzIHdpbGwgYmUgZWcgZnJvbSBhIGN1c3RvbWVyJ3MgYXV0aFVybCBzZXJ2ZXIgKi9cbiAgICAgICAgICAgICAgICBfdGhpcy5jb21wbGV0ZShudWxsLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRpbWVvdXQgPSB0aGlzLnJlcXVlc3RNb2RlID09IFhIUlN0YXRlc18xLmRlZmF1bHQuUkVRX1NFTkQgPyB0aGlzLnRpbWVvdXRzLmh0dHBSZXF1ZXN0VGltZW91dCA6IHRoaXMudGltZW91dHMucmVjdlRpbWVvdXQ7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuYWJvcnQuYmluZCh0aGlzKSwgdGltZW91dCk7XG4gICAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH07XG4gICAgUmVxdWVzdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoZXJyLCBib2R5LCBoZWFkZXJzLCBzdGF0dXNDb2RlKSB7XG4gICAgICAgIGhlYWRlcnMgPSBoZWFkZXJzIHx8IHt9O1xuICAgICAgICBpZiAoIXRoaXMucmVxdWVzdENvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gdHlwZW9mIGJvZHkgPT0gJ3N0cmluZycgPyAndGV4dC9wbGFpbicgOiAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBjb250ZW50VHlwZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY29tcGxldGUnLCBlcnIsIGJvZHksIGhlYWRlcnMsIC8qIHVucGFja2VkOiAqLyB0cnVlLCBzdGF0dXNDb2RlKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICBSZXF1ZXN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGltZXIgPSB0aGlzLnRpbWVyO1xuICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQ7XG4gICAgICAgIGlmIChzY3JpcHQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgIGRlbGV0ZSBfW3RoaXMuaWRdO1xuICAgICAgICB0aGlzLmVtaXQoJ2Rpc3Bvc2VkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVxdWVzdDtcbn0oZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcbmZ1bmN0aW9uIGRlZmF1bHRfMShjb25uZWN0aW9uTWFuYWdlcikge1xuICAgIGdsb2JhbE9iamVjdC5KU09OUFRyYW5zcG9ydCA9IEpTT05QVHJhbnNwb3J0O1xuICAgIGlmIChKU09OUFRyYW5zcG9ydC5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHNbc2hvcnROYW1lXSA9IEpTT05QVHJhbnNwb3J0O1xuICAgIH1cbiAgICByZXR1cm4gSlNPTlBUcmFuc3BvcnQ7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0XzE7XG5cblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBkZWZhdWx0c18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg4KSk7XG52YXIgYXV0aF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNykpO1xudmFyIHB1c2hfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNDYpKTtcbnZhciBwYWdpbmF0ZWRyZXNvdXJjZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxOSkpO1xudmFyIGNoYW5uZWxfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzMpKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIHN0YXRzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KSk7XG52YXIgSHR0cE1ldGhvZHNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTgpKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg5KSk7XG52YXIgcHJlc2VuY2VtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KSk7XG52YXIgcmVzb3VyY2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTQpKTtcbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xudmFyIFJlc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzdChvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdubyBvcHRpb25zIHByb3ZpZGVkJztcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnUmVzdCgpJywgbXNnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRpb25zT2JqID0gZGVmYXVsdHNfMS5kZWZhdWx0Lm9iamVjdGlmeU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zT2JqLmxvZykge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5zZXRMb2cob3B0aW9uc09iai5sb2cubGV2ZWwsIG9wdGlvbnNPYmoubG9nLmhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVzdCgpJywgJ2luaXRpYWxpemVkIHdpdGggY2xpZW50T3B0aW9ucyAnICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KG9wdGlvbnMpKTtcbiAgICAgICAgdmFyIG5vcm1hbE9wdGlvbnMgPSAodGhpcy5vcHRpb25zID0gZGVmYXVsdHNfMS5kZWZhdWx0Lm5vcm1hbGlzZU9wdGlvbnMob3B0aW9uc09iaikpO1xuICAgICAgICAvKiBwcm9jZXNzIG9wdGlvbnMgKi9cbiAgICAgICAgaWYgKG5vcm1hbE9wdGlvbnMua2V5KSB7XG4gICAgICAgICAgICB2YXIga2V5TWF0Y2ggPSBub3JtYWxPcHRpb25zLmtleS5tYXRjaCgvXihbXjpcXHNdKyk6KFteOi5cXHNdKykkLyk7XG4gICAgICAgICAgICBpZiAoIWtleU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdpbnZhbGlkIGtleSBwYXJhbWV0ZXInO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnUmVzdCgpJywgbXNnKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDQwNDAwLCA0MDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9ybWFsT3B0aW9ucy5rZXlOYW1lID0ga2V5TWF0Y2hbMV07XG4gICAgICAgICAgICBub3JtYWxPcHRpb25zLmtleVNlY3JldCA9IGtleU1hdGNoWzJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnY2xpZW50SWQnIGluIG5vcm1hbE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghKHR5cGVvZiBub3JtYWxPcHRpb25zLmNsaWVudElkID09PSAnc3RyaW5nJyB8fCBub3JtYWxPcHRpb25zLmNsaWVudElkID09PSBudWxsKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnY2xpZW50SWQgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVsbCcsIDQwMDEyLCA0MDApO1xuICAgICAgICAgICAgZWxzZSBpZiAobm9ybWFsT3B0aW9ucy5jbGllbnRJZCA9PT0gJyonKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdDYW7igJl0IHVzZSBcIipcIiBhcyBhIGNsaWVudElkIGFzIHRoYXQgc3RyaW5nIGlzIHJlc2VydmVkLiAoVG8gY2hhbmdlIHRoZSBkZWZhdWx0IHRva2VuIHJlcXVlc3QgYmVoYXZpb3VyIHRvIHVzZSBhIHdpbGRjYXJkIGNsaWVudElkLCB1c2Uge2RlZmF1bHRUb2tlblBhcmFtczoge2NsaWVudElkOiBcIipcIn19KScsIDQwMDEyLCA0MDApO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUmVzdCgpJywgJ3N0YXJ0ZWQ7IHZlcnNpb24gPSAnICsgZGVmYXVsdHNfMS5kZWZhdWx0LnZlcnNpb24pO1xuICAgICAgICB0aGlzLmJhc2VVcmkgPSB0aGlzLmF1dGhvcml0eSA9IGZ1bmN0aW9uIChob3N0KSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdHNfMS5kZWZhdWx0LmdldEh0dHBTY2hlbWUobm9ybWFsT3B0aW9ucykgKyBob3N0ICsgJzonICsgZGVmYXVsdHNfMS5kZWZhdWx0LmdldFBvcnQobm9ybWFsT3B0aW9ucywgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jdXJyZW50RmFsbGJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLnNlcnZlclRpbWVPZmZzZXQgPSBudWxsO1xuICAgICAgICB0aGlzLmh0dHAgPSBuZXcgcGxhdGZvcm1fMS5kZWZhdWx0Lkh0dHAobm9ybWFsT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYXV0aCA9IG5ldyBhdXRoXzEuZGVmYXVsdCh0aGlzLCBub3JtYWxPcHRpb25zKTtcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IG5ldyBDaGFubmVscyh0aGlzKTtcbiAgICAgICAgdGhpcy5wdXNoID0gbmV3IHB1c2hfMS5kZWZhdWx0KHRoaXMpO1xuICAgIH1cbiAgICBSZXN0LnByb3RvdHlwZS5zdGF0cyA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xuICAgICAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3N0YXRzJywgW3BhcmFtc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0R2V0SGVhZGVycyh0aGlzLm9wdGlvbnMpLCBmb3JtYXQgPSB0aGlzLm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBlbnZlbG9wZSA9IHRoaXMuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCB0aGlzLm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV8xLmRlZmF1bHQodGhpcywgJy9zdGF0cycsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbiAoYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcbiAgICAgICAgICAgIHZhciBzdGF0c1ZhbHVlcyA9IHVucGFja2VkID8gYm9keSA6IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRzVmFsdWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRzVmFsdWVzW2ldID0gc3RhdHNfMS5kZWZhdWx0LmZyb21WYWx1ZXMoc3RhdHNWYWx1ZXNbaV0pO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRzVmFsdWVzO1xuICAgICAgICB9KS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZXN0LnByb3RvdHlwZS50aW1lID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXG4gICAgICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAndGltZScsIFtwYXJhbXNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9jYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gICAgICAgIHZhciBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdEdldEhlYWRlcnModGhpcy5vcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgdGhpcy5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICB2YXIgdGltZVVyaSA9IGZ1bmN0aW9uIChob3N0KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYXV0aG9yaXR5KGhvc3QpICsgJy90aW1lJztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5odHRwLmRvKEh0dHBNZXRob2RzXzEuZGVmYXVsdC5HZXQsIHRoaXMsIHRpbWVVcmksIGhlYWRlcnMsIG51bGwsIHBhcmFtcywgZnVuY3Rpb24gKGVyciwgcmVzLCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIF9jYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdW5wYWNrZWQpXG4gICAgICAgICAgICAgICAgcmVzID0gSlNPTi5wYXJzZShyZXMpO1xuICAgICAgICAgICAgdmFyIHRpbWUgPSByZXNbMF07XG4gICAgICAgICAgICBpZiAoIXRpbWUpIHtcbiAgICAgICAgICAgICAgICBfY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0ludGVybmFsIGVycm9yICh1bmV4cGVjdGVkIHJlc3VsdCB0eXBlIGZyb20gR0VUIC90aW1lKScsIDUwMDAwLCA1MDApKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjYWxjdWxhdGUgdGltZSBvZmZzZXQgb25seSBvbmNlIGZvciB0aGlzIGRldmljZSBieSBhZGRpbmcgdG8gdGhlIHByb3RvdHlwZSAqL1xuICAgICAgICAgICAgX3RoaXMuc2VydmVyVGltZU9mZnNldCA9IHRpbWUgLSBVdGlscy5ub3coKTtcbiAgICAgICAgICAgIF9jYWxsYmFjayhudWxsLCB0aW1lKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZXN0LnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgcGF0aCwgcGFyYW1zLCBib2R5LCBjdXN0b21IZWFkZXJzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgdXNlQmluYXJ5ID0gdGhpcy5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sLCBlbmNvZGVyID0gdXNlQmluYXJ5ID8gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5tc2dwYWNrLmVuY29kZSA6IEpTT04uc3RyaW5naWZ5LCBkZWNvZGVyID0gdXNlQmluYXJ5ID8gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5tc2dwYWNrLmRlY29kZSA6IEpTT04ucGFyc2UsIGZvcm1hdCA9IHVzZUJpbmFyeSA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGVudmVsb3BlID0gdGhpcy5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgdmFyIF9tZXRob2QgPSBtZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSBfbWV0aG9kID09ICdnZXQnID8gVXRpbHMuZGVmYXVsdEdldEhlYWRlcnModGhpcy5vcHRpb25zLCBmb3JtYXQpIDogVXRpbHMuZGVmYXVsdFBvc3RIZWFkZXJzKHRoaXMub3B0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdyZXF1ZXN0JywgW21ldGhvZCwgcGF0aCwgcGFyYW1zLCBib2R5LCBjdXN0b21IZWFkZXJzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IGVuY29kZXIoYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCB0aGlzLm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1c3RvbUhlYWRlcnMpIHtcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIGN1c3RvbUhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYWdpbmF0ZWRSZXNvdXJjZSA9IG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV8xLmRlZmF1bHQodGhpcywgcGF0aCwgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uIChyZXNib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLmVuc3VyZUFycmF5KHVucGFja2VkID8gcmVzYm9keSA6IGRlY29kZXIocmVzYm9keSkpO1xuICAgICAgICB9LCBcbiAgICAgICAgLyogdXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlOiAqLyB0cnVlKTtcbiAgICAgICAgaWYgKCFVdGlscy5hcnJJbihwbGF0Zm9ybV8xLmRlZmF1bHQuSHR0cC5tZXRob2RzLCBfbWV0aG9kKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1Vuc3VwcG9ydGVkIG1ldGhvZCAnICsgX21ldGhvZCwgNDA1MDAsIDQwNSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWxzLmFyckluKHBsYXRmb3JtXzEuZGVmYXVsdC5IdHRwLm1ldGhvZHNXaXRoQm9keSwgX21ldGhvZCkpIHtcbiAgICAgICAgICAgIHBhZ2luYXRlZFJlc291cmNlW19tZXRob2RdKHBhcmFtcywgYm9keSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFnaW5hdGVkUmVzb3VyY2VbX21ldGhvZF0ocGFyYW1zLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlc3QucHJvdG90eXBlLmJhdGNoUHVibGlzaCA9IGZ1bmN0aW9uIChzcGVjT3JTcGVjcywgY2FsbGJhY2tBcmcpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrQXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdiYXRjaFB1Ymxpc2gnLCBbc3BlY09yU3BlY3NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrQXJnID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFja0FyZztcbiAgICAgICAgdmFyIHJlcXVlc3RCb2R5RFRPO1xuICAgICAgICB2YXIgc2luZ2xlU3BlY01vZGU7XG4gICAgICAgIGlmIChVdGlscy5pc0FycmF5KHNwZWNPclNwZWNzKSkge1xuICAgICAgICAgICAgcmVxdWVzdEJvZHlEVE8gPSBzcGVjT3JTcGVjcztcbiAgICAgICAgICAgIHNpbmdsZVNwZWNNb2RlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0Qm9keURUTyA9IFtzcGVjT3JTcGVjc107XG4gICAgICAgICAgICBzaW5nbGVTcGVjTW9kZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0UG9zdEhlYWRlcnModGhpcy5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCB0aGlzLm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIHZhciByZXF1ZXN0Qm9keSA9IFV0aWxzLmVuY29kZUJvZHkocmVxdWVzdEJvZHlEVE8sIGZvcm1hdCk7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdC5wb3N0KHRoaXMsICcvbWVzc2FnZXMnLCByZXF1ZXN0Qm9keSwgaGVhZGVycywgeyBuZXdCYXRjaFJlc3BvbnNlOiAndHJ1ZScgfSwgbnVsbCwgZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHJlbW92ZSB0aGlzIHR5cGUgYXNzZXJ0aW9uIGFmdGVyIGZpeGluZyBodHRwczovL2dpdGh1Yi5jb20vYWJseS9hYmx5LWpzL2lzc3Vlcy8xNDA1XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmF0Y2hSZXN1bHRzID0gKHVucGFja2VkID8gYm9keSA6IFV0aWxzLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KSk7XG4gICAgICAgICAgICAvLyBJIGRvbid0IGxvdmUgdGhlIGJlbG93IHR5cGUgYXNzZXJ0aW9ucyBmb3IgYGNhbGxiYWNrYCBidXQgbm90IHN1cmUgaG93IHRvIGF2b2lkIHRoZW1cbiAgICAgICAgICAgIGlmIChzaW5nbGVTcGVjTW9kZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGJhdGNoUmVzdWx0c1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBiYXRjaFJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlc3QucHJvdG90eXBlLmJhdGNoUHJlc2VuY2UgPSBmdW5jdGlvbiAoY2hhbm5lbHMsIGNhbGxiYWNrQXJnKSB7XG4gICAgICAgIGlmIChjYWxsYmFja0FyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnYmF0Y2hQcmVzZW5jZScsIFtjaGFubmVsc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2tBcmcgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrQXJnO1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLm9wdGlvbnMsIGZvcm1hdCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHRoaXMub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgdmFyIGNoYW5uZWxzUGFyYW0gPSBjaGFubmVscy5qb2luKCcsJyk7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdC5nZXQodGhpcywgJy9wcmVzZW5jZScsIGhlYWRlcnMsIHsgbmV3QmF0Y2hSZXNwb25zZTogJ3RydWUnLCBjaGFubmVsczogY2hhbm5lbHNQYXJhbSB9LCBudWxsLCBmdW5jdGlvbiAoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgdHlwZSBhc3NlcnRpb24gYWZ0ZXIgZml4aW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5L2FibHktanMvaXNzdWVzLzE0MDVcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiYXRjaFJlc3VsdCA9ICh1bnBhY2tlZCA/IGJvZHkgOiBVdGlscy5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCkpO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYmF0Y2hSZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlc3QucHJvdG90eXBlLnNldExvZyA9IGZ1bmN0aW9uIChsb2dPcHRpb25zKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuc2V0TG9nKGxvZ09wdGlvbnMubGV2ZWwsIGxvZ09wdGlvbnMuaGFuZGxlcik7XG4gICAgfTtcbiAgICBSZXN0LlByb21pc2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gZGVmYXVsdHNfMS5kZWZhdWx0Lm9iamVjdGlmeU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMucHJvbWlzZXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbmV3IFJlc3Qob3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZXN0LkNhbGxiYWNrcyA9IFJlc3Q7XG4gICAgUmVzdC5QbGF0Zm9ybSA9IHBsYXRmb3JtXzEuZGVmYXVsdDtcbiAgICBSZXN0Lk1lc3NhZ2UgPSBtZXNzYWdlXzEuZGVmYXVsdDtcbiAgICBSZXN0LlByZXNlbmNlTWVzc2FnZSA9IHByZXNlbmNlbWVzc2FnZV8xLmRlZmF1bHQ7XG4gICAgcmV0dXJuIFJlc3Q7XG59KCkpO1xudmFyIENoYW5uZWxzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYW5uZWxzKHJlc3QpIHtcbiAgICAgICAgdGhpcy5yZXN0ID0gcmVzdDtcbiAgICAgICAgdGhpcy5hbGwgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBDaGFubmVscy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUsIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XG4gICAgICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgICAgICAgdGhpcy5hbGxbbmFtZV0gPSBjaGFubmVsID0gbmV3IGNoYW5uZWxfMS5kZWZhdWx0KHRoaXMucmVzdCwgbmFtZSwgY2hhbm5lbE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgICAgICBjaGFubmVsLnNldE9wdGlvbnMoY2hhbm5lbE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFubmVsO1xuICAgIH07XG4gICAgLyogSW5jbHVkZWQgdG8gc3VwcG9ydCBjZXJ0YWluIG5pY2hlIHVzZS1jYXNlczsgbW9zdCB1c2VycyBzaG91bGQgaWdub3JlIHRoaXMuXG4gICAgICogUGxlYXNlIGRvIG5vdCB1c2UgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcgKi9cbiAgICBDaGFubmVscy5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmFsbFtTdHJpbmcobmFtZSldO1xuICAgIH07XG4gICAgcmV0dXJuIENoYW5uZWxzO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlc3Q7XG5cblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0cmV0dXJuIENyeXB0b0pTLmVuYy5VdGY4O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDYpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIEluaXRpYWxpemF0aW9uIGFuZCByb3VuZCBjb25zdGFudHMgdGFibGVzXG5cdCAgICB2YXIgSCA9IFtdO1xuXHQgICAgdmFyIEsgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gaXNQcmltZShuKSB7XG5cdCAgICAgICAgICAgIHZhciBzcXJ0TiA9IE1hdGguc3FydChuKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgZmFjdG9yID0gMjsgZmFjdG9yIDw9IHNxcnROOyBmYWN0b3IrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKCEobiAlIGZhY3RvcikpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmdW5jdGlvbiBnZXRGcmFjdGlvbmFsQml0cyhuKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoKG4gLSAobiB8IDApKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIG4gPSAyO1xuXHQgICAgICAgIHZhciBuUHJpbWUgPSAwO1xuXHQgICAgICAgIHdoaWxlIChuUHJpbWUgPCA2NCkge1xuXHQgICAgICAgICAgICBpZiAoaXNQcmltZShuKSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG5QcmltZSA8IDgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBIW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLCAxIC8gMikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgS1tuUHJpbWVdID0gZ2V0RnJhY3Rpb25hbEJpdHMoTWF0aC5wb3cobiwgMSAvIDMpKTtcblxuXHQgICAgICAgICAgICAgICAgblByaW1lKys7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBuKys7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0XG5cdCAgICB2YXIgVyA9IFtdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS0yNTYgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEEyNTYgPSBDX2FsZ28uU0hBMjU2ID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChILnNsaWNlKDApKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBiID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XG5cdCAgICAgICAgICAgIHZhciBlID0gSFs0XTtcblx0ICAgICAgICAgICAgdmFyIGYgPSBIWzVdO1xuXHQgICAgICAgICAgICB2YXIgZyA9IEhbNl07XG5cdCAgICAgICAgICAgIHZhciBoID0gSFs3XTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMTYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gTVtvZmZzZXQgKyBpXSB8IDA7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTB4ID0gV1tpIC0gMTVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTAgID0gKChnYW1tYTB4IDw8IDI1KSB8IChnYW1tYTB4ID4+PiA3KSkgIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZ2FtbWEweCA8PCAxNCkgfCAoZ2FtbWEweCA+Pj4gMTgpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdhbW1hMHggPj4+IDMpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMXggPSBXW2kgLSAyXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExICA9ICgoZ2FtbWExeCA8PCAxNSkgfCAoZ2FtbWExeCA+Pj4gMTcpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGdhbW1hMXggPDwgMTMpIHwgKGdhbW1hMXggPj4+IDE5KSkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnYW1tYTF4ID4+PiAxMCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciBjaCAgPSAoZSAmIGYpIF4gKH5lICYgZyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWFqID0gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWEwID0gKChhIDw8IDMwKSB8IChhID4+PiAyKSkgXiAoKGEgPDwgMTkpIHwgKGEgPj4+IDEzKSkgXiAoKGEgPDwgMTApIHwgKGEgPj4+IDIyKSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWExID0gKChlIDw8IDI2KSB8IChlID4+PiA2KSkgXiAoKGUgPDwgMjEpIHwgKGUgPj4+IDExKSkgXiAoKGUgPDwgNykgIHwgKGUgPj4+IDI1KSk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbaV0gKyBXW2ldO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQyID0gc2lnbWEwICsgbWFqO1xuXG5cdCAgICAgICAgICAgICAgICBoID0gZztcblx0ICAgICAgICAgICAgICAgIGcgPSBmO1xuXHQgICAgICAgICAgICAgICAgZiA9IGU7XG5cdCAgICAgICAgICAgICAgICBlID0gKGQgKyB0MSkgfCAwO1xuXHQgICAgICAgICAgICAgICAgZCA9IGM7XG5cdCAgICAgICAgICAgICAgICBjID0gYjtcblx0ICAgICAgICAgICAgICAgIGIgPSBhO1xuXHQgICAgICAgICAgICAgICAgYSA9ICh0MSArIHQyKSB8IDA7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNF0gPSAoSFs0XSArIGUpIHwgMDtcblx0ICAgICAgICAgICAgSFs1XSA9IChIWzVdICsgZikgfCAwO1xuXHQgICAgICAgICAgICBIWzZdID0gKEhbNl0gKyBnKSB8IDA7XG5cdCAgICAgICAgICAgIEhbN10gPSAoSFs3XSArIGgpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSBuQml0c1RvdGFsO1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjU2KCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEEyNTYgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEEyNTYpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTI1NihtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEEyNTYgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMjU2KTtcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMjU2O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGV2ZW50ZW1pdHRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBwcmVzZW5jZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzNCkpO1xudmFyIG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOSkpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgcGFnaW5hdGVkcmVzb3VyY2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTkpKTtcbnZhciByZXNvdXJjZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNCkpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbnZhciBNU0dfSURfRU5UUk9QWV9CWVRFUyA9IDk7XG5mdW5jdGlvbiBhbGxFbXB0eUlkcyhtZXNzYWdlcykge1xuICAgIHJldHVybiBVdGlscy5hcnJFdmVyeShtZXNzYWdlcywgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuICFtZXNzYWdlLmlkO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBjaGFubmVsT3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKGNoYW5uZWxPcHRpb25zLmNpcGhlcikge1xuICAgICAgICBpZiAoIXBsYXRmb3JtXzEuZGVmYXVsdC5DcnlwdG8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gbm90IGVuYWJsZWQ7IHVzZSBhYmx5LmVuY3J5cHRpb24uanMgaW5zdGVhZCcpO1xuICAgICAgICB2YXIgY2lwaGVyID0gcGxhdGZvcm1fMS5kZWZhdWx0LkNyeXB0by5nZXRDaXBoZXIoY2hhbm5lbE9wdGlvbnMuY2lwaGVyKTtcbiAgICAgICAgY2hhbm5lbE9wdGlvbnMuY2lwaGVyID0gY2lwaGVyLmNpcGhlclBhcmFtcztcbiAgICAgICAgY2hhbm5lbE9wdGlvbnMuY2hhbm5lbENpcGhlciA9IGNpcGhlci5jaXBoZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdjaXBoZXInIGluIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgIC8qIERvbid0IGRlYWN0aXZhdGUgYW4gZXhpc3RpbmcgY2lwaGVyIHVubGVzcyBvcHRpb25zXG4gICAgICAgICAqIGhhcyBhICdjaXBoZXInIGtleSB0aGF0J3MgZmFsc2V5ICovXG4gICAgICAgIGNoYW5uZWxPcHRpb25zLmNpcGhlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgY2hhbm5lbE9wdGlvbnMuY2hhbm5lbENpcGhlciA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjaGFubmVsT3B0aW9ucztcbn1cbnZhciBDaGFubmVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKENoYW5uZWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2hhbm5lbChyZXN0LCBuYW1lLCBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0NoYW5uZWwoKScsICdzdGFydGVkOyBuYW1lID0gJyArIG5hbWUpO1xuICAgICAgICBfdGhpcy5yZXN0ID0gcmVzdDtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLmJhc2VQYXRoID0gJy9jaGFubmVscy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpO1xuICAgICAgICBfdGhpcy5wcmVzZW5jZSA9IG5ldyBwcmVzZW5jZV8xLmRlZmF1bHQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5jaGFubmVsT3B0aW9ucyA9IG5vcm1hbGlzZUNoYW5uZWxPcHRpb25zKGNoYW5uZWxPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDaGFubmVsLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsT3B0aW9ucyA9IG5vcm1hbGlzZUNoYW5uZWxPcHRpb25zKG9wdGlvbnMpO1xuICAgIH07XG4gICAgQ2hhbm5lbC5wcm90b3R5cGUuaGlzdG9yeSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ2hhbm5lbC5oaXN0b3J5KCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLm5hbWUpO1xuICAgICAgICAvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2hpc3RvcnknLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGlzdG9yeShwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIENoYW5uZWwucHJvdG90eXBlLl9oaXN0b3J5ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnJlc3QsIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGVudmVsb3BlID0gdGhpcy5yZXN0Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzKHJlc3Qub3B0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuY2hhbm5lbE9wdGlvbnM7XG4gICAgICAgIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV8xLmRlZmF1bHQocmVzdCwgdGhpcy5iYXNlUGF0aCArICcvbWVzc2FnZXMnLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24gKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShib2R5LCBvcHRpb25zLCB1bnBhY2tlZCA/IHVuZGVmaW5lZCA6IGZvcm1hdCk7XG4gICAgICAgIH0pLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIENoYW5uZWwucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsIGZpcnN0ID0gYXJndW1lbnRzWzBdLCBzZWNvbmQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmdDb3VudCAtIDFdO1xuICAgICAgICB2YXIgbWVzc2FnZXM7XG4gICAgICAgIHZhciBwYXJhbXM7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3B1Ymxpc2gnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmlyc3QgPT09ICdzdHJpbmcnIHx8IGZpcnN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvKiAobmFtZSwgZGF0YSwgLi4uKSAqL1xuICAgICAgICAgICAgbWVzc2FnZXMgPSBbbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyh7IG5hbWU6IGZpcnN0LCBkYXRhOiBzZWNvbmQgfSldO1xuICAgICAgICAgICAgcGFyYW1zID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFV0aWxzLmlzT2JqZWN0KGZpcnN0KSkge1xuICAgICAgICAgICAgbWVzc2FnZXMgPSBbbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyhmaXJzdCldO1xuICAgICAgICAgICAgcGFyYW1zID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFV0aWxzLmlzQXJyYXkoZmlyc3QpKSB7XG4gICAgICAgICAgICBtZXNzYWdlcyA9IG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXNBcnJheShmaXJzdCk7XG4gICAgICAgICAgICBwYXJhbXMgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVGhlIHNpbmdsZS1hcmd1bWVudCBmb3JtIG9mIHB1Ymxpc2goKSBleHBlY3RzIGEgbWVzc2FnZSBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgbWVzc2FnZSBvYmplY3RzJywgNDAwMTMsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgIT09ICdvYmplY3QnIHx8ICFwYXJhbXMpIHtcbiAgICAgICAgICAgIC8qIE5vIHBhcmFtcyBzdXBwbGllZCAoc28gYWZ0ZXItbWVzc2FnZSBhcmd1bWVudCBpcyBqdXN0IHRoZSBjYWxsYmFjayBvciB1bmRlZmluZWQpICovXG4gICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucmVzdCwgb3B0aW9ucyA9IHJlc3Qub3B0aW9ucywgZm9ybWF0ID0gb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyA9IHJlc3Qub3B0aW9ucy5pZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcsIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0UG9zdEhlYWRlcnMocmVzdC5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICBpZiAob3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgaWYgKGlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyAmJiBhbGxFbXB0eUlkcyhtZXNzYWdlcykpIHtcbiAgICAgICAgICAgIHZhciBtc2dJZEJhc2VfMSA9IFV0aWxzLnJhbmRvbVN0cmluZyhNU0dfSURfRU5UUk9QWV9CWVRFUyk7XG4gICAgICAgICAgICBVdGlscy5hcnJGb3JFYWNoKG1lc3NhZ2VzLCBmdW5jdGlvbiAobWVzc2FnZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmlkID0gbXNnSWRCYXNlXzEgKyAnOicgKyBpbmRleC50b1N0cmluZygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZV8xLmRlZmF1bHQuZW5jb2RlQXJyYXkobWVzc2FnZXMsIHRoaXMuY2hhbm5lbE9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFJTTDFpICovXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IG1lc3NhZ2VfMS5kZWZhdWx0LmdldE1lc3NhZ2VzU2l6ZShtZXNzYWdlcyksIG1heE1lc3NhZ2VTaXplID0gb3B0aW9ucy5tYXhNZXNzYWdlU2l6ZTtcbiAgICAgICAgICAgIGlmIChzaXplID4gbWF4TWVzc2FnZVNpemUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnTWF4aW11bSBzaXplIG9mIG1lc3NhZ2VzIHRoYXQgY2FuIGJlIHB1Ymxpc2hlZCBhdCBvbmNlIGV4Y2VlZGVkICggd2FzICcgK1xuICAgICAgICAgICAgICAgICAgICBzaXplICtcbiAgICAgICAgICAgICAgICAgICAgJyBieXRlczsgbGltaXQgaXMgJyArXG4gICAgICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VTaXplICtcbiAgICAgICAgICAgICAgICAgICAgJyBieXRlcyknLCA0MDAwOSwgNDAwKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2gobWVzc2FnZV8xLmRlZmF1bHQuc2VyaWFsaXplKG1lc3NhZ2VzLCBmb3JtYXQpLCBoZWFkZXJzLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaGFubmVsLnByb3RvdHlwZS5fcHVibGlzaCA9IGZ1bmN0aW9uIChyZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQucG9zdCh0aGlzLnJlc3QsIHRoaXMuYmFzZVBhdGggKyAnL21lc3NhZ2VzJywgcmVxdWVzdEJvZHksIGhlYWRlcnMsIHBhcmFtcywgbnVsbCwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgQ2hhbm5lbC5wcm90b3R5cGUuc3RhdHVzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicgJiYgdGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3N0YXR1cycsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5yZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uO1xuICAgICAgICB2YXIgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLnJlc3Qub3B0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LmdldCh0aGlzLnJlc3QsIHRoaXMuYmFzZVBhdGgsIGhlYWRlcnMsIHt9LCBmb3JtYXQsIGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgIH07XG4gICAgcmV0dXJuIENoYW5uZWw7XG59KGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENoYW5uZWw7XG5cblxuLyoqKi8gfSksXG4vKiAzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgZXZlbnRlbWl0dGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIHBhZ2luYXRlZHJlc291cmNlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KSk7XG52YXIgcHJlc2VuY2VtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KSk7XG5mdW5jdGlvbiBub29wKCkgeyB9XG52YXIgUHJlc2VuY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUHJlc2VuY2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJlc2VuY2UoY2hhbm5lbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgX3RoaXMuYmFzZVBhdGggPSBjaGFubmVsLmJhc2VQYXRoICsgJy9wcmVzZW5jZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUHJlc2VuY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUHJlc2VuY2UuZ2V0KCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLmNoYW5uZWwubmFtZSk7XG4gICAgICAgIC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xuICAgICAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdnZXQnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLmNoYW5uZWwucmVzdCwgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgZW52ZWxvcGUgPSB0aGlzLmNoYW5uZWwucmVzdC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQsIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0R2V0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCk7XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmNoYW5uZWwuY2hhbm5lbE9wdGlvbnM7XG4gICAgICAgIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV8xLmRlZmF1bHQocmVzdCwgdGhpcy5iYXNlUGF0aCwgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uIChib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXNlbmNlbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShib2R5LCBvcHRpb25zLCB1bnBhY2tlZCA/IHVuZGVmaW5lZCA6IGZvcm1hdCk7XG4gICAgICAgIH0pLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFByZXNlbmNlLnByb3RvdHlwZS5oaXN0b3J5ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdQcmVzZW5jZS5oaXN0b3J5KCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLmNoYW5uZWwubmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaXN0b3J5KHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUHJlc2VuY2UucHJvdG90eXBlLl9oaXN0b3J5ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgLyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXG4gICAgICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWwucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ19oaXN0b3J5JywgW3BhcmFtc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLmNoYW5uZWwucmVzdCwgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgZW52ZWxvcGUgPSB0aGlzLmNoYW5uZWwucmVzdC5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQsIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0R2V0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCk7XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmNoYW5uZWwuY2hhbm5lbE9wdGlvbnM7XG4gICAgICAgIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV8xLmRlZmF1bHQocmVzdCwgdGhpcy5iYXNlUGF0aCArICcvaGlzdG9yeScsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbiAoYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoYm9keSwgb3B0aW9ucywgdW5wYWNrZWQgPyB1bmRlZmluZWQgOiBmb3JtYXQpO1xuICAgICAgICB9KS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm4gUHJlc2VuY2U7XG59KGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFByZXNlbmNlO1xuXG5cbi8qKiovIH0pLFxuLyogMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYW5zcG9ydFBhcmFtcyA9IHZvaWQgMDtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBwcm90b2NvbG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTApKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIHByb3RvY29sXzEgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKSk7XG52YXIgZGVmYXVsdHNfMSA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oOCkpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciBldmVudGVtaXR0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNykpO1xudmFyIG1lc3NhZ2VxdWV1ZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzNikpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgY29ubmVjdGlvbnN0YXRlY2hhbmdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KSk7XG52YXIgY29ubmVjdGlvbmVycm9yc18xID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygyMCkpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgYXV0aF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNykpO1xudmFyIG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOSkpO1xudmFyIG11bHRpY2FzdGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKSk7XG52YXIgd2Vic29ja2V0dHJhbnNwb3J0XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKSk7XG52YXIgdHJhbnNwb3J0XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KSk7XG52YXIgSHR0cFN0YXR1c0NvZGVzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KSk7XG52YXIgaGF2ZVdlYlN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7IHZhciBfYTsgcmV0dXJuIHR5cGVvZiBwbGF0Zm9ybV8xLmRlZmF1bHQuV2ViU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcgJiYgKChfYSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5XZWJTdG9yYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWxTdXBwb3J0ZWQpOyB9O1xudmFyIGhhdmVTZXNzaW9uU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHsgdmFyIF9hOyByZXR1cm4gdHlwZW9mIHBsYXRmb3JtXzEuZGVmYXVsdC5XZWJTdG9yYWdlICE9PSAndW5kZWZpbmVkJyAmJiAoKF9hID0gcGxhdGZvcm1fMS5kZWZhdWx0LldlYlN0b3JhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXNzaW9uU3VwcG9ydGVkKTsgfTtcbnZhciBhY3Rpb25zID0gcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5BY3Rpb247XG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcbnZhciB0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSA9ICdhYmx5LXRyYW5zcG9ydC1wcmVmZXJlbmNlJztcbnZhciBzZXNzaW9uUmVjb3ZlcnlOYW1lID0gJ2FibHktY29ubmVjdGlvbi1yZWNvdmVyeSc7XG5mdW5jdGlvbiBnZXRTZXNzaW9uUmVjb3ZlckRhdGEoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgKChfYiA9IChfYSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5XZWJTdG9yYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U2Vzc2lvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHNlc3Npb25SZWNvdmVyeU5hbWUpKTtcbn1cbmZ1bmN0aW9uIHNldFNlc3Npb25SZWNvdmVyRGF0YSh2YWx1ZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIGhhdmVTZXNzaW9uU3RvcmFnZSgpICYmICgoX2IgPSAoX2EgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuV2ViU3RvcmFnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldFNlc3Npb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBzZXNzaW9uUmVjb3ZlcnlOYW1lLCB2YWx1ZSkpO1xufVxuZnVuY3Rpb24gY2xlYXJTZXNzaW9uUmVjb3ZlckRhdGEoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgKChfYiA9IChfYSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5XZWJTdG9yYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlU2Vzc2lvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHNlc3Npb25SZWNvdmVyeU5hbWUpKTtcbn1cbmZ1bmN0aW9uIGJldHRlclRyYW5zcG9ydFRoYW4oYSwgYikge1xuICAgIHJldHVybiAoVXRpbHMuYXJySW5kZXhPZihwbGF0Zm9ybV8xLmRlZmF1bHQuRGVmYXVsdHMudHJhbnNwb3J0UHJlZmVyZW5jZU9yZGVyLCBhLnNob3J0TmFtZSkgPlxuICAgICAgICBVdGlscy5hcnJJbmRleE9mKHBsYXRmb3JtXzEuZGVmYXVsdC5EZWZhdWx0cy50cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXIsIGIuc2hvcnROYW1lKSk7XG59XG5mdW5jdGlvbiBidW5kbGVXaXRoKGRlc3QsIHNyYywgbWF4U2l6ZSkge1xuICAgIHZhciBhY3Rpb247XG4gICAgaWYgKGRlc3QuY2hhbm5lbCAhPT0gc3JjLmNoYW5uZWwpIHtcbiAgICAgICAgLyogUlRMNmQzICovXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKChhY3Rpb24gPSBkZXN0LmFjdGlvbikgIT09IGFjdGlvbnMuUFJFU0VOQ0UgJiYgYWN0aW9uICE9PSBhY3Rpb25zLk1FU1NBR0UpIHtcbiAgICAgICAgLyogUlRMNmQgLSBjYW4gb25seSBidW5kbGUgbWVzc2FnZXMgb3IgcHJlc2VuY2UgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYWN0aW9uICE9PSBzcmMuYWN0aW9uKSB7XG4gICAgICAgIC8qIFJUTDZkNCAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBraW5kID0gYWN0aW9uID09PSBhY3Rpb25zLlBSRVNFTkNFID8gJ3ByZXNlbmNlJyA6ICdtZXNzYWdlcycsIHByb3Bvc2VkID0gZGVzdFtraW5kXS5jb25jYXQoc3JjW2tpbmRdKSwgc2l6ZSA9IG1lc3NhZ2VfMS5kZWZhdWx0LmdldE1lc3NhZ2VzU2l6ZShwcm9wb3NlZCk7XG4gICAgaWYgKHNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgIC8qIFJUTDZkMSAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghVXRpbHMuYWxsU2FtZShwcm9wb3NlZCwgJ2NsaWVudElkJykpIHtcbiAgICAgICAgLyogUlRMNmQyICovXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFVdGlscy5hcnJFdmVyeShwcm9wb3NlZCwgZnVuY3Rpb24gKG1zZykge1xuICAgICAgICByZXR1cm4gIW1zZy5pZDtcbiAgICB9KSkge1xuICAgICAgICAvKiBSVEw2ZDcgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKiB3ZSdyZSBnb29kIHRvIGdvISAqL1xuICAgIGRlc3Rba2luZF0gPSBwcm9wb3NlZDtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRlY29kZVJlY292ZXJ5S2V5KHJlY292ZXJ5S2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVjb3ZlcnlLZXkpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG52YXIgVHJhbnNwb3J0UGFyYW1zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zcG9ydFBhcmFtcyhvcHRpb25zLCBob3N0LCBtb2RlLCBjb25uZWN0aW9uS2V5KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbktleSA9IGNvbm5lY3Rpb25LZXk7XG4gICAgICAgIHRoaXMuZm9ybWF0ID0gb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb247XG4gICAgfVxuICAgIFRyYW5zcG9ydFBhcmFtcy5wcm90b3R5cGUuZ2V0Q29ubmVjdFBhcmFtcyA9IGZ1bmN0aW9uIChhdXRoUGFyYW1zKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBhdXRoUGFyYW1zID8gVXRpbHMuY29weShhdXRoUGFyYW1zKSA6IHt9O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3VwZ3JhZGUnOlxuICAgICAgICAgICAgICAgIHBhcmFtcy51cGdyYWRlID0gdGhpcy5jb25uZWN0aW9uS2V5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmVzdW1lJzpcbiAgICAgICAgICAgICAgICBwYXJhbXMucmVzdW1lID0gdGhpcy5jb25uZWN0aW9uS2V5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmVjb3Zlcic6IHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjb3ZlcnlDb250ZXh0ID0gZGVjb2RlUmVjb3ZlcnlLZXkob3B0aW9ucy5yZWNvdmVyKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3ZlcnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5yZWNvdmVyID0gcmVjb3ZlcnlDb250ZXh0LmNvbm5lY3Rpb25LZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jbGllbnRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuY2xpZW50SWQgPSBvcHRpb25zLmNsaWVudElkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVjaG9NZXNzYWdlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHBhcmFtcy5lY2hvID0gJ2ZhbHNlJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmZvcm1hdCA9IHRoaXMuZm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0cmVhbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuc3RyZWFtID0gdGhpcy5zdHJlYW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGVhcnRiZWF0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuaGVhcnRiZWF0cyA9IHRoaXMuaGVhcnRiZWF0cztcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMudiA9IGRlZmF1bHRzXzEuZGVmYXVsdC5wcm90b2NvbFZlcnNpb247XG4gICAgICAgIHBhcmFtcy5hZ2VudCA9IGVuY29kZVVSSUNvbXBvbmVudCgoMCwgZGVmYXVsdHNfMS5nZXRBZ2VudFN0cmluZykodGhpcy5vcHRpb25zKSk7XG4gICAgICAgIGlmIChvcHRpb25zLnRyYW5zcG9ydFBhcmFtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBVdGlscy5taXhpbihwYXJhbXMsIG9wdGlvbnMudHJhbnNwb3J0UGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gICAgVHJhbnNwb3J0UGFyYW1zLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICdbbW9kZT0nICsgdGhpcy5tb2RlO1xuICAgICAgICBpZiAodGhpcy5ob3N0KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJyxob3N0PScgKyB0aGlzLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbktleSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcsY29ubmVjdGlvbktleT0nICsgdGhpcy5jb25uZWN0aW9uS2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZvcm1hdCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcsZm9ybWF0PScgKyB0aGlzLmZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJ10nO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zcG9ydFBhcmFtcztcbn0oKSk7XG5leHBvcnRzLlRyYW5zcG9ydFBhcmFtcyA9IFRyYW5zcG9ydFBhcmFtcztcbnZhciBDb25uZWN0aW9uTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb25uZWN0aW9uTWFuYWdlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25uZWN0aW9uTWFuYWdlcihyZWFsdGltZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kaXNjb25uZWN0ZWRSZXRyeUNvdW50ID0gMDtcbiAgICAgICAgQ29ubmVjdGlvbk1hbmFnZXIuaW5pdFRyYW5zcG9ydHMoKTtcbiAgICAgICAgX3RoaXMucmVhbHRpbWUgPSByZWFsdGltZTtcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHZhciB0aW1lb3V0cyA9IG9wdGlvbnMudGltZW91dHM7XG4gICAgICAgIC8qIGNvbm5lY3RpbmdUaW1lb3V0OiBsZWF2ZSBwcmVmZXJlbmNlQ29ubmVjdFRpbWVvdXQgKH42cykgdG8gdHJ5IHRoZVxuICAgICAgICAgKiBwcmVmZXJlbmNlIHRyYW5zcG9ydCwgdGhlbiByZWFsdGltZVJlcXVlc3RUaW1lb3V0ICh+MTBzKSB0byBlc3RhYmxpc2hcbiAgICAgICAgICogdGhlIGJhc2UgdHJhbnNwb3J0IGluIGNhc2UgdGhhdCBmYWlscyAqL1xuICAgICAgICB2YXIgY29ubmVjdGluZ1RpbWVvdXQgPSB0aW1lb3V0cy5wcmVmZXJlbmNlQ29ubmVjdFRpbWVvdXQgKyB0aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0O1xuICAgICAgICBfdGhpcy5zdGF0ZXMgPSB7XG4gICAgICAgICAgICBpbml0aWFsaXplZDoge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnaW5pdGlhbGl6ZWQnLFxuICAgICAgICAgICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBxdWV1ZUV2ZW50czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWlsU3RhdGU6ICdkaXNjb25uZWN0ZWQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbm5lY3Rpbmc6IHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2Nvbm5lY3RpbmcnLFxuICAgICAgICAgICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBxdWV1ZUV2ZW50czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZXRyeURlbGF5OiBjb25uZWN0aW5nVGltZW91dCxcbiAgICAgICAgICAgICAgICBmYWlsU3RhdGU6ICdkaXNjb25uZWN0ZWQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbm5lY3RlZDoge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnY29ubmVjdGVkJyxcbiAgICAgICAgICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcXVldWVFdmVudHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNlbmRFdmVudHM6IHRydWUsXG4gICAgICAgICAgICAgICAgZmFpbFN0YXRlOiAnZGlzY29ubmVjdGVkJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzeW5jaHJvbml6aW5nOiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdjb25uZWN0ZWQnLFxuICAgICAgICAgICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBxdWV1ZUV2ZW50czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmb3JjZVF1ZXVlRXZlbnRzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZhaWxTdGF0ZTogJ2Rpc2Nvbm5lY3RlZCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzY29ubmVjdGVkOiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdkaXNjb25uZWN0ZWQnLFxuICAgICAgICAgICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBxdWV1ZUV2ZW50czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZXRyeURlbGF5OiB0aW1lb3V0cy5kaXNjb25uZWN0ZWRSZXRyeVRpbWVvdXQsXG4gICAgICAgICAgICAgICAgZmFpbFN0YXRlOiAnZGlzY29ubmVjdGVkJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdXNwZW5kZWQ6IHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3N1c3BlbmRlZCcsXG4gICAgICAgICAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHF1ZXVlRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZXRyeURlbGF5OiB0aW1lb3V0cy5zdXNwZW5kZWRSZXRyeVRpbWVvdXQsXG4gICAgICAgICAgICAgICAgZmFpbFN0YXRlOiAnc3VzcGVuZGVkJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zaW5nOiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdjbG9zaW5nJyxcbiAgICAgICAgICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcXVldWVFdmVudHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNlbmRFdmVudHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJldHJ5RGVsYXk6IHRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQsXG4gICAgICAgICAgICAgICAgZmFpbFN0YXRlOiAnY2xvc2VkJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZWQ6IHsgc3RhdGU6ICdjbG9zZWQnLCB0ZXJtaW5hbDogdHJ1ZSwgcXVldWVFdmVudHM6IGZhbHNlLCBzZW5kRXZlbnRzOiBmYWxzZSwgZmFpbFN0YXRlOiAnY2xvc2VkJyB9LFxuICAgICAgICAgICAgZmFpbGVkOiB7IHN0YXRlOiAnZmFpbGVkJywgdGVybWluYWw6IHRydWUsIHF1ZXVlRXZlbnRzOiBmYWxzZSwgc2VuZEV2ZW50czogZmFsc2UsIGZhaWxTdGF0ZTogJ2ZhaWxlZCcgfSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSBfdGhpcy5zdGF0ZXMuaW5pdGlhbGl6ZWQ7XG4gICAgICAgIF90aGlzLmVycm9yUmVhc29uID0gbnVsbDtcbiAgICAgICAgX3RoaXMucXVldWVkTWVzc2FnZXMgPSBuZXcgbWVzc2FnZXF1ZXVlXzEuZGVmYXVsdCgpO1xuICAgICAgICBfdGhpcy5tc2dTZXJpYWwgPSAwO1xuICAgICAgICBfdGhpcy5jb25uZWN0aW9uRGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMuY29ubmVjdGlvbklkID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5jb25uZWN0aW9uS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5jb25uZWN0aW9uU3RhdGVUdGwgPSB0aW1lb3V0cy5jb25uZWN0aW9uU3RhdGVUdGw7XG4gICAgICAgIF90aGlzLm1heElkbGVJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIF90aGlzLnRyYW5zcG9ydHMgPSBVdGlscy5pbnRlcnNlY3Qob3B0aW9ucy50cmFuc3BvcnRzIHx8IGRlZmF1bHRzXzEuZGVmYXVsdC5kZWZhdWx0VHJhbnNwb3J0cywgQ29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0cyk7XG4gICAgICAgIC8qIGJhc2VUcmFuc3BvcnRzIHNlbGVjdHMgdGhlIGxlZnRtb3N0IHRyYW5zcG9ydCBpbiB0aGUgRGVmYXVsdHMuYmFzZVRyYW5zcG9ydE9yZGVyIGxpc3RcbiAgICAgICAgICogdGhhdCdzIGJvdGggcmVxdWVzdGVkIGFuZCBzdXBwb3J0ZWQuIE5vcm1hbGx5IHRoaXMgd2lsbCBiZSB4aHJfcG9sbGluZztcbiAgICAgICAgICogaWYgeGhyIGlzbid0IHN1cHBvcnRlZCBpdCB3aWxsIGJlIGpzb25wLiBJZiB0aGUgdXNlciBoYXMgZm9yY2VkIGFcbiAgICAgICAgICogdHJhbnNwb3J0LCBpdCdsbCBqdXN0IGJlIHRoYXQgb25lLiAqL1xuICAgICAgICBfdGhpcy5iYXNlVHJhbnNwb3J0ID0gVXRpbHMuaW50ZXJzZWN0KGRlZmF1bHRzXzEuZGVmYXVsdC5iYXNlVHJhbnNwb3J0T3JkZXIsIF90aGlzLnRyYW5zcG9ydHMpWzBdO1xuICAgICAgICBfdGhpcy51cGdyYWRlVHJhbnNwb3J0cyA9IFV0aWxzLmludGVyc2VjdChfdGhpcy50cmFuc3BvcnRzLCBkZWZhdWx0c18xLmRlZmF1bHQudXBncmFkZVRyYW5zcG9ydHMpO1xuICAgICAgICBfdGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gbnVsbDtcbiAgICAgICAgX3RoaXMuaHR0cEhvc3RzID0gZGVmYXVsdHNfMS5kZWZhdWx0LmdldEhvc3RzKG9wdGlvbnMpO1xuICAgICAgICBfdGhpcy5hY3RpdmVQcm90b2NvbCA9IG51bGw7XG4gICAgICAgIF90aGlzLnByb3Bvc2VkVHJhbnNwb3J0cyA9IFtdO1xuICAgICAgICBfdGhpcy5wZW5kaW5nVHJhbnNwb3J0cyA9IFtdO1xuICAgICAgICBfdGhpcy5ob3N0ID0gbnVsbDtcbiAgICAgICAgX3RoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ID0gbnVsbDtcbiAgICAgICAgX3RoaXMubGFzdEFjdGl2aXR5ID0gbnVsbDtcbiAgICAgICAgX3RoaXMuZm9yY2VGYWxsYmFja0hvc3QgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuY29ubmVjdENvdW50ZXIgPSAwO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCAnc3RhcnRlZCcpO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCAncmVxdWVzdGVkIHRyYW5zcG9ydHMgPSBbJyArIChvcHRpb25zLnRyYW5zcG9ydHMgfHwgZGVmYXVsdHNfMS5kZWZhdWx0LmRlZmF1bHRUcmFuc3BvcnRzKSArICddJyk7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKScsICdhdmFpbGFibGUgdHJhbnNwb3J0cyA9IFsnICsgX3RoaXMudHJhbnNwb3J0cyArICddJyk7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKScsICdodHRwIGhvc3RzID0gWycgKyBfdGhpcy5odHRwSG9zdHMgKyAnXScpO1xuICAgICAgICBpZiAoIV90aGlzLnRyYW5zcG9ydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ25vIHJlcXVlc3RlZCB0cmFuc3BvcnRzIGF2YWlsYWJsZSc7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ3JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCBtc2cpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmFkZEV2ZW50TGlzdGVuZXI7XG4gICAgICAgIGlmIChhZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAvKiBpbnRlcmNlcHQgY2xvc2UgZXZlbnQgaW4gYnJvd3NlciB0byBwZXJzaXN0IGNvbm5lY3Rpb24gaWQgaWYgcmVxdWVzdGVkICovXG4gICAgICAgICAgICBpZiAoaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgdHlwZW9mIG9wdGlvbnMucmVjb3ZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8qIFVzdWFsbHkgY2FuJ3QgdXNlIGJpbmQgYXMgbm90IHN1cHBvcnRlZCBpbiBJRTgsIGJ1dCBJRSBkb2Vzbid0IHN1cHBvcnQgc2Vzc2lvblN0b3JhZ2UsIHNvLi4uICovXG4gICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgX3RoaXMucGVyc2lzdENvbm5lY3Rpb24uYmluZChfdGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2xvc2VPblVubG9hZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUFKT1IsICdSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpJywgJ2JlZm9yZXVubG9hZCBldmVudCBoYXMgdHJpZ2dlcmVkIHRoZSBjb25uZWN0aW9uIHRvIGNsb3NlIGFzIGNsb3NlT25VbmxvYWQgaXMgdHJ1ZScpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogJ2Nsb3NpbmcnIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogTGlzdGVuIGZvciBvbmxpbmUgYW5kIG9mZmxpbmUgZXZlbnRzICovXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlID09IF90aGlzLnN0YXRlcy5kaXNjb25uZWN0ZWQgfHwgX3RoaXMuc3RhdGUgPT0gX3RoaXMuc3RhdGVzLnN1c3BlbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyIGNhdWdodCBicm93c2VyIOKAmG9ubGluZeKAmSBldmVudCcsICdyZWF0dGVtcHRpbmcgY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogJ2Nvbm5lY3RpbmcnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5zdGF0ZSA9PSBfdGhpcy5zdGF0ZXMuY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBSVE4yMGM6IGlmICdvbmxpbmUnIGV2ZW50IHJlY2lldmVkIHdoaWxlIENPTk5FQ1RJTkcsIGFiYW5kb24gY29ubmVjdGlvbiBhdHRlbXB0IGFuZCByZXRyeVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERldGFjaCB0cmFuc3BvcnQgbGlzdGVuZXJzIHRvIGF2b2lkIGNvbm5lY3Rpb24gc3RhdGUgc2lkZSBlZmZlY3RzIGZyb20gY2FsbGluZyBkaXNwb3NlXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQub2ZmKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGFydENvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlID09IF90aGlzLnN0YXRlcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlciBjYXVnaHQgYnJvd3NlciDigJhvZmZsaW5l4oCZIGV2ZW50JywgJ2Rpc2Nvbm5lY3RpbmcgYWN0aXZlIHRyYW5zcG9ydCcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3Qgc3VmZmljaWVudCB0byBqdXN0IGdvIHRvIHRoZSAnZGlzY29ubmVjdGVkJyBzdGF0ZSwgd2FudCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3JjZSBhbGwgdHJhbnNwb3J0cyB0byByZWF0dGVtcHQgdGhlIGNvbm5lY3Rpb24uIFdpbGwgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0cnkuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25uZWN0aW9uTWFuYWdlci5pbml0VHJhbnNwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgKDAsIHdlYnNvY2tldHRyYW5zcG9ydF8xLmRlZmF1bHQpKENvbm5lY3Rpb25NYW5hZ2VyKTtcbiAgICAgICAgVXRpbHMuYXJyRm9yRWFjaChwbGF0Zm9ybV8xLmRlZmF1bHQuVHJhbnNwb3J0cywgZnVuY3Rpb24gKGluaXRGbikge1xuICAgICAgICAgICAgaW5pdEZuKENvbm5lY3Rpb25NYW5hZ2VyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0UGFyYW1zID0gZnVuY3Rpb24gKGhvc3QsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc3BvcnRQYXJhbXModGhpcy5vcHRpb25zLCBob3N0LCBtb2RlLCB0aGlzLmNvbm5lY3Rpb25LZXkpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFRyYW5zcG9ydFBhcmFtcyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZGVjaWRlTW9kZSA9IGZ1bmN0aW9uIChtb2RlQ2IpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jb25uZWN0aW9uS2V5KSB7XG4gICAgICAgICAgICAgICAgbW9kZUNiKCdyZXN1bWUnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLm9wdGlvbnMucmVjb3ZlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBtb2RlQ2IoJ3JlY292ZXInKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVjb3ZlckZuID0gX3RoaXMub3B0aW9ucy5yZWNvdmVyLCBsYXN0U2Vzc2lvbkRhdGEgPSBnZXRTZXNzaW9uUmVjb3ZlckRhdGEoKTtcbiAgICAgICAgICAgIGlmIChsYXN0U2Vzc2lvbkRhdGEgJiYgdHlwZW9mIHJlY292ZXJGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZ2V0VHJhbnNwb3J0UGFyYW1zKCknLCAnQ2FsbGluZyBjbGllbnRPcHRpb25zLXByb3ZpZGVkIHJlY292ZXIgZnVuY3Rpb24gd2l0aCBsYXN0IHNlc3Npb24gZGF0YScpO1xuICAgICAgICAgICAgICAgIHJlY292ZXJGbihsYXN0U2Vzc2lvbkRhdGEsIGZ1bmN0aW9uIChzaG91bGRSZWNvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZWNvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vcHRpb25zLnJlY292ZXIgPSBsYXN0U2Vzc2lvbkRhdGEucmVjb3ZlcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlQ2IoJ3JlY292ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVDYignY2xlYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZGVDYignY2xlYW4nKTtcbiAgICAgICAgfTtcbiAgICAgICAgZGVjaWRlTW9kZShmdW5jdGlvbiAobW9kZSkge1xuICAgICAgICAgICAgdmFyIHRyYW5zcG9ydFBhcmFtcyA9IF90aGlzLmNyZWF0ZVRyYW5zcG9ydFBhcmFtcyhudWxsLCBtb2RlKTtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVjb3ZlcicpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmdldFRyYW5zcG9ydFBhcmFtcygpJywgJ1RyYW5zcG9ydCByZWNvdmVyeSBtb2RlID0gcmVjb3ZlcjsgcmVjb3ZlcnlLZXkgPSAnICsgX3RoaXMub3B0aW9ucy5yZWNvdmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVjb3ZlcnlDb250ZXh0ID0gZGVjb2RlUmVjb3ZlcnlLZXkoX3RoaXMub3B0aW9ucy5yZWNvdmVyKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3ZlcnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1zZ1NlcmlhbCA9IHJlY292ZXJ5Q29udGV4dC5tc2dTZXJpYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5nZXRUcmFuc3BvcnRQYXJhbXMoKScsICdUcmFuc3BvcnQgcGFyYW1zID0gJyArIHRyYW5zcG9ydFBhcmFtcy50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKHRyYW5zcG9ydFBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBjb25uZWN0IHVzaW5nIGEgZ2l2ZW4gdHJhbnNwb3J0XG4gICAgICogQHBhcmFtIHRyYW5zcG9ydFBhcmFtc1xuICAgICAqIEBwYXJhbSBjYW5kaWRhdGUsIHRoZSB0cmFuc3BvcnQgdG8gdHJ5XG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnRyeUFUcmFuc3BvcnQgPSBmdW5jdGlvbiAodHJhbnNwb3J0UGFyYW1zLCBjYW5kaWRhdGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpJywgJ3RyeWluZyAnICsgY2FuZGlkYXRlKTtcbiAgICAgICAgdHJhbnNwb3J0XzEuZGVmYXVsdC50cnlDb25uZWN0KENvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHNbY2FuZGlkYXRlXSwgdGhpcywgdGhpcy5yZWFsdGltZS5hdXRoLCB0cmFuc3BvcnRQYXJhbXMsIGZ1bmN0aW9uICh3cmFwcGVkRXJyLCB0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IF90aGlzLnN0YXRlO1xuICAgICAgICAgICAgaWYgKHN0YXRlID09IF90aGlzLnN0YXRlcy5jbG9zaW5nIHx8IHN0YXRlID09IF90aGlzLnN0YXRlcy5jbG9zZWQgfHwgc3RhdGUgPT0gX3RoaXMuc3RhdGVzLmZhaWxlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KCknLCAnY29ubmVjdGlvbiAnICsgc3RhdGUuc3RhdGUgKyAnIHdoaWxlIHdlIHdlcmUgYXR0ZW1wdGluZyB0aGUgdHJhbnNwb3J0OyBjbG9zaW5nICcgKyB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdyYXBwZWRFcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKScsICd0cmFuc3BvcnQgJyArIGNhbmRpZGF0ZSArICcgJyArIHdyYXBwZWRFcnIuZXZlbnQgKyAnLCBlcnI6ICcgKyB3cmFwcGVkRXJyLmVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIC8qIENvbWV0IHRyYW5zcG9ydCBvbmNvbm5lY3QgdG9rZW4gZXJyb3JzIGNhbiBiZSBkZWFsdCB3aXRoIGhlcmUuXG4gICAgICAgICAgICAgICAgICogV2Vic29ja2V0IG9uZXMgb25seSBoYXBwZW4gYWZ0ZXIgdGhlIHRyYW5zcG9ydCBjbGFpbXMgdG8gYmUgdmlhYmxlLFxuICAgICAgICAgICAgICAgICAqIHNvIGFyZSBkZWFsdCB3aXRoIGFzIG5vbi1vbmNvbm5lY3QgdG9rZW4gZXJyb3JzICovXG4gICAgICAgICAgICAgICAgaWYgKGF1dGhfMS5kZWZhdWx0LmlzVG9rZW5FcnIod3JhcHBlZEVyci5lcnJvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgIShfdGhpcy5lcnJvclJlYXNvbiAmJiBhdXRoXzEuZGVmYXVsdC5pc1Rva2VuRXJyKF90aGlzLmVycm9yUmVhc29uKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXJyb3JSZWFzb24gPSB3cmFwcGVkRXJyLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAvKiByZS1nZXQgYSB0b2tlbiBhbmQgdHJ5IGFnYWluICovXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlYWx0aW1lLmF1dGguX2ZvcmNlTmV3VG9rZW4obnVsbCwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIGNhbmRpZGF0ZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod3JhcHBlZEVyci5ldmVudCA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogRXJyb3IgdGhhdCdzIGZhdGFsIHRvIHRoZSBjb25uZWN0aW9uICovXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6ICdmYWlsZWQnLCBlcnJvcjogd3JhcHBlZEVyci5lcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdyYXBwZWRFcnIuZXZlbnQgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKDAsIGNvbm5lY3Rpb25lcnJvcnNfMS5pc1JldHJpYWJsZSkod3JhcHBlZEVyci5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIEVycm9yIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciB0aGF0IGRvZXMgbm90IGNhbGwgZm9yIHRyeWluZyBhIGZhbGxiYWNrIGhvc3QsIGVnIGEgcmF0ZSBsaW1pdCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogX3RoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlLCBlcnJvcjogd3JhcHBlZEVyci5lcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogRXJyb3Igd2l0aCB0aGF0IHRyYW5zcG9ydCBvbmx5OyBjb250aW51ZSB0cnlpbmcgb3RoZXIgZmFsbGJhY2sgaG9zdHMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKScsICd2aWFibGUgdHJhbnNwb3J0ICcgKyBjYW5kaWRhdGUgKyAnOyBzZXR0aW5nIHBlbmRpbmcnKTtcbiAgICAgICAgICAgIF90aGlzLnNldFRyYW5zcG9ydFBlbmRpbmcodHJhbnNwb3J0LCB0cmFuc3BvcnRQYXJhbXMpO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdHJhbnNwb3J0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBpcyBpbmRpY2F0ZWQgdG8gYmUgdmlhYmxlLCBhbmQgdGhlIENvbm5lY3Rpb25NYW5hZ2VyXG4gICAgICogZXhwZWN0cyB0byBhY3RpdmF0ZSB0aGlzIHRyYW5zcG9ydCBhcyBzb29uIGFzIGl0IGlzIGNvbm5lY3RlZC5cbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0XG4gICAgICogQHBhcmFtIHRyYW5zcG9ydFBhcmFtc1xuICAgICAqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRUcmFuc3BvcnRQZW5kaW5nID0gZnVuY3Rpb24gKHRyYW5zcG9ydCwgdHJhbnNwb3J0UGFyYW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtb2RlID0gdHJhbnNwb3J0UGFyYW1zLm1vZGU7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2V0VHJhbnNwb3J0UGVuZGluZygpJywgJ3RyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQgKyAnOyBtb2RlID0gJyArIG1vZGUpO1xuICAgICAgICBVdGlscy5hcnJEZWxldGVWYWx1ZSh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcbiAgICAgICAgdGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5wdXNoKHRyYW5zcG9ydCk7XG4gICAgICAgIHZhciBvcHRpbWFsVHJhbnNwb3J0ID0gcGxhdGZvcm1fMS5kZWZhdWx0LkRlZmF1bHRzLnRyYW5zcG9ydFByZWZlcmVuY2VPcmRlcltwbGF0Zm9ybV8xLmRlZmF1bHQuRGVmYXVsdHMudHJhbnNwb3J0UHJlZmVyZW5jZU9yZGVyLmxlbmd0aCAtIDFdO1xuICAgICAgICB0cmFuc3BvcnQub25jZSgnY29ubmVjdGVkJywgZnVuY3Rpb24gKGVycm9yLCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PSAndXBncmFkZScgJiYgX3RoaXMuYWN0aXZlUHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICAvKiAgaWYgd3MgYW5kIHhocnMgYXJlIGNvbm5lY3RpbmcgaW4gcGFyYWxsZWwsIGRlbGF5IHhocnMgYWN0aXZhdGlvbiB0byBsZXQgd3MgZ28gYWhlYWQgKi9cbiAgICAgICAgICAgICAgICBpZiAodHJhbnNwb3J0LnNob3J0TmFtZSAhPT0gb3B0aW1hbFRyYW5zcG9ydCAmJlxuICAgICAgICAgICAgICAgICAgICBVdGlscy5hcnJJbihfdGhpcy5nZXRVcGdyYWRlUG9zc2liaWxpdGllcygpLCBvcHRpbWFsVHJhbnNwb3J0KSAmJlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmVQcm90b2NvbCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbihlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgX3RoaXMub3B0aW9ucy50aW1lb3V0cy5wYXJhbGxlbFVwZ3JhZGVEZWxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZhdGVUcmFuc3BvcnQoZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscyk7XG4gICAgICAgICAgICAgICAgLyogYWxsb3cgY29ubmVjdEltcGwgdG8gc3RhcnQgdGhlIHVwZ3JhZGUgcHJvY2VzcyBpZiBuZWVkZWQsIGJ1dCBhbGxvd1xuICAgICAgICAgICAgICAgICAqIG90aGVyIGV2ZW50IGhhbmRsZXJzLCBpbmNsdWRpbmcgYWN0aXZhdGluZyB0aGUgdHJhbnNwb3J0LCB0byBydW4gZmlyc3QgKi9cbiAgICAgICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29ubmVjdEltcGwodHJhbnNwb3J0UGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVjb3ZlcicgJiYgX3RoaXMub3B0aW9ucy5yZWNvdmVyKSB7XG4gICAgICAgICAgICAgICAgLyogQWZ0ZXIgYSBzdWNjZXNzZnVsIHJlY292ZXJ5LCB3ZSB1bnBlcnNpc3QsIGFzIGEgcmVjb3Zlcnkga2V5IGNhbm5vdFxuICAgICAgICAgICAgICAgICAqIGJlIHVzZWQgbW9yZSB0aGFuIG9uY2UgKi9cbiAgICAgICAgICAgICAgICBfdGhpcy5vcHRpb25zLnJlY292ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIF90aGlzLnVucGVyc2lzdENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdHJhbnNwb3J0Lm9uKFsnZGlzY29ubmVjdGVkJywgJ2Nsb3NlZCcsICdmYWlsZWQnXSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBzZWxmLmRlYWN0aXZhdGVUcmFuc3BvcnQodHJhbnNwb3J0LCB0aGlzLmV2ZW50LCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXQoJ3RyYW5zcG9ydC5wZW5kaW5nJywgdHJhbnNwb3J0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGFuIHVwZ3JhZGUgdHJhbnNwb3J0IGlzIGNvbm5lY3RlZCxcbiAgICAgKiB0byBzY2hlZHVsZSB0aGUgYWN0aXZhdGlvbiBvZiB0aGF0IHRyYW5zcG9ydC5cbiAgICAgKiBAcGFyYW0gZXJyb3JcbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0XG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25JZFxuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uRGV0YWlsc1xuICAgICAqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24gPSBmdW5jdGlvbiAoZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY3VycmVudFRyYW5zcG9ydCA9IHRoaXMuYWN0aXZlUHJvdG9jb2wgJiYgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSwgYWJhbmRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBVdGlscy5hcnJEZWxldGVWYWx1ZShfdGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZCAmJiB0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAvKiBUaGlzIGlzIG1vc3QgbGlrZWx5IHRvIGhhcHBlbiBmb3IgdGhlIGRlbGF5ZWQgWEhScywgd2hlbiBYSFJzIGFuZCB3cyBhcmUgc2NoZWR1bGVkIGluIHBhcmFsbGVsKi9cbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnQ3VycmVudCBjb25uZWN0aW9uIHN0YXRlICgnICtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnN0YXRlICtcbiAgICAgICAgICAgICAgICAodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuc3luY2hyb25pemluZyA/ICcsIGJ1dCB3aXRoIGFuIHVwZ3JhZGUgYWxyZWFkeSBpbiBwcm9ncmVzcycgOiAnJykgK1xuICAgICAgICAgICAgICAgICcpIGlzIG5vdCB2YWxpZCB0byB1cGdyYWRlIGluOyBhYmFuZG9uaW5nIHVwZ3JhZGUgdG8gJyArXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNob3J0TmFtZSk7XG4gICAgICAgICAgICBhYmFuZG9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRUcmFuc3BvcnQgJiYgIWJldHRlclRyYW5zcG9ydFRoYW4odHJhbnNwb3J0LCBjdXJyZW50VHJhbnNwb3J0KSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdQcm9wb3NlZCB0cmFuc3BvcnQgJyArXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNob3J0TmFtZSArXG4gICAgICAgICAgICAgICAgJyBpcyBubyBiZXR0ZXIgdGhhbiBjdXJyZW50IGFjdGl2ZSB0cmFuc3BvcnQgJyArXG4gICAgICAgICAgICAgICAgY3VycmVudFRyYW5zcG9ydC5zaG9ydE5hbWUgK1xuICAgICAgICAgICAgICAgICcgLSBhYmFuZG9uaW5nIHVwZ3JhZGUnKTtcbiAgICAgICAgICAgIGFiYW5kb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1NjaGVkdWxpbmcgdHJhbnNwb3J0IHVwZ3JhZGU7IHRyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuICAgICAgICB2YXIgb2xkUHJvdG9jb2wgPSBudWxsO1xuICAgICAgICBpZiAoIXRyYW5zcG9ydC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgLyogVGhpcyBpcyBvbmx5IHBvc3NpYmxlIGlmIHRoZSB4aHIgc3RyZWFtaW5nIHRyYW5zcG9ydCB3YXMgZGlzY29ubmVjdGVkIGR1cmluZyB0aGUgcGFyYWxsZWxVcGdyYWRlRGVsYXkgKi9cbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnUHJvcG9zZWQgdHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQuc2hvcnROYW1lICsgJ2lzIG5vIGxvbmdlciBjb25uZWN0ZWQ7IGFiYW5kb25pbmcgdXBncmFkZScpO1xuICAgICAgICAgICAgYWJhbmRvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnQ3VycmVudGx5IGNvbm5lY3RlZCwgc28gdGVtcG9yYXJpbHkgcGF1c2luZyBldmVudHMgdW50aWwgdGhlIHVwZ3JhZGUgaXMgY29tcGxldGUnKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nO1xuICAgICAgICAgICAgb2xkUHJvdG9jb2wgPSB0aGlzLmFjdGl2ZVByb3RvY29sO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgIC8qIE5vdGU6IHVwZ3JhZGluZyBmcm9tIHRoZSBjb25uZWN0aW5nIHN0YXRlIGlzIHZhbGlkIGlmIHRoZSBvbGQgYWN0aXZlXG4gICAgICAgICAgICAgKiB0cmFuc3BvcnQgd2FzIGRlYWN0aXZhdGVkIGFmdGVyIHRoZSB1cGdyYWRlIHRyYW5zcG9ydCBmaXJzdCBjb25uZWN0ZWQ7XG4gICAgICAgICAgICAgKiBzZWUgbG9naWMgaW4gZGVhY3RpdmF0ZVRyYW5zcG9ydCAqL1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdDdXJyZW50IGNvbm5lY3Rpb24gc3RhdGUgKCcgK1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhdGUgK1xuICAgICAgICAgICAgICAgICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nID8gJywgYnV0IHdpdGggYW4gdXBncmFkZSBhbHJlYWR5IGluIHByb2dyZXNzJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgJykgaXMgbm90IHZhbGlkIHRvIHVwZ3JhZGUgaW47IGFiYW5kb25pbmcgdXBncmFkZSB0byAnICtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc2hvcnROYW1lKTtcbiAgICAgICAgICAgIGFiYW5kb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1N5bmNpbmcgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgdmFyIGZpbmlzaFVwZ3JhZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ0FjdGl2YXRpbmcgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIC8vIFNlbmQgQUNUSVZBVEUgdG8gdGVsbCB0aGUgc2VydmVyIHRvIG1ha2UgdGhpcyB0cmFuc3BvcnQgdGhlXG4gICAgICAgICAgICAvLyBhY3RpdmUgdHJhbnNwb3J0LCB3aGljaCBzdXNwZW5kcyBjaGFubmVscyB1bnRpbCB3ZSByZS1hdHRhY2guXG4gICAgICAgICAgICB0cmFuc3BvcnQuc2VuZChwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9ucy5BQ1RJVkFURSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIF90aGlzLmFjdGl2YXRlVHJhbnNwb3J0KGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMpO1xuICAgICAgICAgICAgLyogUmVzdG9yZSBwcmUtc3luYyBzdGF0ZS4gSWYgc3RhdGUgaGFzIGNoYW5nZWQgaW4gdGhlIG1lYW50aW1lLFxuICAgICAgICAgICAgICogZG9uJ3QgdG91Y2ggaXQgLS0gc2luY2UgdGhlIHdlYnNvY2tldCB0cmFuc3BvcnQgd2FpdHMgYSB0aWNrIGJlZm9yZVxuICAgICAgICAgICAgICogZGlzcG9zaW5nIGl0c2VsZiwgaXQncyBwb3NzaWJsZSBmb3IgaXQgdG8gaGF2ZSBoYXBwaWx5IHN5bmNlZFxuICAgICAgICAgICAgICogd2l0aG91dCBlcnIgd2hpbGUsIHVua25vd24gdG8gaXQsIHRoZSBjb25uZWN0aW9uIGhhcyBjbG9zZWQgaW4gdGhlXG4gICAgICAgICAgICAgKiBtZWFudGltZSBhbmQgdGhlIHdzIHRyYW5zcG9ydCBpcyBzY2hlZHVsZWQgZm9yIGRlYXRoICovXG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUgPT09IF90aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdQcmUtdXBncmFkZSBwcm90b2NvbCBpZGxlLCBzZW5kaW5nIHF1ZXVlZCBtZXNzYWdlcyBvbiB1cGdyYWRlZCB0cmFuc3BvcnQ7IHRyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gX3RoaXMuc3RhdGVzLmNvbm5lY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnUHJlLXVwZ3JhZGUgcHJvdG9jb2wgaWRsZSwgYnV0IHN0YXRlIGlzIG5vdyAnICsgX3RoaXMuc3RhdGUuc3RhdGUgKyAnLCBzbyBsZWF2aW5nIHVuY2hhbmdlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZW5kUXVldWVkTWVzc2FnZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyogV2FpdCB1bnRpbCBzeW5jIGlzIGRvbmUgYW5kIG9sZCB0cmFuc3BvcnQgaXMgaWRsZSBiZWZvcmUgYWN0aXZhdGluZyBuZXcgdHJhbnNwb3J0LiBUaGlzXG4gICAgICAgICAqIGd1YXJhbnRlZXMgdGhhdCBtZXNzYWdlcyBhcnJpdmUgYXQgcmVhbHRpbWUgaW4gdGhlIHNhbWUgb3JkZXIgdGhleSBhcmUgc2VudC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYSBtZXNzYWdlIHRpbWVzIG91dCBvbiB0aGUgb2xkIHRyYW5zcG9ydCwgc2luY2UgaXQncyBzdGlsbCB0aGUgYWN0aXZlIHRyYW5zcG9ydCB0aGVcbiAgICAgICAgICogbWVzc2FnZSB3aWxsIGJlIHJlcXVldWVkLiBkZWFjdGl2YXRlVHJhbnNwb3J0IHdpbGwgc2VlIHRoZSBwZW5kaW5nIHRyYW5zcG9ydCBhbmQgbm90aWZ5XG4gICAgICAgICAqIHRoZSBgY29ubmVjdGluZ2Agc3RhdGUgd2l0aG91dCBzdGFydGluZyBhIG5ldyBjb25uZWN0aW9uLCBzbyB0aGUgbmV3IHRyYW5zcG9ydCBjYW4gdGFrZVxuICAgICAgICAgKiBvdmVyIG9uY2UgZGVhY3RpdmF0ZVRyYW5zcG9ydCBjbGVhcnMgdGhlIG9sZCBwcm90b2NvbCdzIHF1ZXVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGVyZSBpcyBubyBvbGQgcHJvdG9jb2wsIHRoYXQgbWVhbnQgdGhhdCB3ZSB3ZXJlbid0IGluIHRoZSBjb25uZWN0ZWQgc3RhdGUgYXQgdGhlXG4gICAgICAgICAqIGJlZ2lubmluZyBvZiB0aGUgc3luYyAtIGxpa2VseSB0aGUgYmFzZSB0cmFuc3BvcnQgZGllZCBqdXN0IGJlZm9yZSB0aGUgc3luYy4gU28gY2FuIGp1c3RcbiAgICAgICAgICogZmluaXNoIHRoZSB1cGdyYWRlLiBJZiB3ZSdyZSBhY3R1YWxseSBpbiBjbG9zaW5nL2ZhaWxlZCByYXRoZXIgdGhhbiBjb25uZWN0aW5nLCB0aGF0J3NcbiAgICAgICAgICogZmluZSwgYWN0aXZhdGV0cmFuc3BvcnQgd2lsbCBkZWFsIHdpdGggdGhhdC4gKi9cbiAgICAgICAgaWYgKG9sZFByb3RvY29sKSB7XG4gICAgICAgICAgICAvKiBNb3N0IG9mIHRoZSB0aW1lIHRoaXMgd2lsbCBiZSBhbHJlYWR5IHRydWU6IHRoZSBuZXctdHJhbnNwb3J0IHN5bmMgd2lsbCBoYXZlIGdpdmVuXG4gICAgICAgICAgICAgKiBlbm91Z2ggdGltZSBmb3IgaW4tZmxpZ2h0IG1lc3NhZ2VzIG9uIHRoZSBvbGQgdHJhbnNwb3J0IHRvIGNvbXBsZXRlLiAqL1xuICAgICAgICAgICAgb2xkUHJvdG9jb2wub25jZUlkbGUoZmluaXNoVXBncmFkZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaW5pc2hVcGdyYWRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGlzIGNvbm5lY3RlZCwgYW5kIHRoZSBjb25uZWN0aW9ubWFuYWdlciBkZWNpZGVzIHRoYXRcbiAgICAgKiBpdCB3aWxsIG5vdyBiZSB0aGUgYWN0aXZlIHRyYW5zcG9ydC4gUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBpdCBhY3RpdmF0ZWRcbiAgICAgKiB0aGUgdHJhbnNwb3J0IChpZiB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nL2Nsb3NlZCBpdCB3aWxsIGNob29zZSBub3QgdG8pLlxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnQgdGhlIHRyYW5zcG9ydCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uSWQgdGhlIGlkIG9mIHRoZSBuZXcgYWN0aXZlIGNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbkRldGFpbHMgdGhlIGRldGFpbHMgb2YgdGhlIG5ldyBhY3RpdmUgY29ubmVjdGlvblxuICAgICAqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5hY3RpdmF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICd0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnZXJyb3IgPSAnICsgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0aW9uSWQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdjb25uZWN0aW9uSWQgPSAgJyArIGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnY29ubmVjdGlvbkRldGFpbHMgPSAgJyArIEpTT04uc3RyaW5naWZ5KGNvbm5lY3Rpb25EZXRhaWxzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSh0cmFuc3BvcnQpO1xuICAgICAgICAvKiBpZiB0aGUgY29ubmVjdGlvbm1hbmFnZXIgbW92ZWQgdG8gdGhlIGNsb3NpbmcvY2xvc2VkIHN0YXRlIGJlZm9yZSB0aGlzXG4gICAgICAgICAqIGNvbm5lY3Rpb24gZXZlbnQsIHRoZW4gd2Ugd29uJ3QgYWN0aXZhdGUgdGhpcyB0cmFuc3BvcnQgKi9cbiAgICAgICAgdmFyIGV4aXN0aW5nU3RhdGUgPSB0aGlzLnN0YXRlLCBjb25uZWN0ZWRTdGF0ZSA9IHRoaXMuc3RhdGVzLmNvbm5lY3RlZC5zdGF0ZTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ2N1cnJlbnQgc3RhdGUgPSAnICsgZXhpc3RpbmdTdGF0ZS5zdGF0ZSk7XG4gICAgICAgIGlmIChleGlzdGluZ1N0YXRlLnN0YXRlID09IHRoaXMuc3RhdGVzLmNsb3Npbmcuc3RhdGUgfHxcbiAgICAgICAgICAgIGV4aXN0aW5nU3RhdGUuc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY2xvc2VkLnN0YXRlIHx8XG4gICAgICAgICAgICBleGlzdGluZ1N0YXRlLnN0YXRlID09IHRoaXMuc3RhdGVzLmZhaWxlZC5zdGF0ZSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ0Rpc2Nvbm5lY3RpbmcgdHJhbnNwb3J0IGFuZCBhYmFuZG9uaW5nJyk7XG4gICAgICAgICAgICB0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qIHJlbW92ZSB0aGlzIHRyYW5zcG9ydCBmcm9tIHBlbmRpbmcgdHJhbnNwb3J0cyAqL1xuICAgICAgICBVdGlscy5hcnJEZWxldGVWYWx1ZSh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xuICAgICAgICAvKiBpZiB0aGUgdHJhbnNwb3J0IGlzIG5vdCBjb25uZWN0ZWQgdGhlbiBkb24ndCBhY3RpdmF0ZSBpdCAqL1xuICAgICAgICBpZiAoIXRyYW5zcG9ydC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ0RlY2xpbmluZyB0byBhY3RpdmF0ZSB0cmFuc3BvcnQgJyArIHRyYW5zcG9ydCArICcgc2luY2UgaXQgYXBwZWFycyB0byBubyBsb25nZXIgYmUgY29ubmVjdGVkJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyogdGhlIGdpdmVuIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQ7IHRoaXMgd2lsbCBpbW1lZGlhdGVseVxuICAgICAgICAgKiB0YWtlIG92ZXIgYXMgdGhlIGFjdGl2ZSB0cmFuc3BvcnQgKi9cbiAgICAgICAgdmFyIGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wgPSB0aGlzLmFjdGl2ZVByb3RvY29sO1xuICAgICAgICB0aGlzLmFjdGl2ZVByb3RvY29sID0gbmV3IHByb3RvY29sXzEuZGVmYXVsdCh0cmFuc3BvcnQpO1xuICAgICAgICB0aGlzLmhvc3QgPSB0cmFuc3BvcnQucGFyYW1zLmhvc3Q7XG4gICAgICAgIHZhciBjb25uZWN0aW9uS2V5ID0gY29ubmVjdGlvbkRldGFpbHMuY29ubmVjdGlvbktleTtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25LZXkgJiYgdGhpcy5jb25uZWN0aW9uS2V5ICE9IGNvbm5lY3Rpb25LZXkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCAhIWVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBSZWJyb2FkY2FzdCBhbnkgbmV3IGNvbm5lY3Rpb25EZXRhaWxzIGZyb20gdGhlIGFjdGl2ZSB0cmFuc3BvcnQsIHdoaWNoXG4gICAgICAgICAqIGNhbiBjb21lIGF0IGFueSB0aW1lIChlZyBmb2xsb3dpbmcgYSByZWF1dGgpLCBhbmQgZW1pdCBhbiBSVE4yNCBVUERBVEVcbiAgICAgICAgICogZXZlbnQuIChMaXN0ZW5lciBhZGRlZCBvbiBuZXh0VGljayBiZWNhdXNlIHdlJ3JlIGluIGEgdHJhbnNwb3J0Lm9uKCdjb25uZWN0ZWQnKVxuICAgICAgICAgKiBjYWxsYmFjayBhdCB0aGUgbW9tZW50OyBpZiB3ZSBhZGQgaXQgbm93IHdlJ2xsIGJlIGFkZGluZyBpdCB0byB0aGUgZW5kXG4gICAgICAgICAqIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkgYW5kIGl0J2xsIGJlIGNhbGxlZCBpbW1lZGlhdGVseSkgKi9cbiAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpO1xuICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5vbignY29ubmVjdGVkJywgZnVuY3Rpb24gKGNvbm5lY3RlZEVyciwgX2Nvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3VwZGF0ZScsIG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfMS5kZWZhdWx0KGNvbm5lY3RlZFN0YXRlLCBjb25uZWN0ZWRTdGF0ZSwgbnVsbCwgY29ubmVjdGVkRXJyKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qIElmIHByZXZpb3VzbHkgbm90IGNvbm5lY3RlZCwgbm90aWZ5IHRoZSBzdGF0ZSBjaGFuZ2UgKGluY2x1ZGluZyBhbnlcbiAgICAgICAgICogZXJyb3IpLiAqL1xuICAgICAgICBpZiAoZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvKiBpZiB1cGdyYWRpbmcgd2l0aG91dCBlcnJvciwgbGVhdmUgYW55IGV4aXN0aW5nIGVycm9yUmVhc29uIGFsb25lICovXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgICAgICAgIC8qIE9ubHkgYm90aGVyIGVtaXR0aW5nIGFuIHVwZ3JhZGUgaWYgdGhlcmUncyBhbiBlcnJvcjsgb3RoZXJ3aXNlIGl0J3NcbiAgICAgICAgICAgICAgICAgKiBqdXN0IGEgdHJhbnNwb3J0IHVwZ3JhZGUsIHNvIGF1dGggZGV0YWlscyB3b24ndCBoYXZlIGNoYW5nZWQgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfMS5kZWZhdWx0KGNvbm5lY3RlZFN0YXRlLCBjb25uZWN0ZWRTdGF0ZSwgbnVsbCwgZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogJ2Nvbm5lY3RlZCcsIGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JSZWFzb24gPSB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uZXJyb3JSZWFzb24gPSBlcnJvciB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qIFNlbmQgYWZ0ZXIgdGhlIGNvbm5lY3Rpb24gc3RhdGUgdXBkYXRlLCBhcyBDaGFubmVscyBob29rcyBpbnRvIHRoaXMgdG9cbiAgICAgICAgICogcmVzZW5kIGF0dGFjaGVzIG9uIGEgbmV3IHRyYW5zcG9ydCBpZiBuZWNlc3NhcnkgKi9cbiAgICAgICAgdGhpcy5lbWl0KCd0cmFuc3BvcnQuYWN0aXZlJywgdHJhbnNwb3J0KTtcbiAgICAgICAgLyogR3JhY2VmdWxseSB0ZXJtaW5hdGUgZXhpc3RpbmcgcHJvdG9jb2wgKi9cbiAgICAgICAgaWYgKGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wpIHtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0FjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpID4gMCkge1xuICAgICAgICAgICAgICAgIC8qIFdlIGNvdWxkIGp1c3QgcmVxdWV1ZSBwZW5kaW5nIG1lc3NhZ2VzIG9uIHRoZSBuZXcgdHJhbnNwb3J0LCBidXRcbiAgICAgICAgICAgICAgICAgKiBhY3R1YWxseSB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW46IHRyYW5zcG9ydHMgc2hvdWxkIG9ubHkgdGFrZSBvdmVyXG4gICAgICAgICAgICAgICAgICogZnJvbSBvdGhlciBhY3RpdmUgdHJhbnNwb3J0cyB3aGVuIHVwZ3JhZGluZywgYW5kIHVwZ3JhZGluZyB3YWl0cyBmb3JcbiAgICAgICAgICAgICAgICAgKiB0aGUgb2xkIHRyYW5zcG9ydCB0byBiZSBpZGxlLiBTbyBsb2cgYW4gZXJyb3IuICovXG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ1ByZXZpb3VzIGFjdGl2ZSBwcm90b2NvbCAoZm9yIHRyYW5zcG9ydCAnICtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdBY3RpdmVQcm90b2NvbC50cmFuc3BvcnQuc2hvcnROYW1lICtcbiAgICAgICAgICAgICAgICAgICAgJywgbmV3IG9uZSBpcyAnICtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNob3J0TmFtZSArXG4gICAgICAgICAgICAgICAgICAgICcpIGZpbmlzaGluZyB3aXRoICcgK1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0FjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpICtcbiAgICAgICAgICAgICAgICAgICAgJyBtZXNzYWdlcyBzdGlsbCBwZW5kaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdBY3RpdmVQcm90b2NvbC50cmFuc3BvcnQgPT09IHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnQXNzdW1wdGlvbiB2aW9sYXRlZDogYWN0aXZhdGluZyBhIHRyYW5zcG9ydCB0aGF0IHdhcyBhbHNvIHRoZSB0cmFuc3BvcnQgZm9yIHRoZSBwcmV2aW91cyBhY3RpdmUgcHJvdG9jb2w7IHRyYW5zcG9ydCA9ICcgK1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc2hvcnROYW1lICtcbiAgICAgICAgICAgICAgICAgICAgJzsgc3RhY2sgPSAnICtcbiAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wuZmluaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogVGVybWluYXRlIGFueSBvdGhlciBwZW5kaW5nIHRyYW5zcG9ydChzKSwgYW5kXG4gICAgICAgICAqIGFib3J0IGFueSBub3QteWV0LXBlbmRpbmcgdHJhbnNwb3J0IGF0dGVtcHRzICovXG4gICAgICAgIFV0aWxzLnNhZmVBcnJGb3JFYWNoKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIGZ1bmN0aW9uIChwZW5kaW5nVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBpZiAocGVuZGluZ1RyYW5zcG9ydCA9PT0gdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdBc3N1bXB0aW9uIHZpb2xhdGVkOiBhY3RpdmF0aW5nIGEgdHJhbnNwb3J0IHRoYXQgaXMgc3RpbGwgbWFya2VkIGFzIGEgcGVuZGluZyB0cmFuc3BvcnQ7IHRyYW5zcG9ydCA9ICcgK1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc2hvcnROYW1lICtcbiAgICAgICAgICAgICAgICAgICAgJzsgc3RhY2sgPSAnICtcbiAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgbXNnKTtcbiAgICAgICAgICAgICAgICBVdGlscy5hcnJEZWxldGVWYWx1ZShfdGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdUcmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgVXRpbHMuc2FmZUFyckZvckVhY2godGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMsIGZ1bmN0aW9uIChwcm9wb3NlZFRyYW5zcG9ydCkge1xuICAgICAgICAgICAgaWYgKHByb3Bvc2VkVHJhbnNwb3J0ID09PSB0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnQXNzdW1wdGlvbiB2aW9sYXRlZDogYWN0aXZhdGluZyBhIHRyYW5zcG9ydCB0aGF0IGlzIHN0aWxsIG1hcmtlZCBhcyBhIHByb3Bvc2VkIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zaG9ydE5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAnOyBzdGFjayA9ICcgK1xuICAgICAgICAgICAgICAgICAgICBuZXcgRXJyb3IoKS5zdGFjayk7XG4gICAgICAgICAgICAgICAgVXRpbHMuYXJyRGVsZXRlVmFsdWUoX3RoaXMucHJvcG9zZWRUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcG9zZWRUcmFuc3BvcnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBpcyBubyBsb25nZXIgdGhlIGFjdGl2ZSB0cmFuc3BvcnQuIFRoaXMgY2FuIG9jY3VyXG4gICAgICogaW4gYW55IHRyYW5zcG9ydCBjb25uZWN0aW9uIHN0YXRlLlxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnRcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGVhY3RpdmF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uICh0cmFuc3BvcnQsIHN0YXRlLCBlcnJvcikge1xuICAgICAgICB2YXIgY3VycmVudFByb3RvY29sID0gdGhpcy5hY3RpdmVQcm90b2NvbCwgd2FzQWN0aXZlID0gY3VycmVudFByb3RvY29sICYmIGN1cnJlbnRQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSA9PT0gdHJhbnNwb3J0LCB3YXNQZW5kaW5nID0gVXRpbHMuYXJyRGVsZXRlVmFsdWUodGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KSwgd2FzUHJvcG9zZWQgPSBVdGlscy5hcnJEZWxldGVWYWx1ZSh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cywgdHJhbnNwb3J0KSwgbm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbiA9IHRoaXMubm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbigpO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICd0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KCknLCAnc3RhdGUgPSAnICtcbiAgICAgICAgICAgIHN0YXRlICtcbiAgICAgICAgICAgICh3YXNBY3RpdmUgPyAnOyB3YXMgYWN0aXZlJyA6IHdhc1BlbmRpbmcgPyAnOyB3YXMgcGVuZGluZycgOiB3YXNQcm9wb3NlZCA/ICc7IHdhcyBwcm9wb3NlZCcgOiAnJykgK1xuICAgICAgICAgICAgKG5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24gPyAnJyA6ICc7IGFub3RoZXIgdHJhbnNwb3J0IGlzIHNjaGVkdWxlZCBmb3IgYWN0aXZhdGlvbicpKTtcbiAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICdyZWFzb24gPSAgJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBpZiAod2FzQWN0aXZlKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICdHZXR0aW5nLCBjbGVhcmluZywgYW5kIHJlcXVldWluZyAnICtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpICtcbiAgICAgICAgICAgICAgICAnIHBlbmRpbmcgbWVzc2FnZXMnKTtcbiAgICAgICAgICAgIHRoaXMucXVldWVQZW5kaW5nTWVzc2FnZXMoY3VycmVudFByb3RvY29sLmdldFBlbmRpbmdNZXNzYWdlcygpKTtcbiAgICAgICAgICAgIC8qIENsZWFyIGFueSBtZXNzYWdlcyB3ZSByZXF1ZXVlIHRvIGFsbG93IHRoZSBwcm90b2NvbCB0byBiZWNvbWUgaWRsZS5cbiAgICAgICAgICAgICAqIEluIGNhc2Ugb2YgYW4gdXBncmFkZSwgdGhpcyB3aWxsIHRyaWdnZXIgYW4gaW1tZWRpYXRlIGFjdGl2YXRpb24gb2ZcbiAgICAgICAgICAgICAqIHRoZSB1cGdyYWRlIHRyYW5zcG9ydCwgc28gZGVsYXkgYSB0aWNrIHNvIHRoaXMgdHJhbnNwb3J0IGNhbiBmaW5pc2hcbiAgICAgICAgICAgICAqIGRlYWN0aXZhdGluZyAqL1xuICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFByb3RvY29sLmNsZWFyUGVuZGluZ01lc3NhZ2VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wgPSB0aGlzLmhvc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgndHJhbnNwb3J0LmluYWN0aXZlJywgdHJhbnNwb3J0KTtcbiAgICAgICAgLyogdGhpcyB0cmFuc3BvcnQgc3RhdGUgY2hhbmdlIGlzIGEgc3RhdGUgY2hhbmdlIGZvciB0aGUgY29ubmVjdGlvbm1hbmFnZXIgaWZcbiAgICAgICAgICogLSB0aGUgdHJhbnNwb3J0IHdhcyB0aGUgYWN0aXZlIHRyYW5zcG9ydCBhbmQgdGhlcmUgYXJlIG5vIHRyYW5zcG9ydHNcbiAgICAgICAgICogICB3aGljaCBhcmUgY29ubmVjdGVkIGFuZCBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb24sIGp1c3Qgd2FpdGluZyBmb3IgdGhlXG4gICAgICAgICAqICAgYWN0aXZlIHRyYW5zcG9ydCB0byBmaW5pc2ggd2hhdCBpdHMgZG9pbmc7IG9yXG4gICAgICAgICAqIC0gdGhlIHRyYW5zcG9ydCB3YXMgdGhlIGFjdGl2ZSB0cmFuc3BvcnQgYW5kIHRoZSBlcnJvciB3YXMgZmF0YWwgKHNvXG4gICAgICAgICAqICAgdW5oZWFsYWJsZSBieSBhbm90aGVyIHRyYW5zcG9ydCk7IG9yXG4gICAgICAgICAqIC0gdGhlcmUgaXMgbm8gYWN0aXZlIHRyYW5zcG9ydCwgYW5kIHRoaXMgaXMgdGhlIGxhc3QgcmVtYWluaW5nXG4gICAgICAgICAqICAgcGVuZGluZyB0cmFuc3BvcnQgKHNvIHdlIHdlcmUgaW4gdGhlIGNvbm5lY3Rpbmcgc3RhdGUpXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoKHdhc0FjdGl2ZSAmJiBub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uKSB8fFxuICAgICAgICAgICAgKHdhc0FjdGl2ZSAmJiBzdGF0ZSA9PT0gJ2ZhaWxlZCcpIHx8XG4gICAgICAgICAgICBzdGF0ZSA9PT0gJ2Nsb3NlZCcgfHxcbiAgICAgICAgICAgIChjdXJyZW50UHJvdG9jb2wgPT09IG51bGwgJiYgd2FzUGVuZGluZyAmJiB0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIC8qIElmIHdlJ3JlIGRpc2Nvbm5lY3RlZCB3aXRoIGEgNXh4IHdlIG5lZWQgdG8gdHJ5IGZhbGxiYWNrIGhvc3RzXG4gICAgICAgICAgICAgKiAoUlROMTRkKSwgYnV0IChhKSBkdWUgdG8gaG93IHRoZSB1cGdyYWRlIHNlcXVlbmNlIHdvcmtzLCB0aGVcbiAgICAgICAgICAgICAqIGhvc3QvdHJhbnNwb3J0IHNlbGVjdGlvbiBzZXF1ZW5jZSBvbmx5IGNhcmVzIGFib3V0IGdldHRpbmcgdG9cbiAgICAgICAgICAgICAqIGBwcmVjb25uZWN0YCAoZWcgZXN0YWJsaXNoaW5nIGEgd2Vic29ja2V0KSBnZXR0aW5nIGEgYGRpc2Nvbm5lY3RlZGBcbiAgICAgICAgICAgICAqIHByb3RvY29sIG1lc3NhZ2UgYWZ0ZXJ3YXJkcyBpcyB0b28gbGF0ZTsgYW5kIChiKSBob3N0IHJldHJ5IG9ubHlcbiAgICAgICAgICAgICAqIGFwcGxpZXMgdG8gY29ubmVjdEJhc2UgdW5sZXNzIHRoZSBzdG9yZWQgcHJlZmVyZW5jZSB0cmFuc3BvcnQgZG9lc24ndFxuICAgICAgICAgICAgICogd29yay4gV2Ugc29sdmUgdGhpcyBieSB1bnBlcnNpc3RpbmcgdGhlIHRyYW5zcG9ydCBwcmVmZXJlbmNlIGFuZFxuICAgICAgICAgICAgICogc2V0dGluZyBhbiBpbnN0YW5jZSB2YXJpYWJsZSB0byBmb3JjZSBmYWxsYmFjayBob3N0cyB0byBiZSB1c2VkIChpZlxuICAgICAgICAgICAgICogYW55KSBoZXJlLiBCaXQgb2YgYSBrbHVkZ2UsIGJ1dCBubyByZWFsIGJldHRlciBhbHRlcm5hdGl2ZXMgd2l0aG91dFxuICAgICAgICAgICAgICogcmV3cml0aW5nIHRoZSBlbnRpcmUgdGhpbmcgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgJiYgZXJyb3IgJiYgZXJyb3Iuc3RhdHVzQ29kZSA+IDUwMCAmJiB0aGlzLmh0dHBIb3N0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JjZUZhbGxiYWNrSG9zdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLyogYW5kIHRyeSB0byBjb25uZWN0IGFnYWluIHRvIHRyeSBhIGZhbGxiYWNrIGhvc3Qgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgdXN1YWwgMTVzIGRpc2Nvbm5lY3RlZFJldHJ5VGltZW91dCAqL1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogc3RhdGUsIGVycm9yOiBlcnJvciwgcmV0cnlJbW1lZGlhdGVseTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBUT0RPIHJlbW92ZSBiZWxvdyBsaW5lIG9uY2UgcmVhbHRpbWUgc2VuZHMgdG9rZW4gZXJyb3JzIGFzIERJU0NPTk5FQ1RFRHMgKi9cbiAgICAgICAgICAgIHZhciBuZXdDb25uZWN0aW9uU3RhdGUgPSBzdGF0ZSA9PT0gJ2ZhaWxlZCcgJiYgYXV0aF8xLmRlZmF1bHQuaXNUb2tlbkVycihlcnJvcikgPyAnZGlzY29ubmVjdGVkJyA6IHN0YXRlO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBuZXdDb25uZWN0aW9uU3RhdGUsIGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2FzQWN0aXZlICYmIHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyAmJiB0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nKSB7XG4gICAgICAgICAgICAvKiBJZiB3ZSB3ZXJlIGFjdGl2ZSBidXQgdGhlcmUgaXMgYW5vdGhlciB0cmFuc3BvcnQgc2NoZWR1bGVkIGZvclxuICAgICAgICAgICAgICogYWN0aXZhdGlvbiwgZ28gaW50byB0byB0aGUgY29ubmVjdGluZyBzdGF0ZSB1bnRpbCB0aGF0IHRyYW5zcG9ydFxuICAgICAgICAgICAgICogYWN0aXZhdGVzIGFuZCBzZXRzIHVzIGJhY2sgdG8gY29ubmVjdGVkLiAobWFudWFsbHkgc3RhcnRpbmcgdGhlXG4gICAgICAgICAgICAgKiB0cmFuc2l0aW9uIHRpbWVycyBpbiBjYXNlIHRoYXQgbmV2ZXIgaGFwcGVucykuIChJZiB3ZSB3ZXJlIGluIHRoZVxuICAgICAgICAgICAgICogc3luY2hyb25pemluZyBzdGF0ZSwgdGhlbiB0aGF0J3MgZmluZSwgdGhlIG9sZCB0cmFuc3BvcnQganVzdCBnb3QgaXRzXG4gICAgICAgICAgICAgKiBkaXNjb25uZWN0ZWQgYmVmb3JlIHRoZSBuZXcgb25lIGdvdCB0aGUgc3luYyAtLSBpZ25vcmUgaXQgYW5kIGtlZXBcbiAgICAgICAgICAgICAqIHdhaXRpbmcgZm9yIHRoZSBzeW5jLiBJZiBpdCBmYWlscyB3ZSBoYXZlIGEgc2VwYXJhdGUgc3luYyB0aW1lciB0aGF0XG4gICAgICAgICAgICAgKiB3aWxsIGV4cGlyZSkuICovXG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICd3YXNBY3RpdmUgYnV0IGFub3RoZXIgdHJhbnNwb3J0IGlzIGNvbm5lY3RlZCBhbmQgc2NoZWR1bGVkIGZvciBhY3RpdmF0aW9uLCBzbyBnb2luZyBpbnRvIHRoZSBjb25uZWN0aW5nIHN0YXRlIHVudGlsIGl0IGFjdGl2YXRlcycpO1xuICAgICAgICAgICAgdGhpcy5zdGFydFN1c3BlbmRUaW1lcigpO1xuICAgICAgICAgICAgdGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jb25uZWN0aW5nKTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogJ2Nvbm5lY3RpbmcnLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qIEhlbHBlciB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgbm8gdHJhbnNwb3J0cyB3aGljaCBhcmUgcGVuZGluZyxcbiAgICAgKiBoYXZlIGJlZW4gY29ubmVjdGVkLCBhbmQgYXJlIGp1c3Qgd2FpdGluZyBmb3Igb25jZU5vUGVuZGluZyB0byBmaXJlIGJlZm9yZVxuICAgICAqIGJlaW5nIGFjdGl2YXRlZCAqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5ub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFV0aWxzLmlzRW1wdHkodGhpcy5wZW5kaW5nVHJhbnNwb3J0cykgfHxcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1RyYW5zcG9ydHMuZXZlcnkoZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhdHJhbnNwb3J0LmlzQ29ubmVjdGVkO1xuICAgICAgICAgICAgfSkpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldENvbm5lY3Rpb24gPSBmdW5jdGlvbiAoY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgaGFzQ29ubmVjdGlvbkVycm9yKSB7XG4gICAgICAgIC8qIGlmIGNvbm5lY3Rpb25LZXkgY2hhbmdlcyBidXQgY29ubmVjdGlvbklkIHN0YXlzIHRoZSBzYW1lLCB0aGVuIGp1c3QgYVxuICAgICAgICAgKiB0cmFuc3BvcnQgY2hhbmdlIG9uIHRoZSBzYW1lIGNvbm5lY3Rpb24uIElmIGNvbm5lY3Rpb25JZCBjaGFuZ2VzLCB3ZSdyZVxuICAgICAgICAgKiBvbiBhIG5ldyBjb25uZWN0aW9uLCB3aXRoIGltcGxpY2F0aW9ucyBmb3IgbXNnU2VyaWFsIGFuZCBjaGFubmVsIHN0YXRlICovXG4gICAgICAgIC8qIElmIG5vIHByZXZpb3VzIGNvbm5lY3Rpb25JZCwgZG9uJ3QgcmVzZXQgdGhlIG1zZ1NlcmlhbCBhcyBpdCBtYXkgaGF2ZVxuICAgICAgICAgKiBiZWVuIHNldCBieSByZWNvdmVyIGRhdGEgKHVubGVzcyB0aGUgcmVjb3ZlciBmYWlsZWQpICovXG4gICAgICAgIHZhciBwcmV2Q29ubklkID0gdGhpcy5jb25uZWN0aW9uSWQsIGNvbm5JZENoYW5nZWQgPSBwcmV2Q29ubklkICYmIHByZXZDb25uSWQgIT09IGNvbm5lY3Rpb25JZCwgcmVjb3ZlckZhaWx1cmUgPSAhcHJldkNvbm5JZCAmJiBoYXNDb25uZWN0aW9uRXJyb3I7XG4gICAgICAgIGlmIChjb25uSWRDaGFuZ2VkIHx8IHJlY292ZXJGYWlsdXJlKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb24oKScsICdSZXNldHRpbmcgbXNnU2VyaWFsJyk7XG4gICAgICAgICAgICB0aGlzLm1zZ1NlcmlhbCA9IDA7XG4gICAgICAgICAgICAvLyBSVE4xOWEyOiBJbiB0aGUgZXZlbnQgb2YgYSBuZXcgY29ubmVjdGlvbklkLCBwcmV2aW91cyBtc2dTZXJpYWxzIGFyZVxuICAgICAgICAgICAgLy8gbWVhbmluZ2xlc3MuXG4gICAgICAgICAgICB0aGlzLnF1ZXVlZE1lc3NhZ2VzLnJlc2V0U2VuZEF0dGVtcHRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25JZCAhPT0gY29ubmVjdGlvbklkKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb24oKScsICdOZXcgY29ubmVjdGlvbklkOyByZWF0dGFjaGluZyBhbnkgYXR0YWNoZWQgY2hhbm5lbHMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uaWQgPSB0aGlzLmNvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb25JZDtcbiAgICAgICAgdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmtleSA9IHRoaXMuY29ubmVjdGlvbktleSA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25LZXk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2xlYXJDb25uZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uaWQgPSB0aGlzLmNvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmtleSA9IHRoaXMuY29ubmVjdGlvbktleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tc2dTZXJpYWwgPSAwO1xuICAgICAgICB0aGlzLnVucGVyc2lzdENvbm5lY3Rpb24oKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVSZWNvdmVyeUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUlROMTZnMi5cbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3Rpb25LZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBjb25uZWN0aW9uS2V5OiB0aGlzLmNvbm5lY3Rpb25LZXksXG4gICAgICAgICAgICBtc2dTZXJpYWw6IHRoaXMubXNnU2VyaWFsLFxuICAgICAgICAgICAgY2hhbm5lbFNlcmlhbHM6IHRoaXMucmVhbHRpbWUuY2hhbm5lbHMuY2hhbm5lbFNlcmlhbHMoKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2hlY2tDb25uZWN0aW9uU3RhdGVGcmVzaG5lc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5sYXN0QWN0aXZpdHkgfHwgIXRoaXMuY29ubmVjdGlvbklkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpbmNlTGFzdCA9IFV0aWxzLm5vdygpIC0gdGhpcy5sYXN0QWN0aXZpdHk7XG4gICAgICAgIGlmIChzaW5jZUxhc3QgPiB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCArIHRoaXMubWF4SWRsZUludGVydmFsKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKCknLCAnTGFzdCBrbm93biBhY3Rpdml0eSBmcm9tIHJlYWx0aW1lIHdhcyAnICsgc2luY2VMYXN0ICsgJ21zIGFnbzsgZGlzY2FyZGluZyBjb25uZWN0aW9uIHN0YXRlJyk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUgPSAnc3VzcGVuZGVkJztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbm5lY3Rpb25tYW5hZ2VyIHdhbnRzIHRvIHBlcnNpc3QgdHJhbnNwb3J0XG4gICAgICogc3RhdGUgZm9yIGxhdGVyIHJlY292ZXJ5LiBPbmx5IGFwcGxpY2FibGUgaW4gdGhlIGJyb3dzZXIgY29udGV4dC5cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucGVyc2lzdENvbm5lY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChoYXZlU2Vzc2lvblN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgdmFyIHJlY292ZXJ5S2V5ID0gdGhpcy5jcmVhdGVSZWNvdmVyeUtleSgpO1xuICAgICAgICAgICAgaWYgKHJlY292ZXJ5S2V5KSB7XG4gICAgICAgICAgICAgICAgc2V0U2Vzc2lvblJlY292ZXJEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcnlLZXk6IHJlY292ZXJ5S2V5LFxuICAgICAgICAgICAgICAgICAgICBkaXNjb25uZWN0ZWRBdDogVXRpbHMubm93KCksXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBnbG9iYWwubG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLnJlYWx0aW1lLmF1dGguY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9ubWFuYWdlciB3YW50cyB0byBwZXJzaXN0IHRyYW5zcG9ydFxuICAgICAqIHN0YXRlIGZvciBsYXRlciByZWNvdmVyeS4gT25seSBhcHBsaWNhYmxlIGluIHRoZSBicm93c2VyIGNvbnRleHQuXG4gICAgICovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnVucGVyc2lzdENvbm5lY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyU2Vzc2lvblJlY292ZXJEYXRhKCk7XG4gICAgfTtcbiAgICAvKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogc3RhdGUgbWFuYWdlbWVudFxuICAgICAqKioqKioqKioqKioqKioqKioqKiovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvclJlYXNvbiB8fCB0aGlzLmdldFN0YXRlRXJyb3IoKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRTdGF0ZUVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gY29ubmVjdGlvbmVycm9yc18xLmRlZmF1bHQpW3RoaXMuc3RhdGUuc3RhdGVdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYWN0aXZlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnF1ZXVlRXZlbnRzIHx8IHRoaXMuc3RhdGUuc2VuZEV2ZW50cztcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5lbmFjdFN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKHN0YXRlQ2hhbmdlKSB7XG4gICAgICAgIHZhciBsb2dMZXZlbCA9IHN0YXRlQ2hhbmdlLmN1cnJlbnQgPT09ICdmYWlsZWQnID8gbG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IgOiBsb2dnZXJfMS5kZWZhdWx0LkxPR19NQUpPUjtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nTGV2ZWwsICdDb25uZWN0aW9uIHN0YXRlJywgc3RhdGVDaGFuZ2UuY3VycmVudCArIChzdGF0ZUNoYW5nZS5yZWFzb24gPyAnOyByZWFzb246ICcgKyBzdGF0ZUNoYW5nZS5yZWFzb24gOiAnJykpO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmVuYWN0U3RhdGVDaGFuZ2UnLCAnc2V0dGluZyBuZXcgc3RhdGU6ICcgK1xuICAgICAgICAgICAgc3RhdGVDaGFuZ2UuY3VycmVudCArXG4gICAgICAgICAgICAnOyByZWFzb24gPSAnICtcbiAgICAgICAgICAgIChzdGF0ZUNoYW5nZS5yZWFzb24gJiYgc3RhdGVDaGFuZ2UucmVhc29uLm1lc3NhZ2UpKTtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gKHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlc1tzdGF0ZUNoYW5nZS5jdXJyZW50XSk7XG4gICAgICAgIGlmIChzdGF0ZUNoYW5nZS5yZWFzb24pIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JSZWFzb24gPSBzdGF0ZUNoYW5nZS5yZWFzb247XG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uZXJyb3JSZWFzb24gPSBzdGF0ZUNoYW5nZS5yZWFzb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1N0YXRlLnRlcm1pbmFsIHx8IG5ld1N0YXRlLnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuICAgICAgICAgICAgLyogc3VzcGVuZGVkIGlzIG5vbnRlcm1pbmFsLCBidXQgb25jZSBpbiB0aGUgc3VzcGVuZGVkIHN0YXRlLCByZWFsdGltZVxuICAgICAgICAgICAgICogd2lsbCBoYXZlIGRpc2NhcmRlZCBvdXIgY29ubmVjdGlvbiBzdGF0ZSwgc28gZnV0aGVyIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAqIGF0dGVtcHRzIHNob3VsZCBzdGFydCBmcm9tIHNjcmF0Y2ggKi9cbiAgICAgICAgICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0aW9uc3RhdGUnLCBzdGF0ZUNoYW5nZSk7XG4gICAgfTtcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIENvbm5lY3Rpb25NYW5hZ2VyIGNvbm5lY3Rpb24gbGlmZWN5Y2xlXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnN0YXJ0VHJhbnNpdGlvblRpbWVyID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0VHJhbnNpdGlvblRpbWVyKCknLCAndHJhbnNpdGlvblN0YXRlOiAnICsgdHJhbnNpdGlvblN0YXRlLnN0YXRlKTtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvblRpbWVyKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0VHJhbnNpdGlvblRpbWVyKCknLCAnY2xlYXJpbmcgYWxyZWFkeS1ydW5uaW5nIHRpbWVyJyk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50cmFuc2l0aW9uVGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNpdGlvblRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMudHJhbnNpdGlvblRpbWVyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJhbnNpdGlvblRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyICcgKyB0cmFuc2l0aW9uU3RhdGUuc3RhdGUgKyAnIHRpbWVyIGV4cGlyZWQnLCAncmVxdWVzdGluZyBuZXcgc3RhdGU6ICcgKyB0cmFuc2l0aW9uU3RhdGUuZmFpbFN0YXRlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiB0cmFuc2l0aW9uU3RhdGUuZmFpbFN0YXRlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cmFuc2l0aW9uU3RhdGUucmV0cnlEZWxheSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2FuY2VsVHJhbnNpdGlvblRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNhbmNlbFRyYW5zaXRpb25UaW1lcigpJywgJycpO1xuICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRyYW5zaXRpb25UaW1lcik7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zdGFydFN1c3BlbmRUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuc3VzcGVuZFRpbWVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnN1c3BlbmRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN1c3BlbmRUaW1lcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnN1c3BlbmRUaW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlciBzdXNwZW5kIHRpbWVyIGV4cGlyZWQnLCAncmVxdWVzdGluZyBuZXcgc3RhdGU6IHN1c3BlbmRlZCcpO1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9ICdzdXNwZW5kZWQnO1xuICAgICAgICAgICAgICAgIF90aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6ICdzdXNwZW5kZWQnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2hlY2tTdXNwZW5kVGltZXIgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlICE9PSAnZGlzY29ubmVjdGVkJyAmJiBzdGF0ZSAhPT0gJ3N1c3BlbmRlZCcgJiYgc3RhdGUgIT09ICdjb25uZWN0aW5nJylcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsU3VzcGVuZFRpbWVyKCk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2FuY2VsU3VzcGVuZFRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9ICdkaXNjb25uZWN0ZWQnO1xuICAgICAgICBpZiAodGhpcy5zdXNwZW5kVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnN1c3BlbmRUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnN1c3BlbmRUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zdGFydFJldHJ5VGltZXIgPSBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXRyeVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyIHJldHJ5IHRpbWVyIGV4cGlyZWQnLCAncmV0cnlpbmcnKTtcbiAgICAgICAgICAgIF90aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMucmVxdWVzdFN0YXRlKHsgc3RhdGU6ICdjb25uZWN0aW5nJyB9KTtcbiAgICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNhbmNlbFJldHJ5VGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJldHJ5VGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZXIpO1xuICAgICAgICAgICAgdGhpcy5yZXRyeVRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm5vdGlmeVN0YXRlID0gZnVuY3Rpb24gKGluZGljYXRlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgc3RhdGUgPSBpbmRpY2F0ZWQuc3RhdGU7XG4gICAgICAgIC8qIFdlIHJldHJ5IGltbWVkaWF0ZWx5IGlmOlxuICAgICAgICAgKiAtIHNvbWV0aGluZyBkaXNjb25uZWN0cyB1cyB3aGlsZSB3ZSdyZSBjb25uZWN0ZWQsIG9yXG4gICAgICAgICAqIC0gYSB2aWFibGUgKGJ1dCBub3QgeWV0IGFjdGl2ZSkgdHJhbnNwb3J0IGZhaWxzIGR1ZSB0byBhIHRva2VuIGVycm9yIChzb1xuICAgICAgICAgKiAgIHRoaXMuZXJyb3JSZWFzb24gd2lsbCBiZSBzZXQsIGFuZCBzdGFydENvbm5lY3Qgd2lsbCBkbyBhIGZvcmNlZFxuICAgICAgICAgKiAgIGF1dGhvcml6ZSkuIElmIHRoaXMuZXJyb3JSZWFzb24gaXMgYWxyZWFkeSBzZXQgKHRvIGEgdG9rZW4gZXJyb3IpLFxuICAgICAgICAgKiAgIHRoZW4gdGhlcmUgaGFzIGJlZW4gYXQgbGVhc3Qgb25lIHByZXZpb3VzIGF0dGVtcHQgdG8gY29ubmVjdCB0aGF0IGFsc29cbiAgICAgICAgICogICBmYWlsZWQgZm9yIGEgdG9rZW4gZXJyb3IsIHNvIGJ5IFJUTjE0YiB3ZSBnbyB0byBESVNDT05ORUNURUQgYW5kIHdhaXRcbiAgICAgICAgICogICBiZWZvcmUgdHJ5aW5nIGFnYWluICovXG4gICAgICAgIHZhciByZXRyeUltbWVkaWF0ZWx5ID0gc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnICYmXG4gICAgICAgICAgICAodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuc3luY2hyb25pemluZyB8fFxuICAgICAgICAgICAgICAgIGluZGljYXRlZC5yZXRyeUltbWVkaWF0ZWx5IHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdGVkLmVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIGF1dGhfMS5kZWZhdWx0LmlzVG9rZW5FcnIoaW5kaWNhdGVkLmVycm9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAhKHRoaXMuZXJyb3JSZWFzb24gJiYgYXV0aF8xLmRlZmF1bHQuaXNUb2tlbkVycih0aGlzLmVycm9yUmVhc29uKSkpKTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5ub3RpZnlTdGF0ZSgpJywgJ25ldyBzdGF0ZTogJyArIHN0YXRlICsgKHJldHJ5SW1tZWRpYXRlbHkgPyAnOyB3aWxsIHJldHJ5IGNvbm5lY3Rpb24gaW1tZWRpYXRlbHknIDogJycpKTtcbiAgICAgICAgLyogZG8gbm90aGluZyBpZiB3ZSdyZSBhbHJlYWR5IGluIHRoZSBpbmRpY2F0ZWQgc3RhdGUgKi9cbiAgICAgICAgaWYgKHN0YXRlID09IHRoaXMuc3RhdGUuc3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8qIGtpbGwgdGltZXJzIChwb3NzaWJseSBleGNlcHRpbmcgc3VzcGVuZCB0aW1lciBkZXBlbmRpbmcgb24gdGhlIG5vdGlmaWVkXG4gICAgICAgICAqIHN0YXRlKSwgYXMgdGhlc2UgYXJlIHN1cGVyc2VkZWQgYnkgdGhpcyBub3RpZmljYXRpb24gKi9cbiAgICAgICAgdGhpcy5jYW5jZWxUcmFuc2l0aW9uVGltZXIoKTtcbiAgICAgICAgdGhpcy5jYW5jZWxSZXRyeVRpbWVyKCk7XG4gICAgICAgIHRoaXMuY2hlY2tTdXNwZW5kVGltZXIoaW5kaWNhdGVkLnN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnc3VzcGVuZGVkJyB8fCBzdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdGVkUmV0cnlDb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyogZG8gbm90aGluZyBpZiB3ZSdyZSB1bmFibGUgdG8gbW92ZSBmcm9tIHRoZSBjdXJyZW50IHN0YXRlICovXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnRlcm1pbmFsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKiBwcm9jZXNzIG5ldyBzdGF0ZSAqL1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSB0aGlzLnN0YXRlc1tpbmRpY2F0ZWQuc3RhdGVdO1xuICAgICAgICB2YXIgcmV0cnlEZWxheSA9IG5ld1N0YXRlLnJldHJ5RGVsYXk7XG4gICAgICAgIGlmIChuZXdTdGF0ZS5zdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdGVkUmV0cnlDb3VudCsrO1xuICAgICAgICAgICAgcmV0cnlEZWxheSA9IFV0aWxzLmdldFJldHJ5VGltZShuZXdTdGF0ZS5yZXRyeURlbGF5LCB0aGlzLmRpc2Nvbm5lY3RlZFJldHJ5Q291bnQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFuZ2UgPSBuZXcgY29ubmVjdGlvbnN0YXRlY2hhbmdlXzEuZGVmYXVsdCh0aGlzLnN0YXRlLnN0YXRlLCBuZXdTdGF0ZS5zdGF0ZSwgcmV0cnlEZWxheSwgaW5kaWNhdGVkLmVycm9yIHx8ICgoX2IgPSAoX2EgPSBjb25uZWN0aW9uZXJyb3JzXzEuZGVmYXVsdClbbmV3U3RhdGUuc3RhdGVdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpKTtcbiAgICAgICAgaWYgKHJldHJ5SW1tZWRpYXRlbHkpIHtcbiAgICAgICAgICAgIHZhciBhdXRvUmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZSA9PT0gX3RoaXMuc3RhdGVzLmRpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgPSBVdGlscy5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVxdWVzdFN0YXRlKHsgc3RhdGU6ICdjb25uZWN0aW5nJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHNpbmNlTGFzdCA9IHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ICYmIFV0aWxzLm5vdygpIC0gdGhpcy5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgKyAxO1xuICAgICAgICAgICAgaWYgKHNpbmNlTGFzdCAmJiBzaW5jZUxhc3QgPCAxMDAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5ub3RpZnlTdGF0ZSgpJywgJ0xhc3QgcmVjb25uZWN0IGF0dGVtcHQgd2FzIG9ubHkgJyArXG4gICAgICAgICAgICAgICAgICAgIHNpbmNlTGFzdCArXG4gICAgICAgICAgICAgICAgICAgICdtcyBhZ28sIHdhaXRpbmcgYW5vdGhlciAnICtcbiAgICAgICAgICAgICAgICAgICAgKDEwMDAgLSBzaW5jZUxhc3QpICtcbiAgICAgICAgICAgICAgICAgICAgJ21zIGJlZm9yZSB0cnlpbmcgYWdhaW4nKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGF1dG9SZWNvbm5lY3QsIDEwMDAgLSBzaW5jZUxhc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhhdXRvUmVjb25uZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgfHwgc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UmV0cnlUaW1lcihyZXRyeURlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICAvKiBJZiBnb2luZyBpbnRvIGRpc2Nvbm5lY3Qvc3VzcGVuZGVkIChhbmQgbm90IHJldHJ5aW5nIGltbWVkaWF0ZWx5KSwgb3IgYVxuICAgICAgICAgKiB0ZXJtaW5hbCBzdGF0ZSwgZW5zdXJlIHRoZXJlIGFyZSBubyBvcnBoYW5lZCB0cmFuc3BvcnRzIGhhbmdpbmcgYXJvdW5kLiAqL1xuICAgICAgICBpZiAoKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyAmJiAhcmV0cnlJbW1lZGlhdGVseSkgfHwgc3RhdGUgPT09ICdzdXNwZW5kZWQnIHx8IG5ld1N0YXRlLnRlcm1pbmFsKSB7XG4gICAgICAgICAgICAvKiBXYWl0IHRpbGwgdGhlIG5leHQgdGljayBzbyB0aGUgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2UgaXMgZW5hY3RlZCxcbiAgICAgICAgICAgICAqIHNvIGFib3J0aW5nIHRyYW5zcG9ydHMgZG9lc24ndCB0cmlnZ2VyIHJlZHVuZGFudCBzdGF0ZSBjaGFuZ2VzICovXG4gICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09ICdjb25uZWN0ZWQnICYmICF0aGlzLmFjdGl2ZVByb3RvY29sKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm5vdGlmeVN0YXRlKCknLCAnQnJva2VuIGludmFyaWFudDogYXR0ZW1wdGVkIHRvIGdvIGludG8gY29ubmVjdGVkIHN0YXRlLCBidXQgdGhlcmUgaXMgbm8gYWN0aXZlIHByb3RvY29sJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaW1wbGVtZW50IHRoZSBjaGFuZ2UgYW5kIG5vdGlmeSAqL1xuICAgICAgICB0aGlzLmVuYWN0U3RhdGVDaGFuZ2UoY2hhbmdlKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VuZEV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5zZW5kUXVldWVkTWVzc2FnZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5zdGF0ZS5xdWV1ZUV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5jaGFubmVscy5wcm9wb2dhdGVDb25uZWN0aW9uSW50ZXJydXB0aW9uKHN0YXRlLCBjaGFuZ2UucmVhc29uKTtcbiAgICAgICAgICAgIHRoaXMuZmFpbFF1ZXVlZE1lc3NhZ2VzKGNoYW5nZS5yZWFzb24pOyAvLyBSVE43Y1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVxdWVzdFN0YXRlID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIHN0YXRlID0gcmVxdWVzdC5zdGF0ZTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5yZXF1ZXN0U3RhdGUoKScsICdyZXF1ZXN0ZWQgc3RhdGU6ICcgKyBzdGF0ZSArICc7IGN1cnJlbnQgc3RhdGU6ICcgKyB0aGlzLnN0YXRlLnN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlID09IHRoaXMuc3RhdGUuc3RhdGUpXG4gICAgICAgICAgICByZXR1cm47IC8qIHNpbGVudGx5IGRvIG5vdGhpbmcgKi9cbiAgICAgICAgLyoga2lsbCBydW5uaW5nIHRpbWVycywgYXMgdGhpcyByZXF1ZXN0IHN1cGVyc2VkZXMgdGhlbSAqL1xuICAgICAgICB0aGlzLmNhbmNlbFRyYW5zaXRpb25UaW1lcigpO1xuICAgICAgICB0aGlzLmNhbmNlbFJldHJ5VGltZXIoKTtcbiAgICAgICAgLyogZm9yIHN1c3BlbmQgdGltZXIgY2hlY2sgcmF0aGVyIHRoYW4gY2FuY2VsIC0tIGVnIHJlcXVlc3RpbmcgYSBjb25uZWN0aW5nXG4gICAgICAgICAqIHN0YXRlIHNob3VsZCBub3QgcmVzZXQgdGhlIHN1c3BlbmQgdGltZXIgKi9cbiAgICAgICAgdGhpcy5jaGVja1N1c3BlbmRUaW1lcihzdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZSA9PSAnY29ubmVjdGluZycgJiYgdGhpcy5zdGF0ZS5zdGF0ZSA9PSAnY29ubmVjdGVkJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHN0YXRlID09ICdjbG9zaW5nJyAmJiB0aGlzLnN0YXRlLnN0YXRlID09ICdjbG9zZWQnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSB0aGlzLnN0YXRlc1tzdGF0ZV0sIGNoYW5nZSA9IG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfMS5kZWZhdWx0KHRoaXMuc3RhdGUuc3RhdGUsIG5ld1N0YXRlLnN0YXRlLCBudWxsLCByZXF1ZXN0LmVycm9yIHx8ICgoX2IgPSAoX2EgPSBjb25uZWN0aW9uZXJyb3JzXzEuZGVmYXVsdClbbmV3U3RhdGUuc3RhdGVdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpKTtcbiAgICAgICAgdGhpcy5lbmFjdFN0YXRlQ2hhbmdlKGNoYW5nZSk7XG4gICAgICAgIGlmIChzdGF0ZSA9PSAnY29ubmVjdGluZycpIHtcbiAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXJ0Q29ubmVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09ICdjbG9zaW5nJykge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUltcGwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnN0YXJ0Q29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRDb25uZWN0KCknLCAnTXVzdCBiZSBpbiBjb25uZWN0aW5nIHN0YXRlIHRvIGNvbm5lY3QsIGJ1dCB3YXMgJyArIHRoaXMuc3RhdGUuc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdXRoID0gdGhpcy5yZWFsdGltZS5hdXRoO1xuICAgICAgICAvKiBUaGUgcG9pbnQgb2YgdGhlIGNvbm5lY3RDb3VudGVyIG1lY2hhbmlzbSBpcyB0byBlbnN1cmUgdGhhdCB0aGVcbiAgICAgICAgICogY29ubmVjdGlvbiBwcm9jZWR1cmUgY2FuIGJlIGNhbmNlbGxlZC4gV2Ugd2FudCBkaXNjb25uZWN0QWxsVHJhbnNwb3J0c1xuICAgICAgICAgKiB0byBiZSBhYmxlIHRvIHN0b3AgYW55IGluLXByb2dyZXNzIGNvbm5lY3Rpb24sIGV2ZW4gYmVmb3JlIGl0IGdldHMgdG9cbiAgICAgICAgICogdGhlIHN0YWdlIG9mIGhhdmluZyBhIHBlbmRpbmcgKG9yIGV2ZW4gYSBwcm9wb3NlZCkgdHJhbnNwb3J0IHRoYXQgaXQgY2FuXG4gICAgICAgICAqIGRpc3Bvc2UoKSBvZi4gU28gd2UgY2hlY2sgdGhhdCBpdCdzIHN0aWxsIGN1cnJlbnQgYWZ0ZXIgYW55IGFzeW5jIHN0YWdlLFxuICAgICAgICAgKiB1cCB1bnRpbCB0aGUgc3RhZ2UgdGhhdCBpcyBzeW5jaHJvbm91cyB3aXRoIGluc3RhbnRpYXRpbmcgYSB0cmFuc3BvcnQgKi9cbiAgICAgICAgdmFyIGNvbm5lY3RDb3VudCA9ICsrdGhpcy5jb25uZWN0Q291bnRlcjtcbiAgICAgICAgdmFyIGNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jaGVja0Nvbm5lY3Rpb25TdGF0ZUZyZXNobmVzcygpO1xuICAgICAgICAgICAgX3RoaXMuZ2V0VHJhbnNwb3J0UGFyYW1zKGZ1bmN0aW9uICh0cmFuc3BvcnRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNwb3J0UGFyYW1zLm1vZGUgPT09ICdyZWNvdmVyJyAmJiB0cmFuc3BvcnRQYXJhbXMub3B0aW9ucy5yZWNvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWNvdmVyeUNvbnRleHQgPSBkZWNvZGVSZWNvdmVyeUtleSh0cmFuc3BvcnRQYXJhbXMub3B0aW9ucy5yZWNvdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY292ZXJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVhbHRpbWUuY2hhbm5lbHMucmVjb3ZlckNoYW5uZWxzKHJlY292ZXJ5Q29udGV4dC5jaGFubmVsU2VyaWFscyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3RDb3VudCAhPT0gX3RoaXMuY29ubmVjdENvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zdGFydENvbm5lY3QoKScsICdzdGFydGluZyBjb25uZWN0aW9uJyk7XG4gICAgICAgIHRoaXMuc3RhcnRTdXNwZW5kVGltZXIoKTtcbiAgICAgICAgdGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jb25uZWN0aW5nKTtcbiAgICAgICAgaWYgKGF1dGgubWV0aG9kID09PSAnYmFzaWMnKSB7XG4gICAgICAgICAgICBjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXV0aENiID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0Q291bnQgIT09IF90aGlzLmNvbm5lY3RDb3VudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZShlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5lcnJvclJlYXNvbiAmJiBhdXRoXzEuZGVmYXVsdC5pc1Rva2VuRXJyKHRoaXMuZXJyb3JSZWFzb24pKSB7XG4gICAgICAgICAgICAgICAgLyogRm9yY2UgYSByZWZldGNoIG9mIGEgbmV3IHRva2VuICovXG4gICAgICAgICAgICAgICAgYXV0aC5fZm9yY2VOZXdUb2tlbihudWxsLCBudWxsLCBhdXRoQ2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXV0aC5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZmFsc2UsIGF1dGhDYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZXJlIGFyZSB0aHJlZSBzdGFnZXMgaW4gY29ubmVjdGluZzpcbiAgICAgKiAtIHByZWZlcmVuY2U6IGlmIHRoZXJlIGlzIGEgY2FjaGVkIHRyYW5zcG9ydCBwcmVmZXJlbmNlLCB3ZSB0cnkgdG8gY29ubmVjdFxuICAgICAqICAgb24gdGhhdC4gSWYgdGhhdCBmYWlscyBvciB0aW1lcyBvdXQgd2UgYWJvcnQgdGhlIGF0dGVtcHQsIHJlbW92ZSB0aGVcbiAgICAgKiAgIHByZWZlcmVuY2UgYW5kIGZhbGwgYmFjayB0byBiYXNlLiBJZiBpdCBzdWNjZWVkcywgd2UgdHJ5IHVwZ3JhZGluZyBpdCBpZlxuICAgICAqICAgbmVlZGVkICh3aWxsIG9ubHkgYmUgaW4gdGhlIGNhc2Ugd2hlcmUgdGhlIHByZWZlcmVuY2UgaXMgeGhycyBhbmQgdGhlXG4gICAgICogICBicm93c2VyIHN1cHBvcnRzIHdzKS5cbiAgICAgKiAtIGJhc2U6IHdlIHRyeSB0byBjb25uZWN0IHdpdGggdGhlIGJlc3QgdHJhbnNwb3J0IHRoYXQgd2UgdGhpbmsgd2lsbFxuICAgICAqICAgbmV2ZXIgZmFpbCBmb3IgdGhpcyBicm93c2VyICh1c3VhbGx5IHRoaXMgaXMgeGhyX3BvbGxpbmc7IGZvciB2ZXJ5IG9sZFxuICAgICAqICAgYnJvd3NlcnMgd2lsbCBiZSBqc29ucCwgZm9yIG5vZGUgd2lsbCBiZSBjb21ldCkuIElmIGl0IGRvZXNuJ3Qgd29yaywgd2VcbiAgICAgKiAgIHRyeSBmYWxsYmFjayBob3N0cy5cbiAgICAgKiAtIHVwZ3JhZGU6IGdpdmVuIGEgY29ubmVjdGVkIHRyYW5zcG9ydCwgd2Ugc2VlIGlmIHRoZXJlIGFyZSBhbnkgYmV0dGVyXG4gICAgICogICBvbmVzLCBhbmQgaWYgc28sIHRyeSB0byB1cGdyYWRlIHRvIHRoZW0uXG4gICAgICpcbiAgICAgKiBjb25uZWN0SW1wbCB3b3JrcyBvdXQgd2hhdCBzdGFnZSB5b3UncmUgYXQgKHdoaWNoIGlzIHB1cmVseSBhIGZ1bmN0aW9uIG9mXG4gICAgICogdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZSBhbmQgd2hldGhlciB0aGVyZSBhcmUgYW55IHN0b3JlZCBwcmVmZXJlbmNlcyksXG4gICAgICogYW5kIGRpc3BhdGNoZXMgYWNjb3JkaW5nbHkuIEFmdGVyIGEgdHJhbnNwb3J0IGhhcyBiZWVuIHNldCBwZW5kaW5nLFxuICAgICAqIHRyeUFUcmFuc3BvcnQgY2FsbHMgY29ubmVjdEltcGwgdG8gc2VlIGlmIHRoZXJlJ3MgYW5vdGhlciBzdGFnZSB0byBiZSBkb25lLlxuICAgICAqICovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3RJbXBsID0gZnVuY3Rpb24gKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGUuc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5zdGF0ZSAmJiBzdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlKSB7XG4gICAgICAgICAgICAvKiBPbmx5IGtlZXAgdHJ5aW5nIGFzIGxvbmcgYXMgaW4gdGhlICdjb25uZWN0aW5nJyBzdGF0ZSAob3IgJ2Nvbm5lY3RlZCdcbiAgICAgICAgICAgICAqIGZvciB1cGdyYWRpbmcpLiBBbnkgb3BlcmF0aW9uIGNhbiBwdXQgdXMgaW50byAnZGlzY29ubmVjdGVkJyB0byBjYW5jZWxcbiAgICAgICAgICAgICAqIGNvbm5lY3Rpb24gYXR0ZW1wdHMgYW5kIHdhaXQgYmVmb3JlIHJldHJ5aW5nLCBvciAnZmFpbGVkJyB0byBmYWlsLiAqL1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0SW1wbCgpJywgJ011c3QgYmUgaW4gY29ubmVjdGluZyBzdGF0ZSB0byBjb25uZWN0IChvciBjb25uZWN0ZWQgdG8gdXBncmFkZSksIGJ1dCB3YXMgJyArIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0SW1wbCgpJywgJ1RyYW5zcG9ydHMgJyArIHRoaXMucGVuZGluZ1RyYW5zcG9ydHNbMF0udG9TdHJpbmcoKSArICcgY3VycmVudGx5IHBlbmRpbmc7IHRha2luZyBubyBhY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMudXBncmFkZUlmTmVlZGVkKHRyYW5zcG9ydFBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50cmFuc3BvcnRzLmxlbmd0aCA+IDEgJiYgdGhpcy5nZXRUcmFuc3BvcnRQcmVmZXJlbmNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFByZWZlcmVuY2UodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0QmFzZSh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uICh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJlZmVyZW5jZSA9IHRoaXMuZ2V0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgICAgICB2YXIgcHJlZmVyZW5jZVRpbWVvdXRFeHBpcmVkID0gZmFsc2U7XG4gICAgICAgIGlmICghVXRpbHMuYXJySW4odGhpcy50cmFuc3BvcnRzLCBwcmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhpcy51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RQcmVmZXJlbmNlKCknLCAnVHJ5aW5nIHRvIGNvbm5lY3Qgd2l0aCBzdG9yZWQgdHJhbnNwb3J0IHByZWZlcmVuY2UgJyArIHByZWZlcmVuY2UpO1xuICAgICAgICB2YXIgcHJlZmVyZW5jZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByZWZlcmVuY2VUaW1lb3V0RXhwaXJlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIShfdGhpcy5zdGF0ZS5zdGF0ZSA9PT0gX3RoaXMuc3RhdGVzLmNvbm5lY3RlZC5zdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RQcmVmZXJlbmNlKCknLCAnU2hvcnRjaXJjdWl0IGNvbm5lY3Rpb24gYXR0ZW1wdCB3aXRoICcgKyBwcmVmZXJlbmNlICsgJyBmYWlsZWQ7IGNsZWFyaW5nIHByZWZlcmVuY2UgYW5kIHRyeWluZyBmcm9tIHNjcmF0Y2gnKTtcbiAgICAgICAgICAgICAgICAvKiBBYm9ydCBhbGwgY29ubmVjdGlvbiBhdHRlbXB0cy4gKFRoaXMgYWxzbyBkaXNjb25uZWN0cyB0aGUgYWN0aXZlXG4gICAgICAgICAgICAgICAgICogcHJvdG9jb2wsIGJ1dCBub25lIGV4aXN0cyBpZiB3ZSdyZSBub3QgaW4gdGhlIGNvbm5lY3RlZCBzdGF0ZSkgKi9cbiAgICAgICAgICAgICAgICBfdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuICAgICAgICAgICAgICAgIC8qIEJlIHF1aXRlIGFncmVzc2l2ZSBhYm91dCBjbGVhcmluZyB0aGUgc3RvcmVkIHByZWZlcmVuY2UgaWYgZXZlciBpdCBkb2Vzbid0IHdvcmsgKi9cbiAgICAgICAgICAgICAgICBfdGhpcy51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy50aW1lb3V0cy5wcmVmZXJlbmNlQ29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAvKiBGb3IgY29ubmVjdFByZWZlcmVuY2UsIGp1c3QgdXNlIHRoZSBtYWluIGhvc3QuIElmIGhvc3QgZmFsbGJhY2sgaXMgbmVlZGVkLCBkbyBpdCBpbiBjb25uZWN0QmFzZS5cbiAgICAgICAgICogVGhlIHdzdHJhbnNwb3J0IGl0IHdpbGwgc3Vic3RpdHV0ZSB0aGUgaHR0cGhvc3QgZm9yIGFuIGFwcHJvcHJpYXRlIHdzaG9zdCAqL1xuICAgICAgICB0cmFuc3BvcnRQYXJhbXMuaG9zdCA9IHRoaXMuaHR0cEhvc3RzWzBdO1xuICAgICAgICB0aGlzLnRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCBwcmVmZXJlbmNlLCBmdW5jdGlvbiAoZmF0YWwsIHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHByZWZlcmVuY2VUaW1lb3V0KTtcbiAgICAgICAgICAgIGlmIChwcmVmZXJlbmNlVGltZW91dEV4cGlyZWQgJiYgdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgLyogVmlhYmxlLCBidXQgdG9vIGxhdGUgLSBjb25uZWN0SW1wbCgpIHdpbGwgYWxyZWFkeSBiZSB0cnlpbmdcbiAgICAgICAgICAgICAgICAgKiBjb25uZWN0QmFzZSwgYW5kIHdlIHdlcmVuJ3QgaW4gdXBncmFkZSBtb2RlLiBKdXN0IHJlbW92ZSB0aGVcbiAgICAgICAgICAgICAgICAgKiBvbmNvbm5lY3RlZCBsaXN0ZW5lciBhbmQgZ2V0IHJpZCBvZiBpdCAqL1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5vZmYoKTtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIFV0aWxzLmFyckRlbGV0ZVZhbHVlKF90aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRyYW5zcG9ydCAmJiAhZmF0YWwpIHtcbiAgICAgICAgICAgICAgICAvKiBQcmVmZXJlbmNlIGZhaWxlZCBpbiBhIHRyYW5zcG9ydC1zcGVjaWZpYyB3YXkuIFRyeSBtb3JlICovXG4gICAgICAgICAgICAgICAgX3RoaXMudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIElmIHN1Y2VlZGVkLCBvciBmYWlsZWQgZmF0YWxseSwgbm90aGluZyB0byBkbyAqL1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyeSB0byBlc3RhYmxpc2ggYSB0cmFuc3BvcnQgb24gdGhlIGJhc2UgdHJhbnNwb3J0ICh0aGUgYmVzdCB0cmFuc3BvcnRcbiAgICAgKiBzdWNoIHRoYXQgaWYgaXQgZG9lc24ndCB3b3JrLCBub3RoaW5nIHdpbGwgd29yaykgYXMgZGV0ZXJtaW5lZCB0aHJvdWdoXG4gICAgICogc3RhdGljIGZlYXR1cmUgZGV0ZWN0aW9uLCBjaGVja2luZyBmb3IgbmV0d29yayBjb25uZWN0aXZpdHkgYW5kIHRyeWluZ1xuICAgICAqIGZhbGxiYWNrIGhvc3RzIGlmIGFwcGxpY2FibGUuXG4gICAgICogQHBhcmFtIHRyYW5zcG9ydFBhcmFtc1xuICAgICAqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0QmFzZSA9IGZ1bmN0aW9uICh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZ2l2ZVVwID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgX3RoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogX3RoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlLCBlcnJvcjogZXJyIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2FuZGlkYXRlSG9zdHMgPSB0aGlzLmh0dHBIb3N0cy5zbGljZSgpO1xuICAgICAgICB2YXIgaG9zdEF0dGVtcHRDYiA9IGZ1bmN0aW9uIChmYXRhbCwgdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBpZiAoY29ubmVjdENvdW50ICE9PSBfdGhpcy5jb25uZWN0Q291bnRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdHJhbnNwb3J0ICYmICFmYXRhbCkge1xuICAgICAgICAgICAgICAgIHRyeUZhbGxiYWNrSG9zdHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0QmFzZSgpJywgJ1RyeWluZyB0byBjb25uZWN0IHdpdGggYmFzZSB0cmFuc3BvcnQgJyArIHRoaXMuYmFzZVRyYW5zcG9ydCk7XG4gICAgICAgIC8qIGZpcnN0IHRyeSB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHdpdGggdGhlIHByaW9yaXR5IGhvc3Qgd2l0aCBodHRwIHRyYW5zcG9ydCAqL1xuICAgICAgICB2YXIgaG9zdCA9IGNhbmRpZGF0ZUhvc3RzLnNoaWZ0KCk7XG4gICAgICAgIGlmICghaG9zdCkge1xuICAgICAgICAgICAgZ2l2ZVVwKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdVbmFibGUgdG8gY29ubmVjdCAobm8gYXZhaWxhYmxlIGhvc3QpJywgODAwMDMsIDQwNCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zcG9ydFBhcmFtcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgLyogdGhpcyBpcyB3aGF0IHdlJ2xsIGJlIGRvaW5nIGlmIHRoZSBhdHRlbXB0IGZvciB0aGUgbWFpbiBob3N0IGZhaWxzICovXG4gICAgICAgIHZhciB0cnlGYWxsYmFja0hvc3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLyogaWYgdGhlcmUgYXJlbid0IGFueSBmYWxsYmFjayBob3N0cywgZmFpbCAqL1xuICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGVIb3N0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBnaXZlVXAobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1VuYWJsZSB0byBjb25uZWN0IChhbmQgbm8gbW9yZSBmYWxsYmFjayBob3N0cyB0byB0cnkpJywgODAwMDMsIDQwNCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGJlZm9yZSB0cnlpbmcgYW55IGZhbGxiYWNrIChvciBhbnkgcmVtYWluaW5nIGZhbGxiYWNrKSB3ZSBkZWNpZGUgaWZcbiAgICAgICAgICAgICAqIHRoZXJlIGlzIGEgcHJvYmxlbSB3aXRoIHRoZSBhYmx5IGhvc3QsIG9yIHRoZXJlIGlzIGEgZ2VuZXJhbCBjb25uZWN0aXZpdHlcbiAgICAgICAgICAgICAqIHByb2JsZW0gKi9cbiAgICAgICAgICAgIGlmICghX3RoaXMucmVhbHRpbWUuaHR0cC5jaGVja0Nvbm5lY3Rpdml0eSkge1xuICAgICAgICAgICAgICAgIGdpdmVVcChuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygnSW50ZXJuYWwgZXJyb3I6IEh0dHAuY2hlY2tDb25uZWN0aXZpdHkgbm90IHNldCcsIG51bGwsIDUwMCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnJlYWx0aW1lLmh0dHAuY2hlY2tDb25uZWN0aXZpdHkoZnVuY3Rpb24gKGVyciwgY29ubmVjdGl2aXR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3RDb3VudCAhPT0gX3RoaXMuY29ubmVjdENvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiB3ZSBrbm93IGVyciB3b24ndCBoYXBwZW4gYnV0IGhhbmRsZSBpdCBoZXJlIGFueXdheSAqL1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2l2ZVVwKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjb25uZWN0aXZpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogdGhlIGludGVybmV0IGlzbid0IHJlYWNoYWJsZSwgc28gZG9uJ3QgdHJ5IHRoZSBmYWxsYmFjayBob3N0cyAqL1xuICAgICAgICAgICAgICAgICAgICBnaXZlVXAobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1VuYWJsZSB0byBjb25uZWN0IChuZXR3b3JrIHVucmVhY2hhYmxlKScsIDgwMDAzLCA0MDQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiB0aGUgbmV0d29yayBpcyB0aGVyZSwgc28gdGhlcmUncyBhIHByb2JsZW0gd2l0aCB0aGUgbWFpbiBob3N0LCBvclxuICAgICAgICAgICAgICAgICAqIGl0cyBkbnMuIFRyeSB0aGUgZmFsbGJhY2sgaG9zdHMuIFdlIGNvdWxkIHRyeSB0aGVtIHNpbXVsdGFuZW91c2x5IGJ1dFxuICAgICAgICAgICAgICAgICAqIHRoYXQgd291bGQgcG90ZW50aWFsbHkgY2F1c2UgYSBodWdlIHNwaWtlIGluIGxvYWQgb24gdGhlIGxvYWQgYmFsYW5jZXIgKi9cbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRQYXJhbXMuaG9zdCA9IFV0aWxzLmFyclBvcFJhbmRvbUVsZW1lbnQoY2FuZGlkYXRlSG9zdHMpO1xuICAgICAgICAgICAgICAgIF90aGlzLnRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCBfdGhpcy5iYXNlVHJhbnNwb3J0LCBob3N0QXR0ZW1wdENiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5mb3JjZUZhbGxiYWNrSG9zdCAmJiBjYW5kaWRhdGVIb3N0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZm9yY2VGYWxsYmFja0hvc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHRyeUZhbGxiYWNrSG9zdHMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCB0aGlzLmJhc2VUcmFuc3BvcnQsIGhvc3RBdHRlbXB0Q2IpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFVwZ3JhZGVQb3NzaWJpbGl0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiByZXR1cm5zIHRoZSBzdWJzZXQgb2YgdXBncmFkZVRyYW5zcG9ydHMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW50XG4gICAgICAgICAqIHRyYW5zcG9ydCBpbiB1cGdyYWRlVHJhbnNwb3J0cyAoaWYgaXQncyBpbiB0aGVyZSAtIGlmIG5vdCwgY3VycmVudFNlcmlhbFxuICAgICAgICAgKiB3aWxsIGJlIC0xLCBzbyByZXR1cm4gdXBncmFkZVRyYW5zcG9ydHMuc2xpY2UoMCkgPT0gdXBncmFkZVRyYW5zcG9ydHMgKi9cbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLnNob3J0TmFtZTtcbiAgICAgICAgdmFyIGN1cnJlbnRTZXJpYWwgPSBVdGlscy5hcnJJbmRleE9mKHRoaXMudXBncmFkZVRyYW5zcG9ydHMsIGN1cnJlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy51cGdyYWRlVHJhbnNwb3J0cy5zbGljZShjdXJyZW50U2VyaWFsICsgMSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUudXBncmFkZUlmTmVlZGVkID0gZnVuY3Rpb24gKHRyYW5zcG9ydFBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdXBncmFkZVBvc3NpYmlsaXRpZXMgPSB0aGlzLmdldFVwZ3JhZGVQb3NzaWJpbGl0aWVzKCk7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIudXBncmFkZUlmTmVlZGVkKCknLCAndXBncmFkZSBwb3NzaWJpbGl0aWVzOiAnICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KHVwZ3JhZGVQb3NzaWJpbGl0aWVzKSk7XG4gICAgICAgIGlmICghdXBncmFkZVBvc3NpYmlsaXRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgVXRpbHMuYXJyRm9yRWFjaCh1cGdyYWRlUG9zc2liaWxpdGllcywgZnVuY3Rpb24gKHVwZ3JhZGVUcmFuc3BvcnQpIHtcbiAgICAgICAgICAgIC8qIE5vdGU6IHRoZSB0cmFuc3BvcnQgbWF5IG11dGF0ZSB0aGUgcGFyYW1zLCBzbyBnaXZlIGVhY2ggdHJhbnNwb3J0IGEgZnJlc2ggb25lICovXG4gICAgICAgICAgICB2YXIgdXBncmFkZVRyYW5zcG9ydFBhcmFtcyA9IF90aGlzLmNyZWF0ZVRyYW5zcG9ydFBhcmFtcyh0cmFuc3BvcnRQYXJhbXMuaG9zdCwgJ3VwZ3JhZGUnKTtcbiAgICAgICAgICAgIF90aGlzLnRyeUFUcmFuc3BvcnQodXBncmFkZVRyYW5zcG9ydFBhcmFtcywgdXBncmFkZVRyYW5zcG9ydCwgbm9vcCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlSW1wbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jbG9zZUltcGwoKScsICdjbG9zaW5nIGNvbm5lY3Rpb24nKTtcbiAgICAgICAgdGhpcy5jYW5jZWxTdXNwZW5kVGltZXIoKTtcbiAgICAgICAgdGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jbG9zaW5nKTtcbiAgICAgICAgVXRpbHMuc2FmZUFyckZvckVhY2godGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5jbG9zZUltcGwoKScsICdDbG9zaW5nIHBlbmRpbmcgdHJhbnNwb3J0OiAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIGlmICh0cmFuc3BvcnQpXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBVdGlscy5zYWZlQXJyRm9yRWFjaCh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cywgZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5jbG9zZUltcGwoKScsICdEaXNwb3Npbmcgb2YgcHJvcG9zZWQgdHJhbnNwb3J0OiAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIGlmICh0cmFuc3BvcnQpXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVByb3RvY29sKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpJywgJ0Nsb3NpbmcgYWN0aXZlIHRyYW5zcG9ydDogJyArIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qIElmIHRoZXJlIHdhcyBhbiBhY3RpdmUgdHJhbnNwb3J0LCB0aGlzIHdpbGwgcHJvYmFibHkgYmVcbiAgICAgICAgICogcHJlZW1wdGVkIGJ5IHRoZSBub3RpZnlTdGF0ZSBjYWxsIGluIGRlYWN0aXZhdGVUcmFuc3BvcnQgKi9cbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiAnY2xvc2VkJyB9KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vbkF1dGhVcGRhdGVkID0gZnVuY3Rpb24gKHRva2VuRGV0YWlscywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6IHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoKScsICdTZW5kaW5nIEFVVEggbWVzc2FnZSBvbiBhY3RpdmUgdHJhbnNwb3J0Jyk7XG4gICAgICAgICAgICAgICAgLyogSWYgdGhlcmUgYXJlIGFueSBwcm9wb3NlZC9wZW5kaW5nIHRyYW5zcG9ydHMgKGVnIGFuIHVwZ3JhZGUgdGhhdFxuICAgICAgICAgICAgICAgICAqIGlzbid0IHlldCBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb24pIHRoYXQgaGFzbid0IHlldCBzdGFydGVkIHN5bmNpbmcsXG4gICAgICAgICAgICAgICAgICoganVzdCB0byBnZXQgcmlkIG9mIHRoZW0gJiByZXN0YXJ0IHRoZSB1cGdyYWRlIHdpdGggdGhlIG5ldyB0b2tlbiwgdG9cbiAgICAgICAgICAgICAgICAgKiBhdm9pZCBhIHJhY2UgY29uZGl0aW9uLiAoSWYgaXQgaGFzIHN0YXJ0ZWQgc3luY2luZywgdGhlIEFVVEggd2lsbCBiZVxuICAgICAgICAgICAgICAgICAqIHF1ZXVlZCB1bnRpbCB0aGUgdXBncmFkZSBpcyBjb21wbGV0ZSwgc28gZXZlcnl0aGluZydzIGZpbmUpICovXG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLmxlbmd0aCB8fCB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cy5sZW5ndGgpICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLnN5bmNocm9uaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygvKiBleGNlcHRBY3RpdmU6ICovIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNwb3J0UGFyYW1zXzEgPSB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLnBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBncmFkZUlmTmVlZGVkKHRyYW5zcG9ydFBhcmFtc18xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIERvIGFueSB0cmFuc3BvcnQtc3BlY2lmaWMgbmV3LXRva2VuIGFjdGlvbiAqL1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmVUcmFuc3BvcnQgPSAoX2EgPSB0aGlzLmFjdGl2ZVByb3RvY29sKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0VHJhbnNwb3J0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVRyYW5zcG9ydCAmJiBhY3RpdmVUcmFuc3BvcnQub25BdXRoVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVUcmFuc3BvcnQub25BdXRoVXBkYXRlZCh0b2tlbkRldGFpbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYXV0aE1zZyA9IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9ucy5BVVRILFxuICAgICAgICAgICAgICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbjogdG9rZW5EZXRhaWxzLnRva2VuLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZChhdXRoTXNnKTtcbiAgICAgICAgICAgICAgICAvKiBUaGUgYW5zd2VyIHdpbGwgY29tZSBiYWNrIGFzIGVpdGhlciBhIGNvbm5lY3Rpb25kZXRhaWxzIGV2ZW50XG4gICAgICAgICAgICAgICAgICogKHJlYWx0aW1lIHNlbmRzIGEgQ09OTkVDVEVEIHRvIGFja25vd2xlZGdlIHRoZSByZWF1dGgpIG9yIGFcbiAgICAgICAgICAgICAgICAgKiBzdGF0ZWNoYW5nZSB0byBmYWlsZWQgKi9cbiAgICAgICAgICAgICAgICB2YXIgc3VjY2Vzc0xpc3RlbmVyXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZihmYWlsdXJlTGlzdGVuZXJfMSk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRva2VuRGV0YWlscyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgZmFpbHVyZUxpc3RlbmVyXzEgPSBmdW5jdGlvbiAoc3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlQ2hhbmdlLmN1cnJlbnQgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmYoc3VjY2Vzc0xpc3RlbmVyXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub2ZmKGZhaWx1cmVMaXN0ZW5lcl8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCBfdGhpcy5nZXRTdGF0ZUVycm9yKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoJ2Nvbm5lY3Rpb25kZXRhaWxzJywgc3VjY2Vzc0xpc3RlbmVyXzEpO1xuICAgICAgICAgICAgICAgIHRoaXMub24oJ2Nvbm5lY3Rpb25zdGF0ZScsIGZhaWx1cmVMaXN0ZW5lcl8xKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RpbmcnOlxuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIub25BdXRoVXBkYXRlZCgpJywgJ0Fib3J0aW5nIGN1cnJlbnQgY29ubmVjdGlvbiBhdHRlbXB0cyBpbiBvcmRlciB0byBzdGFydCBhZ2FpbiB3aXRoIHRoZSBuZXcgYXV0aCBkZXRhaWxzJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuICAgICAgICAgICAgLyogZmFsbHRocm91Z2ggdG8gYWRkIHN0YXRlY2hhbmdlIGxpc3RlbmVyICovXG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKCknLCAnQ29ubmVjdGlvbiBzdGF0ZSBpcyAnICsgdGhpcy5zdGF0ZS5zdGF0ZSArICc7IHdhaXRpbmcgdW50aWwgZWl0aGVyIGNvbm5lY3RlZCBvciBmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJfMSA9IGZ1bmN0aW9uIChzdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlQ2hhbmdlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub2ZmKGxpc3RlbmVyXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRva2VuRGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N1c3BlbmRlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub2ZmKGxpc3RlbmVyXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCBfdGhpcy5nZXRTdGF0ZUVycm9yKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBpZ25vcmUgdGlsbCB3ZSBnZXQgZWl0aGVyIGNvbm5lY3RlZCBvciBmYWlsZWQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbignY29ubmVjdGlvbnN0YXRlJywgbGlzdGVuZXJfMSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RhdGUgPT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvKiBjYW4gaGFwcGVuIGlmIGluIHRoZSBjb25uZWN0aW5nIHN0YXRlIGJ1dCBubyB0cmFuc3BvcnQgd2FzIHBlbmRpbmdcbiAgICAgICAgICAgICAgICAgICAgICogeWV0LCBzbyBkaXNjb25uZWN0QWxsVHJhbnNwb3J0cyBkaWQgbm90IHRyaWdnZXIgYSBkaXNjb25uZWN0ZWQgc3RhdGUgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydENvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKHsgc3RhdGU6ICdjb25uZWN0aW5nJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cyA9IGZ1bmN0aW9uIChleGNlcHRBY3RpdmUpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpJywgJ0Rpc2Nvbm5lY3RpbmcgYWxsIHRyYW5zcG9ydHMnICsgKGV4Y2VwdEFjdGl2ZSA/ICcgZXhjZXB0IHRoZSBhY3RpdmUgdHJhbnNwb3J0JyA6ICcnKSk7XG4gICAgICAgIC8qIFRoaXMgd2lsbCBwcmV2ZW50IGFueSBjb25uZWN0aW9uIHByb2NlZHVyZSBpbiBhbiBhc3luYyBwYXJ0IG9mIG9uZSBvZiBpdHMgZWFybHkgc3RhZ2VzIGZyb20gY29udGludWluZyAqL1xuICAgICAgICB0aGlzLmNvbm5lY3RDb3VudGVyKys7XG4gICAgICAgIFV0aWxzLnNhZmVBcnJGb3JFYWNoKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKScsICdEaXNjb25uZWN0aW5nIHBlbmRpbmcgdHJhbnNwb3J0OiAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIGlmICh0cmFuc3BvcnQpXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGVuZGluZ1RyYW5zcG9ydHMgPSBbXTtcbiAgICAgICAgVXRpbHMuc2FmZUFyckZvckVhY2godGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMsIGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKScsICdEaXNwb3Npbmcgb2YgcHJvcG9zZWQgdHJhbnNwb3J0OiAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIGlmICh0cmFuc3BvcnQpXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzID0gW107XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVByb3RvY29sICYmICFleGNlcHRBY3RpdmUpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKScsICdEaXNjb25uZWN0aW5nIGFjdGl2ZSB0cmFuc3BvcnQ6ICcgKyB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8qIE5vIG5lZWQgdG8gbm90aWZ5IHN0YXRlIGRpc2Nvbm5lY3RlZDsgZGlzY29ubmVjdGluZyB0aGUgYWN0aXZlIHRyYW5zcG9ydFxuICAgICAgICAgKiB3aWxsIGhhdmUgdGhhdCBlZmZlY3QgKi9cbiAgICB9O1xuICAgIC8qKioqKioqKioqKioqKioqKipcbiAgICAgKiBldmVudCBxdWV1ZWluZ1xuICAgICAqKioqKioqKioqKioqKioqKiovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobXNnLCBxdWV1ZUV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoKScsICdzZW5kaW5nIGV2ZW50Jyk7XG4gICAgICAgICAgICB0aGlzLnNlbmRJbXBsKG5ldyBwcm90b2NvbF8xLlBlbmRpbmdNZXNzYWdlKG1zZywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hvdWxkUXVldWUgPSAocXVldWVFdmVudCAmJiBzdGF0ZS5xdWV1ZUV2ZW50cykgfHwgc3RhdGUuZm9yY2VRdWV1ZUV2ZW50cztcbiAgICAgICAgaWYgKCFzaG91bGRRdWV1ZSkge1xuICAgICAgICAgICAgdmFyIGVyciA9ICdyZWplY3RpbmcgZXZlbnQsIHF1ZXVlRXZlbnQgd2FzICcgKyBxdWV1ZUV2ZW50ICsgJywgc3RhdGUgd2FzICcgKyBzdGF0ZS5zdGF0ZTtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2VuZCgpJywgZXJyKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuZXJyb3JSZWFzb24gfHwgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoZXJyLCA5MDAwMCwgNDAwKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvZ2dlcl8xLmRlZmF1bHQuc2hvdWxkTG9nKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZW5kKCknLCAncXVldWVpbmcgbXNnOyAnICsgcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5zdHJpbmdpZnkobXNnKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWV1ZShtc2csIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZW5kSW1wbCA9IGZ1bmN0aW9uIChwZW5kaW5nTWVzc2FnZSkge1xuICAgICAgICB2YXIgbXNnID0gcGVuZGluZ01lc3NhZ2UubWVzc2FnZTtcbiAgICAgICAgLyogSWYgaGF2ZSBhbHJlYWR5IGF0dGVtcHRlZCB0byBzZW5kIHRoaXMsIHJlc2VuZCB3aXRoIHRoZSBzYW1lIG1zZ1NlcmlhbCxcbiAgICAgICAgICogc28gQWJseSBjYW4gZGVkdXAgaWYgdGhlIHByZXZpb3VzIHNlbmQgc3VjY2VlZGVkICovXG4gICAgICAgIGlmIChwZW5kaW5nTWVzc2FnZS5hY2tSZXF1aXJlZCAmJiAhcGVuZGluZ01lc3NhZ2Uuc2VuZEF0dGVtcHRlZCkge1xuICAgICAgICAgICAgbXNnLm1zZ1NlcmlhbCA9IHRoaXMubXNnU2VyaWFsKys7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wuc2VuZChwZW5kaW5nTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2VuZEltcGwoKScsICdVbmV4cGVjdGVkIGV4Y2VwdGlvbiBpbiB0cmFuc3BvcnQuc2VuZCgpOiAnICsgZS5zdGFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uIChtc2csIGNhbGxiYWNrKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIucXVldWUoKScsICdxdWV1ZWluZyBldmVudCcpO1xuICAgICAgICB2YXIgbGFzdFF1ZXVlZCA9IHRoaXMucXVldWVkTWVzc2FnZXMubGFzdCgpO1xuICAgICAgICB2YXIgbWF4U2l6ZSA9IHRoaXMub3B0aW9ucy5tYXhNZXNzYWdlU2l6ZTtcbiAgICAgICAgLyogSWYgaGF2ZSBhbHJlYWR5IGF0dGVtcHRlZCB0byBzZW5kIGEgbWVzc2FnZSwgZG9uJ3QgbWVyZ2UgbW9yZSBtZXNzYWdlc1xuICAgICAgICAgKiBpbnRvIGl0LCBhcyBpZiB0aGUgcHJldmlvdXMgc2VuZCBhY3R1YWxseSBzdWNjZWVkZWQgYW5kIHJlYWx0aW1lIGlnbm9yZXNcbiAgICAgICAgICogdGhlIGR1cCwgdGhleSdsbCBiZSBsb3N0ICovXG4gICAgICAgIGlmIChsYXN0UXVldWVkICYmICFsYXN0UXVldWVkLnNlbmRBdHRlbXB0ZWQgJiYgYnVuZGxlV2l0aChsYXN0UXVldWVkLm1lc3NhZ2UsIG1zZywgbWF4U2l6ZSkpIHtcbiAgICAgICAgICAgIGlmICghbGFzdFF1ZXVlZC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICBsYXN0UXVldWVkLmNhbGxiYWNrID0gbXVsdGljYXN0ZXJfMS5kZWZhdWx0LmNyZWF0ZShbbGFzdFF1ZXVlZC5jYWxsYmFja10pO1xuICAgICAgICAgICAgICAgIGxhc3RRdWV1ZWQubWVyZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RRdWV1ZWQuY2FsbGJhY2sucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlZE1lc3NhZ2VzLnB1c2gobmV3IHByb3RvY29sXzEuUGVuZGluZ01lc3NhZ2UobXNnLCBjYWxsYmFjaykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2VuZFF1ZXVlZE1lc3NhZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNlbmRRdWV1ZWRNZXNzYWdlcygpJywgJ3NlbmRpbmcgJyArIHRoaXMucXVldWVkTWVzc2FnZXMuY291bnQoKSArICcgcXVldWVkIG1lc3NhZ2VzJyk7XG4gICAgICAgIHZhciBwZW5kaW5nTWVzc2FnZTtcbiAgICAgICAgd2hpbGUgKChwZW5kaW5nTWVzc2FnZSA9IHRoaXMucXVldWVkTWVzc2FnZXMuc2hpZnQoKSkpXG4gICAgICAgICAgICB0aGlzLnNlbmRJbXBsKHBlbmRpbmdNZXNzYWdlKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5xdWV1ZVBlbmRpbmdNZXNzYWdlcyA9IGZ1bmN0aW9uIChwZW5kaW5nTWVzc2FnZXMpIHtcbiAgICAgICAgaWYgKHBlbmRpbmdNZXNzYWdlcyAmJiBwZW5kaW5nTWVzc2FnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnF1ZXVlUGVuZGluZ01lc3NhZ2VzKCknLCAncXVldWVpbmcgJyArIHBlbmRpbmdNZXNzYWdlcy5sZW5ndGggKyAnIHBlbmRpbmcgbWVzc2FnZXMnKTtcbiAgICAgICAgICAgIHRoaXMucXVldWVkTWVzc2FnZXMucHJlcGVuZChwZW5kaW5nTWVzc2FnZXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZmFpbFF1ZXVlZE1lc3NhZ2VzID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgbnVtUXVldWVkID0gdGhpcy5xdWV1ZWRNZXNzYWdlcy5jb3VudCgpO1xuICAgICAgICBpZiAobnVtUXVldWVkID4gMCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5mYWlsUXVldWVkTWVzc2FnZXMoKScsICdmYWlsaW5nICcgKyBudW1RdWV1ZWQgKyAnIHF1ZXVlZCBtZXNzYWdlcywgZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgICAgIHRoaXMucXVldWVkTWVzc2FnZXMuY29tcGxldGVBbGxNZXNzYWdlcyhlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25DaGFubmVsTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCB0cmFuc3BvcnQpIHtcbiAgICAgICAgdmFyIG9uQWN0aXZlVHJhbnNwb3J0ID0gdGhpcy5hY3RpdmVQcm90b2NvbCAmJiB0cmFuc3BvcnQgPT09IHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCksIG9uVXBncmFkZVRyYW5zcG9ydCA9IFV0aWxzLmFyckluKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIHRyYW5zcG9ydCkgJiYgdGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nO1xuICAgICAgICAvKiBBcyB0aGUgbGliIG5vdyBoYXMgYSBwZXJpb2Qgd2hlcmUgdGhlIHVwZ3JhZGUgdHJhbnNwb3J0IGlzIHN5bmNlZCBidXRcbiAgICAgICAgICogYmVmb3JlIGl0J3MgYmVjb21lIGFjdGl2ZSAod2hpbGUgd2FpdGluZyBmb3IgdGhlIG9sZCBvbmUgdG8gYmVjb21lXG4gICAgICAgICAqIGlkbGUpLCBtZXNzYWdlIGNhbiB2YWxpZGx5IGFycml2ZSBvbiBpdCBldmVuIHRob3VnaCBpdCBpc24ndCBhY3RpdmUgKi9cbiAgICAgICAgaWYgKG9uQWN0aXZlVHJhbnNwb3J0IHx8IG9uVXBncmFkZVRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5jaGFubmVscy5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTWVzc2FnZSBjYW1lIGluIG9uIGEgZGVmdW5jdCB0cmFuc3BvcnQuIEFsbG93IG9ubHkgYWNrcywgbmFja3MsICYgZXJyb3JzIGZvciBvdXRzdGFuZGluZ1xuICAgICAgICAgICAgLy8gbWVzc2FnZXMsICBubyBuZXcgbWVzc2FnZXMgKGFzIHN5bmMgaGFzIGJlZW4gc2VudCBvbiBuZXcgdHJhbnNwb3J0IHNvIG5ldyBtZXNzYWdlcyB3aWxsXG4gICAgICAgICAgICAvLyBiZSByZXNlbnQgdGhlcmUsIG9yIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2xvc2VkIHNvIGRvbid0IHdhbnQgbmV3IG1lc3NhZ2VzKVxuICAgICAgICAgICAgaWYgKFV0aWxzLmFyckluZGV4T2YoW2FjdGlvbnMuQUNLLCBhY3Rpb25zLk5BQ0ssIGFjdGlvbnMuRVJST1JdLCBtZXNzYWdlLmFjdGlvbikgPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuY2hhbm5lbHMub25DaGFubmVsTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZSgpJywgJ3JlY2VpdmVkIG1lc3NhZ2UgJyArIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpICsgJ29uIGRlZnVuY3QgdHJhbnNwb3J0OyBkaXNjYXJkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKHRyYW5zcG9ydCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyogaWYgdHJhbnNwb3J0IGlzIHNwZWNpZmllZCwgdHJ5IHRoYXQgKi9cbiAgICAgICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5waW5nKCknLCAndHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICB2YXIgb25UaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5vZmYoJ2hlYXJ0YmVhdCcsIG9uSGVhcnRiZWF0XzEpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdUaW1lb3V0IHdhaXRpbmcgZm9yIGhlYXJ0YmVhdCByZXNwb25zZScsIDUwMDAwLCA1MDApKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcGluZ1N0YXJ0XzEgPSBVdGlscy5ub3coKSwgaWRfMSA9IFV0aWxzLmNoZWFwUmFuZFN0cigpO1xuICAgICAgICAgICAgdmFyIG9uSGVhcnRiZWF0XzEgPSBmdW5jdGlvbiAocmVzcG9uc2VJZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUlkID09PSBpZF8xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5vZmYoJ2hlYXJ0YmVhdCcsIG9uSGVhcnRiZWF0XzEpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJfMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZVRpbWUgPSBVdGlscy5ub3coKSAtIHBpbmdTdGFydF8xO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXNwb25zZVRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdGltZXJfMSA9IHNldFRpbWVvdXQob25UaW1lb3V0LCB0aGlzLm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQub24oJ2hlYXJ0YmVhdCcsIG9uSGVhcnRiZWF0XzEpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnBpbmcoaWRfMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyogaWYgd2UncmUgbm90IGNvbm5lY3RlZCwgZG9uJ3QgYXR0ZW1wdCAqL1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0ZSAhPT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdVbmFibGUgdG8gcGluZyBzZXJ2aWNlOyBub3QgY29ubmVjdGVkJywgNDAwMDAsIDQwMCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIG5vIHRyYW5zcG9ydCB3YXMgc3BlY2lmaWVkLCBzbyB1c2UgdGhlIGN1cnJlbnQgKGNvbm5lY3RlZCkgb25lXG4gICAgICAgICAqIGJ1dCBlbnN1cmUgdGhhdCB3ZSByZXRyeSBpZiB0aGUgdHJhbnNwb3J0IGlzIHN1cGVyc2VkZWQgYmVmb3JlIHdlIGNvbXBsZXRlICovXG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIG9uUGluZ0NvbXBsZXRlID0gZnVuY3Rpb24gKGVyciwgcmVzcG9uc2VUaW1lKSB7XG4gICAgICAgICAgICBfdGhpcy5vZmYoJ3RyYW5zcG9ydC5hY3RpdmUnLCBvblRyYW5zcG9ydEFjdGl2ZSk7XG4gICAgICAgICAgICBpZiAoIWNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZVRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgb25UcmFuc3BvcnRBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgIC8qIGVuc3VyZSB0aGF0IG5vIGNhbGxiYWNrIGhhcHBlbnMgZm9yIHRoZSBjdXJyZW50bHkgb3V0c3RhbmRpbmcgb3BlcmF0aW9uICovXG4gICAgICAgICAgICAgICAgY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvKiByZXBlYXQgYnV0IHBpY2tpbmcgdXAgdGhlIG5ldyB0cmFuc3BvcnQgKi9cbiAgICAgICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGluZyhudWxsLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub24oJ3RyYW5zcG9ydC5hY3RpdmUnLCBvblRyYW5zcG9ydEFjdGl2ZSk7XG4gICAgICAgIHRoaXMucGluZyh0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLCBvblBpbmdDb21wbGV0ZSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5mYWlsKGVycm9yKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZWdpc3RlclByb3Bvc2VkVHJhbnNwb3J0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICAgICAgICB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cy5wdXNoKHRyYW5zcG9ydCk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VHJhbnNwb3J0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSB8fCAoaGF2ZVdlYlN0b3JhZ2UoKSAmJiAoKF9iID0gKF9hID0gcGxhdGZvcm1fMS5kZWZhdWx0LldlYlN0b3JhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSkpKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKFV0aWxzLmFyckluKGRlZmF1bHRzXzEuZGVmYXVsdC51cGdyYWRlVHJhbnNwb3J0cywgdHJhbnNwb3J0LnNob3J0TmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSA9IHRyYW5zcG9ydC5zaG9ydE5hbWU7XG4gICAgICAgICAgICBpZiAoaGF2ZVdlYlN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5XZWJTdG9yYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUsIHRyYW5zcG9ydC5zaG9ydE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gbnVsbDtcbiAgICAgICAgaWYgKGhhdmVXZWJTdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5XZWJTdG9yYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiBUaGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgZHVyaW5nIGNvbm5lY3Rpb24gYXR0ZW1wdHMsIHNvIGltcGxlbWVudHMgUlNBNGMxLCBSU0E0YzIsXG4gICAgICogYW5kIFJTQTRkLiBJdCBpcyBnZW5lcmFsbHkgbm90IGludm9rZWQgZm9yIHNlcnZlcnNpZGUtdHJpZ2dlcmVkIHJlYXV0aHMgb3IgbWFudWFsXG4gICAgICogcmVhdXRocywgc28gUlNBNGMzIGRvZXMgbm90IGFwcGx5LCBleGNlcHQgKHBlciBwZXIgUlNBNGQxKSBpbiB0aGUgY2FzZSB0aGF0IHRoZSBhdXRoXG4gICAgICogc2VydmVyIHJldHVybnMgNDAzLiAqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSA0MDE3MSkge1xuICAgICAgICAgICAgLyogTm8gd2F5IHRvIHJlYXV0aCAqL1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiAnZmFpbGVkJywgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcnIuY29kZSA9PT0gNDAxMDIpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogJ2ZhaWxlZCcsIGVycm9yOiBlcnIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyLnN0YXR1c0NvZGUgPT09IEh0dHBTdGF0dXNDb2Rlc18xLmRlZmF1bHQuRm9yYmlkZGVuKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ0NsaWVudCBjb25maWd1cmVkIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIHJldHVybmVkIDQwMzsgZmFpbGluZyB0aGUgY29ubmVjdGlvbic7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKCknLCBtc2cpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiAnZmFpbGVkJywgZXJyb3I6IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgODAwMTksIDQwMywgZXJyKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnQ2xpZW50IGNvbmZpZ3VyZWQgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgcmVxdWVzdCBmYWlsZWQnO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZScsIG1zZyk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IHRoaXMuc3RhdGUuZmFpbFN0YXRlLCBlcnJvcjogbmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA4MDAxOSwgNDAxLCBlcnIpIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZSA9IGZ1bmN0aW9uIChjb25uZWN0aW9uRGV0YWlscywgdHJhbnNwb3J0KSB7XG4gICAgICAgIGlmICghY29ubmVjdGlvbkRldGFpbHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25EZXRhaWxzID0gY29ubmVjdGlvbkRldGFpbHM7XG4gICAgICAgIGlmIChjb25uZWN0aW9uRGV0YWlscy5tYXhNZXNzYWdlU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1heE1lc3NhZ2VTaXplID0gY29ubmVjdGlvbkRldGFpbHMubWF4TWVzc2FnZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsaWVudElkID0gY29ubmVjdGlvbkRldGFpbHMuY2xpZW50SWQ7XG4gICAgICAgIGlmIChjbGllbnRJZCkge1xuICAgICAgICAgICAgdmFyIGVyciA9IHRoaXMucmVhbHRpbWUuYXV0aC5fdW5jaGVja2VkU2V0Q2xpZW50SWQoY2xpZW50SWQpO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZSgpJywgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIC8qIEVycm9ycyBzZXR0aW5nIHRoZSBjbGllbnRJZCBhcmUgZmF0YWwgdG8gdGhlIGNvbm5lY3Rpb24gKi9cbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuZmFpbChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubmVjdGlvblN0YXRlVHRsID0gY29ubmVjdGlvbkRldGFpbHMuY29ubmVjdGlvblN0YXRlVHRsO1xuICAgICAgICBpZiAoY29ubmVjdGlvblN0YXRlVHRsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCA9IGNvbm5lY3Rpb25TdGF0ZVR0bDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1heElkbGVJbnRlcnZhbCA9IGNvbm5lY3Rpb25EZXRhaWxzLm1heElkbGVJbnRlcnZhbDtcbiAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0aW9uZGV0YWlscycsIGNvbm5lY3Rpb25EZXRhaWxzKTtcbiAgICB9O1xuICAgIC8qKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiB0cmFuc3BvcnQgbWFuYWdlbWVudFxuICAgICAqKioqKioqKioqKioqKioqKioqKiovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0cyA9IHt9O1xuICAgIHJldHVybiBDb25uZWN0aW9uTWFuYWdlcjtcbn0oZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKSkpXG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBldmVudGVtaXR0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNykpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgTWVzc2FnZVF1ZXVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1lc3NhZ2VRdWV1ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXNzYWdlUXVldWUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm1lc3NhZ2VzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXMubGVuZ3RoO1xuICAgIH07XG4gICAgTWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgTWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuc2hpZnQoKTtcbiAgICB9O1xuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNbdGhpcy5tZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuY29weUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuc2xpY2UoKTtcbiAgICB9O1xuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKG1lc3NhZ2VzKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMucHVzaC5hcHBseSh0aGlzLm1lc3NhZ2VzLCBtZXNzYWdlcyk7XG4gICAgfTtcbiAgICBNZXNzYWdlUXVldWUucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiAobWVzc2FnZXMpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy51bnNoaWZ0LmFwcGx5KHRoaXMubWVzc2FnZXMsIG1lc3NhZ2VzKTtcbiAgICB9O1xuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuY29tcGxldGVNZXNzYWdlcyA9IGZ1bmN0aW9uIChzZXJpYWwsIGNvdW50LCBlcnIpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdNZXNzYWdlUXVldWUuY29tcGxldGVNZXNzYWdlcygpJywgJ3NlcmlhbCA9ICcgKyBzZXJpYWwgKyAnOyBjb3VudCA9ICcgKyBjb3VudCk7XG4gICAgICAgIGVyciA9IGVyciB8fCBudWxsO1xuICAgICAgICB2YXIgbWVzc2FnZXMgPSB0aGlzLm1lc3NhZ2VzO1xuICAgICAgICBpZiAobWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKCk6IGNvbXBsZXRlTWVzc2FnZXMgY2FsbGVkIG9uIGFueSBlbXB0eSBNZXNzYWdlUXVldWUnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3QgPSBtZXNzYWdlc1swXTtcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRTZXJpYWwgPSBmaXJzdC5tZXNzYWdlLm1zZ1NlcmlhbDtcbiAgICAgICAgICAgIHZhciBlbmRTZXJpYWwgPSBzZXJpYWwgKyBjb3VudDsgLyogdGhlIHNlcmlhbCBvZiB0aGUgZmlyc3QgbWVzc2FnZSB0aGF0IGlzICpub3QqIHRoZSBzdWJqZWN0IG9mIHRoaXMgY2FsbCAqL1xuICAgICAgICAgICAgaWYgKGVuZFNlcmlhbCA+IHN0YXJ0U2VyaWFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBsZXRlTWVzc2FnZXMgPSBtZXNzYWdlcy5zcGxpY2UoMCwgZW5kU2VyaWFsIC0gc3RhcnRTZXJpYWwpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgY29tcGxldGVNZXNzYWdlc18xID0gY29tcGxldGVNZXNzYWdlczsgX2kgPCBjb21wbGV0ZU1lc3NhZ2VzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gY29tcGxldGVNZXNzYWdlc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2lkbGUnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jb21wbGV0ZUFsbE1lc3NhZ2VzID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmNvbXBsZXRlTWVzc2FnZXMoMCwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgTnVtYmVyLk1BWF9WQUxVRSwgZXJyKTtcbiAgICB9O1xuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUucmVzZXRTZW5kQXR0ZW1wdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5tZXNzYWdlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSBfYVtfaV07XG4gICAgICAgICAgICBtc2cuc2VuZEF0dGVtcHRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXNzYWdlUXVldWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ01lc3NhZ2VRdWV1ZS5jbGVhcigpJywgJ2NsZWFyaW5nICcgKyB0aGlzLm1lc3NhZ2VzLmxlbmd0aCArICcgbWVzc2FnZXMnKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgICAgICB0aGlzLmVtaXQoJ2lkbGUnKTtcbiAgICB9O1xuICAgIHJldHVybiBNZXNzYWdlUXVldWU7XG59KGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE1lc3NhZ2VRdWV1ZTtcblxuXG4vKioqLyB9KSxcbi8qIDM3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbm5lY3Rpb25TdGF0ZUNoYW5nZShwcmV2aW91cywgY3VycmVudCwgcmV0cnlJbiwgcmVhc29uKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICAgICAgaWYgKHJldHJ5SW4pXG4gICAgICAgICAgICB0aGlzLnJldHJ5SW4gPSByZXRyeUluO1xuICAgICAgICBpZiAocmVhc29uKVxuICAgICAgICAgICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgfVxuICAgIHJldHVybiBDb25uZWN0aW9uU3RhdGVDaGFuZ2U7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvblN0YXRlQ2hhbmdlO1xuXG5cbi8qKiovIH0pLFxuLyogMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBwcm90b2NvbG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTApKTtcbnZhciBldmVudGVtaXR0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNykpO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgY2hhbm5lbF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzMykpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgcmVhbHRpbWVwcmVzZW5jZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg1NCkpO1xudmFyIG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOSkpO1xudmFyIGNoYW5uZWxzdGF0ZWNoYW5nZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzOSkpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgcHJlc2VuY2VtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KSk7XG52YXIgY29ubmVjdGlvbmVycm9yc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyMCkpO1xudmFyIGFjdGlvbnMgPSBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LkFjdGlvbjtcbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuZnVuY3Rpb24gdmFsaWRhdGVDaGFubmVsT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgJ3BhcmFtcycgaW4gb3B0aW9ucyAmJiAhVXRpbHMuaXNPYmplY3Qob3B0aW9ucy5wYXJhbXMpKSB7XG4gICAgICAgIHJldHVybiBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnb3B0aW9ucy5wYXJhbXMgbXVzdCBiZSBhbiBvYmplY3QnLCA0MDAwMCwgNDAwKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgJ21vZGVzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmICghVXRpbHMuaXNBcnJheShvcHRpb25zLm1vZGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdvcHRpb25zLm1vZGVzIG11c3QgYmUgYW4gYXJyYXknLCA0MDAwMCwgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMubW9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TW9kZSA9IG9wdGlvbnMubW9kZXNbaV07XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRNb2RlIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGN1cnJlbnRNb2RlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgICFVdGlscy5hcnJJbihwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmNoYW5uZWxNb2RlcywgU3RyaW5nLnByb3RvdHlwZS50b1VwcGVyQ2FzZS5jYWxsKGN1cnJlbnRNb2RlKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0ludmFsaWQgY2hhbm5lbCBtb2RlOiAnICsgY3VycmVudE1vZGUsIDQwMDAwLCA0MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxudmFyIFJlYWx0aW1lQ2hhbm5lbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZWFsdGltZUNoYW5uZWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVhbHRpbWVDaGFubmVsKHJlYWx0aW1lLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJlYWx0aW1lLCBuYW1lLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICAgICAgX3RoaXMuaGlzdG9yeSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5oaXN0b3J5KCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLm5hbWUpO1xuICAgICAgICAgICAgLyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2hpc3RvcnknLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW1zICYmIHBhcmFtcy51bnRpbEF0dGFjaCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnYXR0YWNoZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdvcHRpb24gdW50aWxBdHRhY2ggcmVxdWlyZXMgdGhlIGNoYW5uZWwgdG8gYmUgYXR0YWNoZWQnLCA0MDAwMCwgNDAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCd1bnRpbEF0dGFjaCB3YXMgc3BlY2lmaWVkIGFuZCBjaGFubmVsIGlzIGF0dGFjaGVkLCBidXQgYXR0YWNoU2VyaWFsIGlzIG5vdCBkZWZpbmVkJywgNDAwMDAsIDQwMCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXMudW50aWxBdHRhY2g7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmZyb21fc2VyaWFsID0gdGhpcy5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYW5uZWxfMS5kZWZhdWx0LnByb3RvdHlwZS5faGlzdG9yeS5jYWxsKHRoaXMsIHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy53aGVuU3RhdGUgPSAoZnVuY3Rpb24gKHN0YXRlLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQucHJvdG90eXBlLndoZW5TdGF0ZS5jYWxsKF90aGlzLCBzdGF0ZSwgX3RoaXMuc3RhdGUsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsKCknLCAnc3RhcnRlZDsgbmFtZSA9ICcgKyBuYW1lKTtcbiAgICAgICAgX3RoaXMucmVhbHRpbWUgPSByZWFsdGltZTtcbiAgICAgICAgX3RoaXMucHJlc2VuY2UgPSBuZXcgcmVhbHRpbWVwcmVzZW5jZV8xLmRlZmF1bHQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IHJlYWx0aW1lLmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgICAgIF90aGlzLnN0YXRlID0gJ2luaXRpYWxpemVkJztcbiAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBldmVudGVtaXR0ZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIF90aGlzLnN5bmNDaGFubmVsU2VyaWFsID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5wcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgYXR0YWNoU2VyaWFsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaGFubmVsU2VyaWFsOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIF90aGlzLmVycm9yUmVhc29uID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX3JlcXVlc3RlZEZsYWdzID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX21vZGUgPSBudWxsO1xuICAgICAgICBfdGhpcy5fYXR0YWNoUmVzdW1lID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9kZWNvZGluZ0NvbnRleHQgPSB7XG4gICAgICAgICAgICBjaGFubmVsT3B0aW9uczogX3RoaXMuY2hhbm5lbE9wdGlvbnMsXG4gICAgICAgICAgICBwbHVnaW5zOiByZWFsdGltZS5vcHRpb25zLnBsdWdpbnMgfHwge30sXG4gICAgICAgICAgICBiYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fbGFzdFBheWxvYWQgPSB7XG4gICAgICAgICAgICBtZXNzYWdlSWQ6IG51bGwsXG4gICAgICAgICAgICBwcm90b2NvbE1lc3NhZ2VDaGFubmVsU2VyaWFsOiBudWxsLFxuICAgICAgICAgICAgZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzczogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgLyogT25seSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoaXMgYW5kIHRoZSBwdWJsaWMgZXZlbnQgZW1pdHRlciBpcyB0aGF0IHRoaXMgZW1pdHMgYW5cbiAgICAgICAgICogdXBkYXRlIGV2ZW50IGZvciBhbGwgQVRUQUNIRURzLCB3aGV0aGVyIHJlc3VtZWQgb3Igbm90ICovXG4gICAgICAgIF90aGlzLl9hbGxDaGFubmVsQ2hhbmdlcyA9IG5ldyBldmVudGVtaXR0ZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5pbnZhbGlkU3RhdGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdDaGFubmVsIG9wZXJhdGlvbiBmYWlsZWQgYXMgY2hhbm5lbCBzdGF0ZSBpcyAnICsgdGhpcy5zdGF0ZSwgOTAwMDEsIDQwMCwgdGhpcy5lcnJvclJlYXNvbiB8fCB1bmRlZmluZWQpO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NMaXN0ZW5lckFyZ3MgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqL1xuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3NldE9wdGlvbnMnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBfY2FsbGJhY2sgPSBjYWxsYmFjayB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdSZWFsdGltZUNoYW5uZWwuc2V0T3B0aW9ucygpJywgJ1NldCBvcHRpb25zIGZhaWxlZDogJyArIGVyci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB2YXIgZXJyID0gdmFsaWRhdGVDaGFubmVsT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgX2NhbGxiYWNrKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2hhbm5lbF8xLmRlZmF1bHQucHJvdG90eXBlLnNldE9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuX2RlY29kaW5nQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMuX2RlY29kaW5nQ29udGV4dC5jaGFubmVsT3B0aW9ucyA9IHRoaXMuY2hhbm5lbE9wdGlvbnM7XG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRSZWF0dGFjaFRvU2V0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgICAgICAgLyogVGhpcyBkb2VzIG5vdCBqdXN0IGRvIF9hdHRhY2godHJ1ZSwgbnVsbCwgY2FsbGJhY2spIGJlY2F1c2UgdGhhdCB3b3VsZCBwdXQgdXNcbiAgICAgICAgICAgICAqIGludG8gdGhlICdhdHRhY2hpbmcnIHN0YXRlIHVudGlsIHdlIHJlY2VpdmUgdGhlIG5ldyBhdHRhY2hlZCwgd2hpY2ggaXNcbiAgICAgICAgICAgICAqIGNvbmNlcHR1YWxseSBpbmNvcnJlY3Q6IHdlIGFyZSBzdGlsbCBhdHRhY2hlZCwgd2UganVzdCBoYXZlIGEgcGVuZGluZyByZXF1ZXN0IHRvXG4gICAgICAgICAgICAgKiBjaGFuZ2Ugc29tZSBjaGFubmVsIHBhcmFtcy4gUGVyIFJUTDE3IGdvaW5nIGludG8gdGhlIGF0dGFjaGluZyBzdGF0ZSB3b3VsZCBtZWFuXG4gICAgICAgICAgICAgKiByZWplY3RpbmcgbWVzc2FnZXMgdW50aWwgd2UgaGF2ZSBjb25maXJtYXRpb24gdGhhdCB0aGUgb3B0aW9ucyBoYXZlIGNoYW5nZWQsXG4gICAgICAgICAgICAgKiB3aGljaCB3b3VsZCB1bm5lY2Vzc2FyaWx5IGxvc2UgbWVzc2FnZSBjb250aW51aXR5LiAqL1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hJbXBsKCk7XG4gICAgICAgICAgICAvLyBJZ25vcmUgJ2F0dGFjaGluZycgLS0gY291bGQgYmUganVzdCBkdWUgdG8gdG8gYSByZXN1bWUgJiByZWF0dGFjaCwgc2hvdWxkIG5vdFxuICAgICAgICAgICAgLy8gY2FsbCBiYWNrIHNldE9wdGlvbnMgdW50aWwgd2UncmUgZGVmaW5pdGVseSBhdHRhY2hlZCB3aXRoIHRoZSBuZXcgb3B0aW9ucyAob3JcbiAgICAgICAgICAgIC8vIGVsc2UgaW4gYSB0ZXJtaW5hbCBzdGF0ZSlcbiAgICAgICAgICAgIHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLm9uY2UoWydhdHRhY2hlZCcsICd1cGRhdGUnLCAnZGV0YWNoZWQnLCAnZmFpbGVkJ10sIGZ1bmN0aW9uIChzdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5ldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd1cGRhdGUnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdhdHRhY2hlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBfY2FsbGJhY2sgPT09IG51bGwgfHwgX2NhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBfY2FsbGJhY2sgPT09IG51bGwgfHwgX2NhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY2FsbGJhY2soc3RhdGVDaGFuZ2UucmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9jYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLl9zaG91bGRSZWF0dGFjaFRvU2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zdGF0ZSA9PT0gJ2F0dGFjaGVkJyB8fCB0aGlzLnN0YXRlID09PSAnYXR0YWNoaW5nJykgJiYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKSB8fCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGVzKSk7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lc3NhZ2VzID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGFyZ0NvdW50ID0gYXJncy5sZW5ndGg7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbYXJnQ291bnQgLSAxXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3B1Ymxpc2gnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICAgICAgKythcmdDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5jb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJnQ291bnQgPT0gMikge1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0KG1lc3NhZ2VzKSlcbiAgICAgICAgICAgICAgICBtZXNzYWdlcyA9IFttZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKG1lc3NhZ2VzKV07XG4gICAgICAgICAgICBlbHNlIGlmIChVdGlscy5pc0FycmF5KG1lc3NhZ2VzKSlcbiAgICAgICAgICAgICAgICBtZXNzYWdlcyA9IG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXNBcnJheShtZXNzYWdlcyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1RoZSBzaW5nbGUtYXJndW1lbnQgZm9ybSBvZiBwdWJsaXNoKCkgZXhwZWN0cyBhIG1lc3NhZ2Ugb2JqZWN0IG9yIGFuIGFycmF5IG9mIG1lc3NhZ2Ugb2JqZWN0cycsIDQwMDEzLCA0MDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZXMgPSBbbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyh7IG5hbWU6IGFyZ3NbMF0sIGRhdGE6IGFyZ3NbMV0gfSldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhNZXNzYWdlU2l6ZSA9IHRoaXMucmVhbHRpbWUub3B0aW9ucy5tYXhNZXNzYWdlU2l6ZTtcbiAgICAgICAgbWVzc2FnZV8xLmRlZmF1bHQuZW5jb2RlQXJyYXkobWVzc2FnZXMsIHRoaXMuY2hhbm5lbE9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFJTTDFpICovXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IG1lc3NhZ2VfMS5kZWZhdWx0LmdldE1lc3NhZ2VzU2l6ZShtZXNzYWdlcyk7XG4gICAgICAgICAgICBpZiAoc2l6ZSA+IG1heE1lc3NhZ2VTaXplKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ01heGltdW0gc2l6ZSBvZiBtZXNzYWdlcyB0aGF0IGNhbiBiZSBwdWJsaXNoZWQgYXQgb25jZSBleGNlZWRlZCAoIHdhcyAnICtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSArXG4gICAgICAgICAgICAgICAgICAgICcgYnl0ZXM7IGxpbWl0IGlzICcgK1xuICAgICAgICAgICAgICAgICAgICBtYXhNZXNzYWdlU2l6ZSArXG4gICAgICAgICAgICAgICAgICAgICcgYnl0ZXMpJywgNDAwMDksIDQwMCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl9fcHVibGlzaChtZXNzYWdlcywgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIERvdWJsZSB1bmRlcnNjb3JlIHVzZWQgdG8gcHJldmVudCB0eXBlIGNvbmZsaWN0IHdpdGggdW5kZXJseWluZyBDaGFubmVsLl9wdWJsaXNoIG1ldGhvZFxuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuX19wdWJsaXNoID0gZnVuY3Rpb24gKG1lc3NhZ2VzLCBjYWxsYmFjaykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5wdWJsaXNoKCknLCAnbWVzc2FnZSBjb3VudCA9ICcgKyBtZXNzYWdlcy5sZW5ndGgpO1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICAgICAgY2FzZSAnc3VzcGVuZGVkJzpcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXModGhpcy5pbnZhbGlkU3RhdGVFcnJvcigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwucHVibGlzaCgpJywgJ3NlbmRpbmcgbWVzc2FnZTsgY2hhbm5lbCBzdGF0ZSBpcyAnICsgc3RhdGUpO1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSBuZXcgcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIG1zZy5hY3Rpb24gPSBhY3Rpb25zLk1FU1NBR0U7XG4gICAgICAgICAgICAgICAgbXNnLmNoYW5uZWwgPSB0aGlzLm5hbWU7XG4gICAgICAgICAgICAgICAgbXNnLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShtc2csIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5vbkV2ZW50ID0gZnVuY3Rpb24gKG1lc3NhZ2VzKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLm9uRXZlbnQoKScsICdyZWNlaXZlZCBtZXNzYWdlJyk7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG1lc3NhZ2VzW2ldO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5lbWl0KG1lc3NhZ2UubmFtZSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKGZsYWdzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2ZsYWdzO1xuICAgICAgICBpZiAodHlwZW9mIGZsYWdzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGZsYWdzO1xuICAgICAgICAgICAgX2ZsYWdzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9mbGFncyA9IGZsYWdzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdhdHRhY2gnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NQUpPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5hdHRhY2goKScsICdDaGFubmVsIGF0dGFjaCBmYWlsZWQ6ICcgKyBlcnIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2ZsYWdzKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlcHJlY2F0ZWQoJ2NoYW5uZWwuYXR0YWNoKCkgd2l0aCBmbGFncycsICdjaGFubmVsLnNldE9wdGlvbnMoKSB3aXRoIGNoYW5uZWxPcHRpb25zLnBhcmFtcycpO1xuICAgICAgICAgICAgLyogSWYgZmxhZ3MgcmVxdWVzdGVkLCBhbHdheXMgZG8gYSByZS1hdHRhY2guIFRPRE8gb25seSBkbyB0aGlzIGlmXG4gICAgICAgICAgICAgKiBjdXJyZW50IG1vZGUgZGlmZmVycyBmcm9tIHJlcXVlc3RlZCBtb2RlICovXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ZWRGbGFncyA9IF9mbGFncztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAnYXR0YWNoZWQnKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hdHRhY2goZmFsc2UsIG51bGwsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuX2F0dGFjaCA9IGZ1bmN0aW9uIChmb3JjZVJlYXR0YWNoLCBhdHRhY2hSZWFzb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdSZWFsdGltZUNoYW5uZWwuX2F0dGFjaCgpJywgJ0NoYW5uZWwgYXR0YWNoIGZhaWxlZDogJyArIGVyci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25uZWN0aW9uTWFuYWdlciA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgICAgIGlmICghY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgICAgICAgY2FsbGJhY2soY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdhdHRhY2hpbmcnIHx8IGZvcmNlUmVhdHRhY2gpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKCdhdHRhY2hpbmcnLCBhdHRhY2hSZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25jZShmdW5jdGlvbiAoc3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5ldmVudCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2F0dGFjaGVkJzpcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKG51bGwsIHN0YXRlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGV0YWNoZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3N1c3BlbmRlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1VuYWJsZSB0byBhdHRhY2g7IHJlYXNvbiB1bmtub3duOyBzdGF0ZSA9ICcgKyB0aGlzLmV2ZW50LCA5MDAwMCwgNTAwKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RldGFjaGluZyc6XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnQXR0YWNoIHJlcXVlc3Qgc3VwZXJzZWRlZCBieSBhIHN1YnNlcXVlbnQgZGV0YWNoIHJlcXVlc3QnLCA5MDAwMCwgNDA5KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuYXR0YWNoSW1wbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwuYXR0YWNoSW1wbCgpJywgJ3NlbmRpbmcgQVRUQUNIIG1lc3NhZ2UnKTtcbiAgICAgICAgdmFyIGF0dGFjaE1zZyA9IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbnMuQVRUQUNILFxuICAgICAgICAgICAgY2hhbm5lbDogdGhpcy5uYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLmNoYW5uZWxPcHRpb25zLnBhcmFtcyxcbiAgICAgICAgICAgIC8vIFJUTDRjMTogSW5jbHVkZXMgdGhlIGNoYW5uZWwgc2VyaWFsIHRvIHJlc3VtZSBmcm9tIGEgcHJldmlvdXMgbWVzc2FnZVxuICAgICAgICAgICAgLy8gb3IgYXR0YWNobWVudC5cbiAgICAgICAgICAgIGNoYW5uZWxTZXJpYWw6IHRoaXMucHJvcGVydGllcy5jaGFubmVsU2VyaWFsLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RlZEZsYWdzKSB7XG4gICAgICAgICAgICBhdHRhY2hNc2cuZW5jb2RlTW9kZXNUb0ZsYWdzKHRoaXMuX3JlcXVlc3RlZEZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNoYW5uZWxPcHRpb25zLm1vZGVzKSB7XG4gICAgICAgICAgICBhdHRhY2hNc2cuZW5jb2RlTW9kZXNUb0ZsYWdzKFV0aWxzLmFsbFRvVXBwZXJDYXNlKHRoaXMuY2hhbm5lbE9wdGlvbnMubW9kZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYXR0YWNoUmVzdW1lKSB7XG4gICAgICAgICAgICBhdHRhY2hNc2cuc2V0RmxhZygnQVRUQUNIX1JFU1VNRScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzKSB7XG4gICAgICAgICAgICBhdHRhY2hNc2cuY2hhbm5lbFNlcmlhbCA9IHRoaXMuX2xhc3RQYXlsb2FkLnByb3RvY29sTWVzc2FnZUNoYW5uZWxTZXJpYWw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShhdHRhY2hNc2csIG5vb3ApO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2RldGFjaCcsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N1c3BlbmRlZCc6XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSgnZGV0YWNoZWQnKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGV0YWNoZWQnOlxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdVbmFibGUgdG8gZGV0YWNoOyBjaGFubmVsIHN0YXRlID0gZmFpbGVkJywgOTAwMDEsIDQwMCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RTdGF0ZSgnZGV0YWNoaW5nJyk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ2RldGFjaGluZyc6XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKGZ1bmN0aW9uIChzdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RldGFjaGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXR0YWNoZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3VzcGVuZGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soc3RhdGVDaGFuZ2UucmVhc29uIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1VuYWJsZSB0byBkZXRhY2g7IHJlYXNvbiB1bmtub3duOyBzdGF0ZSA9ICcgKyB0aGlzLmV2ZW50LCA5MDAwMCwgNTAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhdHRhY2hpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdEZXRhY2ggcmVxdWVzdCBzdXBlcnNlZGVkIGJ5IGEgc3Vic2VxdWVudCBhdHRhY2ggcmVxdWVzdCcsIDkwMDAwLCA0MDkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmRldGFjaEltcGwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwuZGV0YWNoKCknLCAnc2VuZGluZyBERVRBQ0ggbWVzc2FnZScpO1xuICAgICAgICB2YXIgbXNnID0gcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHsgYWN0aW9uOiBhY3Rpb25zLkRFVEFDSCwgY2hhbm5lbDogdGhpcy5uYW1lIH0pO1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKG1zZywgY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTsgLyogW2V2ZW50XSwgbGlzdGVuZXIsIFtjYWxsYmFja10gKi9cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwIC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGggLyogW2V2ZW50XSwgbGlzdGVuZXIsIFtjYWxsYmFja10gKi87IF9pKysgLyogW2V2ZW50XSwgbGlzdGVuZXIsIFtjYWxsYmFja10gKi8pIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTsgLyogW2V2ZW50XSwgbGlzdGVuZXIsIFtjYWxsYmFja10gKi9cbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSBSZWFsdGltZUNoYW5uZWwucHJvY2Vzc0xpc3RlbmVyQXJncyhhcmdzKSwgZXZlbnQgPSBfYVswXSwgbGlzdGVuZXIgPSBfYVsxXSwgY2FsbGJhY2sgPSBfYVsyXTtcbiAgICAgICAgaWYgKCFjYWxsYmFjayAmJiB0aGlzLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3N1YnNjcmliZScsIFtldmVudCwgbGlzdGVuZXJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXModGhpcy5pbnZhbGlkU3RhdGVFcnJvcigpKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlsdGVyZWRcbiAgICAgICAgaWYgKGV2ZW50ICYmIHR5cGVvZiBldmVudCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVGaWx0ZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmF0dGFjaChjYWxsYmFjayB8fCBub29wKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuX3N1YnNjcmliZUZpbHRlciA9IGZ1bmN0aW9uIChmaWx0ZXIsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBmaWx0ZXJlZExpc3RlbmVyID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogbS5uYW1lLFxuICAgICAgICAgICAgICAgIHJlZlRpbWVzZXJpYWw6IChfYiA9IChfYSA9IG0uZXh0cmFzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudGltZXNlcmlhbCxcbiAgICAgICAgICAgICAgICByZWZUeXBlOiAoX2QgPSAoX2MgPSBtLmV4dHJhcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlZikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnR5cGUsXG4gICAgICAgICAgICAgICAgaXNSZWY6ICEhKChfZiA9IChfZSA9IG0uZXh0cmFzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UucmVmKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YudGltZXNlcmlhbCksXG4gICAgICAgICAgICAgICAgY2xpZW50SWQ6IG0uY2xpZW50SWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW55IHZhbHVlcyBhcmUgZGVmaW5lZCBpbiB0aGUgZmlsdGVyIGFuZCBpZiB0aGV5IG1hdGNoIHRoZSB2YWx1ZSBpbiB0aGUgbWVzc2FnZSBvYmplY3RcbiAgICAgICAgICAgIGlmIChPYmplY3QuZW50cmllcyhmaWx0ZXIpLmZpbmQoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF9hWzBdLCB2YWx1ZSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gbWFwcGluZ1trZXldICE9PSB2YWx1ZSA6IGZhbHNlO1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0ZW5lcihtKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fYWRkRmlsdGVyZWRTdWJzY3JpcHRpb24oZmlsdGVyLCBsaXN0ZW5lciwgZmlsdGVyZWRMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vbihmaWx0ZXJlZExpc3RlbmVyKTtcbiAgICB9O1xuICAgIC8vIEFkZHMgYSBuZXcgZmlsdGVyZWQgc3Vic2NyaXB0aW9uXG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5fYWRkRmlsdGVyZWRTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoZmlsdGVyLCByZWFsTGlzdGVuZXIsIGZpbHRlcmVkTGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuZmlsdGVyZWRTdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcmVkU3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuaGFzKHJlYWxMaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIHZhciByZWFsTGlzdGVuZXJNYXAgPSB0aGlzLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5nZXQocmVhbExpc3RlbmVyKTtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgZmlsdGVyZWQgbGlzdGVuZXIgdG8gdGhlIG1hcCwgb3IgYXBwZW5kIHRvIHRoZSBhcnJheSBpZiB0aGlzIGZpbHRlciBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcbiAgICAgICAgICAgIHJlYWxMaXN0ZW5lck1hcC5zZXQoZmlsdGVyLCAoKF9hID0gcmVhbExpc3RlbmVyTWFwID09PSBudWxsIHx8IHJlYWxMaXN0ZW5lck1hcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVhbExpc3RlbmVyTWFwLmdldChmaWx0ZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uY2F0KGZpbHRlcmVkTGlzdGVuZXIpKSB8fCBbZmlsdGVyZWRMaXN0ZW5lcl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuc2V0KHJlYWxMaXN0ZW5lciwgbmV3IE1hcChbW2ZpbHRlciwgW2ZpbHRlcmVkTGlzdGVuZXJdXV0pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5fZ2V0QW5kRGVsZXRlRmlsdGVyZWRTdWJzY3JpcHRpb25zID0gZnVuY3Rpb24gKGZpbHRlciwgcmVhbExpc3RlbmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIE5vIGZpbHRlcmVkIHN1YnNjcmlwdGlvbnMgbWFwIG1lYW5zIHRoZXJlIGhhcyBiZWVuIG5vIGZpbHRlcmVkIHN1YnNjcmlwdGlvbnMgeWV0LCBzbyByZXR1cm4gbm90aGluZ1xuICAgICAgICBpZiAoIXRoaXMuZmlsdGVyZWRTdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBhIGZpbHRlciBpcyBwYXNzZWQgaW4gd2l0aCBubyBzcGVjaWZpYyBsaXN0ZW5lclxuICAgICAgICBpZiAoIXJlYWxMaXN0ZW5lciAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIC8vIFJldHVybiBlYWNoIGxpc3RlbmVyIHdoaWNoIGlzIGF0dGFjaGVkIHRvIHRoZSBzcGVjaWZpZWQgZmlsdGVyIG9iamVjdFxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuZW50cmllcygpKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfYVswXSwgZmlsdGVyTWFwcyA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIC8vIEdldCAodGhlbiBkZWxldGUpIHRoZSBtYXBzIG1hdGNoaW5nIHRoaXMgZmlsdGVyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyTWFwcyA9IGZpbHRlck1hcHMuZ2V0KGZpbHRlcik7XG4gICAgICAgICAgICAgICAgZmlsdGVyTWFwcy5kZWxldGUoZmlsdGVyKTtcbiAgICAgICAgICAgICAgICAvLyBDbGVhciB0aGUgcGFyZW50IGlmIG5vdGhpbmcgaXMgbGVmdFxuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJNYXBzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgKF9iID0gX3RoaXMuZmlsdGVyZWRTdWJzY3JpcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lck1hcHM7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGN1ciA/IChfYSA9IHByZXYpLmNvbmNhdC5hcHBseShfYSwgY3VyKSA6IHByZXYpO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIHN1YnNjcmlwdGlvbnMgZm9yIHRoaXMgbGlzdGVuZXJcbiAgICAgICAgaWYgKCFyZWFsTGlzdGVuZXIgfHwgIXRoaXMuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmhhcyhyZWFsTGlzdGVuZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlYWxMaXN0ZW5lck1hcCA9IHRoaXMuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmdldChyZWFsTGlzdGVuZXIpO1xuICAgICAgICAvLyBJZiBubyBmaWx0ZXIgaXMgc3BlY2lmaWVkIHJldHVybiBhbGwgbGlzdGVuZXJzIHVzaW5nIHRoYXQgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFmaWx0ZXIpIHtcbiAgICAgICAgICAgIC8vIGFycmF5LmZsYXQgaXMgbm90IGF2YWlsYWJsZSB1bmxlc3Mgd2Ugc3VwcG9ydCBlczIwMTkgb3IgaGlnaGVyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzXzEgPSBBcnJheS5mcm9tKHJlYWxMaXN0ZW5lck1hcC52YWx1ZXMoKSkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXIpIHsgcmV0dXJuIHByZXYuY29uY2F0LmFwcGx5KHByZXYsIGN1cik7IH0sIFtdKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgbGlzdGVuZXIgZnJvbSB0aGUgbWFwXG4gICAgICAgICAgICB0aGlzLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5kZWxldGUocmVhbExpc3RlbmVyKTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnNfMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gcmVhbExpc3RlbmVyTWFwLmdldChmaWx0ZXIpO1xuICAgICAgICByZWFsTGlzdGVuZXJNYXAuZGVsZXRlKGZpbHRlcik7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcnMgfHwgW107XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBhcmdzID0gW107IC8qIFtldmVudF0sIGxpc3RlbmVyICovXG4gICAgICAgIGZvciAodmFyIF9pID0gMCAvKiBbZXZlbnRdLCBsaXN0ZW5lciAqLzsgX2kgPCBhcmd1bWVudHMubGVuZ3RoIC8qIFtldmVudF0sIGxpc3RlbmVyICovOyBfaSsrIC8qIFtldmVudF0sIGxpc3RlbmVyICovKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07IC8qIFtldmVudF0sIGxpc3RlbmVyICovXG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9iID0gUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NMaXN0ZW5lckFyZ3MoYXJncyksIGV2ZW50ID0gX2JbMF0sIGxpc3RlbmVyID0gX2JbMV07XG4gICAgICAgIC8vIElmIHdlIGVpdGhlciBoYXZlIGEgZmlsdGVyZWQgbGlzdGVuZXIsIGEgZmlsdGVyIG9yIGJvdGggd2UgbmVlZCB0byBkbyBhZGRpdGlvbmFsIHByb2Nlc3NpbmcgdG8gZmluZCB0aGUgb3JpZ2luYWwgZnVuY3Rpb24ocylcbiAgICAgICAgaWYgKCh0eXBlb2YgZXZlbnQgPT09ICdvYmplY3QnICYmICFsaXN0ZW5lcikgfHwgKChfYSA9IHRoaXMuZmlsdGVyZWRTdWJzY3JpcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFzKGxpc3RlbmVyKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2dldEFuZERlbGV0ZUZpbHRlcmVkU3Vic2NyaXB0aW9ucyhldmVudCwgbGlzdGVuZXIpLmZvckVhY2goZnVuY3Rpb24gKGwpIHsgcmV0dXJuIF90aGlzLnN1YnNjcmlwdGlvbnMub2ZmKGwpOyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIGNoZWNrIHByZWNvbmRpdGlvbnMgKi9cbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdpbml0aWFsaXplZCc6XG4gICAgICAgICAgICBjYXNlICdkZXRhY2hpbmcnOlxuICAgICAgICAgICAgY2FzZSAnZGV0YWNoZWQnOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdVbmFibGUgdG8gc3luYyB0byBjaGFubmVsOyBub3QgYXR0YWNoZWQnLCA0MDAwMCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgICAgIHZhciBjb25uZWN0aW9uTWFuYWdlciA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgICAgIGlmICghY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuICAgICAgICAgICAgdGhyb3cgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBzZW5kIHN5bmMgcmVxdWVzdCAqL1xuICAgICAgICB2YXIgc3luY01lc3NhZ2UgPSBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoeyBhY3Rpb246IGFjdGlvbnMuU1lOQywgY2hhbm5lbDogdGhpcy5uYW1lIH0pO1xuICAgICAgICBpZiAodGhpcy5zeW5jQ2hhbm5lbFNlcmlhbCkge1xuICAgICAgICAgICAgc3luY01lc3NhZ2UuY2hhbm5lbFNlcmlhbCA9IHRoaXMuc3luY0NoYW5uZWxTZXJpYWw7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIuc2VuZChzeW5jTWVzc2FnZSk7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKG1zZywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zZW5kKG1zZywgdGhpcy5yZWFsdGltZS5vcHRpb25zLnF1ZXVlTWVzc2FnZXMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc2VuZFByZXNlbmNlID0gZnVuY3Rpb24gKHByZXNlbmNlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgbXNnID0gcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9ucy5QUkVTRU5DRSxcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIHByZXNlbmNlOiBVdGlscy5pc0FycmF5KHByZXNlbmNlKVxuICAgICAgICAgICAgICAgID8gcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzQXJyYXkocHJlc2VuY2UpXG4gICAgICAgICAgICAgICAgOiBbcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHByZXNlbmNlKV0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKG1zZywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5vbk1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMuQVRUQUNIRUQgfHxcbiAgICAgICAgICAgIG1lc3NhZ2UuYWN0aW9uID09PSBhY3Rpb25zLk1FU1NBR0UgfHxcbiAgICAgICAgICAgIG1lc3NhZ2UuYWN0aW9uID09PSBhY3Rpb25zLlBSRVNFTkNFKSB7XG4gICAgICAgICAgICAvLyBSVEwxNWJcbiAgICAgICAgICAgIHRoaXMuc2V0Q2hhbm5lbFNlcmlhbChtZXNzYWdlLmNoYW5uZWxTZXJpYWwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzeW5jQ2hhbm5lbFNlcmlhbCwgaXNTeW5jID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS5hY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5BVFRBQ0hFRDoge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWwgPSBtZXNzYWdlLmNoYW5uZWxTZXJpYWw7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9kZSA9IG1lc3NhZ2UuZ2V0TW9kZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zID0gbWVzc2FnZS5wYXJhbXMgfHwge307XG4gICAgICAgICAgICAgICAgdmFyIG1vZGVzRnJvbUZsYWdzID0gbWVzc2FnZS5kZWNvZGVNb2Rlc0Zyb21GbGFncygpO1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZXMgPSAobW9kZXNGcm9tRmxhZ3MgJiYgVXRpbHMuYWxsVG9Mb3dlckNhc2UobW9kZXNGcm9tRmxhZ3MpKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VtZWQgPSBtZXNzYWdlLmhhc0ZsYWcoJ1JFU1VNRUQnKTtcbiAgICAgICAgICAgICAgICB2YXIgaGFzUHJlc2VuY2UgPSBtZXNzYWdlLmhhc0ZsYWcoJ0hBU19QUkVTRU5DRScpO1xuICAgICAgICAgICAgICAgIHZhciBoYXNCYWNrbG9nID0gbWVzc2FnZS5oYXNGbGFnKCdIQVNfQkFDS0xPRycpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnYXR0YWNoZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdW1lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogT24gYSBsb3NzIG9mIGNvbnRpbnVpdHksIHRoZSBwcmVzZW5jZSBzZXQgbmVlZHMgdG8gYmUgcmUtc3luY2VkICovXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXNlbmNlLm9uQXR0YWNoZWQoaGFzUHJlc2VuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBuZXcgY2hhbm5lbHN0YXRlY2hhbmdlXzEuZGVmYXVsdCh0aGlzLnN0YXRlLCB0aGlzLnN0YXRlLCByZXN1bWVkLCBoYXNCYWNrbG9nLCBtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWxsQ2hhbm5lbENoYW5nZXMuZW1pdCgndXBkYXRlJywgY2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bWVkIHx8IHRoaXMuY2hhbm5lbE9wdGlvbnMudXBkYXRlT25BdHRhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCBjaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICdkZXRhY2hpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFJUTDVpOiByZS1zZW5kIERFVEFDSCBhbmQgcmVtYWluIGluIHRoZSAnZGV0YWNoaW5nJyBzdGF0ZSAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKCdhdHRhY2hlZCcsIG1lc3NhZ2UuZXJyb3IsIHJlc3VtZWQsIGhhc1ByZXNlbmNlLCBoYXNCYWNrbG9nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGFjdGlvbnMuREVUQUNIRUQ6IHtcbiAgICAgICAgICAgICAgICB2YXIgZGV0YWNoRXJyID0gbWVzc2FnZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICA/IGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyhtZXNzYWdlLmVycm9yKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdDaGFubmVsIGRldGFjaGVkJywgOTAwMDEsIDQwNCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdkZXRhY2hpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoJ2RldGFjaGVkJywgZGV0YWNoRXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ2F0dGFjaGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogT25seSByZXRyeSBpbW1lZGlhdGVseSBpZiB3ZSB3ZXJlIHByZXZpb3VzbHkgYXR0YWNoZWQuIElmIHdlIHdlcmVcbiAgICAgICAgICAgICAgICAgICAgICogYXR0YWNoaW5nLCBnbyBpbnRvIHN1c3BlbmRlZCwgZmFpbCBtZXNzYWdlcywgYW5kIHdhaXQgYSBmZXcgc2Vjb25kc1xuICAgICAgICAgICAgICAgICAgICAgKiBiZWZvcmUgcmV0cnlpbmcgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSgnc3VzcGVuZGVkJywgZGV0YWNoRXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKCdhdHRhY2hpbmcnLCBkZXRhY2hFcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5TWU5DOlxuICAgICAgICAgICAgICAgIC8qIHN5bmNzIGNhbiBoYXZlIGNoYW5uZWxTZXJpYWxzLCBidXQgbWlnaHQgbm90IGlmIHRoZSBzeW5jIGlzIG9uZSBwYWdlIGxvbmcgKi9cbiAgICAgICAgICAgICAgICBpc1N5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN5bmNDaGFubmVsU2VyaWFsID0gdGhpcy5zeW5jQ2hhbm5lbFNlcmlhbCA9IG1lc3NhZ2UuY2hhbm5lbFNlcmlhbDtcbiAgICAgICAgICAgICAgICAvKiBzeW5jcyBjYW4gaGFwcGVuIG9uIGNoYW5uZWxzIHdpdGggbm8gcHJlc2VuY2UgZGF0YSBhcyBwYXJ0IG9mIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgKiByZXN1bWluZywgaW4gd2hpY2ggY2FzZSBwcm90b2NvbCBtZXNzYWdlIGhhcyBubyBwcmVzZW5jZSBwcm9wZXJ0eSAqL1xuICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZS5wcmVzZW5jZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5QUkVTRU5DRToge1xuICAgICAgICAgICAgICAgIHZhciBwcmVzZW5jZSA9IG1lc3NhZ2UucHJlc2VuY2U7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gbWVzc2FnZS5pZCwgY29ubmVjdGlvbklkID0gbWVzc2FnZS5jb25uZWN0aW9uSWQsIHRpbWVzdGFtcCA9IG1lc3NhZ2UudGltZXN0YW1wO1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcbiAgICAgICAgICAgICAgICB2YXIgcHJlc2VuY2VNc2cgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVzZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2VNc2cgPSBwcmVzZW5jZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbmNlbWVzc2FnZV8xLmRlZmF1bHQuZGVjb2RlKHByZXNlbmNlTXNnLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJlc2VuY2VNc2cuY29ubmVjdGlvbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbmNlTXNnLmNvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb25JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJlc2VuY2VNc2cudGltZXN0YW1wKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbmNlTXNnLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJlc2VuY2VNc2cuaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2VNc2cuaWQgPSBpZCArICc6JyArIGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uTWVzc2FnZSgpJywgZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnByZXNlbmNlLnNldFByZXNlbmNlKHByZXNlbmNlLCBpc1N5bmMsIHN5bmNDaGFubmVsU2VyaWFsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5NRVNTQUdFOiB7XG4gICAgICAgICAgICAgICAgLy9SVEwxN1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnYXR0YWNoZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01BSk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uTWVzc2FnZSgpJywgJ01lc3NhZ2UgXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1wiIHNraXBwZWQgYXMgdGhpcyBjaGFubmVsIFwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1wiIHN0YXRlIGlzIG5vdCBcImF0dGFjaGVkXCIgKHN0YXRlIGlzIFwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcIikuJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VzID0gbWVzc2FnZS5tZXNzYWdlcywgZmlyc3RNZXNzYWdlID0gbWVzc2FnZXNbMF0sIGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV0sIGlkID0gbWVzc2FnZS5pZCwgY29ubmVjdGlvbklkID0gbWVzc2FnZS5jb25uZWN0aW9uSWQsIHRpbWVzdGFtcCA9IG1lc3NhZ2UudGltZXN0YW1wO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdE1lc3NhZ2UuZXh0cmFzICYmXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0TWVzc2FnZS5leHRyYXMuZGVsdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RNZXNzYWdlLmV4dHJhcy5kZWx0YS5mcm9tICE9PSB0aGlzLl9sYXN0UGF5bG9hZC5tZXNzYWdlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdEZWx0YSBtZXNzYWdlIGRlY29kZSBmYWlsdXJlIC0gcHJldmlvdXMgbWVzc2FnZSBub3QgYXZhaWxhYmxlIGZvciBtZXNzYWdlIFwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcIiBvbiB0aGlzIGNoYW5uZWwgXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXCIuJztcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCBtc2cpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydERlY29kZUZhaWx1cmVSZWNvdmVyeShuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDQwMDE4LCA0MDApKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IG1lc3NhZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZV8xLmRlZmF1bHQuZGVjb2RlKG1zZywgdGhpcy5fZGVjb2RpbmdDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogZGVjcnlwdCBmYWlsZWQgLi4gdGhlIG1vc3QgbGlrZWx5IGNhdXNlIGlzIHRoYXQgd2UgaGF2ZSB0aGUgd3Jvbmcga2V5ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbk1lc3NhZ2UoKScsIGUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGUuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDAwMTg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGRlY29kZSBmYWlsdXJlICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0RGVjb2RlRmFpbHVyZVJlY292ZXJ5KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MDAxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBObyB2Y2RpZmYgcGx1Z2luIHBhc3NlZCBpbiAtIG5vIHBvaW50IHJlY292ZXJpbmcsIGdpdmUgdXAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQwMDIxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgZGVsdGFzLCBzaW1pbGFybHkgbm8gcG9pbnQgcmVjb3ZlcmluZyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKCdmYWlsZWQnLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghbXNnLmNvbm5lY3Rpb25JZClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZy5jb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uSWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbXNnLnRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbXNnLmlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnLmlkID0gaWQgKyAnOicgKyBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0UGF5bG9hZC5tZXNzYWdlSWQgPSBsYXN0TWVzc2FnZS5pZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0UGF5bG9hZC5wcm90b2NvbE1lc3NhZ2VDaGFubmVsU2VyaWFsID0gbWVzc2FnZS5jaGFubmVsU2VyaWFsO1xuICAgICAgICAgICAgICAgIHRoaXMub25FdmVudChtZXNzYWdlcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGFjdGlvbnMuRVJST1I6IHtcbiAgICAgICAgICAgICAgICAvKiB0aGVyZSB3YXMgYSBjaGFubmVsLXNwZWNpZmljIGVycm9yICovXG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IG1lc3NhZ2UuZXJyb3I7XG4gICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PSA4MDAxNikge1xuICAgICAgICAgICAgICAgICAgICAvKiBhdHRhY2gvZGV0YWNoIG9wZXJhdGlvbiBhdHRlbXB0ZWQgb24gc3VwZXJzZWRlZCB0cmFuc3BvcnQgaGFuZGxlICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nU3RhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoJ2ZhaWxlZCcsIGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyhlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uTWVzc2FnZSgpJywgJ0ZhdGFsIHByb3RvY29sIGVycm9yOiB1bnJlY29nbmlzZWQgYWN0aW9uICgnICsgbWVzc2FnZS5hY3Rpb24gKyAnKScpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuYWJvcnQoY29ubmVjdGlvbmVycm9yc18xLmRlZmF1bHQudW5rbm93bkNoYW5uZWxFcnIoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuX3N0YXJ0RGVjb2RlRmFpbHVyZVJlY292ZXJ5ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01BSk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uTWVzc2FnZSgpJywgJ1N0YXJ0aW5nIGRlY29kZSBmYWlsdXJlIHJlY292ZXJ5IHByb2Nlc3MuJyk7XG4gICAgICAgICAgICB0aGlzLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaCh0cnVlLCByZWFzb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUub25BdHRhY2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwub25BdHRhY2hlZCcsICdhY3RpdmF0aW5nIGNoYW5uZWw7IG5hbWUgPSAnICsgdGhpcy5uYW1lKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUubm90aWZ5U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHJlYXNvbiwgcmVzdW1lZCwgaGFzUHJlc2VuY2UsIGhhc0JhY2tsb2cpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwubm90aWZ5U3RhdGUnLCAnbmFtZSA9ICcgKyB0aGlzLm5hbWUgKyAnLCBjdXJyZW50IHN0YXRlID0gJyArIHRoaXMuc3RhdGUgKyAnLCBub3RpZnlpbmcgc3RhdGUgJyArIHN0YXRlKTtcbiAgICAgICAgdGhpcy5jbGVhclN0YXRlVGltZXIoKTtcbiAgICAgICAgLy8gUlRQNWExXG4gICAgICAgIGlmIChVdGlscy5hcnJJbihbJ2RldGFjaGVkJywgJ3N1c3BlbmRlZCcsICdmYWlsZWQnXSwgc3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09PSB0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVzZW5jZS5hY3RPbkNoYW5uZWxTdGF0ZShzdGF0ZSwgaGFzUHJlc2VuY2UsIHJlYXNvbik7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ3N1c3BlbmRlZCcgJiYgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UmV0cnlUaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxSZXRyeVRpbWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYXNvbikge1xuICAgICAgICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhbmdlID0gbmV3IGNoYW5uZWxzdGF0ZWNoYW5nZV8xLmRlZmF1bHQodGhpcy5zdGF0ZSwgc3RhdGUsIHJlc3VtZWQsIGhhc0JhY2tsb2csIHJlYXNvbik7XG4gICAgICAgIHZhciBsb2dMZXZlbCA9IHN0YXRlID09PSAnZmFpbGVkJyA/IGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SIDogbG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUFKT1I7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ0xldmVsLCAnQ2hhbm5lbCBzdGF0ZSBmb3IgY2hhbm5lbCBcIicgKyB0aGlzLm5hbWUgKyAnXCInLCBzdGF0ZSArIChyZWFzb24gPyAnOyByZWFzb246ICcgKyByZWFzb24gOiAnJykpO1xuICAgICAgICBpZiAoc3RhdGUgIT09ICdhdHRhY2hpbmcnICYmIHN0YXRlICE9PSAnc3VzcGVuZGVkJykge1xuICAgICAgICAgICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvKiBOb3RlOiB3ZSBkb24ndCBzZXQgaW5Qcm9ncmVzcyBmb3IgcGVuZGluZyBzdGF0ZXMgdW50aWwgdGhlIHJlcXVlc3QgaXMgYWN0dWFsbHkgaW4gcHJvZ3Jlc3MgKi9cbiAgICAgICAgaWYgKHN0YXRlID09PSAnYXR0YWNoZWQnKSB7XG4gICAgICAgICAgICB0aGlzLm9uQXR0YWNoZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaFJlc3VtZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdkZXRhY2hpbmcnIHx8IHN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoUmVzdW1lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLl9hbGxDaGFubmVsQ2hhbmdlcy5lbWl0KHN0YXRlLCBjaGFuZ2UpO1xuICAgICAgICB0aGlzLmVtaXQoc3RhdGUsIGNoYW5nZSk7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnJlcXVlc3RTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgcmVhc29uKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLnJlcXVlc3RTdGF0ZScsICduYW1lID0gJyArIHRoaXMubmFtZSArICcsIHN0YXRlID0gJyArIHN0YXRlKTtcbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZShzdGF0ZSwgcmVhc29uKTtcbiAgICAgICAgLyogc2VuZCB0aGUgZXZlbnQgYW5kIGF3YWl0IHJlc3BvbnNlICovXG4gICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nU3RhdGUoKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuY2hlY2tQZW5kaW5nU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIGlmIGNhbid0IHNlbmQgZXZlbnRzLCBkbyBub3RoaW5nICovXG4gICAgICAgIHZhciBjbVN0YXRlID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZTtcbiAgICAgICAgLyogQWxsb3cgYXR0YWNoIG1lc3NhZ2VzIHRvIHF1ZXVlIHVwIHdoZW4gc3luY2hyb25pemluZywgc2luY2UgdGhpcyB3aWxsIGJlXG4gICAgICAgICAqIHRoZSBzdGF0ZSB3ZSdsbCBiZSBpbiB3aGVuIHVwZ3JhZGUgdHJhbnNwb3J0LmFjdGl2ZSB0cmlnZ2VycyBhIGNoZWNrcGVuZGluZ3N0YXRlICovXG4gICAgICAgIGlmICghKGNtU3RhdGUuc2VuZEV2ZW50cyB8fCBjbVN0YXRlLmZvcmNlUXVldWVFdmVudHMpKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5jaGVja1BlbmRpbmdTdGF0ZScsICdzZW5kRXZlbnRzIGlzIGZhbHNlOyBzdGF0ZSBpcyAnICsgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGUnLCAnbmFtZSA9ICcgKyB0aGlzLm5hbWUgKyAnLCBzdGF0ZSA9ICcgKyB0aGlzLnN0YXRlKTtcbiAgICAgICAgLyogT25seSBzdGFydCB0aGUgc3RhdGUgdGltZXIgcnVubmluZyB3aGVuIGFjdHVhbGx5IHNlbmRpbmcgdGhlIGV2ZW50ICovXG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnYXR0YWNoaW5nJzpcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZygpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoSW1wbCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGV0YWNoaW5nJzpcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoSW1wbCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYXR0YWNoZWQnOlxuICAgICAgICAgICAgICAgIC8qIHJlc3VtZSBhbnkgc3luYyBvcGVyYXRpb24gdGhhdCB3YXMgaW4gcHJvZ3Jlc3MgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnN5bmMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUudGltZW91dFBlbmRpbmdTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdhdHRhY2hpbmcnOiB7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdDaGFubmVsIGF0dGFjaCB0aW1lZCBvdXQnLCA5MDAwNywgNDA4KTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKCdzdXNwZW5kZWQnLCBlcnIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnZGV0YWNoaW5nJzoge1xuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnQ2hhbm5lbCBkZXRhY2ggdGltZWQgb3V0JywgOTAwMDcsIDQwOCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSgnYXR0YWNoZWQnLCBlcnIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGVUaW1lcikge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nJywgJ3RpbWVyIGV4cGlyZWQnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy50aW1lb3V0UGVuZGluZ1N0YXRlKCk7XG4gICAgICAgICAgICB9LCB0aGlzLnJlYWx0aW1lLm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuY2xlYXJTdGF0ZVRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGVUaW1lciA9IHRoaXMuc3RhdGVUaW1lcjtcbiAgICAgICAgaWYgKHN0YXRlVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChzdGF0ZVRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc3RhcnRSZXRyeVRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5yZXRyeVRpbWVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJldHJ5Q291bnQrKztcbiAgICAgICAgdmFyIHJldHJ5RGVsYXkgPSBVdGlscy5nZXRSZXRyeVRpbWUodGhpcy5yZWFsdGltZS5vcHRpb25zLnRpbWVvdXRzLmNoYW5uZWxSZXRyeVRpbWVvdXQsIHRoaXMucmV0cnlDb3VudCk7XG4gICAgICAgIHRoaXMucmV0cnlUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLyogSWYgY29ubmVjdGlvbiBpcyBub3QgY29ubmVjdGVkLCBqdXN0IGxlYXZlIGluIHN1c3BlbmRlZCwgYSByZWF0dGFjaFxuICAgICAgICAgICAgICogd2lsbCBiZSB0cmlnZ2VyZWQgb25jZSBpdCBjb25uZWN0cyBhZ2FpbiAqL1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlID09PSAnc3VzcGVuZGVkJyAmJiBfdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmV0cnlUaW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwgcmV0cnkgdGltZXIgZXhwaXJlZCcsICdhdHRlbXB0aW5nIGEgbmV3IGF0dGFjaCcpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlcXVlc3RTdGF0ZSgnYXR0YWNoaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHJldHJ5RGVsYXkpO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5jYW5jZWxSZXRyeVRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yZXRyeVRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMucmV0cnlUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qIEByZXR1cm5zIG51bGwgKGlmIGNhbiBzYWZlbHkgYmUgcmVsZWFzZWQpIHwgRXJyb3JJbmZvIChpZiBjYW5ub3QpICovXG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5nZXRSZWxlYXNlRXJyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcyA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGlmIChzID09PSAnaW5pdGlhbGl6ZWQnIHx8IHMgPT09ICdkZXRhY2hlZCcgfHwgcyA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnQ2FuIG9ubHkgcmVsZWFzZSBhIGNoYW5uZWwgaW4gYSBzdGF0ZSB3aGVyZSB0aGVyZSBpcyBubyBwb3NzaWJpbGl0eSBvZiBmdXJ0aGVyIHVwZGF0ZXMgZnJvbSB0aGUgc2VydmVyIGJlaW5nIHJlY2VpdmVkIChpbml0aWFsaXplZCwgZGV0YWNoZWQsIG9yIGZhaWxlZCk7IHdhcyAnICtcbiAgICAgICAgICAgIHMsIDkwMDAxLCA0MDApO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zZXRDaGFubmVsU2VyaWFsID0gZnVuY3Rpb24gKGNoYW5uZWxTZXJpYWwpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwuc2V0Q2hhbm5lbFNlcmlhbCgpJywgJ1VwZGF0aW5nIGNoYW5uZWwgc2VyaWFsOyBzZXJpYWwgPSAnICsgY2hhbm5lbFNlcmlhbCArICc7IHByZXZpb3VzID0gJyArIHRoaXMucHJvcGVydGllcy5jaGFubmVsU2VyaWFsKTtcbiAgICAgICAgLy8gUlRQMTdoOiBPbmx5IHVwZGF0ZSB0aGUgY2hhbm5lbCBzZXJpYWwgaWYgaXRzIHByZXNlbnQgKGl0IHdvbid0IGFsd2F5c1xuICAgICAgICAvLyBiZSBzZXQpLlxuICAgICAgICBpZiAoY2hhbm5lbFNlcmlhbCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWwgPSBjaGFubmVsU2VyaWFsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUmVhbHRpbWVDaGFubmVsO1xufShjaGFubmVsXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUmVhbHRpbWVDaGFubmVsO1xuXG5cbi8qKiovIH0pLFxuLyogMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDaGFubmVsU3RhdGVDaGFuZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhbm5lbFN0YXRlQ2hhbmdlKHByZXZpb3VzLCBjdXJyZW50LCByZXN1bWVkLCBoYXNCYWNrbG9nLCByZWFzb24pIHtcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICBpZiAoY3VycmVudCA9PT0gJ2F0dGFjaGVkJykge1xuICAgICAgICAgICAgdGhpcy5yZXN1bWVkID0gcmVzdW1lZDtcbiAgICAgICAgICAgIHRoaXMuaGFzQmFja2xvZyA9IGhhc0JhY2tsb2c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYXNvbilcbiAgICAgICAgICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIH1cbiAgICByZXR1cm4gQ2hhbm5lbFN0YXRlQ2hhbmdlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENoYW5uZWxTdGF0ZUNoYW5nZTtcblxuXG4vKioqLyB9KSxcbi8qIDQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdFxuXHQgICAgdmFyIFcgPSBbXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTSEEtMSBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTEgPSBDX2FsZ28uU0hBMSA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoW1xuXHQgICAgICAgICAgICAgICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSxcblx0ICAgICAgICAgICAgICAgIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsXG5cdCAgICAgICAgICAgICAgICAweGMzZDJlMWYwXG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblx0ICAgICAgICAgICAgdmFyIGUgPSBIWzRdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdO1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSAobiA8PCAxKSB8IChuID4+PiAzMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBlICsgV1tpXTtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMjApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9ICgoYiAmIGMpIHwgKH5iICYgZCkpICsgMHg1YTgyNzk5OTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IDQwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoYiBeIGMgXiBkKSArIDB4NmVkOWViYTE7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPCA2MCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKSkgLSAweDcwZTQ0MzI0O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIC8qIGlmIChpIDwgODApICovIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9IChiIF4gYyBeIGQpIC0gMHgzNTlkM2UyYTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZSA9IGQ7XG5cdCAgICAgICAgICAgICAgICBkID0gYztcblx0ICAgICAgICAgICAgICAgIGMgPSAoYiA8PCAzMCkgfCAoYiA+Pj4gMik7XG5cdCAgICAgICAgICAgICAgICBiID0gYTtcblx0ICAgICAgICAgICAgICAgIGEgPSB0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuXHQgICAgICAgICAgICBIWzFdID0gKEhbMV0gKyBiKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcblx0ICAgICAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuXHQgICAgICAgICAgICBIWzRdID0gKEhbNF0gKyBlKSB8IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTEoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTEod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEExID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMShtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEExID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTEpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlNIQTE7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiA0MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gaW5zcGVjdChidWZmZXIpIHtcbiAgICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB2YXIgdmlldztcbiAgICB2YXIgdHlwZTtcbiAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdHlwZSA9ICdBcnJheUJ1ZmZlcic7XG4gICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnVmZmVyIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgICAgdHlwZSA9ICdEYXRhVmlldyc7XG4gICAgICAgIHZpZXcgPSBidWZmZXI7XG4gICAgfVxuICAgIGlmICghdmlldylcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGJ1ZmZlcik7XG4gICAgdmFyIGJ5dGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpID4gMjApIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goJy4uLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVfID0gdmlldy5nZXRVaW50OChpKS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChieXRlXy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICBieXRlXyA9ICcwJyArIGJ5dGVfO1xuICAgICAgICBieXRlcy5wdXNoKGJ5dGVfKTtcbiAgICB9XG4gICAgcmV0dXJuICc8JyArIHR5cGUgKyAnICcgKyBieXRlcy5qb2luKCcgJykgKyAnPic7XG59XG4vLyBFbmNvZGUgc3RyaW5nIGFzIHV0ZjggaW50byBkYXRhdmlldyBhdCBvZmZzZXRcbmZ1bmN0aW9uIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQsIHN0cmluZykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3RyaW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIC8vIE9uZSBieXRlIG9mIFVURi04XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAoKGNvZGVQb2ludCA+Pj4gMCkgJiAweDdmKSB8IDB4MDApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHdvIGJ5dGVzIG9mIFVURi04XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgKChjb2RlUG9pbnQgPj4+IDYpICYgMHgxZikgfCAweGMwKTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssICgoY29kZVBvaW50ID4+PiAwKSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaHJlZSBieXRlcyBvZiBVVEYtOC5cbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssICgoY29kZVBvaW50ID4+PiAxMikgJiAweDBmKSB8IDB4ZTApO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgKChjb2RlUG9pbnQgPj4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssICgoY29kZVBvaW50ID4+PiAwKSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3VyIGJ5dGVzIG9mIFVURi04XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgKChjb2RlUG9pbnQgPj4+IDE4KSAmIDB4MDcpIHwgMHhmMCk7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAoKGNvZGVQb2ludCA+Pj4gMTIpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssICgoY29kZVBvaW50ID4+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAoKGNvZGVQb2ludCA+Pj4gMCkgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgY29kZXBvaW50ICcgKyBjb2RlUG9pbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHV0ZjhSZWFkKHZpZXcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgdmFyIHN0cmluZyA9ICcnO1xuICAgIGZvciAodmFyIGkgPSBvZmZzZXQsIGVuZCA9IG9mZnNldCArIGxlbmd0aDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIHZhciBieXRlXyA9IHZpZXcuZ2V0VWludDgoaSk7XG4gICAgICAgIC8vIE9uZSBieXRlIGNoYXJhY3RlclxuICAgICAgICBpZiAoKGJ5dGVfICYgMHg4MCkgPT09IDB4MDApIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVfKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFR3byBieXRlIGNoYXJhY3RlclxuICAgICAgICBpZiAoKGJ5dGVfICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYnl0ZV8gJiAweDBmKSA8PCA2KSB8ICh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaHJlZSBieXRlIGNoYXJhY3RlclxuICAgICAgICBpZiAoKGJ5dGVfICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYnl0ZV8gJiAweDBmKSA8PCAxMikgfCAoKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpIDw8IDYpIHwgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCAwKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3VyIGJ5dGUgY2hhcmFjdGVyXG4gICAgICAgIGlmICgoYnl0ZV8gJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChieXRlXyAmIDB4MDcpIDw8IDE4KSB8XG4gICAgICAgICAgICAgICAgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCAxMikgfFxuICAgICAgICAgICAgICAgICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgNikgfFxuICAgICAgICAgICAgICAgICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgMCkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgJyArIGJ5dGVfLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmc7XG59XG5mdW5jdGlvbiB1dGY4Qnl0ZUNvdW50KHN0cmluZykge1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgICAgICAgIGNvdW50ICs9IDI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgY291bnQgKz0gMztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgY291bnQgKz0gNDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGNvZGVwb2ludCAnICsgY29kZVBvaW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gZW5jb2RlKHZhbHVlLCBzcGFyc2UpIHtcbiAgICB2YXIgc2l6ZSA9IHNpemVvZih2YWx1ZSwgc3BhcnNlKTtcbiAgICBpZiAoc2l6ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHNpemUpO1xuICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgX2VuY29kZSh2YWx1ZSwgdmlldywgMCwgc3BhcnNlKTtcbiAgICByZXR1cm4gYnVmZmVyO1xufVxudmFyIFNIX0xfMzIgPSAoMSA8PCAxNikgKiAoMSA8PCAxNiksIFNIX1JfMzIgPSAxIC8gU0hfTF8zMjtcbmZ1bmN0aW9uIGdldEludDY0KHZpZXcsIG9mZnNldCkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgIHJldHVybiB2aWV3LmdldEludDMyKG9mZnNldCkgKiBTSF9MXzMyICsgdmlldy5nZXRVaW50MzIob2Zmc2V0ICsgNCk7XG59XG5mdW5jdGlvbiBnZXRVaW50NjQodmlldywgb2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgcmV0dXJuIHZpZXcuZ2V0VWludDMyKG9mZnNldCkgKiBTSF9MXzMyICsgdmlldy5nZXRVaW50MzIob2Zmc2V0ICsgNCk7XG59XG5mdW5jdGlvbiBzZXRJbnQ2NCh2aWV3LCBvZmZzZXQsIHZhbCkge1xuICAgIGlmICh2YWwgPCAweDgwMDAwMDAwMDAwMDAwMDApIHtcbiAgICAgICAgdmlldy5zZXRJbnQzMihvZmZzZXQsIE1hdGguZmxvb3IodmFsICogU0hfUl8zMikpO1xuICAgICAgICB2aWV3LnNldEludDMyKG9mZnNldCArIDQsIHZhbCAmIC0xKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgMHg3ZmZmZmZmZik7XG4gICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCArIDQsIDB4N2ZmZmZmZmYpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldFVpbnQ2NCh2aWV3LCBvZmZzZXQsIHZhbCkge1xuICAgIGlmICh2YWwgPCAweDEwMDAwMDAwMDAwMDAwMDAwKSB7XG4gICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgTWF0aC5mbG9vcih2YWwgKiBTSF9SXzMyKSk7XG4gICAgICAgIHZpZXcuc2V0SW50MzIob2Zmc2V0ICsgNCwgdmFsICYgLTEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCAweGZmZmZmZmZmKTtcbiAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgNCwgMHhmZmZmZmZmZik7XG4gICAgfVxufVxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZnJzeXVraS81NDMyNTU5IC0gdjUgc3BlY1xuLy9cbi8vIEkndmUgdXNlZCBvbmUgZXh0ZW5zaW9uIHBvaW50IGZyb20gYGZpeGV4dCAxYCB0byBzdG9yZSBgdW5kZWZpbmVkYC4gT24gdGhlIHdpcmUgdGhpc1xuLy8gc2hvdWxkIHRyYW5zbGF0ZSB0byBleGFjdGx5IDB4ZDQwMDAwXG4vL1xuLy8gKy0tLS0tLS0tKy0tLS0tLS0tKy0tLS0tLS0tK1xuLy8gfCAgMHhkNCAgfCAgMHgwMCAgfCAgMHgwMCAgfFxuLy8gKy0tLS0tLS0tKy0tLS0tLS0tKy0tLS0tLS0tK1xuLy8gICAgXiBmaXhleHQgfCAgICAgICAgXiB2YWx1ZSBwYXJ0IHVudXNlZCAoZml4ZWQgdG8gYmUgMClcbi8vICAgICAgICAgICAgIF4gaW5kaWNhdGVzIHVuZGVmaW5lZCB2YWx1ZVxuLy9cbnZhciBEZWNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlY29kZXIodmlldywgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubWFwID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF90aGlzLnBhcnNlKCk7XG4gICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9IF90aGlzLnBhcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmluID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV3IEFycmF5QnVmZmVyKGxlbmd0aCk7XG4gICAgICAgICAgICBuZXcgVWludDhBcnJheSh2YWx1ZSkuc2V0KG5ldyBVaW50OEFycmF5KF90aGlzLnZpZXcuYnVmZmVyLCBfdGhpcy5vZmZzZXQsIGxlbmd0aCksIDApO1xuICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5idWYgPSB0aGlzLmJpbjtcbiAgICAgICAgdGhpcy5zdHIgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB1dGY4UmVhZChfdGhpcy52aWV3LCBfdGhpcy5vZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFycmF5ID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVbaV0gPSBfdGhpcy5wYXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV4dCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSBsZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IF90aGlzLnZpZXcuZ2V0SW50OChfdGhpcy5vZmZzZXQpLFxuICAgICAgICAgICAgICAgIGRhdGE6IF90aGlzLmJ1ZihsZW5ndGgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wYXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gX3RoaXMudmlldy5nZXRVaW50OChfdGhpcy5vZmZzZXQpO1xuICAgICAgICAgICAgdmFyIHZhbHVlLCBsZW5ndGg7XG4gICAgICAgICAgICAvLyBQb3NpdGl2ZSBGaXhJbnQgLSAweHh4eHh4eFxuICAgICAgICAgICAgaWYgKCh0eXBlICYgMHg4MCkgPT09IDB4MDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpeE1hcCAtIDEwMDB4eHh4XG4gICAgICAgICAgICBpZiAoKHR5cGUgJiAweGYwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHR5cGUgJiAweDBmO1xuICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5tYXAobGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpeEFycmF5IC0gMTAwMXh4eHhcbiAgICAgICAgICAgIGlmICgodHlwZSAmIDB4ZjApID09PSAweDkwKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdHlwZSAmIDB4MGY7XG4gICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaXhTdHIgLSAxMDF4eHh4eFxuICAgICAgICAgICAgaWYgKCh0eXBlICYgMHhlMCkgPT09IDB4YTApIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB0eXBlICYgMHgxZjtcbiAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc3RyKGxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOZWdhdGl2ZSBGaXhJbnQgLSAxMTF4eHh4eFxuICAgICAgICAgICAgaWYgKCh0eXBlICYgMHhlMCkgPT09IDB4ZTApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnZpZXcuZ2V0SW50OChfdGhpcy5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIG5pbFxuICAgICAgICAgICAgICAgIGNhc2UgMHhjMDpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIC8vIDB4YzEgbmV2ZXIgdXNlZCAtIHVzZSBmb3IgdW5kZWZpbmVkIChOT04tU1RBTkRBUkQpXG4gICAgICAgICAgICAgICAgY2FzZSAweGMxOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBmYWxzZVxuICAgICAgICAgICAgICAgIGNhc2UgMHhjMjpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyB0cnVlXG4gICAgICAgICAgICAgICAgY2FzZSAweGMzOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgLy8gYmluIDhcbiAgICAgICAgICAgICAgICBjYXNlIDB4YzQ6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IF90aGlzLnZpZXcuZ2V0VWludDgoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYmluKGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gYmluIDE2XG4gICAgICAgICAgICAgICAgY2FzZSAweGM1OlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBfdGhpcy52aWV3LmdldFVpbnQxNihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5iaW4obGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBiaW4gMzJcbiAgICAgICAgICAgICAgICBjYXNlIDB4YzY6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IF90aGlzLnZpZXcuZ2V0VWludDMyKF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmJpbihsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIGV4dCA4XG4gICAgICAgICAgICAgICAgY2FzZSAweGM3OlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBfdGhpcy52aWV3LmdldFVpbnQ4KF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV4dChsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIGV4dCAxNlxuICAgICAgICAgICAgICAgIGNhc2UgMHhjODpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX3RoaXMudmlldy5nZXRVaW50MTYoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gZXh0IDMyXG4gICAgICAgICAgICAgICAgY2FzZSAweGM5OlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBfdGhpcy52aWV3LmdldFVpbnQzMihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5leHQobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBmbG9hdCAzMlxuICAgICAgICAgICAgICAgIGNhc2UgMHhjYTpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy52aWV3LmdldEZsb2F0MzIoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gZmxvYXQgNjRcbiAgICAgICAgICAgICAgICBjYXNlIDB4Y2I6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMudmlldy5nZXRGbG9hdDY0KF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gOTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIHVpbnQ4XG4gICAgICAgICAgICAgICAgY2FzZSAweGNjOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnZpZXcuZ2V0VWludDgoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gdWludCAxNlxuICAgICAgICAgICAgICAgIGNhc2UgMHhjZDpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy52aWV3LmdldFVpbnQxNihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyB1aW50IDMyXG4gICAgICAgICAgICAgICAgY2FzZSAweGNlOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnZpZXcuZ2V0VWludDMyKF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIHVpbnQgNjRcbiAgICAgICAgICAgICAgICBjYXNlIDB4Y2Y6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0VWludDY0KF90aGlzLnZpZXcsIF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gOTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIGludCA4XG4gICAgICAgICAgICAgICAgY2FzZSAweGQwOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnZpZXcuZ2V0SW50OChfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyBpbnQgMTZcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZDE6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMudmlldy5nZXRJbnQxNihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyBpbnQgMzJcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZDI6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMudmlldy5nZXRJbnQzMihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyBpbnQgNjRcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZDM6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0SW50NjQoX3RoaXMudmlldywgX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSA5O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gZml4ZXh0IDFcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZDQ6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gZml4ZXh0IDJcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZDU6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gZml4ZXh0IDRcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZDY6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gZml4ZXh0IDhcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZDc6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IDg7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gZml4ZXh0IDE2XG4gICAgICAgICAgICAgICAgY2FzZSAweGQ4OlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSAxNjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5leHQobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBzdHI4XG4gICAgICAgICAgICAgICAgY2FzZSAweGQ5OlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBfdGhpcy52aWV3LmdldFVpbnQ4KF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnN0cihsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIHN0ciAxNlxuICAgICAgICAgICAgICAgIGNhc2UgMHhkYTpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX3RoaXMudmlldy5nZXRVaW50MTYoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc3RyKGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gc3RyIDMyXG4gICAgICAgICAgICAgICAgY2FzZSAweGRiOlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBfdGhpcy52aWV3LmdldFVpbnQzMihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zdHIobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBhcnJheSAxNlxuICAgICAgICAgICAgICAgIGNhc2UgMHhkYzpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX3RoaXMudmlldy5nZXRVaW50MTYoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBhcnJheSAzMlxuICAgICAgICAgICAgICAgIGNhc2UgMHhkZDpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX3RoaXMudmlldy5nZXRVaW50MzIoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBtYXAgMTZcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZGU6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IF90aGlzLnZpZXcuZ2V0VWludDE2KF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm1hcChsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIG1hcCAzMlxuICAgICAgICAgICAgICAgIGNhc2UgMHhkZjpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX3RoaXMudmlldy5nZXRVaW50MzIoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubWFwKGxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZSAweCcgKyB0eXBlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgfVxuICAgIHJldHVybiBEZWNvZGVyO1xufSgpKTtcbmZ1bmN0aW9uIGRlY29kZShidWZmZXIpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIHZhciBkZWNvZGVyID0gbmV3IERlY29kZXIodmlldyk7XG4gICAgdmFyIHZhbHVlID0gZGVjb2Rlci5wYXJzZSgpO1xuICAgIGlmIChkZWNvZGVyLm9mZnNldCAhPT0gYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihidWZmZXIuYnl0ZUxlbmd0aCAtIGRlY29kZXIub2Zmc2V0ICsgJyB0cmFpbGluZyBieXRlcycpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGVuY29kZWFibGVLZXlzKHZhbHVlLCBzcGFyc2UpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdmFsID0gdmFsdWVbZV0sIHR5cGUgPSB0eXBlb2YgdmFsO1xuICAgICAgICByZXR1cm4gKCFzcGFyc2UgfHwgKHZhbCAhPT0gdW5kZWZpbmVkICYmIHZhbCAhPT0gbnVsbCkpICYmICgnZnVuY3Rpb24nICE9PSB0eXBlIHx8ICEhdmFsLnRvSlNPTik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBfZW5jb2RlKHZhbHVlLCB2aWV3LCBvZmZzZXQsIHNwYXJzZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIC8vIFN0cmluZ3MgQnl0ZXNcbiAgICAvLyBUaGVyZSBhcmUgZm91ciBzdHJpbmcgdHlwZXM6IGZpeHN0ci9zdHI4L3N0cjE2L3N0cjMyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGxlbmd0aF8xID0gdXRmOEJ5dGVDb3VudCh2YWx1ZSk7XG4gICAgICAgIC8vIGZpeHN0clxuICAgICAgICBpZiAobGVuZ3RoXzEgPCAweDIwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgbGVuZ3RoXzEgfCAweGEwKTtcbiAgICAgICAgICAgIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gMSArIGxlbmd0aF8xO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0cjhcbiAgICAgICAgaWYgKGxlbmd0aF8xIDwgMHgxMDApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGQ5KTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMSwgbGVuZ3RoXzEpO1xuICAgICAgICAgICAgdXRmOFdyaXRlKHZpZXcsIG9mZnNldCArIDIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAyICsgbGVuZ3RoXzE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RyMTZcbiAgICAgICAgaWYgKGxlbmd0aF8xIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZGEpO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MTYob2Zmc2V0ICsgMSwgbGVuZ3RoXzEpO1xuICAgICAgICAgICAgdXRmOFdyaXRlKHZpZXcsIG9mZnNldCArIDMsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAzICsgbGVuZ3RoXzE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RyMzJcbiAgICAgICAgaWYgKGxlbmd0aF8xIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGRiKTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCArIDEsIGxlbmd0aF8xKTtcbiAgICAgICAgICAgIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQgKyA1LCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gNSArIGxlbmd0aF8xO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgICAgICAvLyBleHRyYWN0IHRoZSBhcnJheWJ1ZmZlciBhbmQgZmFsbHRocm91Z2hcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5idWZmZXI7XG4gICAgfVxuICAgIC8vIFRoZXJlIGFyZSB0aHJlZSBiaW4gdHlwZXM6IGJpbjgvYmluMTYvYmluMzJcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICB2YXIgbGVuZ3RoXzIgPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICAvLyBiaW44XG4gICAgICAgIGlmIChsZW5ndGhfMiA8IDB4MTAwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjNCk7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIDEsIGxlbmd0aF8yKTtcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHZpZXcuYnVmZmVyKS5zZXQobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCBvZmZzZXQgKyAyKTtcbiAgICAgICAgICAgIHJldHVybiAyICsgbGVuZ3RoXzI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmluMTZcbiAgICAgICAgaWYgKGxlbmd0aF8yIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4YzUpO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MTYob2Zmc2V0ICsgMSwgbGVuZ3RoXzIpO1xuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkodmlldy5idWZmZXIpLnNldChuZXcgVWludDhBcnJheSh2YWx1ZSksIG9mZnNldCArIDMpO1xuICAgICAgICAgICAgcmV0dXJuIDMgKyBsZW5ndGhfMjtcbiAgICAgICAgfVxuICAgICAgICAvLyBiaW4gMzJcbiAgICAgICAgaWYgKGxlbmd0aF8yIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGM2KTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCArIDEsIGxlbmd0aF8yKTtcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHZpZXcuYnVmZmVyKS5zZXQobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCBvZmZzZXQgKyA1KTtcbiAgICAgICAgICAgIHJldHVybiA1ICsgbGVuZ3RoXzI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gRmxvYXRpbmcgUG9pbnRcbiAgICAgICAgLy8gTk9URTogV2UncmUgYWx3YXlzIHVzaW5nIGZsb2F0NjRcbiAgICAgICAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4Y2IpO1xuICAgICAgICAgICAgdmlldy5zZXRGbG9hdDY0KG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICB9XG4gICAgICAgIC8vIEludGVnZXJzXG4gICAgICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwb3NpdGl2ZSBmaXhudW1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdWludCA4XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAweDEwMCkge1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGNjKTtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVpbnQgMTZcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjZCk7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRVaW50MTYob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdWludCAzMlxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjZSk7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdWludCA2NFxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHgxMDAwMDAwMDAwMDAwMDAwMCkge1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGNmKTtcbiAgICAgICAgICAgICAgICBzZXRVaW50NjQodmlldywgb2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgdG9vIGJpZyAweCcgKyB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5lZ2F0aXZlIGZpeG51bVxuICAgICAgICBpZiAodmFsdWUgPj0gLTB4MjApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0SW50OChvZmZzZXQsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIGludCA4XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMHg4MCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDApO1xuICAgICAgICAgICAgdmlldy5zZXRJbnQ4KG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGludCAxNlxuICAgICAgICBpZiAodmFsdWUgPj0gLTB4ODAwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDEpO1xuICAgICAgICAgICAgdmlldy5zZXRJbnQxNihvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgfVxuICAgICAgICAvLyBpbnQgMzJcbiAgICAgICAgaWYgKHZhbHVlID49IC0weDgwMDAwMDAwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkMik7XG4gICAgICAgICAgICB2aWV3LnNldEludDMyKG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICB9XG4gICAgICAgIC8vIGludCA2NFxuICAgICAgICBpZiAodmFsdWUgPj0gLTB4ODAwMDAwMDAwMDAwMDAwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDMpO1xuICAgICAgICAgICAgc2V0SW50NjQodmlldywgb2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgdG9vIHNtYWxsIC0weCcgKyAoLXZhbHVlKS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbiAgICB9XG4gICAgLy8gdW5kZWZpbmVkIC0gdXNlIGQ0IChOT04tU1RBTkRBUkQpXG4gICAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChzcGFyc2UpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDQpO1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIDEsIDB4MDApO1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIDIsIDB4MDApO1xuICAgICAgICByZXR1cm4gMztcbiAgICB9XG4gICAgLy8gbnVsbFxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoc3BhcnNlKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGMwKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIC8vIEJvb2xlYW5cbiAgICBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCB2YWx1ZSA/IDB4YzMgOiAweGMyKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdmFsdWUudG9KU09OKVxuICAgICAgICByZXR1cm4gX2VuY29kZSh2YWx1ZS50b0pTT04oKSwgdmlldywgb2Zmc2V0LCBzcGFyc2UpO1xuICAgIC8vIENvbnRhaW5lciBUeXBlc1xuICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgbGVuZ3RoXzMsIHNpemUgPSAwO1xuICAgICAgICB2YXIga2V5cyA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgIGxlbmd0aF8zID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAga2V5cyA9IGVuY29kZWFibGVLZXlzKHZhbHVlLCBzcGFyc2UpO1xuICAgICAgICAgICAgbGVuZ3RoXzMgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoXzMgPCAweDEwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgbGVuZ3RoXzMgfCAoaXNBcnJheSA/IDB4OTAgOiAweDgwKSk7XG4gICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW5ndGhfMyA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCBpc0FycmF5ID8gMHhkYyA6IDB4ZGUpO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MTYob2Zmc2V0ICsgMSwgbGVuZ3RoXzMpO1xuICAgICAgICAgICAgc2l6ZSA9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoXzMgPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIGlzQXJyYXkgPyAweGRkIDogMHhkZik7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQgKyAxLCBsZW5ndGhfMyk7XG4gICAgICAgICAgICBzaXplID0gNTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGhfMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSArPSBfZW5jb2RlKHZhbHVlW2ldLCB2aWV3LCBvZmZzZXQgKyBzaXplLCBzcGFyc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoXzM7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIHNpemUgKz0gX2VuY29kZShrZXksIHZpZXcsIG9mZnNldCArIHNpemUpO1xuICAgICAgICAgICAgICAgIHNpemUgKz0gX2VuY29kZSh2YWx1ZVtrZXldLCB2aWV3LCBvZmZzZXQgKyBzaXplLCBzcGFyc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGUgJyArIHR5cGUpO1xufVxuZnVuY3Rpb24gc2l6ZW9mKHZhbHVlLCBzcGFyc2UpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAvLyBmaXhzdHIgb3Igc3RyOCBvciBzdHIxNiBvciBzdHIzMlxuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgbGVuZ3RoXzQgPSB1dGY4Qnl0ZUNvdW50KHZhbHVlKTtcbiAgICAgICAgaWYgKGxlbmd0aF80IDwgMHgyMCkge1xuICAgICAgICAgICAgcmV0dXJuIDEgKyBsZW5ndGhfNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoXzQgPCAweDEwMCkge1xuICAgICAgICAgICAgcmV0dXJuIDIgKyBsZW5ndGhfNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoXzQgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMyArIGxlbmd0aF80O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGhfNCA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gNSArIGxlbmd0aF80O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgICAgICAvLyBleHRyYWN0IHRoZSBhcnJheWJ1ZmZlciBhbmQgZmFsbHRocm91Z2hcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5idWZmZXI7XG4gICAgfVxuICAgIC8vIGJpbjggb3IgYmluMTYgb3IgYmluMzJcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICB2YXIgbGVuZ3RoXzUgPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoXzUgPCAweDEwMCkge1xuICAgICAgICAgICAgcmV0dXJuIDIgKyBsZW5ndGhfNTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoXzUgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMyArIGxlbmd0aF81O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGhfNSA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gNSArIGxlbmd0aF81O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIEZsb2F0aW5nIFBvaW50ICgzMiBiaXRzKVxuICAgICAgICAvLyBkb3VibGVcbiAgICAgICAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICAvLyBJbnRlZ2Vyc1xuICAgICAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgLy8gcG9zaXRpdmUgZml4aW50XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAweDgwKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgLy8gdWludCA4XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAweDEwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIC8vIHVpbnQgMTZcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4MTAwMDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICAvLyB1aW50IDMyXG4gICAgICAgICAgICBpZiAodmFsdWUgPCAweDEwMDAwMDAwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgICAgIC8vIHVpbnQgNjRcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4MTAwMDAwMDAwMDAwMDAwMDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgICAgICAvLyBUb28gYmlnXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciB0b28gYmlnIDB4JyArIHZhbHVlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmVnYXRpdmUgZml4aW50XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMHgyMClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAvLyBpbnQgOFxuICAgICAgICBpZiAodmFsdWUgPj0gLTB4ODApXG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgLy8gaW50IDE2XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMHg4MDAwKVxuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgIC8vIGludCAzMlxuICAgICAgICBpZiAodmFsdWUgPj0gLTB4ODAwMDAwMDApXG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgLy8gaW50IDY0XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMHg4MDAwMDAwMDAwMDAwMDAwKVxuICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgIC8vIFRvbyBzbWFsbFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciB0b28gc21hbGwgLTB4JyArIHZhbHVlLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xuICAgIH1cbiAgICAvLyBCb29sZWFuXG4gICAgaWYgKHR5cGUgPT09ICdib29sZWFuJylcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgLy8gdW5kZWZpbmVkLCBudWxsXG4gICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICByZXR1cm4gc3BhcnNlID8gMCA6IDE7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBzcGFyc2UgPyAwIDogMztcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHZhbHVlLnRvSlNPTilcbiAgICAgICAgcmV0dXJuIHNpemVvZih2YWx1ZS50b0pTT04oKSwgc3BhcnNlKTtcbiAgICAvLyBDb250YWluZXIgVHlwZXNcbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIGxlbmd0aF82LCBzaXplID0gMDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBsZW5ndGhfNiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoXzY7IGkrKykge1xuICAgICAgICAgICAgICAgIHNpemUgKz0gc2l6ZW9mKHZhbHVlW2ldLCBzcGFyc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBlbmNvZGVhYmxlS2V5cyh2YWx1ZSwgc3BhcnNlKTtcbiAgICAgICAgICAgIGxlbmd0aF82ID0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aF82OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBzaXplICs9IHNpemVvZihrZXkpICsgc2l6ZW9mKHZhbHVlW2tleV0sIHNwYXJzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aF82IDwgMHgxMCkge1xuICAgICAgICAgICAgcmV0dXJuIDEgKyBzaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGhfNiA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIHJldHVybiAzICsgc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoXzYgPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgcmV0dXJuIDUgKyBzaXplO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXJyYXkgb3Igb2JqZWN0IHRvbyBsb25nIDB4JyArIGxlbmd0aF82LnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gMDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZSAnICsgdHlwZSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgaW5zcGVjdDogaW5zcGVjdCxcbiAgICB1dGY4V3JpdGU6IHV0ZjhXcml0ZSxcbiAgICB1dGY4UmVhZDogdXRmOFJlYWQsXG4gICAgdXRmOEJ5dGVDb3VudDogdXRmOEJ5dGVDb3VudCxcbn07XG5cblxuLyoqKi8gfSksXG4vKiA0MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLy8gQ29tbW9uXG52YXIgcmVzdF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzMCkpO1xudmFyIHJlYWx0aW1lXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xuLy8gUGxhdGZvcm0gU3BlY2lmaWNcbnZhciBidWZmZXJ1dGlsc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg1NSkpO1xuLy8gQHRzLWlnbm9yZVxudmFyIGNyeXB0b18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg1NykpO1xudmFyIGh0dHBfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNjIpKTtcbnZhciBjb25maWdfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNjQpKTtcbi8vIEB0cy1pZ25vcmVcbnZhciB0cmFuc3BvcnRfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNjgpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIGRlZmF1bHRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xudmFyIHdlYnN0b3JhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNjUpKTtcbnZhciBkZWZhdWx0c18yID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg2NikpO1xudmFyIG1zZ3BhY2tfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNDEpKTtcbnZhciBDcnlwdG8gPSAoMCwgY3J5cHRvXzEuZGVmYXVsdCkoY29uZmlnXzEuZGVmYXVsdCwgYnVmZmVydXRpbHNfMS5kZWZhdWx0KTtcbnBsYXRmb3JtXzEuZGVmYXVsdC5DcnlwdG8gPSBDcnlwdG87XG5wbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMgPSBidWZmZXJ1dGlsc18xLmRlZmF1bHQ7XG5wbGF0Zm9ybV8xLmRlZmF1bHQuSHR0cCA9IGh0dHBfMS5kZWZhdWx0O1xucGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZyA9IGNvbmZpZ18xLmRlZmF1bHQ7XG5wbGF0Zm9ybV8xLmRlZmF1bHQuVHJhbnNwb3J0cyA9IHRyYW5zcG9ydF8xLmRlZmF1bHQ7XG5wbGF0Zm9ybV8xLmRlZmF1bHQuV2ViU3RvcmFnZSA9IHdlYnN0b3JhZ2VfMS5kZWZhdWx0O1xucmVzdF8xLmRlZmF1bHQuQ3J5cHRvID0gQ3J5cHRvO1xucmVhbHRpbWVfMS5kZWZhdWx0LkNyeXB0byA9IENyeXB0bztcbmxvZ2dlcl8xLmRlZmF1bHQuaW5pdExvZ0hhbmRsZXJzKCk7XG5wbGF0Zm9ybV8xLmRlZmF1bHQuRGVmYXVsdHMgPSAoMCwgZGVmYXVsdHNfMS5nZXREZWZhdWx0cykoZGVmYXVsdHNfMi5kZWZhdWx0KTtcbmlmIChwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmFnZW50KSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5EZWZhdWx0cy5hZ2VudCArPSAnICcgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmFnZW50O1xufVxuLyogSWYgdXNpbmcgSUU4LCBkb24ndCBhdHRlbXB0IHRvIHVwZ3JhZGUgZnJvbSB4aHJfcG9sbGluZyB0byB4aHJfc3RyZWFtaW5nIC1cbiAqIHdoaWxlIGl0IGNhbiBkbyBzdHJlYW1pbmcsIHRoZSBsb3cgbWF4IGh0dHAtY29ubmVjdGlvbnMtcGVyLWhvc3QgbGltaXQgbWVhbnNcbiAqIHRoYXQgdGhlIHBvbGxpbmcgdHJhbnNwb3J0IGlzIGNyaXBwbGVkIGR1cmluZyB0aGUgdXBncmFkZSBwcm9jZXNzLiBTbyBqdXN0XG4gKiBsZWF2ZSBpdCBhdCB0aGUgYmFzZSB0cmFuc3BvcnQgKi9cbmlmIChwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5vVXBncmFkZSkge1xuICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5EZWZhdWx0cy51cGdyYWRlVHJhbnNwb3J0cyA9IFtdO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIFJlc3Q6IHJlc3RfMS5kZWZhdWx0LFxuICAgIFJlYWx0aW1lOiByZWFsdGltZV8xLmRlZmF1bHQsXG4gICAgbXNncGFjazogbXNncGFja18xLmRlZmF1bHQsXG59O1xuXG5cbi8qKiovIH0pLFxuLyogNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBKU09OLnBhcnNlKFwie1xcXCJuYW1lXFxcIjpcXFwiYWJseVxcXCIsXFxcImRlc2NyaXB0aW9uXFxcIjpcXFwiUmVhbHRpbWUgY2xpZW50IGxpYnJhcnkgZm9yIEFibHksIHRoZSByZWFsdGltZSBtZXNzYWdpbmcgc2VydmljZVxcXCIsXFxcInZlcnNpb25cXFwiOlxcXCIxLjIuNDNcXFwiLFxcXCJsaWNlbnNlXFxcIjpcXFwiQXBhY2hlLTIuMFxcXCIsXFxcImJ1Z3NcXFwiOntcXFwidXJsXFxcIjpcXFwiaHR0cHM6Ly9naXRodWIuY29tL2FibHkvYWJseS1qcy9pc3N1ZXNcXFwiLFxcXCJlbWFpbFxcXCI6XFxcInN1cHBvcnRAYWJseS5jb21cXFwifSxcXFwibWFpblxcXCI6XFxcIi4vYnVpbGQvYWJseS1ub2RlLmpzXFxcIixcXFwidHlwaW5nc1xcXCI6XFxcIi4vYWJseS5kLnRzXFxcIixcXFwicmVhY3QtbmF0aXZlXFxcIjp7XFxcIi4vYnVpbGQvYWJseS1ub2RlLmpzXFxcIjpcXFwiLi9idWlsZC9hYmx5LXJlYWN0bmF0aXZlLmpzXFxcIn0sXFxcImJyb3dzZXJcXFwiOntcXFwiLi9idWlsZC9hYmx5LW5vZGUuanNcXFwiOlxcXCIuL2J1aWxkL2FibHktY29tbW9uanMuanNcXFwifSxcXFwiZmlsZXNcXFwiOltcXFwiYnVpbGQvKipcXFwiLFxcXCJhYmx5LmQudHNcXFwiLFxcXCJjYWxsYmFja3MuZC50c1xcXCIsXFxcImNhbGxiYWNrcy5qc1xcXCIsXFxcInByb21pc2VzLmQudHNcXFwiLFxcXCJwcm9taXNlcy5qc1xcXCIsXFxcInJlc291cmNlcy8qKlxcXCJdLFxcXCJkZXBlbmRlbmNpZXNcXFwiOntcXFwiQGFibHkvbXNncGFjay1qc1xcXCI6XFxcIl4wLjQuMFxcXCIsXFxcImdvdFxcXCI6XFxcIl4xMS44LjVcXFwiLFxcXCJ3c1xcXCI6XFxcIl41LjFcXFwifSxcXFwiZGV2RGVwZW5kZW5jaWVzXFxcIjp7XFxcIkBhYmx5L3ZjZGlmZi1kZWNvZGVyXFxcIjpcXFwiMS4wLjRcXFwiLFxcXCJAdHlwZXMvY3J5cHRvLWpzXFxcIjpcXFwiXjQuMC4xXFxcIixcXFwiQHR5cGVzL25vZGVcXFwiOlxcXCJeMTUuMC4wXFxcIixcXFwiQHR5cGVzL3JlcXVlc3RcXFwiOlxcXCJeMi40OC43XFxcIixcXFwiQHR5cGVzL3dzXFxcIjpcXFwiXjguMi4wXFxcIixcXFwiQHR5cGVzY3JpcHQtZXNsaW50L2VzbGludC1wbHVnaW5cXFwiOlxcXCJeNS4xNC4wXFxcIixcXFwiQHR5cGVzY3JpcHQtZXNsaW50L3BhcnNlclxcXCI6XFxcIl41LjE0LjBcXFwiLFxcXCJhc3luY1xcXCI6XFxcImFibHktZm9ya3MvYXN5bmMjcmVxdWlyZWpzXFxcIixcXFwiYXdzLXNka1xcXCI6XFxcIl4yLjE0MTMuMFxcXCIsXFxcImNoYWlcXFwiOlxcXCJeNC4yLjBcXFwiLFxcXCJjb3B5LXdlYnBhY2stcGx1Z2luXFxcIjpcXFwiXjYuNC4xXFxcIixcXFwiY29yc1xcXCI6XFxcIl4yLjguNVxcXCIsXFxcImNyeXB0by1qc1xcXCI6XFxcImFibHktZm9ya3MvY3J5cHRvLWpzI2NyeXB0by1saXRlXFxcIixcXFwiZXNsaW50XFxcIjpcXFwiXjcuMTMuMFxcXCIsXFxcImVzbGludC1wbHVnaW4tanNkb2NcXFwiOlxcXCJeNDAuMC4wXFxcIixcXFwiZXNsaW50LXBsdWdpbi1zZWN1cml0eVxcXCI6XFxcIl4xLjQuMFxcXCIsXFxcImV4cHJlc3NcXFwiOlxcXCJeNC4xNy4xXFxcIixcXFwiZ2xvYlxcXCI6XFxcIn40LjRcXFwiLFxcXCJnb29nbGUtY2xvc3VyZS1jb21waWxlclxcXCI6XFxcIl4yMDE4MDYxMC4wLjFcXFwiLFxcXCJncnVudFxcXCI6XFxcIl4xLjYuMVxcXCIsXFxcImdydW50LWJ1bXBcXFwiOlxcXCJeMC4zLjFcXFwiLFxcXCJncnVudC1jbGlcXFwiOlxcXCJ+MS4yLjBcXFwiLFxcXCJncnVudC1jbG9zdXJlLXRvb2xzXFxcIjpcXFwiXjEuMC4wXFxcIixcXFwiZ3J1bnQtY29udHJpYi1jb25jYXRcXFwiOlxcXCJ+MC41XFxcIixcXFwiZ3J1bnQtc2hlbGxcXFwiOlxcXCJ+MS4xXFxcIixcXFwiZ3J1bnQtd2VicGFja1xcXCI6XFxcIl40LjAuMlxcXCIsXFxcImhleHlcXFwiOlxcXCJ+MC4yXFxcIixcXFwia2V4ZWNcXFwiOlxcXCJhYmx5LWZvcmtzL25vZGUta2V4ZWMjdXBkYXRlLWZvci1ub2RlLTEyXFxcIixcXFwibWluaW1pc3RcXFwiOlxcXCJeMS4yLjVcXFwiLFxcXCJtb2NoYVxcXCI6XFxcIl44LjEuM1xcXCIsXFxcIm51bGwtbG9hZGVyXFxcIjpcXFwiXjQuMC4xXFxcIixcXFwicGxheXdyaWdodFxcXCI6XFxcIl4xLjEwLjBcXFwiLFxcXCJwcmV0dGllclxcXCI6XFxcIl4yLjUuMVxcXCIsXFxcInJlcXVpcmVqc1xcXCI6XFxcIn4yLjFcXFwiLFxcXCJzaGVsbGpzXFxcIjpcXFwifjAuOFxcXCIsXFxcInNvdXJjZS1tYXAtZXhwbG9yZXJcXFwiOlxcXCJeMi41LjJcXFwiLFxcXCJ0cy1sb2FkZXJcXFwiOlxcXCJeOC4yLjBcXFwiLFxcXCJ0c2NvbmZpZy1wYXRocy13ZWJwYWNrLXBsdWdpblxcXCI6XFxcIl40LjAuMVxcXCIsXFxcInRzbGliXFxcIjpcXFwiXjIuMy4xXFxcIixcXFwidHlwZWRvY1xcXCI6XFxcIl4wLjIzLjhcXFwiLFxcXCJ0eXBlc2NyaXB0XFxcIjpcXFwiXjQuNi40XFxcIixcXFwid2VicGFja1xcXCI6XFxcIl40LjQ0LjJcXFwiLFxcXCJ3ZWJwYWNrLWNsaVxcXCI6XFxcIl40LjIuMFxcXCJ9LFxcXCJlbmdpbmVzXFxcIjp7XFxcIm5vZGVcXFwiOlxcXCI+PTUuMTAueFxcXCJ9LFxcXCJyZXBvc2l0b3J5XFxcIjpcXFwiYWJseS9hYmx5LWpzXFxcIixcXFwianNwbVxcXCI6e1xcXCJyZWdpc3RyeVxcXCI6XFxcIm5wbVxcXCIsXFxcImRpcmVjdG9yaWVzXFxcIjp7XFxcImxpYlxcXCI6XFxcImJ1aWxkXFxcIn0sXFxcIm1haW5cXFwiOlxcXCJhYmx5XFxcIn0sXFxcInNjcmlwdHNcXFwiOntcXFwiZ3J1bnRcXFwiOlxcXCJncnVudFxcXCIsXFxcInRlc3RcXFwiOlxcXCJncnVudCB0ZXN0XFxcIixcXFwidGVzdDpub2RlXFxcIjpcXFwiZ3J1bnQgdGVzdDpub2RlXFxcIixcXFwidGVzdDpub2RlOnNraXAtYnVpbGRcXFwiOlxcXCJncnVudCBtb2NoYVxcXCIsXFxcInRlc3Q6d2Vic2VydmVyXFxcIjpcXFwiZ3J1bnQgdGVzdDp3ZWJzZXJ2ZXJcXFwiLFxcXCJ0ZXN0OnBsYXl3cmlnaHRcXFwiOlxcXCJub2RlIHRlc3Qvc3VwcG9ydC9ydW5QbGF5d3JpZ2h0VGVzdHMuanNcXFwiLFxcXCJjb25jYXRcXFwiOlxcXCJncnVudCBjb25jYXRcXFwiLFxcXCJidWlsZFxcXCI6XFxcImdydW50IGJ1aWxkOmFsbFxcXCIsXFxcImJ1aWxkOm5vZGVcXFwiOlxcXCJncnVudCBidWlsZDpub2RlXFxcIixcXFwiYnVpbGQ6YnJvd3NlclxcXCI6XFxcImdydW50IGJ1aWxkOmJyb3dzZXJcXFwiLFxcXCJyZXF1aXJlanNcXFwiOlxcXCJncnVudCByZXF1aXJlanNcXFwiLFxcXCJsaW50XFxcIjpcXFwiZXNsaW50IC5cXFwiLFxcXCJsaW50OmZpeFxcXCI6XFxcImVzbGludCAtLWZpeCAuXFxcIixcXFwiY2hlY2stY2xvc3VyZS1jb21waWxlclxcXCI6XFxcImdydW50IGNoZWNrLWNsb3N1cmUtY29tcGlsZXJcXFwiLFxcXCJwcmVwYXJlXFxcIjpcXFwibnBtIHJ1biBidWlsZFxcXCIsXFxcImZvcm1hdFxcXCI6XFxcInByZXR0aWVyIC0td3JpdGUgLS1pZ25vcmUtcGF0aCAuZ2l0aWdub3JlIC0taWdub3JlLXBhdGggLnByZXR0aWVyaWdub3JlIHNyYyB0ZXN0IGFibHkuZC50cyB3ZWJwYWNrLmNvbmZpZy5qcyBHcnVudGZpbGUuanMgc2NyaXB0cy9jZG5fZGVwbG95LmpzIGRvY3MvY2hyb21lLW12My5tZFxcXCIsXFxcImZvcm1hdDpjaGVja1xcXCI6XFxcInByZXR0aWVyIC0tY2hlY2sgLS1pZ25vcmUtcGF0aCAuZ2l0aWdub3JlIC0taWdub3JlLXBhdGggLnByZXR0aWVyaWdub3JlIHNyYyB0ZXN0IGFibHkuZC50cyB3ZWJwYWNrLmNvbmZpZy5qcyBHcnVudGZpbGUuanMgc2NyaXB0cy9jZG5fZGVwbG95LmpzXFxcIixcXFwic291cmNlbWFwXFxcIjpcXFwic291cmNlLW1hcC1leHBsb3JlciBidWlsZC9hYmx5Lm1pbi5qc1xcXCIsXFxcInNvdXJjZW1hcDpub2VuY3J5cHRpb25cXFwiOlxcXCJzb3VyY2UtbWFwLWV4cGxvcmVyIGJ1aWxkL2FibHkubm9lbmNyeXB0aW9uLm1pbi5qc1xcXCIsXFxcImRvY3NcXFwiOlxcXCJ0eXBlZG9jIC0tZW50cnlQb2ludHMgYWJseS5kLnRzIC0tb3V0IGRvY3MvZ2VuZXJhdGVkL2RlZmF1bHQgLS1yZWFkbWUgZG9jcy9sYW5kaW5nLXBhZ2VzL2RlZmF1bHQubWQgJiYgdHlwZWRvYyAtLWVudHJ5UG9pbnRzIHByb21pc2VzLmQudHMgLS1vdXQgZG9jcy9nZW5lcmF0ZWQvcHJvbWlzZXMgLS1uYW1lIFxcXFxcXFwiYWJseSAoUHJvbWlzZS1iYXNlZClcXFxcXFxcIiAtLXJlYWRtZSBkb2NzL2xhbmRpbmctcGFnZXMvcHJvbWlzZXMubWQgJiYgY3AgZG9jcy9sYW5kaW5nLXBhZ2VzL2Nob29zZS1saWJyYXJ5Lmh0bWwgZG9jcy9nZW5lcmF0ZWQvaW5kZXguaHRtbFxcXCJ9fVwiKTtcblxuLyoqKi8gfSksXG4vKiA0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cblxuLyoqKi8gfSksXG4vKiA0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNiksIF9fd2VicGFja19yZXF1aXJlX18oMzIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHRyZXR1cm4gQ3J5cHRvSlMuSG1hY1NIQTI1NjtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBkZXZpY2VkZXRhaWxzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KSk7XG52YXIgcmVzb3VyY2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTQpKTtcbnZhciBwYWdpbmF0ZWRyZXNvdXJjZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxOSkpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgcHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNDgpKTtcbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xudmFyIFB1c2ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHVzaChyZXN0KSB7XG4gICAgICAgIHRoaXMucmVzdCA9IHJlc3Q7XG4gICAgICAgIHRoaXMuYWRtaW4gPSBuZXcgQWRtaW4ocmVzdCk7XG4gICAgfVxuICAgIHJldHVybiBQdXNoO1xufSgpKTtcbnZhciBBZG1pbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBZG1pbihyZXN0KSB7XG4gICAgICAgIHRoaXMucmVzdCA9IHJlc3Q7XG4gICAgICAgIHRoaXMuZGV2aWNlUmVnaXN0cmF0aW9ucyA9IG5ldyBEZXZpY2VSZWdpc3RyYXRpb25zKHJlc3QpO1xuICAgICAgICB0aGlzLmNoYW5uZWxTdWJzY3JpcHRpb25zID0gbmV3IENoYW5uZWxTdWJzY3JpcHRpb25zKHJlc3QpO1xuICAgIH1cbiAgICBBZG1pbi5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uIChyZWNpcGllbnQsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5yZXN0O1xuICAgICAgICB2YXIgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRQb3N0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCksIHBhcmFtcyA9IHt9O1xuICAgICAgICB2YXIgYm9keSA9IFV0aWxzLm1peGluKHsgcmVjaXBpZW50OiByZWNpcGllbnQgfSwgcGF5bG9hZCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3B1Ymxpc2gnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICAgICAgICBVdGlscy5taXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6ICd0cnVlJyB9KTtcbiAgICAgICAgdmFyIHJlcXVlc3RCb2R5ID0gVXRpbHMuZW5jb2RlQm9keShib2R5LCBmb3JtYXQpO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQucG9zdChyZXN0LCAnL3B1c2gvcHVibGlzaCcsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMsIG51bGwsIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFkbWluO1xufSgpKTtcbnZhciBEZXZpY2VSZWdpc3RyYXRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERldmljZVJlZ2lzdHJhdGlvbnMocmVzdCkge1xuICAgICAgICB0aGlzLnJlc3QgPSByZXN0O1xuICAgIH1cbiAgICBEZXZpY2VSZWdpc3RyYXRpb25zLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKGRldmljZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnJlc3Q7XG4gICAgICAgIHZhciBib2R5ID0gZGV2aWNlZGV0YWlsc18xLmRlZmF1bHQuZnJvbVZhbHVlcyhkZXZpY2UpO1xuICAgICAgICB2YXIgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRQb3N0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCksIHBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdzYXZlJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgICAgICAgVXRpbHMubWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiAndHJ1ZScgfSk7XG4gICAgICAgIHZhciByZXF1ZXN0Qm9keSA9IFV0aWxzLmVuY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LnB1dChyZXN0LCAnL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZS5pZCksIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMsIG51bGwsIGZ1bmN0aW9uIChlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsICFlcnJcbiAgICAgICAgICAgICAgICA/IGRldmljZWRldGFpbHNfMS5kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoYm9keSwgdW5wYWNrZWQgPyB1bmRlZmluZWQgOiBmb3JtYXQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERldmljZVJlZ2lzdHJhdGlvbnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChkZXZpY2VJZE9yRGV0YWlscywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnJlc3QsIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0R2V0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCksIGRldmljZUlkID0gZGV2aWNlSWRPckRldGFpbHMuaWQgfHwgZGV2aWNlSWRPckRldGFpbHM7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2dldCcsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkZXZpY2VJZCAhPT0gJ3N0cmluZycgfHwgIWRldmljZUlkLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0ZpcnN0IGFyZ3VtZW50IHRvIERldmljZVJlZ2lzdHJhdGlvbnMjZ2V0IG11c3QgYmUgYSBkZXZpY2VJZCBzdHJpbmcgb3IgRGV2aWNlRGV0YWlscycsIDQwMDAwLCA0MDApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdC5nZXQocmVzdCwgJy9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMvJyArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2VJZCksIGhlYWRlcnMsIHt9LCBudWxsLCBmdW5jdGlvbiAoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCAhZXJyXG4gICAgICAgICAgICAgICAgPyBkZXZpY2VkZXRhaWxzXzEuZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIHVucGFja2VkID8gdW5kZWZpbmVkIDogZm9ybWF0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEZXZpY2VSZWdpc3RyYXRpb25zLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnJlc3QsIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGVudmVsb3BlID0gdGhpcy5yZXN0Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzKHJlc3Qub3B0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnbGlzdCcsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfMS5kZWZhdWx0KHJlc3QsICcvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zJywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uIChib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRldmljZWRldGFpbHNfMS5kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoYm9keSwgdW5wYWNrZWQgPyB1bmRlZmluZWQgOiBmb3JtYXQpO1xuICAgICAgICB9KS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBEZXZpY2VSZWdpc3RyYXRpb25zLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZGV2aWNlSWRPckRldGFpbHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5yZXN0LCBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdEdldEhlYWRlcnMocmVzdC5vcHRpb25zLCBmb3JtYXQpLCBwYXJhbXMgPSB7fSwgZGV2aWNlSWQgPSBkZXZpY2VJZE9yRGV0YWlscy5pZCB8fCBkZXZpY2VJZE9yRGV0YWlscztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAncmVtb3ZlJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRldmljZUlkICE9PSAnc3RyaW5nJyB8fCAhZGV2aWNlSWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnRmlyc3QgYXJndW1lbnQgdG8gRGV2aWNlUmVnaXN0cmF0aW9ucyNyZW1vdmUgbXVzdCBiZSBhIGRldmljZUlkIHN0cmluZyBvciBEZXZpY2VEZXRhaWxzJywgNDAwMDAsIDQwMCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICAgICAgICBVdGlscy5taXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6ICd0cnVlJyB9KTtcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0WydkZWxldGUnXShyZXN0LCAnL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZUlkKSwgaGVhZGVycywgcGFyYW1zLCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9KTtcbiAgICB9O1xuICAgIERldmljZVJlZ2lzdHJhdGlvbnMucHJvdG90eXBlLnJlbW92ZVdoZXJlID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnJlc3QsIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0R2V0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3JlbW92ZVdoZXJlJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgICAgICAgVXRpbHMubWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiAndHJ1ZScgfSk7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdFsnZGVsZXRlJ10ocmVzdCwgJy9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMnLCBoZWFkZXJzLCBwYXJhbXMsIG51bGwsIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIERldmljZVJlZ2lzdHJhdGlvbnM7XG59KCkpO1xudmFyIENoYW5uZWxTdWJzY3JpcHRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYW5uZWxTdWJzY3JpcHRpb25zKHJlc3QpIHtcbiAgICAgICAgLyogQ2hhbm5lbFN1YnNjcmlwdGlvbnMgaGF2ZSBubyB1bmlxdWUgaWQ7IHJlbW92aW5nIG9uZSBpcyBlcXVpdmFsZW50IHRvIHJlbW92ZVdoZXJlIGJ5IGl0cyBwcm9wZXJ0aWVzICovXG4gICAgICAgIHRoaXMucmVtb3ZlID0gQ2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnJlbW92ZVdoZXJlO1xuICAgICAgICB0aGlzLnJlc3QgPSByZXN0O1xuICAgIH1cbiAgICBDaGFubmVsU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5yZXN0O1xuICAgICAgICB2YXIgYm9keSA9IHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIHZhciBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdFBvc3RIZWFkZXJzKHJlc3Qub3B0aW9ucywgZm9ybWF0KSwgcGFyYW1zID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3NhdmUnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICAgICAgICBVdGlscy5taXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6ICd0cnVlJyB9KTtcbiAgICAgICAgdmFyIHJlcXVlc3RCb2R5ID0gVXRpbHMuZW5jb2RlQm9keShib2R5LCBmb3JtYXQpO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQucG9zdChyZXN0LCAnL3B1c2gvY2hhbm5lbFN1YnNjcmlwdGlvbnMnLCByZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zLCBudWxsLCBmdW5jdGlvbiAoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCAhZXJyICYmIHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uXzEuZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIHVucGFja2VkID8gdW5kZWZpbmVkIDogZm9ybWF0KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucmVzdCwgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgZW52ZWxvcGUgPSB0aGlzLnJlc3QuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0LCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdEdldEhlYWRlcnMocmVzdC5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdsaXN0JywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV8xLmRlZmF1bHQocmVzdCwgJy9wdXNoL2NoYW5uZWxTdWJzY3JpcHRpb25zJywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uIChib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uXzEuZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIHVucGFja2VkID8gdW5kZWZpbmVkIDogZm9ybWF0KTtcbiAgICAgICAgfSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgQ2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnJlbW92ZVdoZXJlID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnJlc3QsIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0R2V0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3JlbW92ZVdoZXJlJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgICAgICAgVXRpbHMubWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiAndHJ1ZScgfSk7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdFsnZGVsZXRlJ10ocmVzdCwgJy9wdXNoL2NoYW5uZWxTdWJzY3JpcHRpb25zJywgaGVhZGVycywgcGFyYW1zLCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9KTtcbiAgICB9O1xuICAgIENoYW5uZWxTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5saXN0Q2hhbm5lbHMgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucmVzdCwgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgZW52ZWxvcGUgPSB0aGlzLnJlc3QuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0LCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdEdldEhlYWRlcnMocmVzdC5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdsaXN0Q2hhbm5lbHMnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICAgICAgICBVdGlscy5taXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6ICd0cnVlJyB9KTtcbiAgICAgICAgbmV3IHBhZ2luYXRlZHJlc291cmNlXzEuZGVmYXVsdChyZXN0LCAnL3B1c2gvY2hhbm5lbHMnLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24gKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkQm9keSA9ICghdW5wYWNrZWQgJiYgZm9ybWF0ID8gVXRpbHMuZGVjb2RlQm9keShib2R5LCBmb3JtYXQpIDogYm9keSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnNlZEJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwYXJzZWRCb2R5W2ldID0gU3RyaW5nKHBhcnNlZEJvZHlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZEJvZHk7XG4gICAgICAgIH0pLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIHJldHVybiBDaGFubmVsU3Vic2NyaXB0aW9ucztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQdXNoO1xuXG5cbi8qKiovIH0pLFxuLyogNDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgRGV2aWNlRm9ybUZhY3RvcjtcbihmdW5jdGlvbiAoRGV2aWNlRm9ybUZhY3Rvcikge1xuICAgIERldmljZUZvcm1GYWN0b3JbXCJQaG9uZVwiXSA9IFwicGhvbmVcIjtcbiAgICBEZXZpY2VGb3JtRmFjdG9yW1wiVGFibGV0XCJdID0gXCJ0YWJsZXRcIjtcbiAgICBEZXZpY2VGb3JtRmFjdG9yW1wiRGVza3RvcFwiXSA9IFwiZGVza3RvcFwiO1xuICAgIERldmljZUZvcm1GYWN0b3JbXCJUVlwiXSA9IFwidHZcIjtcbiAgICBEZXZpY2VGb3JtRmFjdG9yW1wiV2F0Y2hcIl0gPSBcIndhdGNoXCI7XG4gICAgRGV2aWNlRm9ybUZhY3RvcltcIkNhclwiXSA9IFwiY2FyXCI7XG4gICAgRGV2aWNlRm9ybUZhY3RvcltcIkVtYmVkZGVkXCJdID0gXCJlbWJlZGRlZFwiO1xuICAgIERldmljZUZvcm1GYWN0b3JbXCJPdGhlclwiXSA9IFwib3RoZXJcIjtcbn0pKERldmljZUZvcm1GYWN0b3IgfHwgKERldmljZUZvcm1GYWN0b3IgPSB7fSkpO1xudmFyIERldmljZVBsYXRmb3JtO1xuKGZ1bmN0aW9uIChEZXZpY2VQbGF0Zm9ybSkge1xuICAgIERldmljZVBsYXRmb3JtW1wiQW5kcm9pZFwiXSA9IFwiYW5kcm9pZFwiO1xuICAgIERldmljZVBsYXRmb3JtW1wiSU9TXCJdID0gXCJpb3NcIjtcbiAgICBEZXZpY2VQbGF0Zm9ybVtcIkJyb3dzZXJcIl0gPSBcImJyb3dzZXJcIjtcbn0pKERldmljZVBsYXRmb3JtIHx8IChEZXZpY2VQbGF0Zm9ybSA9IHt9KSk7XG52YXIgRGV2aWNlRGV0YWlscyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXZpY2VEZXRhaWxzKCkge1xuICAgIH1cbiAgICBEZXZpY2VEZXRhaWxzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBkZXZpY2VTZWNyZXQ6IHRoaXMuZGV2aWNlU2VjcmV0LFxuICAgICAgICAgICAgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG4gICAgICAgICAgICBmb3JtRmFjdG9yOiB0aGlzLmZvcm1GYWN0b3IsXG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhLFxuICAgICAgICAgICAgZGV2aWNlSWRlbnRpdHlUb2tlbjogdGhpcy5kZXZpY2VJZGVudGl0eVRva2VuLFxuICAgICAgICAgICAgcHVzaDoge1xuICAgICAgICAgICAgICAgIHJlY2lwaWVudDogKF9hID0gdGhpcy5wdXNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVjaXBpZW50LFxuICAgICAgICAgICAgICAgIHN0YXRlOiAoX2IgPSB0aGlzLnB1c2gpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGF0ZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogKF9jID0gdGhpcy5wdXNoKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZXJyb3IsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgRGV2aWNlRGV0YWlscy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICdbRGV2aWNlRGV0YWlscyc7XG4gICAgICAgIGlmICh0aGlzLmlkKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGlkPScgKyB0aGlzLmlkO1xuICAgICAgICBpZiAodGhpcy5wbGF0Zm9ybSlcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBwbGF0Zm9ybT0nICsgdGhpcy5wbGF0Zm9ybTtcbiAgICAgICAgaWYgKHRoaXMuZm9ybUZhY3RvcilcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBmb3JtRmFjdG9yPScgKyB0aGlzLmZvcm1GYWN0b3I7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudElkKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGNsaWVudElkPScgKyB0aGlzLmNsaWVudElkO1xuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YSlcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBtZXRhZGF0YT0nICsgdGhpcy5tZXRhZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuZGV2aWNlSWRlbnRpdHlUb2tlbilcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBkZXZpY2VJZGVudGl0eVRva2VuPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmRldmljZUlkZW50aXR5VG9rZW4pO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy5wdXNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVjaXBpZW50KVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IHB1c2gucmVjaXBpZW50PScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnB1c2gucmVjaXBpZW50KTtcbiAgICAgICAgaWYgKChfYiA9IHRoaXMucHVzaCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0YXRlKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IHB1c2guc3RhdGU9JyArIHRoaXMucHVzaC5zdGF0ZTtcbiAgICAgICAgaWYgKChfYyA9IHRoaXMucHVzaCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmVycm9yKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IHB1c2guZXJyb3I9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMucHVzaC5lcnJvcik7XG4gICAgICAgIGlmICgoX2QgPSB0aGlzLnB1c2gpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5tZXRhZGF0YSlcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBwdXNoLm1ldGFkYXRhPScgKyB0aGlzLnB1c2gubWV0YWRhdGE7XG4gICAgICAgIHJlc3VsdCArPSAnXSc7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBEZXZpY2VEZXRhaWxzLmZyb21SZXNwb25zZUJvZHkgPSBmdW5jdGlvbiAoYm9keSwgZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGJvZHkgPSBVdGlscy5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWxzLmlzQXJyYXkoYm9keSkpIHtcbiAgICAgICAgICAgIHJldHVybiBEZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXNBcnJheShib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBEZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXMoYm9keSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERldmljZURldGFpbHMuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzLmVycm9yID0gdmFsdWVzLmVycm9yICYmIGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyh2YWx1ZXMuZXJyb3IpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRGV2aWNlRGV0YWlscygpLCB2YWx1ZXMpO1xuICAgIH07XG4gICAgRGV2aWNlRGV0YWlscy5mcm9tVmFsdWVzQXJyYXkgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IERldmljZURldGFpbHMuZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgRGV2aWNlRGV0YWlscy50b1JlcXVlc3RCb2R5ID0gVXRpbHMuZW5jb2RlQm9keTtcbiAgICByZXR1cm4gRGV2aWNlRGV0YWlscztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBEZXZpY2VEZXRhaWxzO1xuXG5cbi8qKiovIH0pLFxuLyogNDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVybG9hZCB0b0pTT04oKSB0byBpbnRlcmNlcHQgSlNPTi5zdHJpbmdpZnkoKVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG4gICAgUHVzaENoYW5uZWxTdWJzY3JpcHRpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXMuY2hhbm5lbCxcbiAgICAgICAgICAgIGRldmljZUlkOiB0aGlzLmRldmljZUlkLFxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnW1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uJztcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBjaGFubmVsPScgKyB0aGlzLmNoYW5uZWw7XG4gICAgICAgIGlmICh0aGlzLmRldmljZUlkKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGRldmljZUlkPScgKyB0aGlzLmRldmljZUlkO1xuICAgICAgICBpZiAodGhpcy5jbGllbnRJZClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBjbGllbnRJZD0nICsgdGhpcy5jbGllbnRJZDtcbiAgICAgICAgcmVzdWx0ICs9ICddJztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21SZXNwb25zZUJvZHkgPSBmdW5jdGlvbiAoYm9keSwgZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGJvZHkgPSBVdGlscy5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWxzLmlzQXJyYXkoYm9keSkpIHtcbiAgICAgICAgICAgIHJldHVybiBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzQXJyYXkoYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlcyhib2R5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uKCksIHZhbHVlcyk7XG4gICAgfTtcbiAgICBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzQXJyYXkgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXModmFsdWVzW2ldKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLnRvUmVxdWVzdEJvZHkgPSBVdGlscy5lbmNvZGVCb2R5O1xuICAgIHJldHVybiBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbjtcblxuXG4vKioqLyB9KSxcbi8qIDQ5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBNZXNzYWdlQ291bnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVzc2FnZUNvdW50KHZhbHVlcykge1xuICAgICAgICB0aGlzLmNvdW50ID0gKHZhbHVlcyAmJiB2YWx1ZXMuY291bnQpIHx8IDA7XG4gICAgICAgIHRoaXMuZGF0YSA9ICh2YWx1ZXMgJiYgdmFsdWVzLmRhdGEpIHx8IDA7XG4gICAgICAgIHRoaXMudW5jb21wcmVzc2VkRGF0YSA9ICh2YWx1ZXMgJiYgdmFsdWVzLnVuY29tcHJlc3NlZERhdGEpIHx8IDA7XG4gICAgICAgIHRoaXMuZmFpbGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuZmFpbGVkKSB8fCAwO1xuICAgICAgICB0aGlzLnJlZnVzZWQgPSAodmFsdWVzICYmIHZhbHVlcy5yZWZ1c2VkKSB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gTWVzc2FnZUNvdW50O1xufSgpKTtcbnZhciBNZXNzYWdlQ2F0ZWdvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTWVzc2FnZUNhdGVnb3J5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VDYXRlZ29yeSh2YWx1ZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdmFsdWVzKSB8fCB0aGlzO1xuICAgICAgICBpZiAodmFsdWVzICYmIHZhbHVlcy5jYXRlZ29yeSkge1xuICAgICAgICAgICAgX3RoaXMuY2F0ZWdvcnkgPSB7fTtcbiAgICAgICAgICAgIFV0aWxzLmZvckluT3duTm9uTnVsbFByb3BlcnRpZXModmFsdWVzLmNhdGVnb3J5LCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNhdGVnb3J5W3Byb3BdID0gbmV3IE1lc3NhZ2VDb3VudCh2YWx1ZXMuY2F0ZWdvcnlbcHJvcF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWVzc2FnZUNhdGVnb3J5O1xufShNZXNzYWdlQ291bnQpKTtcbnZhciBSZXNvdXJjZUNvdW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc291cmNlQ291bnQodmFsdWVzKSB7XG4gICAgICAgIHRoaXMucGVhayA9ICh2YWx1ZXMgJiYgdmFsdWVzLnBlYWspIHx8IDA7XG4gICAgICAgIHRoaXMubWluID0gKHZhbHVlcyAmJiB2YWx1ZXMubWluKSB8fCAwO1xuICAgICAgICB0aGlzLm1lYW4gPSAodmFsdWVzICYmIHZhbHVlcy5tZWFuKSB8fCAwO1xuICAgICAgICB0aGlzLm9wZW5lZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLm9wZW5lZCkgfHwgMDtcbiAgICAgICAgdGhpcy5yZWZ1c2VkID0gKHZhbHVlcyAmJiB2YWx1ZXMucmVmdXNlZCkgfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIFJlc291cmNlQ291bnQ7XG59KCkpO1xudmFyIFJlcXVlc3RDb3VudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXF1ZXN0Q291bnQodmFsdWVzKSB7XG4gICAgICAgIHRoaXMuc3VjY2VlZGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuc3VjY2VlZGVkKSB8fCAwO1xuICAgICAgICB0aGlzLmZhaWxlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLmZhaWxlZCkgfHwgMDtcbiAgICAgICAgdGhpcy5yZWZ1c2VkID0gKHZhbHVlcyAmJiB2YWx1ZXMucmVmdXNlZCkgfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIFJlcXVlc3RDb3VudDtcbn0oKSk7XG52YXIgQ29ubmVjdGlvblR5cGVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbm5lY3Rpb25UeXBlcyh2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5wbGFpbiA9IG5ldyBSZXNvdXJjZUNvdW50KHZhbHVlcyAmJiB2YWx1ZXMucGxhaW4pO1xuICAgICAgICB0aGlzLnRscyA9IG5ldyBSZXNvdXJjZUNvdW50KHZhbHVlcyAmJiB2YWx1ZXMudGxzKTtcbiAgICAgICAgdGhpcy5hbGwgPSBuZXcgUmVzb3VyY2VDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLmFsbCk7XG4gICAgfVxuICAgIHJldHVybiBDb25uZWN0aW9uVHlwZXM7XG59KCkpO1xudmFyIE1lc3NhZ2VUeXBlcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXNzYWdlVHlwZXModmFsdWVzKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBuZXcgTWVzc2FnZUNhdGVnb3J5KHZhbHVlcyAmJiB2YWx1ZXMubWVzc2FnZXMpO1xuICAgICAgICB0aGlzLnByZXNlbmNlID0gbmV3IE1lc3NhZ2VDYXRlZ29yeSh2YWx1ZXMgJiYgdmFsdWVzLnByZXNlbmNlKTtcbiAgICAgICAgdGhpcy5hbGwgPSBuZXcgTWVzc2FnZUNhdGVnb3J5KHZhbHVlcyAmJiB2YWx1ZXMuYWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIE1lc3NhZ2VUeXBlcztcbn0oKSk7XG52YXIgTWVzc2FnZVRyYWZmaWMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVzc2FnZVRyYWZmaWModmFsdWVzKSB7XG4gICAgICAgIHRoaXMucmVhbHRpbWUgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMucmVhbHRpbWUpO1xuICAgICAgICB0aGlzLnJlc3QgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMucmVzdCk7XG4gICAgICAgIHRoaXMud2ViaG9vayA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy53ZWJob29rKTtcbiAgICAgICAgdGhpcy5zaGFyZWRRdWV1ZSA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5zaGFyZWRRdWV1ZSk7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxRdWV1ZSA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5leHRlcm5hbFF1ZXVlKTtcbiAgICAgICAgdGhpcy5odHRwRXZlbnQgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuaHR0cEV2ZW50KTtcbiAgICAgICAgdGhpcy5wdXNoID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLnB1c2gpO1xuICAgICAgICB0aGlzLmFsbCA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5hbGwpO1xuICAgIH1cbiAgICByZXR1cm4gTWVzc2FnZVRyYWZmaWM7XG59KCkpO1xudmFyIE1lc3NhZ2VEaXJlY3Rpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VEaXJlY3Rpb25zKHZhbHVlcykge1xuICAgICAgICB0aGlzLmFsbCA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5hbGwpO1xuICAgICAgICB0aGlzLmluYm91bmQgPSBuZXcgTWVzc2FnZVRyYWZmaWModmFsdWVzICYmIHZhbHVlcy5pbmJvdW5kKTtcbiAgICAgICAgdGhpcy5vdXRib3VuZCA9IG5ldyBNZXNzYWdlVHJhZmZpYyh2YWx1ZXMgJiYgdmFsdWVzLm91dGJvdW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIE1lc3NhZ2VEaXJlY3Rpb25zO1xufSgpKTtcbnZhciBYY2hnTWVzc2FnZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWGNoZ01lc3NhZ2VzKHZhbHVlcykge1xuICAgICAgICB0aGlzLmFsbCA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5hbGwpO1xuICAgICAgICB0aGlzLnByb2R1Y2VyUGFpZCA9IG5ldyBNZXNzYWdlRGlyZWN0aW9ucyh2YWx1ZXMgJiYgdmFsdWVzLnByb2R1Y2VyUGFpZCk7XG4gICAgICAgIHRoaXMuY29uc3VtZXJQYWlkID0gbmV3IE1lc3NhZ2VEaXJlY3Rpb25zKHZhbHVlcyAmJiB2YWx1ZXMuY29uc3VtZXJQYWlkKTtcbiAgICB9XG4gICAgcmV0dXJuIFhjaGdNZXNzYWdlcztcbn0oKSk7XG52YXIgUHVzaFN0YXRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFB1c2hTdGF0cyh2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9ICh2YWx1ZXMgJiYgdmFsdWVzLm1lc3NhZ2VzKSB8fCAwO1xuICAgICAgICB2YXIgbm90aWZpY2F0aW9ucyA9IHZhbHVlcyAmJiB2YWx1ZXMubm90aWZpY2F0aW9ucztcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zID0ge1xuICAgICAgICAgICAgaW52YWxpZDogKG5vdGlmaWNhdGlvbnMgJiYgbm90aWZpY2F0aW9ucy5pbnZhbGlkKSB8fCAwLFxuICAgICAgICAgICAgYXR0ZW1wdGVkOiAobm90aWZpY2F0aW9ucyAmJiBub3RpZmljYXRpb25zLmF0dGVtcHRlZCkgfHwgMCxcbiAgICAgICAgICAgIHN1Y2Nlc3NmdWw6IChub3RpZmljYXRpb25zICYmIG5vdGlmaWNhdGlvbnMuc3VjY2Vzc2Z1bCkgfHwgMCxcbiAgICAgICAgICAgIGZhaWxlZDogKG5vdGlmaWNhdGlvbnMgJiYgbm90aWZpY2F0aW9ucy5mYWlsZWQpIHx8IDAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGlyZWN0UHVibGlzaGVzID0gKHZhbHVlcyAmJiB2YWx1ZXMuZGlyZWN0UHVibGlzaGVzKSB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gUHVzaFN0YXRzO1xufSgpKTtcbnZhciBQcm9jZXNzZWRDb3VudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcm9jZXNzZWRDb3VudCh2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5zdWNjZWVkZWQgPSAodmFsdWVzICYmIHZhbHVlcy5zdWNjZWVkZWQpIHx8IDA7XG4gICAgICAgIHRoaXMuc2tpcHBlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnNraXBwZWQpIHx8IDA7XG4gICAgICAgIHRoaXMuZmFpbGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuZmFpbGVkKSB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gUHJvY2Vzc2VkQ291bnQ7XG59KCkpO1xudmFyIFByb2Nlc3NlZE1lc3NhZ2VzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByb2Nlc3NlZE1lc3NhZ2VzKHZhbHVlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmRlbHRhID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodmFsdWVzICYmIHZhbHVlcy5kZWx0YSkge1xuICAgICAgICAgICAgdGhpcy5kZWx0YSA9IHt9O1xuICAgICAgICAgICAgVXRpbHMuZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllcyh2YWx1ZXMuZGVsdGEsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGVsdGFbcHJvcF0gPSBuZXcgUHJvY2Vzc2VkQ291bnQodmFsdWVzLmRlbHRhW3Byb3BdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9jZXNzZWRNZXNzYWdlcztcbn0oKSk7XG52YXIgU3RhdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU3RhdHMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhdHModmFsdWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHZhbHVlcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGVyc2lzdGVkID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLnBlcnNpc3RlZCk7XG4gICAgICAgIF90aGlzLmNvbm5lY3Rpb25zID0gbmV3IENvbm5lY3Rpb25UeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmNvbm5lY3Rpb25zKTtcbiAgICAgICAgX3RoaXMuY2hhbm5lbHMgPSBuZXcgUmVzb3VyY2VDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLmNoYW5uZWxzKTtcbiAgICAgICAgX3RoaXMuYXBpUmVxdWVzdHMgPSBuZXcgUmVxdWVzdENvdW50KHZhbHVlcyAmJiB2YWx1ZXMuYXBpUmVxdWVzdHMpO1xuICAgICAgICBfdGhpcy50b2tlblJlcXVlc3RzID0gbmV3IFJlcXVlc3RDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLnRva2VuUmVxdWVzdHMpO1xuICAgICAgICBfdGhpcy54Y2hnUHJvZHVjZXIgPSBuZXcgWGNoZ01lc3NhZ2VzKHZhbHVlcyAmJiB2YWx1ZXMueGNoZ1Byb2R1Y2VyKTtcbiAgICAgICAgX3RoaXMueGNoZ0NvbnN1bWVyID0gbmV3IFhjaGdNZXNzYWdlcyh2YWx1ZXMgJiYgdmFsdWVzLnhjaGdDb25zdW1lcik7XG4gICAgICAgIF90aGlzLnB1c2ggPSBuZXcgUHVzaFN0YXRzKHZhbHVlcyAmJiB2YWx1ZXMucHVzaFN0YXRzKTtcbiAgICAgICAgX3RoaXMucHJvY2Vzc2VkID0gbmV3IFByb2Nlc3NlZE1lc3NhZ2VzKHZhbHVlcyAmJiB2YWx1ZXMucHJvY2Vzc2VkKTtcbiAgICAgICAgX3RoaXMuaW5Qcm9ncmVzcyA9ICh2YWx1ZXMgJiYgdmFsdWVzLmluUHJvZ3Jlc3MpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMudW5pdCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnVuaXQpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMuaW50ZXJ2YWxJZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLmludGVydmFsSWQpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdGF0cy5mcm9tVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRzKHZhbHVlcyk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdHM7XG59KE1lc3NhZ2VEaXJlY3Rpb25zKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTdGF0cztcblxuXG4vKioqLyB9KSxcbi8qIDUwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciByZXN0XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKSk7XG52YXIgZXZlbnRlbWl0dGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIGNvbm5lY3Rpb25fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNTEpKTtcbnZhciByZWFsdGltZWNoYW5uZWxfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzgpKTtcbnZhciBkZWZhdWx0c18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg4KSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBwcm90b2NvbG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTApKTtcbnZhciBjb25uZWN0aW9ubWFuYWdlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzNSkpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciBtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDkpKTtcbnZhciBSZWFsdGltZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZWFsdGltZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWFsdGltZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUmVhbHRpbWUoKScsICcnKTtcbiAgICAgICAgX3RoaXMuY29ubmVjdGlvbiA9IG5ldyBjb25uZWN0aW9uXzEuZGVmYXVsdChfdGhpcywgX3RoaXMub3B0aW9ucyk7XG4gICAgICAgIF90aGlzLmNoYW5uZWxzID0gbmV3IENoYW5uZWxzKF90aGlzKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlKVxuICAgICAgICAgICAgX3RoaXMuY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlYWx0aW1lLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1JlYWx0aW1lLmNvbm5lY3QoKScsICcnKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmNvbm5lY3QoKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdSZWFsdGltZS5jbG9zZSgpJywgJycpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lLlByb21pc2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gZGVmYXVsdHNfMS5kZWZhdWx0Lm9iamVjdGlmeU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMucHJvbWlzZXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbmV3IFJlYWx0aW1lKG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVhbHRpbWUuQ2FsbGJhY2tzID0gUmVhbHRpbWU7XG4gICAgUmVhbHRpbWUuVXRpbHMgPSBVdGlscztcbiAgICBSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlciA9IGNvbm5lY3Rpb25tYW5hZ2VyXzEuZGVmYXVsdDtcbiAgICBSZWFsdGltZS5QbGF0Zm9ybSA9IHBsYXRmb3JtXzEuZGVmYXVsdDtcbiAgICBSZWFsdGltZS5Qcm90b2NvbE1lc3NhZ2UgPSBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0O1xuICAgIFJlYWx0aW1lLk1lc3NhZ2UgPSBtZXNzYWdlXzEuZGVmYXVsdDtcbiAgICByZXR1cm4gUmVhbHRpbWU7XG59KHJlc3RfMS5kZWZhdWx0KSk7XG52YXIgQ2hhbm5lbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ2hhbm5lbHMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2hhbm5lbHMocmVhbHRpbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVhbHRpbWUgPSByZWFsdGltZTtcbiAgICAgICAgX3RoaXMuYWxsID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgcmVhbHRpbWUuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5vbigndHJhbnNwb3J0LmFjdGl2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLm9uVHJhbnNwb3J0QWN0aXZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENoYW5uZWxzLnByb3RvdHlwZS5jaGFubmVsU2VyaWFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlcmlhbHMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IFV0aWxzLmtleXNBcnJheSh0aGlzLmFsbCwgdHJ1ZSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXzFdO1xuICAgICAgICAgICAgaWYgKGNoYW5uZWwucHJvcGVydGllcy5jaGFubmVsU2VyaWFsKSB7XG4gICAgICAgICAgICAgICAgc2VyaWFsc1tuYW1lXzFdID0gY2hhbm5lbC5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmlhbHM7XG4gICAgfTtcbiAgICAvLyByZWNvdmVyQ2hhbm5lbHMgZ2V0cyB0aGUgZ2l2ZW4gY2hhbm5lbHMgYW5kIHNldHMgdGhlaXIgY2hhbm5lbCBzZXJpYWxzLlxuICAgIENoYW5uZWxzLnByb3RvdHlwZS5yZWNvdmVyQ2hhbm5lbHMgPSBmdW5jdGlvbiAoY2hhbm5lbFNlcmlhbHMpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IFV0aWxzLmtleXNBcnJheShjaGFubmVsU2VyaWFscywgdHJ1ZSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZV8yID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmdldChuYW1lXzIpO1xuICAgICAgICAgICAgY2hhbm5lbC5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWwgPSBjaGFubmVsU2VyaWFsc1tuYW1lXzJdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDaGFubmVscy5wcm90b3R5cGUub25DaGFubmVsTWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIGNoYW5uZWxOYW1lID0gbXNnLmNoYW5uZWw7XG4gICAgICAgIGlmIChjaGFubmVsTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0NoYW5uZWxzLm9uQ2hhbm5lbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBldmVudCB1bnNwZWNpZmllZCBjaGFubmVsLCBhY3Rpb24gPSAnICsgbXNnLmFjdGlvbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsTmFtZV07XG4gICAgICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDaGFubmVscy5vbkNoYW5uZWxNZXNzYWdlKCknLCAncmVjZWl2ZWQgZXZlbnQgZm9yIG5vbi1leGlzdGVudCBjaGFubmVsOiAnICsgY2hhbm5lbE5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5uZWwub25NZXNzYWdlKG1zZyk7XG4gICAgfTtcbiAgICAvKiBjYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBiZWNvbWVzIGNvbm5lY3RlZDsgcmVhdHRlbXB0IGF0dGFjaC9kZXRhY2hcbiAgICAgKiBmb3IgY2hhbm5lbHMgdGhhdCBhcmUgYXR0YWNoaW5nIG9yIGRldGFjaGluZy4gKi9cbiAgICBDaGFubmVscy5wcm90b3R5cGUub25UcmFuc3BvcnRBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGNoYW5uZWxOYW1lIGluIHRoaXMuYWxsKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxOYW1lXTtcbiAgICAgICAgICAgIGlmIChjaGFubmVsLnN0YXRlID09PSAnYXR0YWNoaW5nJyB8fCBjaGFubmVsLnN0YXRlID09PSAnZGV0YWNoaW5nJykge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5uZWwuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5fYXR0YWNoKGZhbHNlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5uZWwuc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlIGV4cGxpY2l0eSByZXF1ZXN0IHRoZSBzdGF0ZSwgY2hhbm5lbC5hdHRhY2goKSB3b3VsZCBkbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgLy8gYXMgaXRzIGFscmVhZHkgYXR0YWNoZWQuXG4gICAgICAgICAgICAgICAgY2hhbm5lbC5yZXF1ZXN0U3RhdGUoJ2F0dGFjaGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiBDb25uZWN0aW9uIGludGVycnVwdGlvbnMgKGllIHdoZW4gdGhlIGNvbm5lY3Rpb24gd2lsbCBubyBsb25nZXIgcXVldWVcbiAgICAgKiBldmVudHMpIGltcGx5IGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlcyBmb3IgYW55IGNoYW5uZWwgd2hpY2ggaXMgZWl0aGVyXG4gICAgICogYXR0YWNoZWQsIHBlbmRpbmcsIG9yIHdpbGwgYXR0ZW1wdCB0byBiZWNvbWUgYXR0YWNoZWQgaW4gdGhlIGZ1dHVyZSAqL1xuICAgIENoYW5uZWxzLnByb3RvdHlwZS5wcm9wb2dhdGVDb25uZWN0aW9uSW50ZXJydXB0aW9uID0gZnVuY3Rpb24gKGNvbm5lY3Rpb25TdGF0ZSwgcmVhc29uKSB7XG4gICAgICAgIHZhciBjb25uZWN0aW9uU3RhdGVUb0NoYW5uZWxTdGF0ZSA9IHtcbiAgICAgICAgICAgIGNsb3Npbmc6ICdkZXRhY2hlZCcsXG4gICAgICAgICAgICBjbG9zZWQ6ICdkZXRhY2hlZCcsXG4gICAgICAgICAgICBmYWlsZWQ6ICdmYWlsZWQnLFxuICAgICAgICAgICAgc3VzcGVuZGVkOiAnc3VzcGVuZGVkJyxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGZyb21DaGFubmVsU3RhdGVzID0gWydhdHRhY2hpbmcnLCAnYXR0YWNoZWQnLCAnZGV0YWNoaW5nJywgJ3N1c3BlbmRlZCddO1xuICAgICAgICB2YXIgdG9DaGFubmVsU3RhdGUgPSBjb25uZWN0aW9uU3RhdGVUb0NoYW5uZWxTdGF0ZVtjb25uZWN0aW9uU3RhdGVdO1xuICAgICAgICBmb3IgKHZhciBjaGFubmVsSWQgaW4gdGhpcy5hbGwpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5hbGxbY2hhbm5lbElkXTtcbiAgICAgICAgICAgIGlmIChVdGlscy5hcnJJbihmcm9tQ2hhbm5lbFN0YXRlcywgY2hhbm5lbC5zdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLm5vdGlmeVN0YXRlKHRvQ2hhbm5lbFN0YXRlLCByZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDaGFubmVscy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUsIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XG4gICAgICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgICAgICAgY2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdID0gbmV3IHJlYWx0aW1lY2hhbm5lbF8xLmRlZmF1bHQodGhpcy5yZWFsdGltZSwgbmFtZSwgY2hhbm5lbE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoY2hhbm5lbC5fc2hvdWxkUmVhdHRhY2hUb1NldE9wdGlvbnMoY2hhbm5lbE9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0NoYW5uZWxzLmdldCgpIGNhbm5vdCBiZSB1c2VkIHRvIHNldCBjaGFubmVsIG9wdGlvbnMgdGhhdCB3b3VsZCBjYXVzZSB0aGUgY2hhbm5lbCB0byByZWF0dGFjaC4gUGxlYXNlLCB1c2UgUmVhbHRpbWVDaGFubmVsLnNldE9wdGlvbnMoKSBpbnN0ZWFkLicsIDQwMDAwLCA0MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhbm5lbC5zZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbm5lbDtcbiAgICB9O1xuICAgIENoYW5uZWxzLnByb3RvdHlwZS5nZXREZXJpdmVkID0gZnVuY3Rpb24gKG5hbWUsIGRlcml2ZU9wdGlvbnMsIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgIGlmIChkZXJpdmVPcHRpb25zLmZpbHRlcikge1xuICAgICAgICAgICAgdmFyIGZpbHRlciA9IFV0aWxzLnRvQmFzZTY0KGRlcml2ZU9wdGlvbnMuZmlsdGVyKTtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IFV0aWxzLm1hdGNoRGVyaXZlZENoYW5uZWwobmFtZSk7XG4gICAgICAgICAgICBuYW1lID0gXCJbZmlsdGVyPVwiLmNvbmNhdChmaWx0ZXIpLmNvbmNhdChtYXRjaC5xdWFsaWZpZXJQYXJhbSwgXCJdXCIpLmNvbmNhdChtYXRjaC5jaGFubmVsTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUsIGNoYW5uZWxPcHRpb25zKTtcbiAgICB9O1xuICAgIC8qIEluY2x1ZGVkIHRvIHN1cHBvcnQgY2VydGFpbiBuaWNoZSB1c2UtY2FzZXM7IG1vc3QgdXNlcnMgc2hvdWxkIGlnbm9yZSB0aGlzLlxuICAgICAqIFBsZWFzZSBkbyBub3QgdXNlIHRoaXMgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nICovXG4gICAgQ2hhbm5lbHMucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdO1xuICAgICAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVsZWFzZUVyciA9IGNoYW5uZWwuZ2V0UmVsZWFzZUVycigpO1xuICAgICAgICBpZiAocmVsZWFzZUVycikge1xuICAgICAgICAgICAgdGhyb3cgcmVsZWFzZUVycjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5hbGxbbmFtZV07XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhbm5lbHM7XG59KGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlYWx0aW1lO1xuXG5cbi8qKiovIH0pLFxuLyogNTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGV2ZW50ZW1pdHRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG52YXIgY29ubmVjdGlvbm1hbmFnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzUpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIGNvbm5lY3Rpb25zdGF0ZWNoYW5nZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzNykpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbnZhciBDb25uZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKENvbm5lY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGlvbihhYmx5LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLndoZW5TdGF0ZSA9IChmdW5jdGlvbiAoc3RhdGUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRlbWl0dGVyXzEuZGVmYXVsdC5wcm90b3R5cGUud2hlblN0YXRlLmNhbGwoX3RoaXMsIHN0YXRlLCBfdGhpcy5zdGF0ZSwgbGlzdGVuZXIsIG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfMS5kZWZhdWx0KHVuZGVmaW5lZCwgc3RhdGUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLmFibHkgPSBhYmx5O1xuICAgICAgICBfdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBjb25uZWN0aW9ubWFuYWdlcl8xLmRlZmF1bHQoYWJseSwgb3B0aW9ucyk7XG4gICAgICAgIF90aGlzLnN0YXRlID0gX3RoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc3RhdGU7XG4gICAgICAgIF90aGlzLmtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMuaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLmVycm9yUmVhc29uID0gbnVsbDtcbiAgICAgICAgX3RoaXMuY29ubmVjdGlvbk1hbmFnZXIub24oJ2Nvbm5lY3Rpb25zdGF0ZScsIGZ1bmN0aW9uIChzdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gKF90aGlzLnN0YXRlID0gc3RhdGVDaGFuZ2UuY3VycmVudCk7XG4gICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KHN0YXRlLCBzdGF0ZUNoYW5nZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uKCd1cGRhdGUnLCBmdW5jdGlvbiAoc3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3VwZGF0ZScsIHN0YXRlQ2hhbmdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb24uY29ubmVjdCgpJywgJycpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiAnY29ubmVjdGluZycgfSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbi5waW5nKCknLCAnJyk7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFibHkub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3BpbmcnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucGluZyhudWxsLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uLmNsb3NlKCknLCAnY29ubmVjdGlvbktleSA9ICcgKyB0aGlzLmtleSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVxdWVzdFN0YXRlKHsgc3RhdGU6ICdjbG9zaW5nJyB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0aW9uLnByb3RvdHlwZSwgXCJyZWNvdmVyeUtleVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUmVjb3ZlcnlLZXkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZVJlY292ZXJ5S2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jcmVhdGVSZWNvdmVyeUtleSgpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbm5lY3Rpb247XG59KGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb247XG5cblxuLyoqKi8gfSksXG4vKiA1MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QZW5kaW5nTWVzc2FnZSA9IHZvaWQgMDtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBwcm90b2NvbG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTApKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGV2ZW50ZW1pdHRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBtZXNzYWdlcXVldWVfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzYpKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIGFjdGlvbnMgPSBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LkFjdGlvbjtcbnZhciBQZW5kaW5nTWVzc2FnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQZW5kaW5nTWVzc2FnZShtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMubWVyZ2VkID0gZmFsc2U7XG4gICAgICAgIHZhciBhY3Rpb24gPSBtZXNzYWdlLmFjdGlvbjtcbiAgICAgICAgdGhpcy5zZW5kQXR0ZW1wdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWNrUmVxdWlyZWQgPSBhY3Rpb24gPT0gYWN0aW9ucy5NRVNTQUdFIHx8IGFjdGlvbiA9PSBhY3Rpb25zLlBSRVNFTkNFO1xuICAgIH1cbiAgICByZXR1cm4gUGVuZGluZ01lc3NhZ2U7XG59KCkpO1xuZXhwb3J0cy5QZW5kaW5nTWVzc2FnZSA9IFBlbmRpbmdNZXNzYWdlO1xudmFyIFByb3RvY29sID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFByb3RvY29sLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByb3RvY29sKHRyYW5zcG9ydCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIF90aGlzLm1lc3NhZ2VRdWV1ZSA9IG5ldyBtZXNzYWdlcXVldWVfMS5kZWZhdWx0KCk7XG4gICAgICAgIHRyYW5zcG9ydC5vbignYWNrJywgZnVuY3Rpb24gKHNlcmlhbCwgY291bnQpIHtcbiAgICAgICAgICAgIF90aGlzLm9uQWNrKHNlcmlhbCwgY291bnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uKCduYWNrJywgZnVuY3Rpb24gKHNlcmlhbCwgY291bnQsIGVycikge1xuICAgICAgICAgICAgX3RoaXMub25OYWNrKHNlcmlhbCwgY291bnQsIGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFByb3RvY29sLnByb3RvdHlwZS5vbkFjayA9IGZ1bmN0aW9uIChzZXJpYWwsIGNvdW50KSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUHJvdG9jb2wub25BY2soKScsICdzZXJpYWwgPSAnICsgc2VyaWFsICsgJzsgY291bnQgPSAnICsgY291bnQpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKHNlcmlhbCwgY291bnQpO1xuICAgIH07XG4gICAgUHJvdG9jb2wucHJvdG90eXBlLm9uTmFjayA9IGZ1bmN0aW9uIChzZXJpYWwsIGNvdW50LCBlcnIpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdQcm90b2NvbC5vbk5hY2soKScsICdzZXJpYWwgPSAnICsgc2VyaWFsICsgJzsgY291bnQgPSAnICsgY291bnQgKyAnOyBlcnIgPSAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgZXJyID0gbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1VuYWJsZSB0byBzZW5kIG1lc3NhZ2U7IGNoYW5uZWwgbm90IHJlc3BvbmRpbmcnLCA1MDAwMSwgNTAwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKHNlcmlhbCwgY291bnQsIGVycik7XG4gICAgfTtcbiAgICBQcm90b2NvbC5wcm90b3R5cGUub25jZUlkbGUgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2VRdWV1ZSA9IHRoaXMubWVzc2FnZVF1ZXVlO1xuICAgICAgICBpZiAobWVzc2FnZVF1ZXVlLmNvdW50KCkgPT09IDApIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZVF1ZXVlLm9uY2UoJ2lkbGUnLCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBQcm90b2NvbC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwZW5kaW5nTWVzc2FnZSkge1xuICAgICAgICBpZiAocGVuZGluZ01lc3NhZ2UuYWNrUmVxdWlyZWQpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlLnB1c2gocGVuZGluZ01lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2dnZXJfMS5kZWZhdWx0LnNob3VsZExvZyhsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUHJvdG9jb2wuc2VuZCgpJywgJ3NlbmRpbmcgbXNnOyAnICsgcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5zdHJpbmdpZnkocGVuZGluZ01lc3NhZ2UubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgICAgIHBlbmRpbmdNZXNzYWdlLnNlbmRBdHRlbXB0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHBlbmRpbmdNZXNzYWdlLm1lc3NhZ2UpO1xuICAgIH07XG4gICAgUHJvdG9jb2wucHJvdG90eXBlLmdldFRyYW5zcG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0O1xuICAgIH07XG4gICAgUHJvdG9jb2wucHJvdG90eXBlLmdldFBlbmRpbmdNZXNzYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZVF1ZXVlLmNvcHlBbGwoKTtcbiAgICB9O1xuICAgIFByb3RvY29sLnByb3RvdHlwZS5jbGVhclBlbmRpbmdNZXNzYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZVF1ZXVlLmNsZWFyKCk7XG4gICAgfTtcbiAgICBQcm90b2NvbC5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnQ7XG4gICAgICAgIHRoaXMub25jZUlkbGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvdG9jb2w7XG59KGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFByb3RvY29sO1xuXG5cbi8qKiovIH0pLFxuLyogNTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciB0cmFuc3BvcnRfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjYpKTtcbnZhciBkZWZhdWx0c18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg4KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBwcm90b2NvbG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTApKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIHNob3J0TmFtZSA9ICd3ZWJfc29ja2V0JztcbmZ1bmN0aW9uIGlzTm9kZVdlYlNvY2tldCh3cykge1xuICAgIHJldHVybiAhIXdzLm9uO1xufVxudmFyIFdlYlNvY2tldFRyYW5zcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhXZWJTb2NrZXRUcmFuc3BvcnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV2ViU29ja2V0VHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lO1xuICAgICAgICAvKiBJZiBpcyBhIGJyb3dzZXIsIGNhbid0IGRldGVjdCBwaW5ncywgc28gcmVxdWVzdCBwcm90b2NvbCBoZWFydGJlYXRzICovXG4gICAgICAgIHBhcmFtcy5oZWFydGJlYXRzID0gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy51c2VQcm90b2NvbEhlYXJ0YmVhdHM7XG4gICAgICAgIF90aGlzLndzSG9zdCA9IGRlZmF1bHRzXzEuZGVmYXVsdC5nZXRIb3N0KHBhcmFtcy5vcHRpb25zLCBwYXJhbXMuaG9zdCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgV2ViU29ja2V0VHJhbnNwb3J0LmlzQXZhaWxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISFwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLldlYlNvY2tldDtcbiAgICB9O1xuICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY3JlYXRlV2ViU29ja2V0ID0gZnVuY3Rpb24gKHVyaSwgY29ubmVjdFBhcmFtcykge1xuICAgICAgICB0aGlzLnVyaSA9IHVyaSArIFV0aWxzLnRvUXVlcnlTdHJpbmcoY29ubmVjdFBhcmFtcyk7XG4gICAgICAgIHJldHVybiBuZXcgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5XZWJTb2NrZXQodGhpcy51cmkpO1xuICAgIH07XG4gICAgV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdXZWJTb2NrZXRUcmFuc3BvcnQ7IHVyaT0nICsgdGhpcy51cmk7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdzdGFydGluZycpO1xuICAgICAgICB0cmFuc3BvcnRfMS5kZWZhdWx0LnByb3RvdHlwZS5jb25uZWN0LmNhbGwodGhpcyk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcywgcGFyYW1zID0gdGhpcy5wYXJhbXMsIG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucztcbiAgICAgICAgdmFyIHdzU2NoZW1lID0gb3B0aW9ucy50bHMgPyAnd3NzOi8vJyA6ICd3czovLyc7XG4gICAgICAgIHZhciB3c1VyaSA9IHdzU2NoZW1lICsgdGhpcy53c0hvc3QgKyAnOicgKyBkZWZhdWx0c18xLmRlZmF1bHQuZ2V0UG9ydChvcHRpb25zKSArICcvJztcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpJywgJ3VyaTogJyArIHdzVXJpKTtcbiAgICAgICAgdGhpcy5hdXRoLmdldEF1dGhQYXJhbXMoZnVuY3Rpb24gKGVyciwgYXV0aFBhcmFtcykge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXJhbVN0ciA9ICcnO1xuICAgICAgICAgICAgZm9yICh2YXIgcGFyYW0gaW4gYXV0aFBhcmFtcylcbiAgICAgICAgICAgICAgICBwYXJhbVN0ciArPSAnICcgKyBwYXJhbSArICc6ICcgKyBhdXRoUGFyYW1zW3BhcmFtXSArICc7JztcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdhdXRoUGFyYW1zOicgKyBwYXJhbVN0ciArICcgZXJyOiAnICsgZXJyKTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRpc2Nvbm5lY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29ubmVjdFBhcmFtcyA9IHBhcmFtcy5nZXRDb25uZWN0UGFyYW1zKGF1dGhQYXJhbXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgd3NDb25uZWN0aW9uID0gKHNlbGYud3NDb25uZWN0aW9uID0gc2VsZi5jcmVhdGVXZWJTb2NrZXQod3NVcmksIGNvbm5lY3RQYXJhbXMpKTtcbiAgICAgICAgICAgICAgICB3c0Nvbm5lY3Rpb24uYmluYXJ5VHlwZSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuYmluYXJ5VHlwZTtcbiAgICAgICAgICAgICAgICB3c0Nvbm5lY3Rpb24ub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9uV3NPcGVuKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3c0Nvbm5lY3Rpb24ub25jbG9zZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9uV3NDbG9zZShldik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3c0Nvbm5lY3Rpb24ub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub25Xc0RhdGEoZXYuZGF0YSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3c0Nvbm5lY3Rpb24ub25lcnJvciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9uV3NFcnJvcihldik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb2RlV2ViU29ja2V0KHdzQ29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogbm9kZTsgYnJvd3NlcnMgY3VycmVudGx5IGRvbid0IGhhdmUgYSBnZW5lcmFsIGV2ZW50ZW1pdHRlciBhbmQgY2FuJ3QgZGV0ZWN0XG4gICAgICAgICAgICAgICAgICAgICAqIHBpbmdzLiBBbHNvLCBubyBuZWVkIHRvIHJlcGx5IHdpdGggYSBwb25nIGV4cGxpY2l0bHksIHdzIGxpYiBoYW5kbGVzIHRoYXQgKi9cbiAgICAgICAgICAgICAgICAgICAgd3NDb25uZWN0aW9uLm9uKCdwaW5nJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5vbkFjdGl2aXR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpJywgJ1VuZXhwZWN0ZWQgZXhjZXB0aW9uIGNyZWF0aW5nIHdlYnNvY2tldDogZXJyID0gJyArIChlLnN0YWNrIHx8IGUubWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgIHNlbGYuZGlzY29ubmVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgd3NDb25uZWN0aW9uID0gdGhpcy53c0Nvbm5lY3Rpb247XG4gICAgICAgIGlmICghd3NDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5zZW5kKCknLCAnTm8gc29ja2V0IGNvbm5lY3Rpb24nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd3NDb25uZWN0aW9uLnNlbmQocHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5zZXJpYWxpemUobWVzc2FnZSwgdGhpcy5wYXJhbXMuZm9ybWF0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnRXhjZXB0aW9uIGZyb20gd3MgY29ubmVjdGlvbiB3aGVuIHRyeWluZyB0byBzZW5kOiAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGUpO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuc2VuZCgpJywgbXNnKTtcbiAgICAgICAgICAgIC8qIERvbid0IHRyeSB0byByZXF1ZXN0IGEgZGlzY29ubmVjdCwgdGhhdCdsbCBqdXN0IGludm9sdmUgc2VuZGluZyBkYXRhXG4gICAgICAgICAgICAgKiBkb3duIHRoZSB3ZWJzb2NrZXQgYWdhaW4uIEp1c3QgZmluaXNoIHRoZSB0cmFuc3BvcnQuICovXG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA1MDAwMCwgNTAwKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUub25Xc0RhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1dlYlNvY2tldFRyYW5zcG9ydC5vbldzRGF0YSgpJywgJ2RhdGEgcmVjZWl2ZWQ7IGxlbmd0aCA9ICcgKyBkYXRhLmxlbmd0aCArICc7IHR5cGUgPSAnICsgdHlwZW9mIGRhdGEpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5vblByb3RvY29sTWVzc2FnZShwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmRlc2VyaWFsaXplKGRhdGEsIHRoaXMuZm9ybWF0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NEYXRhKCknLCAnVW5leHBlY3RlZCBleGNlcHRpb24gaGFuZGluZyBjaGFubmVsIG1lc3NhZ2U6ICcgKyBlLnN0YWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5vbldzT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25Xc09wZW4oKScsICdvcGVuZWQgV2ViU29ja2V0Jyk7XG4gICAgICAgIHRoaXMuZW1pdCgncHJlY29ubmVjdCcpO1xuICAgIH07XG4gICAgV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5vbldzQ2xvc2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIHdhc0NsZWFuLCBjb2RlO1xuICAgICAgICBpZiAodHlwZW9mIGV2ID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvKiBXM0Mgc3BlYy1jb21wYXRpYmxlICovXG4gICAgICAgICAgICBjb2RlID0gZXYuY29kZTtcbiAgICAgICAgICAgIC8vIGV2Lndhc0NsZWFuIGlzIHVuZGVmaW5lZCBpbiByZWFjdG5hdGl2ZVxuICAgICAgICAgICAgd2FzQ2xlYW4gPSBldi53YXNDbGVhbiB8fCBjb2RlID09PSAxMDAwO1xuICAgICAgICB9IC8qaWYodHlwZW9mKGV2KSA9PSAnbnVtYmVyJykqL1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIHdzIGluIG5vZGUgKi9cbiAgICAgICAgICAgIGNvZGUgPSBldjtcbiAgICAgICAgICAgIHdhc0NsZWFuID0gY29kZSA9PSAxMDAwO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLndzQ29ubmVjdGlvbjtcbiAgICAgICAgaWYgKHdhc0NsZWFuKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5vbldzQ2xvc2UoKScsICdDbGVhbmx5IGNsb3NlZCBXZWJTb2NrZXQnKTtcbiAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnV2Vic29ja2V0IGNsb3NlZCcsIDgwMDAzLCA0MDApO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ1VuY2xlYW4gZGlzY29ubmVjdGlvbiBvZiBXZWJTb2NrZXQgOyBjb2RlID0gJyArIGNvZGUsIGVyciA9IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgODAwMDMsIDQwMCk7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5vbldzQ2xvc2UoKScsIG1zZyk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ2Rpc3Bvc2VkJyk7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uV3NFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25FcnJvcigpJywgJ0Vycm9yIGZyb20gV2ViU29ja2V0OiAnICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAvKiBXYWl0IGEgdGljayBiZWZvcmUgYWJvcnRpbmc6IGlmIHRoZSB3ZWJzb2NrZXQgd2FzIGNvbm5lY3RlZCwgdGhpcyBldmVudFxuICAgICAgICAgKiB3aWxsIGJlIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFuIG9uY2xvc2UgZXZlbnQgd2l0aCBhIGNsb3NlIGNvZGUuIEFsbG93XG4gICAgICAgICAqIHRoYXQgdG8gY2xvc2UgaXQgKHNvIHdlIHNlZSB0aGUgY2xvc2UgY29kZSkgcmF0aGVyIHRoYW4gYW50aWNpcGF0aW5nIGl0ICovXG4gICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZGlzY29ubmVjdChFcnJvcihlcnIubWVzc2FnZSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuZGlzcG9zZSgpJywgJycpO1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB2YXIgd3NDb25uZWN0aW9uID0gdGhpcy53c0Nvbm5lY3Rpb247XG4gICAgICAgIGlmICh3c0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIC8qIElnbm9yZSBhbnkgbWVzc2FnZXMgdGhhdCBjb21lIHRocm91Z2ggYWZ0ZXIgZGlzcG9zZSgpIGlzIGNhbGxlZCBidXQgYmVmb3JlXG4gICAgICAgICAgICAgKiB3ZWJzb2NrZXQgaXMgYWN0dWFsbHkgY2xvc2VkLiAobW9zdGx5IHdvdWxkIGJlIGhhcm1sZXNzLCBidXQgaWYgaXQncyBhXG4gICAgICAgICAgICAgKiBDT05ORUNURUQsIGl0J2xsIHJlLXRpY2sgaXNDb25uZWN0ZWQgYW5kIGNhdXNlIGFsbCBzb3J0cyBvZiBoYXZvYykgKi9cbiAgICAgICAgICAgIHdzQ29ubmVjdGlvbi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy53c0Nvbm5lY3Rpb247XG4gICAgICAgICAgICAvKiBkZWZlciB1bnRpbCB0aGUgbmV4dCBldmVudCBsb29wIGN5Y2xlIGJlZm9yZSBjbG9zaW5nIHRoZSBzb2NrZXQsXG4gICAgICAgICAgICAgKiBnaXZpbmcgc29tZSBpbXBsZW1lbnRhdGlvbnMgdGhlIG9wcG9ydHVuaXR5IHRvIHNlbmQgYW55IG91dHN0YW5kaW5nIGNsb3NlIG1lc3NhZ2UgKi9cbiAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnV2ViU29ja2V0VHJhbnNwb3J0LmRpc3Bvc2UoKScsICdjbG9zaW5nIHdlYnNvY2tldCcpO1xuICAgICAgICAgICAgICAgIGlmICghd3NDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0VHJhbnNwb3J0LmRpc3Bvc2UoKTogd3NDb25uZWN0aW9uIGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdzQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBXZWJTb2NrZXRUcmFuc3BvcnQ7XG59KHRyYW5zcG9ydF8xLmRlZmF1bHQpKTtcbmZ1bmN0aW9uIGluaXRpYWxpc2VUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIpIHtcbiAgICBpZiAoV2ViU29ja2V0VHJhbnNwb3J0LmlzQXZhaWxhYmxlKCkpXG4gICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHNbc2hvcnROYW1lXSA9IFdlYlNvY2tldFRyYW5zcG9ydDtcbiAgICByZXR1cm4gV2ViU29ja2V0VHJhbnNwb3J0O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gaW5pdGlhbGlzZVRyYW5zcG9ydDtcblxuXG4vKioqLyB9KSxcbi8qIDU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBwcmVzZW5jZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzNCkpO1xudmFyIGV2ZW50ZW1pdHRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBwcmVzZW5jZW1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTUpKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIHJlYWx0aW1lY2hhbm5lbF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzOCkpO1xudmFyIG11bHRpY2FzdGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKSk7XG52YXIgY2hhbm5lbHN0YXRlY2hhbmdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KSk7XG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcbmZ1bmN0aW9uIGdldENsaWVudElkKHJlYWx0aW1lUHJlc2VuY2UpIHtcbiAgICByZXR1cm4gcmVhbHRpbWVQcmVzZW5jZS5jaGFubmVsLnJlYWx0aW1lLmF1dGguY2xpZW50SWQ7XG59XG5mdW5jdGlvbiBpc0Fub255bW91c09yV2lsZGNhcmQocmVhbHRpbWVQcmVzZW5jZSkge1xuICAgIHZhciByZWFsdGltZSA9IHJlYWx0aW1lUHJlc2VuY2UuY2hhbm5lbC5yZWFsdGltZTtcbiAgICAvKiBJZiBub3QgY3VycmVudGx5IGNvbm5lY3RlZCwgd2UgY2FuJ3QgYXNzdW1lIHRoYXQgd2UncmUgYW4gYW5vbnltb3VzXG4gICAgICogY2xpZW50LCBhcyByZWFsdGltZSBtYXkgaW5mb3JtIHVzIG9mIG91ciBjbGllbnRJZCBpbiB0aGUgQ09OTkVDVEVEXG4gICAgICogbWVzc2FnZS4gU28gYXNzdW1lIHdlJ3JlIG5vdCBhbm9ueW1vdXMgYW5kIGxlYXZlIGl0IHRvIHJlYWx0aW1lIHRvXG4gICAgICogcmV0dXJuIGFuIGVycm9yIGlmIHdlIGFyZSAqL1xuICAgIHZhciBjbGllbnRJZCA9IHJlYWx0aW1lLmF1dGguY2xpZW50SWQ7XG4gICAgcmV0dXJuICghY2xpZW50SWQgfHwgY2xpZW50SWQgPT09ICcqJykgJiYgcmVhbHRpbWUuY29ubmVjdGlvbi5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCc7XG59XG4vKiBDYWxsYmFjayBpcyBjYWxsZWQgb25seSBpbiB0aGUgZXZlbnQgb2YgYW4gZXJyb3IgKi9cbmZ1bmN0aW9uIHdhaXRBdHRhY2hlZChjaGFubmVsLCBjYWxsYmFjaywgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChjaGFubmVsLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgJ2F0dGFjaGVkJzpcbiAgICAgICAgY2FzZSAnc3VzcGVuZGVkJzpcbiAgICAgICAgICAgIGFjdGlvbigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2luaXRpYWxpemVkJzpcbiAgICAgICAgY2FzZSAnZGV0YWNoZWQnOlxuICAgICAgICBjYXNlICdkZXRhY2hpbmcnOlxuICAgICAgICBjYXNlICdhdHRhY2hpbmcnOlxuICAgICAgICAgICAgY2hhbm5lbC5hdHRhY2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMoY2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvcigpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3ZXJUaGFuKGl0ZW0sIGV4aXN0aW5nKSB7XG4gICAgLyogUlRQMmIxOiBpZiBlaXRoZXIgaXMgc3ludGhlc2lzZWQsIGNvbXBhcmUgYnkgdGltZXN0YW1wICovXG4gICAgaWYgKGl0ZW0uaXNTeW50aGVzaXplZCgpIHx8IGV4aXN0aW5nLmlzU3ludGhlc2l6ZWQoKSkge1xuICAgICAgICAvLyBSVFAyYjFhOiBpZiBlcXVhbCwgcHJlZmVyIHRoZSBuZXdseS1hcnJpdmVkIG9uZVxuICAgICAgICByZXR1cm4gaXRlbS50aW1lc3RhbXAgPj0gZXhpc3RpbmcudGltZXN0YW1wO1xuICAgIH1cbiAgICAvKiBSVFAyYjIgKi9cbiAgICB2YXIgaXRlbU9yZGVyaW5ncyA9IGl0ZW0ucGFyc2VJZCgpLCBleGlzdGluZ09yZGVyaW5ncyA9IGV4aXN0aW5nLnBhcnNlSWQoKTtcbiAgICBpZiAoaXRlbU9yZGVyaW5ncy5tc2dTZXJpYWwgPT09IGV4aXN0aW5nT3JkZXJpbmdzLm1zZ1NlcmlhbCkge1xuICAgICAgICByZXR1cm4gaXRlbU9yZGVyaW5ncy5pbmRleCA+IGV4aXN0aW5nT3JkZXJpbmdzLmluZGV4O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1PcmRlcmluZ3MubXNnU2VyaWFsID4gZXhpc3RpbmdPcmRlcmluZ3MubXNnU2VyaWFsO1xuICAgIH1cbn1cbnZhciBSZWFsdGltZVByZXNlbmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJlYWx0aW1lUHJlc2VuY2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVhbHRpbWVQcmVzZW5jZShjaGFubmVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNoYW5uZWwpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICBfdGhpcy5zeW5jQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubWVtYmVycyA9IG5ldyBQcmVzZW5jZU1hcChfdGhpcywgZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uY2xpZW50SWQgKyAnOicgKyBpdGVtLmNvbm5lY3Rpb25JZDsgfSk7XG4gICAgICAgIC8vIFJUUDE3aDogU3RvcmUgb3duIG1lbWJlcnMgYnkgY2xpZW50SWQgb25seS5cbiAgICAgICAgX3RoaXMuX215TWVtYmVycyA9IG5ldyBQcmVzZW5jZU1hcChfdGhpcywgZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uY2xpZW50SWQ7IH0pO1xuICAgICAgICBfdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgX3RoaXMucGVuZGluZ1ByZXNlbmNlID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGlzQW5vbnltb3VzT3JXaWxkY2FyZCh0aGlzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ2NsaWVudElkIG11c3QgYmUgc3BlY2lmaWVkIHRvIGVudGVyIGEgcHJlc2VuY2UgY2hhbm5lbCcsIDQwMDEyLCA0MDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkYXRhLCAnZW50ZXInLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGlzQW5vbnltb3VzT3JXaWxkY2FyZCh0aGlzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ2NsaWVudElkIG11c3QgYmUgc3BlY2lmaWVkIHRvIHVwZGF0ZSBwcmVzZW5jZSBkYXRhJywgNDAwMTIsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQodW5kZWZpbmVkLCB1bmRlZmluZWQsIGRhdGEsICd1cGRhdGUnLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5lbnRlckNsaWVudCA9IGZ1bmN0aW9uIChjbGllbnRJZCwgZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQodW5kZWZpbmVkLCBjbGllbnRJZCwgZGF0YSwgJ2VudGVyJywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUudXBkYXRlQ2xpZW50ID0gZnVuY3Rpb24gKGNsaWVudElkLCBkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh1bmRlZmluZWQsIGNsaWVudElkLCBkYXRhLCAndXBkYXRlJywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuX2VudGVyT3JVcGRhdGVDbGllbnQgPSBmdW5jdGlvbiAoaWQsIGNsaWVudElkLCBkYXRhLCBhY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZGF0YTtcbiAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWwucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdfZW50ZXJPclVwZGF0ZUNsaWVudCcsIFtpZCwgY2xpZW50SWQsIGRhdGEsIGFjdGlvbl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG4gICAgICAgIGlmICghY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS4nICsgYWN0aW9uICsgJ0NsaWVudCgpJywgJ2NoYW5uZWwgPSAnICsgY2hhbm5lbC5uYW1lICsgJywgaWQgPSAnICsgaWQgKyAnLCBjbGllbnQgPSAnICsgKGNsaWVudElkIHx8ICcoaW1wbGljaXQpICcgKyBnZXRDbGllbnRJZCh0aGlzKSkpO1xuICAgICAgICB2YXIgcHJlc2VuY2UgPSBwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmZyb21EYXRhKGRhdGEpO1xuICAgICAgICBwcmVzZW5jZS5hY3Rpb24gPSBhY3Rpb247XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgcHJlc2VuY2UuaWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xpZW50SWQpIHtcbiAgICAgICAgICAgIHByZXNlbmNlLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgIH1cbiAgICAgICAgcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5lbmNvZGUocHJlc2VuY2UsIGNoYW5uZWwuY2hhbm5lbE9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhbm5lbC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2F0dGFjaGVkJzpcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5zZW5kUHJlc2VuY2UocHJlc2VuY2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW5pdGlhbGl6ZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RldGFjaGVkJzpcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5hdHRhY2goKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlICdhdHRhY2hpbmcnOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wZW5kaW5nUHJlc2VuY2UucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZTogcHJlc2VuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBlcnIgPSBuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygnVW5hYmxlIHRvICcgKyBhY3Rpb24gKyAnIHByZXNlbmNlIGNoYW5uZWwgd2hpbGUgaW4gJyArIGNoYW5uZWwuc3RhdGUgKyAnIHN0YXRlJywgOTAwMDEpO1xuICAgICAgICAgICAgICAgICAgICBlcnIuY29kZSA9IDkwMDAxO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChpc0Fub255bW91c09yV2lsZGNhcmQodGhpcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdjbGllbnRJZCBtdXN0IGhhdmUgYmVlbiBzcGVjaWZpZWQgdG8gZW50ZXIgb3IgbGVhdmUgYSBwcmVzZW5jZSBjaGFubmVsJywgNDAwMTIsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGVhdmVDbGllbnQodW5kZWZpbmVkLCBkYXRhLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5sZWF2ZUNsaWVudCA9IGZ1bmN0aW9uIChjbGllbnRJZCwgZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbC5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2xlYXZlQ2xpZW50JywgW2NsaWVudElkLCBkYXRhXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcbiAgICAgICAgaWYgKCFjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS5sZWF2ZUNsaWVudCgpJywgJ2xlYXZpbmc7IGNoYW5uZWwgPSAnICsgdGhpcy5jaGFubmVsLm5hbWUgKyAnLCBjbGllbnQgPSAnICsgY2xpZW50SWQpO1xuICAgICAgICB2YXIgcHJlc2VuY2UgPSBwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgYWN0aW9uOiAnbGVhdmUnLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjbGllbnRJZCkge1xuICAgICAgICAgICAgcHJlc2VuY2UuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGNoYW5uZWwuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2F0dGFjaGVkJzpcbiAgICAgICAgICAgICAgICBjaGFubmVsLnNlbmRQcmVzZW5jZShwcmVzZW5jZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYXR0YWNoaW5nJzpcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdQcmVzZW5jZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2U6IHByZXNlbmNlLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbml0aWFsaXplZCc6XG4gICAgICAgICAgICBjYXNlICdmYWlsZWQnOiB7XG4gICAgICAgICAgICAgICAgLyogd2UncmUgbm90IGF0dGFjaGVkOyB0aGVyZWZvcmUgd2UgbGV0IGFueSBlbnRlcmVkIHN0YXR1c1xuICAgICAgICAgICAgICAgICAqIHRpbWVvdXQgYnkgaXRzZWxmIGluc3RlYWQgb2YgYXR0YWNoaW5nIGp1c3QgaW4gb3JkZXIgdG8gbGVhdmUgKi9cbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ1VuYWJsZSB0byBsZWF2ZSBwcmVzZW5jZSBjaGFubmVsIChpbmNvbXBhdGlibGUgc3RhdGUpJywgOTAwMDEpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soY2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvcigpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gUmV0dXJuIHR5cGUgaXMgYW55IHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggYmFzZSBQcmVzZW5jZSBjbGFzc1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDEgJiYgdHlwZW9mIGFyZ3NbMF0gPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdChudWxsKTtcbiAgICAgICAgcGFyYW1zID0gYXJnc1swXTtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgd2FpdEZvclN5bmMgPSAhcGFyYW1zIHx8ICgnd2FpdEZvclN5bmMnIGluIHBhcmFtcyA/IHBhcmFtcy53YWl0Rm9yU3luYyA6IHRydWUpO1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdnZXQnLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXR1cm5NZW1iZXJzKG1lbWJlcnMpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHBhcmFtcyA/IG1lbWJlcnMubGlzdChwYXJhbXMpIDogbWVtYmVycy52YWx1ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogU3BlY2lhbC1jYXNlIHRoZSBzdXNwZW5kZWQgc3RhdGU6IGNhbiBzdGlsbCBnZXQgKHN0YWxlKSBwcmVzZW5jZSBzZXQgaWYgd2FpdEZvclN5bmMgaXMgZmFsc2UgKi9cbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbC5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcbiAgICAgICAgICAgIGlmICh3YWl0Rm9yU3luYykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogOTEwMDUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdQcmVzZW5jZSBzdGF0ZSBpcyBvdXQgb2Ygc3luYyBkdWUgdG8gY2hhbm5lbCBiZWluZyBpbiB0aGUgU1VTUEVOREVEIHN0YXRlJyxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm5NZW1iZXJzKHRoaXMubWVtYmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2FpdEF0dGFjaGVkKHRoaXMuY2hhbm5lbCwgY2FsbGJhY2ssIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZW1iZXJzID0gX3RoaXMubWVtYmVycztcbiAgICAgICAgICAgIGlmICh3YWl0Rm9yU3luYykge1xuICAgICAgICAgICAgICAgIG1lbWJlcnMud2FpdFN5bmMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5NZW1iZXJzKG1lbWJlcnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuTWVtYmVycyhtZW1iZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5oaXN0b3J5ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZVByZXNlbmNlLmhpc3RvcnkoKScsICdjaGFubmVsID0gJyArIHRoaXMubmFtZSk7XG4gICAgICAgIC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xuICAgICAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnaGlzdG9yeScsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zICYmIHBhcmFtcy51bnRpbEF0dGFjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbC5zdGF0ZSA9PT0gJ2F0dGFjaGVkJykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXMudW50aWxBdHRhY2g7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmZyb21fc2VyaWFsID0gdGhpcy5jaGFubmVsLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ29wdGlvbiB1bnRpbEF0dGFjaCByZXF1aXJlcyB0aGUgY2hhbm5lbCB0byBiZSBhdHRhY2hlZCwgd2FzOiAnICsgdGhpcy5jaGFubmVsLnN0YXRlLCA0MDAwMCwgNDAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJlc2VuY2VfMS5kZWZhdWx0LnByb3RvdHlwZS5faGlzdG9yeS5jYWxsKHRoaXMsIHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuc2V0UHJlc2VuY2UgPSBmdW5jdGlvbiAocHJlc2VuY2VTZXQsIGlzU3luYywgc3luY0NoYW5uZWxTZXJpYWwpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZVByZXNlbmNlLnNldFByZXNlbmNlKCknLCAncmVjZWl2ZWQgcHJlc2VuY2UgZm9yICcgKyBwcmVzZW5jZVNldC5sZW5ndGggKyAnIHBhcnRpY2lwYW50czsgc3luY0NoYW5uZWxTZXJpYWwgPSAnICsgc3luY0NoYW5uZWxTZXJpYWwpO1xuICAgICAgICB2YXIgc3luY0N1cnNvciwgbWF0Y2g7XG4gICAgICAgIHZhciBtZW1iZXJzID0gdGhpcy5tZW1iZXJzLCBteU1lbWJlcnMgPSB0aGlzLl9teU1lbWJlcnMsIGJyb2FkY2FzdE1lc3NhZ2VzID0gW10sIGNvbm5JZCA9IHRoaXMuY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWQ7XG4gICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHRoaXMubWVtYmVycy5zdGFydFN5bmMoKTtcbiAgICAgICAgICAgIGlmIChzeW5jQ2hhbm5lbFNlcmlhbCAmJiAobWF0Y2ggPSBzeW5jQ2hhbm5lbFNlcmlhbC5tYXRjaCgvXltcXHctXSs6KC4qKSQvKSkpIHtcbiAgICAgICAgICAgICAgICBzeW5jQ3Vyc29yID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVzZW5jZVNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHByZXNlbmNlID0gcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHByZXNlbmNlU2V0W2ldKTtcbiAgICAgICAgICAgIHN3aXRjaCAocHJlc2VuY2UuYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGVhdmUnOlxuICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVycy5yZW1vdmUocHJlc2VuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3RNZXNzYWdlcy5wdXNoKHByZXNlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJlc2VuY2UuY29ubmVjdGlvbklkID09PSBjb25uSWQgJiYgIXByZXNlbmNlLmlzU3ludGhlc2l6ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXlNZW1iZXJzLnJlbW92ZShwcmVzZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZW50ZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3ByZXNlbnQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXJzLnB1dChwcmVzZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyb2FkY2FzdE1lc3NhZ2VzLnB1c2gocHJlc2VuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVzZW5jZS5jb25uZWN0aW9uSWQgPT09IGNvbm5JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXlNZW1iZXJzLnB1dChwcmVzZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogaWYgdGhpcyBpcyB0aGUgbGFzdCAob3Igb25seSkgbWVzc2FnZSBpbiBhIHNlcXVlbmNlIG9mIHN5bmMgdXBkYXRlcywgZW5kIHRoZSBzeW5jICovXG4gICAgICAgIGlmIChpc1N5bmMgJiYgIXN5bmNDdXJzb3IpIHtcbiAgICAgICAgICAgIG1lbWJlcnMuZW5kU3luYygpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLnN5bmNDaGFubmVsU2VyaWFsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKiBicm9hZGNhc3QgdG8gbGlzdGVuZXJzICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnJvYWRjYXN0TWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcmVzZW5jZSA9IGJyb2FkY2FzdE1lc3NhZ2VzW2ldO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmVtaXQocHJlc2VuY2UuYWN0aW9uLCBwcmVzZW5jZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLm9uQXR0YWNoZWQgPSBmdW5jdGlvbiAoaGFzUHJlc2VuY2UpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdSZWFsdGltZVByZXNlbmNlLm9uQXR0YWNoZWQoKScsICdjaGFubmVsID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lICsgJywgaGFzUHJlc2VuY2UgPSAnICsgaGFzUHJlc2VuY2UpO1xuICAgICAgICBpZiAoaGFzUHJlc2VuY2UpIHtcbiAgICAgICAgICAgIHRoaXMubWVtYmVycy5zdGFydFN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N5bnRoZXNpemVMZWF2ZXModGhpcy5tZW1iZXJzLnZhbHVlcygpKTtcbiAgICAgICAgICAgIHRoaXMubWVtYmVycy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJUUDE3ZjogUmUtZW50ZXIgb3duIG1lbWJlcnMgd2hlbiBtb3ZpbmcgaW50byB0aGUgYXR0YWNoZWQgc3RhdGUuXG4gICAgICAgIHRoaXMuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKTtcbiAgICAgICAgLyogTkIgdGhpcyBtdXN0IGJlIGFmdGVyIHRoZSBfZW5zdXJlTXlNZW1iZXJzUHJlc2VudCBjYWxsLCB3aGljaCBtYXkgYWRkIGl0ZW1zIHRvIHBlbmRpbmdQcmVzZW5jZSAqL1xuICAgICAgICB2YXIgcGVuZGluZ1ByZXNlbmNlID0gdGhpcy5wZW5kaW5nUHJlc2VuY2UsIHBlbmRpbmdQcmVzQ291bnQgPSBwZW5kaW5nUHJlc2VuY2UubGVuZ3RoO1xuICAgICAgICBpZiAocGVuZGluZ1ByZXNDb3VudCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nUHJlc2VuY2UgPSBbXTtcbiAgICAgICAgICAgIHZhciBwcmVzZW5jZUFycmF5ID0gW107XG4gICAgICAgICAgICB2YXIgbXVsdGljYXN0ZXIgPSBtdWx0aWNhc3Rlcl8xLmRlZmF1bHQuY3JlYXRlKCk7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2Uub25BdHRhY2hlZCcsICdzZW5kaW5nICcgKyBwZW5kaW5nUHJlc0NvdW50ICsgJyBxdWV1ZWQgcHJlc2VuY2UgbWVzc2FnZXMnKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGVuZGluZ1ByZXNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50XzEgPSBwZW5kaW5nUHJlc2VuY2VbaV07XG4gICAgICAgICAgICAgICAgcHJlc2VuY2VBcnJheS5wdXNoKGV2ZW50XzEucHJlc2VuY2UpO1xuICAgICAgICAgICAgICAgIG11bHRpY2FzdGVyLnB1c2goZXZlbnRfMS5jYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwuc2VuZFByZXNlbmNlKHByZXNlbmNlQXJyYXksIG11bHRpY2FzdGVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuYWN0T25DaGFubmVsU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIGhhc1ByZXNlbmNlLCBlcnIpIHtcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnYXR0YWNoZWQnOlxuICAgICAgICAgICAgICAgIHRoaXMub25BdHRhY2hlZChoYXNQcmVzZW5jZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkZXRhY2hlZCc6XG4gICAgICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyTXlNZW1iZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZW1iZXJzLmNsZWFyKCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdzdXNwZW5kZWQnOlxuICAgICAgICAgICAgICAgIHRoaXMuZmFpbFBlbmRpbmdQcmVzZW5jZShlcnIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5mYWlsUGVuZGluZ1ByZXNlbmNlID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nUHJlc2VuY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5mYWlsUGVuZGluZ1ByZXNlbmNlJywgJ2NoYW5uZWw7IG5hbWUgPSAnICsgdGhpcy5jaGFubmVsLm5hbWUgKyAnLCBlcnIgPSAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdQcmVzZW5jZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdQcmVzZW5jZVtpXS5jYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nUHJlc2VuY2UgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuX2NsZWFyTXlNZW1iZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9teU1lbWJlcnMuY2xlYXIoKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbXlNZW1iZXJzID0gdGhpcy5fbXlNZW1iZXJzLCByZWVudGVyQ2IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdQcmVzZW5jZSBhdXRvLXJlLWVudGVyIGZhaWxlZDogJyArIGVyci50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHZhciB3cmFwcGVkRXJyID0gbmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA5MTAwNCwgNDAwKTtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1JlYWx0aW1lUHJlc2VuY2UuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKScsIG1zZyk7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZSA9IG5ldyBjaGFubmVsc3RhdGVjaGFuZ2VfMS5kZWZhdWx0KF90aGlzLmNoYW5uZWwuc3RhdGUsIF90aGlzLmNoYW5uZWwuc3RhdGUsIHRydWUsIGZhbHNlLCB3cmFwcGVkRXJyKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jaGFubmVsLmVtaXQoJ3VwZGF0ZScsIGNoYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIG1lbWJlcktleSBpbiBteU1lbWJlcnMubWFwKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBteU1lbWJlcnMubWFwW21lbWJlcktleV07XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2UuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKScsICdBdXRvLXJlZW50ZXJpbmcgY2xpZW50SWQgXCInICsgZW50cnkuY2xpZW50SWQgKyAnXCIgaW50byB0aGUgcHJlc2VuY2Ugc2V0Jyk7XG4gICAgICAgICAgICAvLyBSVFAxN2c6IFNlbmQgRU5URVIgY29udGFpbmluZyB0aGUgbWVtYmVyIGlkLCBjbGllbnRJZCBhbmQgZGF0YVxuICAgICAgICAgICAgLy8gYXR0cmlidXRlcy5cbiAgICAgICAgICAgIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQoZW50cnkuaWQsIGVudHJ5LmNsaWVudElkLCBlbnRyeS5kYXRhLCAnZW50ZXInLCByZWVudGVyQ2IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5fc3ludGhlc2l6ZUxlYXZlcyA9IGZ1bmN0aW9uIChpdGVtcykge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucztcbiAgICAgICAgVXRpbHMuYXJyRm9yRWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBwcmVzZW5jZSA9IHByZXNlbmNlbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnbGVhdmUnLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogaXRlbS5jb25uZWN0aW9uSWQsXG4gICAgICAgICAgICAgICAgY2xpZW50SWQ6IGl0ZW0uY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgZGF0YTogaXRlbS5kYXRhLFxuICAgICAgICAgICAgICAgIGVuY29kaW5nOiBpdGVtLmVuY29kaW5nLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogVXRpbHMubm93KCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuZW1pdCgnbGVhdmUnLCBwcmVzZW5jZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyogRGVwcmVjYXRlZCAqL1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZGVwcmVjYXRlZCgncHJlc2VuY2Uub24nLCAncHJlc2VuY2Uuc3Vic2NyaWJlJyk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgLyogRGVwcmVjYXRlZCAqL1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlcHJlY2F0ZWQoJ3ByZXNlbmNlLm9mZicsICdwcmVzZW5jZS51bnN1YnNjcmliZScpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2FyZ3MgPSBbXTsgLyogW2V2ZW50XSwgbGlzdGVuZXIsIFtjYWxsYmFja10gKi9cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwIC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGggLyogW2V2ZW50XSwgbGlzdGVuZXIsIFtjYWxsYmFja10gKi87IF9pKysgLyogW2V2ZW50XSwgbGlzdGVuZXIsIFtjYWxsYmFja10gKi8pIHtcbiAgICAgICAgICAgIF9hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07IC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ3MgPSByZWFsdGltZWNoYW5uZWxfMS5kZWZhdWx0LnByb2Nlc3NMaXN0ZW5lckFyZ3MoX2FyZ3MpO1xuICAgICAgICB2YXIgZXZlbnQgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzWzJdO1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbC5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnc3Vic2NyaWJlJywgW2V2ZW50LCBsaXN0ZW5lcl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFubmVsLnN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKGNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoKSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICBjaGFubmVsLmF0dGFjaChjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hcmdzID0gW107IC8qIFtldmVudF0sIGxpc3RlbmVyICovXG4gICAgICAgIGZvciAodmFyIF9pID0gMCAvKiBbZXZlbnRdLCBsaXN0ZW5lciAqLzsgX2kgPCBhcmd1bWVudHMubGVuZ3RoIC8qIFtldmVudF0sIGxpc3RlbmVyICovOyBfaSsrIC8qIFtldmVudF0sIGxpc3RlbmVyICovKSB7XG4gICAgICAgICAgICBfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldOyAvKiBbZXZlbnRdLCBsaXN0ZW5lciAqL1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcmdzID0gcmVhbHRpbWVjaGFubmVsXzEuZGVmYXVsdC5wcm9jZXNzTGlzdGVuZXJBcmdzKF9hcmdzKTtcbiAgICAgICAgdmFyIGV2ZW50ID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gYXJnc1sxXTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlYWx0aW1lUHJlc2VuY2U7XG59KHByZXNlbmNlXzEuZGVmYXVsdCkpO1xudmFyIFByZXNlbmNlTWFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFByZXNlbmNlTWFwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByZXNlbmNlTWFwKHByZXNlbmNlLCBtZW1iZXJLZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucHJlc2VuY2UgPSBwcmVzZW5jZTtcbiAgICAgICAgX3RoaXMubWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgX3RoaXMuc3luY0luUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMucmVzaWR1YWxNZW1iZXJzID0gbnVsbDtcbiAgICAgICAgX3RoaXMubWVtYmVyS2V5ID0gbWVtYmVyS2V5O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFByZXNlbmNlTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcFtrZXldO1xuICAgIH07XG4gICAgUHJlc2VuY2VNYXAucHJvdG90eXBlLmdldENsaWVudCA9IGZ1bmN0aW9uIChjbGllbnRJZCkge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5tYXAsIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbWFwKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IG1hcFtrZXldO1xuICAgICAgICAgICAgaWYgKGl0ZW0uY2xpZW50SWQgPT0gY2xpZW50SWQgJiYgaXRlbS5hY3Rpb24gIT0gJ2Fic2VudCcpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFByZXNlbmNlTWFwLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5tYXAsIGNsaWVudElkID0gcGFyYW1zICYmIHBhcmFtcy5jbGllbnRJZCwgY29ubmVjdGlvbklkID0gcGFyYW1zICYmIHBhcmFtcy5jb25uZWN0aW9uSWQsIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbWFwKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IG1hcFtrZXldO1xuICAgICAgICAgICAgaWYgKGl0ZW0uYWN0aW9uID09PSAnYWJzZW50JylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChjbGllbnRJZCAmJiBjbGllbnRJZCAhPSBpdGVtLmNsaWVudElkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25JZCAmJiBjb25uZWN0aW9uSWQgIT0gaXRlbS5jb25uZWN0aW9uSWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUHJlc2VuY2VNYXAucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLmFjdGlvbiA9PT0gJ2VudGVyJyB8fCBpdGVtLmFjdGlvbiA9PT0gJ3VwZGF0ZScpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoaXRlbSk7XG4gICAgICAgICAgICBpdGVtLmFjdGlvbiA9ICdwcmVzZW50JztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFwID0gdGhpcy5tYXAsIGtleSA9IHRoaXMubWVtYmVyS2V5KGl0ZW0pO1xuICAgICAgICAvKiB3ZSd2ZSBzZWVuIHRoaXMgbWVtYmVyLCBzbyBkbyBub3QgcmVtb3ZlIGl0IGF0IHRoZSBlbmQgb2Ygc3luYyAqL1xuICAgICAgICBpZiAodGhpcy5yZXNpZHVhbE1lbWJlcnMpXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5yZXNpZHVhbE1lbWJlcnNba2V5XTtcbiAgICAgICAgLyogY29tcGFyZSB0aGUgdGltZXN0YW1wIG9mIHRoZSBuZXcgaXRlbSB3aXRoIGFueSBleGlzdGluZyBtZW1iZXIgKG9yIEFCU0VOVCB3aXRuZXNzKSAqL1xuICAgICAgICB2YXIgZXhpc3RpbmdJdGVtID0gbWFwW2tleV07XG4gICAgICAgIGlmIChleGlzdGluZ0l0ZW0gJiYgIW5ld2VyVGhhbihpdGVtLCBleGlzdGluZ0l0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbWFwW2tleV0gPSBpdGVtO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFByZXNlbmNlTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLm1hcCwgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBtYXApIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gbWFwW2tleV07XG4gICAgICAgICAgICBpZiAoaXRlbS5hY3Rpb24gIT0gJ2Fic2VudCcpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFByZXNlbmNlTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5tYXAsIGtleSA9IHRoaXMubWVtYmVyS2V5KGl0ZW0pO1xuICAgICAgICB2YXIgZXhpc3RpbmdJdGVtID0gbWFwW2tleV07XG4gICAgICAgIGlmIChleGlzdGluZ0l0ZW0gJiYgIW5ld2VyVGhhbihpdGVtLCBleGlzdGluZ0l0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyogUlRQMmYgKi9cbiAgICAgICAgaWYgKHRoaXMuc3luY0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoaXRlbSk7XG4gICAgICAgICAgICBpdGVtLmFjdGlvbiA9ICdhYnNlbnQnO1xuICAgICAgICAgICAgbWFwW2tleV0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIG1hcFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgUHJlc2VuY2VNYXAucHJvdG90eXBlLnN0YXJ0U3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwLCBzeW5jSW5Qcm9ncmVzcyA9IHRoaXMuc3luY0luUHJvZ3Jlc3M7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUHJlc2VuY2VNYXAuc3RhcnRTeW5jKCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLnByZXNlbmNlLmNoYW5uZWwubmFtZSArICc7IHN5bmNJblByb2dyZXNzID0gJyArIHN5bmNJblByb2dyZXNzKTtcbiAgICAgICAgLyogd2UgbWlnaHQgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdoaWxlIGEgc3luYyBpcyBpbiBwcm9ncmVzcyAqL1xuICAgICAgICBpZiAoIXRoaXMuc3luY0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaWR1YWxNZW1iZXJzID0gVXRpbHMuY29weShtYXApO1xuICAgICAgICAgICAgdGhpcy5zZXRJblByb2dyZXNzKHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQcmVzZW5jZU1hcC5wcm90b3R5cGUuZW5kU3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwLCBzeW5jSW5Qcm9ncmVzcyA9IHRoaXMuc3luY0luUHJvZ3Jlc3M7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUHJlc2VuY2VNYXAuZW5kU3luYygpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5wcmVzZW5jZS5jaGFubmVsLm5hbWUgKyAnOyBzeW5jSW5Qcm9ncmVzcyA9ICcgKyBzeW5jSW5Qcm9ncmVzcyk7XG4gICAgICAgIGlmIChzeW5jSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgLyogd2UgY2FuIG5vdyBzdHJpcCBvdXQgdGhlIEFCU0VOVCBtZW1iZXJzLCBhcyB3ZSBoYXZlXG4gICAgICAgICAgICAgKiByZWNlaXZlZCBhbGwgb2YgdGhlIG91dC1vZi1vcmRlciBzeW5jIG1lc3NhZ2VzICovXG4gICAgICAgICAgICBmb3IgKHZhciBtZW1iZXJLZXkgaW4gbWFwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gbWFwW21lbWJlcktleV07XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LmFjdGlvbiA9PT0gJ2Fic2VudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1hcFttZW1iZXJLZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGFueSBtZW1iZXJzIHRoYXQgd2VyZSBwcmVzZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgc3luYyxcbiAgICAgICAgICAgICAqIGFuZCBoYXZlIG5vdCBiZWVuIHNlZW4gaW4gc3luYywgY2FuIGJlIHJlbW92ZWQsIGFuZCBsZWF2ZSBldmVudHMgZW1pdHRlZCAqL1xuICAgICAgICAgICAgdGhpcy5wcmVzZW5jZS5fc3ludGhlc2l6ZUxlYXZlcyhVdGlscy52YWx1ZXNBcnJheSh0aGlzLnJlc2lkdWFsTWVtYmVycykpO1xuICAgICAgICAgICAgZm9yICh2YXIgbWVtYmVyS2V5IGluIHRoaXMucmVzaWR1YWxNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hcFttZW1iZXJLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBudWxsO1xuICAgICAgICAgICAgLyogZmluaXNoLCBub3RpZnlpbmcgYW55IHdhaXRlcnMgKi9cbiAgICAgICAgICAgIHRoaXMuc2V0SW5Qcm9ncmVzcyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdzeW5jJyk7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1hcC5wcm90b3R5cGUud2FpdFN5bmMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHN5bmNJblByb2dyZXNzID0gdGhpcy5zeW5jSW5Qcm9ncmVzcztcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdQcmVzZW5jZU1hcC53YWl0U3luYygpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5wcmVzZW5jZS5jaGFubmVsLm5hbWUgKyAnOyBzeW5jSW5Qcm9ncmVzcyA9ICcgKyBzeW5jSW5Qcm9ncmVzcyk7XG4gICAgICAgIGlmICghc3luY0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbmNlKCdzeW5jJywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUHJlc2VuY2VNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1hcCA9IHt9O1xuICAgICAgICB0aGlzLnNldEluUHJvZ3Jlc3MoZmFsc2UpO1xuICAgICAgICB0aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1hcC5wcm90b3R5cGUuc2V0SW5Qcm9ncmVzcyA9IGZ1bmN0aW9uIChpblByb2dyZXNzKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUHJlc2VuY2VNYXAuc2V0SW5Qcm9ncmVzcygpJywgJ2luUHJvZ3Jlc3MgPSAnICsgaW5Qcm9ncmVzcyk7XG4gICAgICAgIHRoaXMuc3luY0luUHJvZ3Jlc3MgPSBpblByb2dyZXNzO1xuICAgICAgICB0aGlzLnByZXNlbmNlLnN5bmNDb21wbGV0ZSA9ICFpblByb2dyZXNzO1xuICAgIH07XG4gICAgcmV0dXJuIFByZXNlbmNlTWFwO1xufShldmVudGVtaXR0ZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBSZWFsdGltZVByZXNlbmNlO1xuXG5cbi8qKiovIH0pLFxuLyogNTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBlbmNfaGV4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcbnZhciBlbmNfdXRmOF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG52YXIgZW5jX2Jhc2U2NF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG52YXIgbGliX3R5cGVkYXJyYXlzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDUpKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgQnVmZmVyVXRpbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnVmZmVyVXRpbHMoKSB7XG4gICAgICAgIHRoaXMuYmFzZTY0Q2hhclNldCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgICAgICAgdGhpcy5oZXhDaGFyU2V0ID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuICAgIH1cbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUuaXNXb3JkQXJyYXkgPSBmdW5jdGlvbiAob2IpIHtcbiAgICAgICAgcmV0dXJuIG9iICE9PSBudWxsICYmIG9iICE9PSB1bmRlZmluZWQgJiYgb2Iuc2lnQnl0ZXMgIT09IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS5pc0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKG9iKSB7XG4gICAgICAgIHJldHVybiBvYiAhPT0gbnVsbCAmJiBvYiAhPT0gdW5kZWZpbmVkICYmIG9iLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcjtcbiAgICB9O1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS5pc1R5cGVkQXJyYXkgPSBmdW5jdGlvbiAob2IpIHtcbiAgICAgICAgcmV0dXJuICEhQXJyYXlCdWZmZXIgJiYgQXJyYXlCdWZmZXIuaXNWaWV3ICYmIEFycmF5QnVmZmVyLmlzVmlldyhvYik7XG4gICAgfTtcbiAgICAvLyAvLyBodHRwczovL2dpc3QuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2pvbmxlaWdodG9uLzk1ODg0MS9yYXcvZjIwMGUzMGRmZTk1MjEyYzAxNjVjY2YxYWUwMDBjYTUxZTlkZTgwMy9naXN0ZmlsZTEuanNcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUudWludDhWaWV3VG9CYXNlNjQgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIGJhc2U2NCA9ICcnO1xuICAgICAgICB2YXIgZW5jb2RpbmdzID0gdGhpcy5iYXNlNjRDaGFyU2V0O1xuICAgICAgICB2YXIgYnl0ZUxlbmd0aCA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgICAgIHZhciBieXRlUmVtYWluZGVyID0gYnl0ZUxlbmd0aCAlIDM7XG4gICAgICAgIHZhciBtYWluTGVuZ3RoID0gYnl0ZUxlbmd0aCAtIGJ5dGVSZW1haW5kZXI7XG4gICAgICAgIHZhciBhLCBiLCBjLCBkO1xuICAgICAgICB2YXIgY2h1bms7XG4gICAgICAgIC8vIE1haW4gbG9vcCBkZWFscyB3aXRoIGJ5dGVzIGluIGNodW5rcyBvZiAzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFpbkxlbmd0aDsgaSA9IGkgKyAzKSB7XG4gICAgICAgICAgICAvLyBDb21iaW5lIHRoZSB0aHJlZSBieXRlcyBpbnRvIGEgc2luZ2xlIGludGVnZXJcbiAgICAgICAgICAgIGNodW5rID0gKGJ5dGVzW2ldIDw8IDE2KSB8IChieXRlc1tpICsgMV0gPDwgOCkgfCBieXRlc1tpICsgMl07XG4gICAgICAgICAgICAvLyBVc2UgYml0bWFza3MgdG8gZXh0cmFjdCA2LWJpdCBzZWdtZW50cyBmcm9tIHRoZSB0cmlwbGV0XG4gICAgICAgICAgICBhID0gKGNodW5rICYgMTY1MTUwNzIpID4+IDE4OyAvLyAxNjUxNTA3MiA9ICgyXjYgLSAxKSA8PCAxOFxuICAgICAgICAgICAgYiA9IChjaHVuayAmIDI1ODA0OCkgPj4gMTI7IC8vIDI1ODA0OCAgID0gKDJeNiAtIDEpIDw8IDEyXG4gICAgICAgICAgICBjID0gKGNodW5rICYgNDAzMikgPj4gNjsgLy8gNDAzMiAgICAgPSAoMl42IC0gMSkgPDwgNlxuICAgICAgICAgICAgZCA9IGNodW5rICYgNjM7IC8vIDYzICAgICAgID0gMl42IC0gMVxuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcmF3IGJpbmFyeSBzZWdtZW50cyB0byB0aGUgYXBwcm9wcmlhdGUgQVNDSUkgZW5jb2RpbmdcbiAgICAgICAgICAgIGJhc2U2NCArPSBlbmNvZGluZ3NbYV0gKyBlbmNvZGluZ3NbYl0gKyBlbmNvZGluZ3NbY10gKyBlbmNvZGluZ3NbZF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVhbCB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMgYW5kIHBhZGRpbmdcbiAgICAgICAgaWYgKGJ5dGVSZW1haW5kZXIgPT0gMSkge1xuICAgICAgICAgICAgY2h1bmsgPSBieXRlc1ttYWluTGVuZ3RoXTtcbiAgICAgICAgICAgIGEgPSAoY2h1bmsgJiAyNTIpID4+IDI7IC8vIDI1MiA9ICgyXjYgLSAxKSA8PCAyXG4gICAgICAgICAgICAvLyBTZXQgdGhlIDQgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyB0byB6ZXJvXG4gICAgICAgICAgICBiID0gKGNodW5rICYgMykgPDwgNDsgLy8gMyAgID0gMl4yIC0gMVxuICAgICAgICAgICAgYmFzZTY0ICs9IGVuY29kaW5nc1thXSArIGVuY29kaW5nc1tiXSArICc9PSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnl0ZVJlbWFpbmRlciA9PSAyKSB7XG4gICAgICAgICAgICBjaHVuayA9IChieXRlc1ttYWluTGVuZ3RoXSA8PCA4KSB8IGJ5dGVzW21haW5MZW5ndGggKyAxXTtcbiAgICAgICAgICAgIGEgPSAoY2h1bmsgJiA2NDUxMikgPj4gMTA7IC8vIDY0NTEyID0gKDJeNiAtIDEpIDw8IDEwXG4gICAgICAgICAgICBiID0gKGNodW5rICYgMTAwOCkgPj4gNDsgLy8gMTAwOCAgPSAoMl42IC0gMSkgPDwgNFxuICAgICAgICAgICAgLy8gU2V0IHRoZSAyIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgdG8gemVyb1xuICAgICAgICAgICAgYyA9IChjaHVuayAmIDE1KSA8PCAyOyAvLyAxNSAgICA9IDJeNCAtIDFcbiAgICAgICAgICAgIGJhc2U2NCArPSBlbmNvZGluZ3NbYV0gKyBlbmNvZGluZ3NbYl0gKyBlbmNvZGluZ3NbY10gKyAnPSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U2NDtcbiAgICB9O1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS5iYXNlNjRUb0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKGJhc2U2NCkge1xuICAgICAgICB2YXIgYmluYXJ5X3N0cmluZyA9IGF0b2IgPT09IG51bGwgfHwgYXRvYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXRvYihiYXNlNjQpOyAvLyB0aGlzIHdpbGwgYWx3YXlzIGJlIGRlZmluZWQgaW4gYnJvd3NlciBzbyBpdCdzIHNhZmUgdG8gY2FzdFxuICAgICAgICB2YXIgbGVuID0gYmluYXJ5X3N0cmluZy5sZW5ndGg7XG4gICAgICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhc2NpaSA9IGJpbmFyeV9zdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGJ5dGVzW2ldID0gYXNjaWk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzLmJ1ZmZlcjtcbiAgICB9O1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS5pc0J1ZmZlciA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBcnJheUJ1ZmZlcihidWZmZXIpIHx8IHRoaXMuaXNXb3JkQXJyYXkoYnVmZmVyKSB8fCB0aGlzLmlzVHlwZWRBcnJheShidWZmZXIpO1xuICAgIH07XG4gICAgLyogSW4gYnJvd3NlcnMsIHJldHVybnMgYSBVaW50OEFycmF5ICovXG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICBpZiAoIUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb252ZXJ0IHRvIEJ1ZmZlcjogYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBuZWNlc3NhcnkgdHlwZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheUJ1ZmZlcihidWZmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1R5cGVkQXJyYXkoYnVmZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlci5idWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzV29yZEFycmF5KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIC8qIEJhY2twb3J0ZWQgZnJvbSB1bnJlbGVhc2VkIENyeXB0b0pTXG4gICAgICAgICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy9zb3VyY2UvYnJvd3NlL2JyYW5jaGVzLzMueC9zcmMvbGliLXR5cGVkYXJyYXlzLmpzP3I9NjYxICovXG4gICAgICAgICAgICB2YXIgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLnNpZ0J5dGVzKTtcbiAgICAgICAgICAgIHZhciB1aW50OFZpZXcgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5zaWdCeXRlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdWludDhWaWV3W2ldID0gKGJ1ZmZlci53b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdWludDhWaWV3O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQnVmZmVyVXRpbHMudG9CdWZmZXIgZXhwZWN0ZWQgYW4gYXJyYXlidWZmZXIsIHR5cGVkIGFycmF5LCBvciBDcnlwdG9KUyB3b3JkYXJyYXknKTtcbiAgICB9O1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICBpZiAodGhpcy5pc0FycmF5QnVmZmVyKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudG9CdWZmZXIoYnVmZmVyKS5idWZmZXI7XG4gICAgfTtcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUudG9Xb3JkQXJyYXkgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVHlwZWRBcnJheShidWZmZXIpKSB7XG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmlzV29yZEFycmF5KGJ1ZmZlcikgPyBidWZmZXIgOiBsaWJfdHlwZWRhcnJheXNfMS5kZWZhdWx0LmNyZWF0ZShidWZmZXIpO1xuICAgIH07XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLmJhc2U2NEVuY29kZSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNXb3JkQXJyYXkoYnVmZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBlbmNfYmFzZTY0XzEuc3RyaW5naWZ5KShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnVpbnQ4Vmlld1RvQmFzZTY0KHRoaXMudG9CdWZmZXIoYnVmZmVyKSk7XG4gICAgfTtcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUuYmFzZTY0RGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoQXJyYXlCdWZmZXIgJiYgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5hdG9iKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlNjRUb0FycmF5QnVmZmVyKHN0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBlbmNfYmFzZTY0XzEucGFyc2UpKHN0cik7XG4gICAgfTtcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUuaGV4RW5jb2RlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gKDAsIGVuY19oZXhfMS5zdHJpbmdpZnkpKHRoaXMudG9Xb3JkQXJyYXkoYnVmZmVyKSk7XG4gICAgfTtcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUuaGV4RGVjb2RlID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICB2YXIgd29yZEFycmF5ID0gKDAsIGVuY19oZXhfMS5wYXJzZSkoc3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIEFycmF5QnVmZmVyID8gdGhpcy50b0FycmF5QnVmZmVyKHdvcmRBcnJheSkgOiB3b3JkQXJyYXk7XG4gICAgfTtcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUudXRmOEVuY29kZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuVGV4dEVuY29kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5UZXh0RW5jb2RlcigpLmVuY29kZShzdHJpbmcpLmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGVuY191dGY4XzEucGFyc2UpKHN0cmluZyk7XG4gICAgfTtcbiAgICAvKiBGb3IgdXRmOCBkZWNvZGluZyB3ZSBhcHBseSBzbGlnaHRseSBzdHJpY3RlciBpbnB1dCB2YWxpZGF0aW9uIHRoYW4gdG9cbiAgICAgKiBoZXhFbmNvZGUvYmFzZTY0RW5jb2RlL2V0YzogaW4gdGhvc2Ugd2UgYWNjZXB0IGFueXRoaW5nIHRoYXQgQnVmZmVyLmZyb21cbiAgICAgKiBjYW4gdGFrZSAoaW4gcGFydGljdWxhciBhbGxvd2luZyBzdHJpbmdzLCB3aGljaCBhcmUganVzdCBpbnRlcnByZXRlZCBhc1xuICAgICAqIGJpbmFyeSk7IGhlcmUgd2UgZW5zdXJlIHRoYXQgdGhlIGlucHV0IGlzIGFjdHVhbGx5IGEgYnVmZmVyIHNpbmNlIHRyeWluZ1xuICAgICAqIHRvIHV0ZjgtZGVjb2RlIGEgc3RyaW5nIHRvIGFub3RoZXIgc3RyaW5nIGlzIGFsbW9zdCBjZXJ0YWlubHkgYSBtaXN0YWtlICovXG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLnV0ZjhEZWNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGlucHV0IG9mIHV0ZjhkZWNvZGUgdG8gYmUgYW4gYXJyYXlidWZmZXIsIHR5cGVkIGFycmF5LCBvciBDcnlwdG9KUyB3b3JkYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVGV4dERlY29kZXIgJiYgIXRoaXMuaXNXb3JkQXJyYXkoYnVmZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlciA9IHRoaXMudG9Xb3JkQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuICgwLCBlbmNfdXRmOF8xLnN0cmluZ2lmeSkoYnVmZmVyKTtcbiAgICB9O1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS5idWZmZXJDb21wYXJlID0gZnVuY3Rpb24gKGJ1ZmZlcjEsIGJ1ZmZlcjIpIHtcbiAgICAgICAgaWYgKCFidWZmZXIxKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoIWJ1ZmZlcjIpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgdmFyIHdvcmRBcnJheTEgPSB0aGlzLnRvV29yZEFycmF5KGJ1ZmZlcjEpO1xuICAgICAgICB2YXIgd29yZEFycmF5MiA9IHRoaXMudG9Xb3JkQXJyYXkoYnVmZmVyMik7XG4gICAgICAgIHdvcmRBcnJheTEuY2xhbXAoKTtcbiAgICAgICAgd29yZEFycmF5Mi5jbGFtcCgpO1xuICAgICAgICB2YXIgY21wID0gd29yZEFycmF5MS5zaWdCeXRlcyAtIHdvcmRBcnJheTIuc2lnQnl0ZXM7XG4gICAgICAgIGlmIChjbXAgIT0gMClcbiAgICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIHZhciB3b3JkczEgPSB3b3JkQXJyYXkxLndvcmRzO1xuICAgICAgICB2YXIgd29yZHMyID0gd29yZEFycmF5Mi53b3JkcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JkczEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNtcCA9IHdvcmRzMVtpXSAtIHdvcmRzMltpXTtcbiAgICAgICAgICAgIGlmIChjbXAgIT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXlCdWZmZXIoYnVmZmVyKSB8fCB0aGlzLmlzVHlwZWRBcnJheShidWZmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1dvcmRBcnJheShidWZmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLnNpZ0J5dGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIC8qIFJldHVybnMgQXJyYXlCdWZmZXIgb24gYnJvd3NlciBhbmQgQnVmZmVyIG9uIE5vZGUuanMgKi9cbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUudHlwZWRBcnJheVRvQnVmZmVyID0gZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVkQXJyYXkuYnVmZmVyO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlclV0aWxzO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBCdWZmZXJVdGlscygpO1xuXG5cbi8qKiovIH0pLFxuLyogNTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDYpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuSGV4O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogNTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfZW5jX2Jhc2U2NF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjcnlwdG9fanNfYnVpbGRfZW5jX2Jhc2U2NF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNyeXB0b19qc19idWlsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyk7XG5cblxuXG5cblxuXG52YXIgQ3J5cHRvRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWcsIGJ1ZmZlclV0aWxzKSB7XG4gIHZhciBERUZBVUxUX0FMR09SSVRITSA9ICdhZXMnO1xuICB2YXIgREVGQVVMVF9LRVlMRU5HVEggPSAyNTY7IC8vIGJpdHNcbiAgdmFyIERFRkFVTFRfTU9ERSA9ICdjYmMnO1xuICB2YXIgREVGQVVMVF9CTE9DS0xFTkdUSCA9IDE2OyAvLyBieXRlc1xuICB2YXIgREVGQVVMVF9CTE9DS0xFTkdUSF9XT1JEUyA9IDQ7IC8vIDMyLWJpdCB3b3Jkc1xuICB2YXIgVUlOVDMyX1NVUCA9IDB4MTAwMDAwMDAwO1xuICB2YXIgSU5UMzJfU1VQID0gMHg4MDAwMDAwMDtcblxuICAvKipcbiAgICogSW50ZXJuYWw6IGdlbmVyYXRlIGFuIGFycmF5IG9mIHNlY3VyZSByYW5kb20gd29yZHMgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGVuZ3RoIG9mIGJ5dGVzXG4gICAqIEBwYXJhbSBieXRlc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHZhciBnZW5lcmF0ZVJhbmRvbTtcbiAgaWYgKGNvbmZpZy5nZXRSYW5kb21Xb3JkQXJyYXkpIHtcbiAgICBnZW5lcmF0ZVJhbmRvbSA9IGNvbmZpZy5nZXRSYW5kb21Xb3JkQXJyYXk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIFVpbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBjb25maWcuZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgdmFyIGJsb2NrUmFuZG9tQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoREVGQVVMVF9CTE9DS0xFTkdUSF9XT1JEUyk7XG4gICAgZ2VuZXJhdGVSYW5kb20gPSBmdW5jdGlvbiAoYnl0ZXMsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgd29yZHMgPSBieXRlcyAvIDQsXG4gICAgICAgIG5hdGl2ZUFycmF5ID0gd29yZHMgPT0gREVGQVVMVF9CTE9DS0xFTkdUSF9XT1JEUyA/IGJsb2NrUmFuZG9tQXJyYXkgOiBuZXcgVWludDMyQXJyYXkod29yZHMpO1xuICAgICAgY29uZmlnLmdldFJhbmRvbVZhbHVlcyhuYXRpdmVBcnJheSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNhbGxiYWNrKGVyciwgYnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkobmF0aXZlQXJyYXkpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBnZW5lcmF0ZVJhbmRvbSA9IGZ1bmN0aW9uIChieXRlcywgY2FsbGJhY2spIHtcbiAgICAgIF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdC5hLmxvZ0FjdGlvbihcbiAgICAgICAgX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0LmEuTE9HX01BSk9SLFxuICAgICAgICAnQWJseS5DcnlwdG8uZ2VuZXJhdGVSYW5kb20oKScsXG4gICAgICAgICdXYXJuaW5nOiB0aGUgYnJvd3NlciB5b3UgYXJlIHVzaW5nIGRvZXMgbm90IHN1cHBvcnQgc2VjdXJlIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSByYW5kb21uZXNzIGdlbmVyYXRpb247IGZhbGxpbmcgYmFjayB0byBpbnNlY3VyZSBNYXRoLnJhbmRvbSgpJ1xuICAgICAgKTtcbiAgICAgIHZhciB3b3JkcyA9IGJ5dGVzIC8gNCxcbiAgICAgICAgYXJyYXkgPSBuZXcgQXJyYXkod29yZHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JkczsgaSsrKSB7XG4gICAgICAgIC8qIGNyeXB0b2pzIHdvcmRhcnJheXMgdXNlIHNpZ25lZCBpbnRzLiBXaGVuIFdvcmRBcnJheS5jcmVhdGUgaXMgZmVkIGFcbiAgICAgICAgICogVWludDMyQXJyYXkgdW5zaWduZWQgYXJlIGNvbnZlcnRlZCB0byBzaWduZWQgYXV0b21hdGljYWxseSwgYnV0IHdoZW5cbiAgICAgICAgICogZmVkIGEgbm9ybWFsIGFycmF5IHRoZXkgYXJlbid0LCBzbyBuZWVkIHRvIGRvIHNvIG91cnNlbHZlcyBieVxuICAgICAgICAgKiBzdWJ0cmFjdGluZyBJTlQzMl9TVVAgKi9cbiAgICAgICAgYXJyYXlbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBVSU5UMzJfU1VQKSAtIElOVDMyX1NVUDtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoYXJyYXkpKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsOiBjYWxjdWxhdGUgdGhlIHBhZGRlZCBsZW5ndGggb2YgYSBnaXZlbiBwbGFpbnRleHRcbiAgICogdXNpbmcgUEtDUzUuXG4gICAqIEBwYXJhbSBwbGFpbnRleHRMZW5ndGhcbiAgICogQHJldHVyblxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UGFkZGVkTGVuZ3RoKHBsYWludGV4dExlbmd0aCkge1xuICAgIHJldHVybiAocGxhaW50ZXh0TGVuZ3RoICsgREVGQVVMVF9CTE9DS0xFTkdUSCkgJiAtREVGQVVMVF9CTE9DS0xFTkdUSDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbDogY2hlY2tzIHRoYXQgdGhlIGNpcGhlclBhcmFtcyBhcmUgYSB2YWxpZCBjb21iaW5hdGlvbi4gQ3VycmVudGx5XG4gICAqIGp1c3QgY2hlY2tzIHRoYXQgdGhlIGNhbGN1bGF0ZWQga2V5TGVuZ3RoIGlzIGEgdmFsaWQgb25lIGZvciBhZXMtY2JjXG4gICAqL1xuICBmdW5jdGlvbiB2YWxpZGF0ZUNpcGhlclBhcmFtcyhwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zLmFsZ29yaXRobSA9PT0gJ2FlcycgJiYgcGFyYW1zLm1vZGUgPT09ICdjYmMnKSB7XG4gICAgICBpZiAocGFyYW1zLmtleUxlbmd0aCA9PT0gMTI4IHx8IHBhcmFtcy5rZXlMZW5ndGggPT09IDI1Nikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdVbnN1cHBvcnRlZCBrZXkgbGVuZ3RoICcgK1xuICAgICAgICAgIHBhcmFtcy5rZXlMZW5ndGggK1xuICAgICAgICAgICcgZm9yIGFlcy1jYmMgZW5jcnlwdGlvbi4gRW5jcnlwdGlvbiBrZXkgbXVzdCBiZSAxMjggb3IgMjU2IGJpdHMgKDE2IG9yIDMyIEFTQ0lJIGNoYXJhY3RlcnMpJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpc2VCYXNlNjQoc3RyaW5nKSB7XG4gICAgLyogdXJsLXNhZmUgYmFzZTY0IHN0cmluZ3MgdXNlIF8gYW5kIC0gaW5zdHJlYWQgb2YgLyBhbmQgKyAqL1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgnXycsICcvJykucmVwbGFjZSgnLScsICcrJyk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWw6IG9idGFpbiB0aGUgcGtjczUgcGFkZGluZyBzdHJpbmcgZm9yIGEgZ2l2ZW4gcGFkZGVkIGxlbmd0aDtcbiAgICovXG4gIHZhciBwa2NzNVBhZGRpbmcgPSBbXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MTAxMDEwMTAsIDB4MTAxMDEwMTAsIDB4MTAxMDEwMTAsIDB4MTAxMDEwMTBdLCAxNiksXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDEwMDAwMDBdLCAxKSxcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwMjAyMDAwMF0sIDIpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDAzMDMwMzAwXSwgMyksXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDQwNDA0MDRdLCA0KSxcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwNTA1MDUwNSwgMHgwNTAwMDAwMF0sIDUpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDA2MDYwNjA2LCAweDA2MDYwMDAwXSwgNiksXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDcwNzA3MDcsIDB4MDcwNzA3MDBdLCA3KSxcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwODA4MDgwOCwgMHgwODA4MDgwOF0sIDgpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDA5MDkwOTA5LCAweDA5MDkwOTA5LCAweDA5MDAwMDAwXSwgOSksXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MGEwYTBhMGEsIDB4MGEwYTBhMGEsIDB4MGEwYTAwMDBdLCAxMCksXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MGIwYjBiMGIsIDB4MGIwYjBiMGIsIDB4MGIwYjBiMDBdLCAxMSksXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MGMwYzBjMGMsIDB4MGMwYzBjMGMsIDB4MGMwYzBjMGNdLCAxMiksXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MGQwZDBkMGQsIDB4MGQwZDBkMGQsIDB4MGQwZDBkMGQsIDB4MGQwMDAwMDBdLCAxMyksXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MGUwZTBlMGUsIDB4MGUwZTBlMGUsIDB4MGUwZTBlMGUsIDB4MGUwZTAwMDBdLCAxNCksXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MGYwZjBmMGYsIDB4MGYwZjBmMGYsIDB4MGYwZjBmMGYsIDB4MGYwZjBmMGZdLCAxNSksXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MTAxMDEwMTAsIDB4MTAxMDEwMTAsIDB4MTAxMDEwMTAsIDB4MTAxMDEwMTBdLCAxNiksXG4gIF07XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyBmb3IgbWVzc2FnZSBwYXlsb2FkIGVuY3J5cHRpb24uXG4gICAqXG4gICAqIFRoaXMgY2xhc3Mgc3VwcG9ydHMgQUVTL0NCQy9QS0NTNSB3aXRoIGEgZGVmYXVsdCBrZXlsZW5ndGggb2YgMTI4IGJpdHNcbiAgICogYnV0IHN1cHBvcnRpbmcgb3RoZXIga2V5bGVuZ3Rocy4gT3RoZXIgYWxnb3JpdGhtcyBhbmQgY2hhaW5pbmcgbW9kZXMgYXJlXG4gICAqIG5vdCBzdXBwb3J0ZWQgZGlyZWN0bHksIGJ1dCBzdXBwb3J0YWJsZSBieSBleHRlbmRpbmcvaW1wbGVtZW50aW5nIHRoZSBiYXNlXG4gICAqIGNsYXNzZXMgYW5kIGludGVyZmFjZXMgaGVyZS5cbiAgICotXG4gICAqIFNlY3VyZSByYW5kb20gZGF0YSBmb3IgY3JlYXRpb24gb2YgSW5pdGlhbGl6YXRpb24gVmVjdG9ycyAoSVZzKSBhbmQga2V5c1xuICAgKiBpcyBvYnRhaW5lZCBmcm9tIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIGlmIGF2YWlsYWJsZSwgb3IgZnJvbVxuICAgKiBNYXRoLnJhbmRvbSgpIGlmIG5vdC4gQ2xpZW50cyB3aG8gZG8gbm90IHdhbnQgdG8gZGVwZW5kIG9uIE1hdGgucmFuZG9tKClcbiAgICogc2hvdWxkIHBvbHlmaWxsIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHdpdGggYSBsaWJyYXJ5IHRoYXQgc2VlZHNcbiAgICogYSBQUk5HIHdpdGggcmVhbCBlbnRyb3B5LlxuICAgKlxuICAgKiBFYWNoIG1lc3NhZ2UgcGF5bG9hZCBpcyBlbmNyeXB0ZWQgd2l0aCBhbiBJViBpbiBDQkMgbW9kZSwgYW5kIHRoZSBJViBpc1xuICAgKiBjb25jYXRlbmF0ZWQgd2l0aCB0aGUgcmVzdWx0aW5nIHJhdyBjaXBoZXJ0ZXh0IHRvIGNvbnN0cnVjdCB0aGUgXCJjaXBoZXJ0ZXh0XCJcbiAgICogZGF0YSBwYXNzZWQgdG8gdGhlIHJlY2lwaWVudC5cbiAgICovXG4gIGZ1bmN0aW9uIENyeXB0bygpIHt9XG5cbiAgLyoqXG4gICAqIEEgY2xhc3MgZW5jYXBzdWxhdGluZyB0aGUgY2xpZW50LXNwZWNpZmlhYmxlIHBhcmFtZXRlcnMgZm9yXG4gICAqIHRoZSBjaXBoZXIuXG4gICAqXG4gICAqIGFsZ29yaXRobSBpcyB0aGUgbmFtZSBvZiB0aGUgYWxnb3JpdGhtIGluIHRoZSBkZWZhdWx0IHN5c3RlbSBwcm92aWRlcixcbiAgICogb3IgdGhlIGxvd2VyLWNhc2VkIHZlcnNpb24gb2YgaXQ7IGVnIFwiYWVzXCIgb3IgXCJBRVNcIi5cbiAgICpcbiAgICogQ2xpZW50cyBhcmUgcmVjb21tZW5kZWQgdG8gbm90IGNhbGwgdGhpcyBkaXJlY3RseSwgYnV0IGluc3RlYWQgdG8gdXNlIHRoZVxuICAgKiBDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyBoZWxwZXIsIHdoaWNoIHdpbGwgZmlsbCBpbiBhbnkgZmllbGRzIG5vdCBzdXBwbGllZFxuICAgKiB3aXRoIGRlZmF1bHQgdmFsdWVzIGFuZCB2YWxpZGF0aW9uIHRoZSByZXN1bHQuXG4gICAqL1xuICBmdW5jdGlvbiBDaXBoZXJQYXJhbXMoKSB7XG4gICAgdGhpcy5hbGdvcml0aG0gPSBudWxsO1xuICAgIHRoaXMua2V5TGVuZ3RoID0gbnVsbDtcbiAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgfVxuICBDcnlwdG8uQ2lwaGVyUGFyYW1zID0gQ2lwaGVyUGFyYW1zO1xuXG4gIC8qKlxuICAgKiBPYnRhaW4gYSBjb21wbGV0ZSBDaXBoZXJQYXJhbXMgaW5zdGFuY2UgZnJvbSB0aGUgcHJvdmlkZWQgcGFyYW1zLCBmaWxsaW5nXG4gICAqIGluIGFueSBub3QgcHJvdmlkZWQgd2l0aCBkZWZhdWx0IHZhbHVlcywgY2FsY3VsYXRpbmcgYSBrZXlMZW5ndGggZnJvbVxuICAgKiB0aGUgc3VwcGxpZWQga2V5LCBhbmQgdmFsaWRhdGluZyB0aGUgcmVzdWx0LlxuICAgKiBAcGFyYW0gcGFyYW1zIGFuIG9iamVjdCBjb250YWluaW5nIGF0IGEgbWluaW11bSBhIGBrZXlgIGtleSB3aXRoIHZhbHVlIHRoZVxuICAgKiBrZXksIGFzIGVpdGhlciBhIGJpbmFyeSAoQXJyYXlCdWZmZXIsIEFycmF5LCBXb3JkQXJyYXkpIG9yIGFcbiAgICogYmFzZTY0LWVuY29kZWQgc3RyaW5nLiBNYXkgb3B0aW9uYWxseSBhbHNvIGNvbnRhaW46IGFsZ29yaXRobSAoZGVmYXVsdHMgdG9cbiAgICogQUVTKSwgbW9kZSAoZGVmYXVsdHMgdG8gJ2NiYycpXG4gICAqL1xuICBDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICB2YXIga2V5O1xuICAgIC8qIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkgKi9cbiAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgICAgX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0LmEuZGVwcmVjYXRlZCgnQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMoa2V5LCBjYWxsYmFjayknLCAnQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMoe2tleToga2V5fSknKTtcbiAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIENyeXB0by5nZW5lcmF0ZVJhbmRvbUtleShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcGFyYW1zKG51bGwsIENyeXB0by5nZXREZWZhdWx0UGFyYW1zKHsga2V5OiBrZXkgfSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBhcmd1bWVudHNbMV0obnVsbCwgQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMoeyBrZXk6IHBhcmFtcyB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIGZvciBDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghcGFyYW1zLmtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtczogYSBrZXkgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBhcmFtcy5rZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBrZXkgPSBPYmplY3QoY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcInBhcnNlXCJdKShub3JtYWxpc2VCYXNlNjQocGFyYW1zLmtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBidWZmZXJVdGlscy50b1dvcmRBcnJheShwYXJhbXMua2V5KTsgLy8gRXhwZWN0IGtleSB0byBiZSBhbiBBcnJheSwgQXJyYXlCdWZmZXIsIG9yIFdvcmRBcnJheSBhdCB0aGlzIHBvaW50XG4gICAgfVxuXG4gICAgdmFyIGNpcGhlclBhcmFtcyA9IG5ldyBDaXBoZXJQYXJhbXMoKTtcbiAgICBjaXBoZXJQYXJhbXMua2V5ID0ga2V5O1xuICAgIGNpcGhlclBhcmFtcy5hbGdvcml0aG0gPSBwYXJhbXMuYWxnb3JpdGhtIHx8IERFRkFVTFRfQUxHT1JJVEhNO1xuICAgIGNpcGhlclBhcmFtcy5rZXlMZW5ndGggPSBrZXkud29yZHMubGVuZ3RoICogKDQgKiA4KTtcbiAgICBjaXBoZXJQYXJhbXMubW9kZSA9IHBhcmFtcy5tb2RlIHx8IERFRkFVTFRfTU9ERTtcblxuICAgIGlmIChwYXJhbXMua2V5TGVuZ3RoICYmIHBhcmFtcy5rZXlMZW5ndGggIT09IGNpcGhlclBhcmFtcy5rZXlMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zOiBhIGtleUxlbmd0aCBvZiAnICtcbiAgICAgICAgICBwYXJhbXMua2V5TGVuZ3RoICtcbiAgICAgICAgICAnIHdhcyBzcGVjaWZpZWQsIGJ1dCB0aGUga2V5IGFjdHVhbGx5IGhhcyBsZW5ndGggJyArXG4gICAgICAgICAgY2lwaGVyUGFyYW1zLmtleUxlbmd0aFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZUNpcGhlclBhcmFtcyhjaXBoZXJQYXJhbXMpO1xuICAgIHJldHVybiBjaXBoZXJQYXJhbXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgcmFuZG9tIGVuY3J5cHRpb24ga2V5IGZyb20gdGhlIHN1cHBsaWVkIGtleWxlbmd0aCAob3IgdGhlXG4gICAqIGRlZmF1bHQga2V5TGVuZ3RoIGlmIG5vbmUgc3VwcGxpZWQpIGFzIGEgQ3J5cHRvSlMgV29yZEFycmF5XG4gICAqIEBwYXJhbSBrZXlMZW5ndGggKG9wdGlvbmFsKSB0aGUgcmVxdWlyZWQga2V5TGVuZ3RoIGluIGJpdHNcbiAgICogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgKGVyciwga2V5KVxuICAgKi9cbiAgQ3J5cHRvLmdlbmVyYXRlUmFuZG9tS2V5ID0gZnVuY3Rpb24gKGtleUxlbmd0aCwgY2FsbGJhY2spIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIHR5cGVvZiBrZXlMZW5ndGggPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBrZXlMZW5ndGg7XG4gICAgICBrZXlMZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZ2VuZXJhdGVSYW5kb20oKGtleUxlbmd0aCB8fCBERUZBVUxUX0tFWUxFTkdUSCkgLyA4LCBmdW5jdGlvbiAoZXJyLCBidWYpIHtcbiAgICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbGxiYWNrKGVyciA/IGNvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdC5hLmZyb21WYWx1ZXMoZXJyKSA6IG51bGwsIGJ1Zik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEludGVybmFsOyBnZXQgYSBDaGFubmVsQ2lwaGVyIGluc3RhbmNlIGJhc2VkIG9uIHRoZSBnaXZlbiBjaXBoZXJQYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcyBlaXRoZXIgYSBDaXBoZXJQYXJhbXMgaW5zdGFuY2Ugb3Igc29tZSBzdWJzZXQgb2YgaXRzXG4gICAqIGZpZWxkcyB0aGF0IGluY2x1ZGVzIGEga2V5XG4gICAqL1xuICBDcnlwdG8uZ2V0Q2lwaGVyID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBjaXBoZXJQYXJhbXMgPSBwYXJhbXMgaW5zdGFuY2VvZiBDaXBoZXJQYXJhbXMgPyBwYXJhbXMgOiBDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyhwYXJhbXMpO1xuXG4gICAgcmV0dXJuIHsgY2lwaGVyUGFyYW1zOiBjaXBoZXJQYXJhbXMsIGNpcGhlcjogbmV3IENCQ0NpcGhlcihjaXBoZXJQYXJhbXMsIERFRkFVTFRfQkxPQ0tMRU5HVEhfV09SRFMsIHBhcmFtcy5pdikgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBDQkNDaXBoZXIocGFyYW1zLCBibG9ja0xlbmd0aFdvcmRzLCBpdikge1xuICAgIHRoaXMuYWxnb3JpdGhtID0gcGFyYW1zLmFsZ29yaXRobSArICctJyArIFN0cmluZyhwYXJhbXMua2V5TGVuZ3RoKSArICctJyArIHBhcmFtcy5tb2RlO1xuICAgIHRoaXMuY2pzQWxnb3JpdGhtID0gcGFyYW1zLmFsZ29yaXRobS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLy1cXGQrJC8sICcnKTtcbiAgICB0aGlzLmtleSA9IGJ1ZmZlclV0aWxzLnRvV29yZEFycmF5KHBhcmFtcy5rZXkpO1xuICAgIGlmIChpdikge1xuICAgICAgdGhpcy5pdiA9IGJ1ZmZlclV0aWxzLnRvV29yZEFycmF5KGl2KS5jbG9uZSgpO1xuICAgIH1cbiAgICB0aGlzLmJsb2NrTGVuZ3RoV29yZHMgPSBibG9ja0xlbmd0aFdvcmRzO1xuICB9XG5cbiAgQ0JDQ2lwaGVyLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24gKHBsYWludGV4dCwgY2FsbGJhY2spIHtcbiAgICBfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQuYS5sb2dBY3Rpb24oX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0LmEuTE9HX01JQ1JPLCAnQ0JDQ2lwaGVyLmVuY3J5cHQoKScsICcnKTtcbiAgICBwbGFpbnRleHQgPSBidWZmZXJVdGlscy50b1dvcmRBcnJheShwbGFpbnRleHQpO1xuICAgIHZhciBwbGFpbnRleHRMZW5ndGggPSBwbGFpbnRleHQuc2lnQnl0ZXMsXG4gICAgICBwYWRkZWRMZW5ndGggPSBnZXRQYWRkZWRMZW5ndGgocGxhaW50ZXh0TGVuZ3RoKSxcbiAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHRoZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmdldEl2KGZ1bmN0aW9uIChlcnIsIGl2KSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2lwaGVyT3V0ID0gc2VsZi5lbmNyeXB0Q2lwaGVyLnByb2Nlc3MocGxhaW50ZXh0LmNvbmNhdChwa2NzNVBhZGRpbmdbcGFkZGVkTGVuZ3RoIC0gcGxhaW50ZXh0TGVuZ3RoXSkpO1xuICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGl2LmNvbmNhdChjaXBoZXJPdXQpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCBjaXBoZXJ0ZXh0KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoIXRoaXMuZW5jcnlwdENpcGhlcikge1xuICAgICAgaWYgKHRoaXMuaXYpIHtcbiAgICAgICAgdGhpcy5lbmNyeXB0Q2lwaGVyID0gY3J5cHRvX2pzX2J1aWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdC5hLmFsZ29bdGhpcy5janNBbGdvcml0aG1dLmNyZWF0ZUVuY3J5cHRvcih0aGlzLmtleSwgeyBpdjogdGhpcy5pdiB9KTtcbiAgICAgICAgdGhlbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuZXJhdGVSYW5kb20oREVGQVVMVF9CTE9DS0xFTkdUSCwgZnVuY3Rpb24gKGVyciwgaXYpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmVuY3J5cHRDaXBoZXIgPSBjcnlwdG9fanNfYnVpbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0LmEuYWxnb1tzZWxmLmNqc0FsZ29yaXRobV0uY3JlYXRlRW5jcnlwdG9yKHNlbGYua2V5LCB7IGl2OiBpdiB9KTtcbiAgICAgICAgICBzZWxmLml2ID0gaXY7XG4gICAgICAgICAgdGhlbigpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhlbigpO1xuICAgIH1cbiAgfTtcblxuICBDQkNDaXBoZXIucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbiAoY2lwaGVydGV4dCkge1xuICAgIF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdC5hLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQuYS5MT0dfTUlDUk8sICdDQkNDaXBoZXIuZGVjcnlwdCgpJywgJycpO1xuICAgIGNpcGhlcnRleHQgPSBidWZmZXJVdGlscy50b1dvcmRBcnJheShjaXBoZXJ0ZXh0KTtcbiAgICB2YXIgYmxvY2tMZW5ndGhXb3JkcyA9IHRoaXMuYmxvY2tMZW5ndGhXb3JkcyxcbiAgICAgIGNpcGhlcnRleHRXb3JkcyA9IGNpcGhlcnRleHQud29yZHMsXG4gICAgICBpdiA9IGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKGNpcGhlcnRleHRXb3Jkcy5zbGljZSgwLCBibG9ja0xlbmd0aFdvcmRzKSksXG4gICAgICBjaXBoZXJ0ZXh0Qm9keSA9IGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKGNpcGhlcnRleHRXb3Jkcy5zbGljZShibG9ja0xlbmd0aFdvcmRzKSk7XG5cbiAgICB2YXIgZGVjcnlwdENpcGhlciA9IGNyeXB0b19qc19idWlsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQuYS5hbGdvW3RoaXMuY2pzQWxnb3JpdGhtXS5jcmVhdGVEZWNyeXB0b3IodGhpcy5rZXksIHsgaXY6IGl2IH0pO1xuICAgIHZhciBwbGFpbnRleHQgPSBkZWNyeXB0Q2lwaGVyLnByb2Nlc3MoY2lwaGVydGV4dEJvZHkpO1xuICAgIHZhciBlcGlsb2d1ZSA9IGRlY3J5cHRDaXBoZXIuZmluYWxpemUoKTtcbiAgICBkZWNyeXB0Q2lwaGVyLnJlc2V0KCk7XG4gICAgaWYgKGVwaWxvZ3VlICYmIGVwaWxvZ3VlLnNpZ0J5dGVzKSBwbGFpbnRleHQuY29uY2F0KGVwaWxvZ3VlKTtcbiAgICByZXR1cm4gcGxhaW50ZXh0O1xuICB9O1xuXG4gIENCQ0NpcGhlci5wcm90b3R5cGUuZ2V0SXYgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5pdikge1xuICAgICAgdmFyIGl2ID0gdGhpcy5pdjtcbiAgICAgIHRoaXMuaXYgPSBudWxsO1xuICAgICAgY2FsbGJhY2sobnVsbCwgaXYpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qIFNpbmNlIHRoZSBpdiBmb3IgYSBuZXcgYmxvY2sgaXMgdGhlIGNpcGhlcnRleHQgb2YgdGhlIGxhc3QsIHRoaXNcbiAgICAgKiBzZXRzIGEgbmV3IGl2ICg9IGFlcyhyYW5kb21CbG9jayBYT1IgbGFzdENpcGhlclRleHQpKSBhcyB3ZWxsIGFzXG4gICAgICogcmV0dXJuaW5nIGl0ICovXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGdlbmVyYXRlUmFuZG9tKERFRkFVTFRfQkxPQ0tMRU5HVEgsIGZ1bmN0aW9uIChlcnIsIHJhbmRvbUJsb2NrKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIHNlbGYuZW5jcnlwdENpcGhlci5wcm9jZXNzKHJhbmRvbUJsb2NrKSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIENyeXB0bztcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ3J5cHRvRmFjdG9yeSk7XG5cblxuLyoqKi8gfSksXG4vKiA1OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVURi0xNiBCRSBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFV0ZjE2QkUgPSBDX2VuYy5VdGYxNiA9IENfZW5jLlV0ZjE2QkUgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTE2IEJFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtMTYgQkUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgdXRmMTZTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmMTYuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB1dGYxNkNoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDE2IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmZmZjtcblx0ICAgICAgICAgICAgICAgIHV0ZjE2Q2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHV0ZjE2Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgVVRGLTE2IEJFIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmMTZTdHIgVGhlIFVURi0xNiBCRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjE2LnBhcnNlKHV0ZjE2U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjE2U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciB1dGYxNlN0ckxlbmd0aCA9IHV0ZjE2U3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHV0ZjE2U3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDFdIHw9IHV0ZjE2U3RyLmNoYXJDb2RlQXQoaSkgPDwgKDE2IC0gKGkgJSAyKSAqIDE2KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCB1dGYxNlN0ckxlbmd0aCAqIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogVVRGLTE2IExFIGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICBDX2VuYy5VdGYxNkxFID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi0xNiBMRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTE2IExFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjE2U3RyID0gQ3J5cHRvSlMuZW5jLlV0ZjE2TEUuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB1dGYxNkNoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IHN3YXBFbmRpYW4oKHdvcmRzW2kgPj4+IDJdID4+PiAoMTYgLSAoaSAlIDQpICogOCkpICYgMHhmZmZmKTtcblx0ICAgICAgICAgICAgICAgIHV0ZjE2Q2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHV0ZjE2Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgVVRGLTE2IExFIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmMTZTdHIgVGhlIFVURi0xNiBMRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjE2TEUucGFyc2UodXRmMTZTdHIpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmMTZTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIHV0ZjE2U3RyTGVuZ3RoID0gdXRmMTZTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXRmMTZTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMV0gfD0gc3dhcEVuZGlhbih1dGYxNlN0ci5jaGFyQ29kZUF0KGkpIDw8ICgxNiAtIChpICUgMikgKiAxNikpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIHV0ZjE2U3RyTGVuZ3RoICogMik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gc3dhcEVuZGlhbih3b3JkKSB7XG5cdCAgICAgICAgcmV0dXJuICgod29yZCA8PCA4KSAmIDB4ZmYwMGZmMDApIHwgKCh3b3JkID4+PiA4KSAmIDB4MDBmZjAwZmYpO1xuXHQgICAgfVxuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmVuYy5VdGYxNjtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDU5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyOCkpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIENpcGhlclBhcmFtcyA9IENfbGliLkNpcGhlclBhcmFtcztcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXHQgICAgdmFyIEhleCA9IENfZW5jLkhleDtcblx0ICAgIHZhciBDX2Zvcm1hdCA9IEMuZm9ybWF0O1xuXG5cdCAgICB2YXIgSGV4Rm9ybWF0dGVyID0gQ19mb3JtYXQuSGV4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoZSBjaXBoZXJ0ZXh0IG9mIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN9IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGV4U3RyaW5nID0gQ3J5cHRvSlMuZm9ybWF0LkhleC5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGNpcGhlclBhcmFtcy5jaXBoZXJ0ZXh0LnRvU3RyaW5nKEhleCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgaGV4YWRlY2ltYWxseSBlbmNvZGVkIGNpcGhlcnRleHQgc3RyaW5nIHRvIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgVGhlIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmZvcm1hdC5IZXgucGFyc2UoaGV4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGlucHV0KSB7XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gSGV4LnBhcnNlKGlucHV0KTtcblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0IH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuZm9ybWF0LkhleDtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDYwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMSksIF9fd2VicGFja19yZXF1aXJlX18oNjEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyOCkpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJsb2NrQ2lwaGVyID0gQ19saWIuQmxvY2tDaXBoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBMb29rdXAgdGFibGVzXG5cdCAgICB2YXIgU0JPWCA9IFtdO1xuXHQgICAgdmFyIElOVl9TQk9YID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8wID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8xID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8yID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8zID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMCA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzEgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8yID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMyA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIGxvb2t1cCB0YWJsZXNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy8gQ29tcHV0ZSBkb3VibGUgdGFibGVcblx0ICAgICAgICB2YXIgZCA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKGkgPCAxMjgpIHtcblx0ICAgICAgICAgICAgICAgIGRbaV0gPSBpIDw8IDE7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBkW2ldID0gKGkgPDwgMSkgXiAweDExYjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFdhbGsgR0YoMl44KVxuXHQgICAgICAgIHZhciB4ID0gMDtcblx0ICAgICAgICB2YXIgeGkgPSAwO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBzYm94XG5cdCAgICAgICAgICAgIHZhciBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpO1xuXHQgICAgICAgICAgICBzeCA9IChzeCA+Pj4gOCkgXiAoc3ggJiAweGZmKSBeIDB4NjM7XG5cdCAgICAgICAgICAgIFNCT1hbeF0gPSBzeDtcblx0ICAgICAgICAgICAgSU5WX1NCT1hbc3hdID0geDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG11bHRpcGxpY2F0aW9uXG5cdCAgICAgICAgICAgIHZhciB4MiA9IGRbeF07XG5cdCAgICAgICAgICAgIHZhciB4NCA9IGRbeDJdO1xuXHQgICAgICAgICAgICB2YXIgeDggPSBkW3g0XTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIHN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXG5cdCAgICAgICAgICAgIHZhciB0ID0gKGRbc3hdICogMHgxMDEpIF4gKHN4ICogMHgxMDEwMTAwKTtcblx0ICAgICAgICAgICAgU1VCX01JWF8wW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzFbeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzJbeF0gPSAodCA8PCA4KSAgfCAodCA+Pj4gMjQpO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzNbeF0gPSB0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuXHQgICAgICAgICAgICB2YXIgdCA9ICh4OCAqIDB4MTAxMDEwMSkgXiAoeDQgKiAweDEwMDAxKSBeICh4MiAqIDB4MTAxKSBeICh4ICogMHgxMDEwMTAwKTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfMFtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzFbc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfMltzeF0gPSAodCA8PCA4KSAgfCAodCA+Pj4gMjQpO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8zW3N4XSA9IHQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBuZXh0IGNvdW50ZXJcblx0ICAgICAgICAgICAgaWYgKCF4KSB7XG5cdCAgICAgICAgICAgICAgICB4ID0geGkgPSAxO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcblx0ICAgICAgICAgICAgICAgIHhpIF49IGRbZFt4aV1dO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLy8gUHJlY29tcHV0ZWQgUmNvbiBsb29rdXBcblx0ICAgIHZhciBSQ09OID0gWzB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgQUVTID0gQ19hbGdvLkFFUyA9IEJsb2NrQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHQ7XG5cblx0ICAgICAgICAgICAgLy8gU2tpcCByZXNldCBvZiBuUm91bmRzIGhhcyBiZWVuIHNldCBiZWZvcmUgYW5kIGtleSBkaWQgbm90IGNoYW5nZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5fblJvdW5kcyAmJiB0aGlzLl9rZXlQcmlvclJlc2V0ID09PSB0aGlzLl9rZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fa2V5UHJpb3JSZXNldCA9IHRoaXMuX2tleTtcblx0ICAgICAgICAgICAgdmFyIGtleVdvcmRzID0ga2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIga2V5U2l6ZSA9IGtleS5zaWdCeXRlcyAvIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBudW1iZXIgb2Ygcm91bmRzXG5cdCAgICAgICAgICAgIHZhciBuUm91bmRzID0gdGhpcy5fblJvdW5kcyA9IGtleVNpemUgKyA2O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbnVtYmVyIG9mIGtleSBzY2hlZHVsZSByb3dzXG5cdCAgICAgICAgICAgIHZhciBrc1Jvd3MgPSAoblJvdW5kcyArIDEpICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGtleSBzY2hlZHVsZVxuXHQgICAgICAgICAgICB2YXIga2V5U2NoZWR1bGUgPSB0aGlzLl9rZXlTY2hlZHVsZSA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XG5cdCAgICAgICAgICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5V29yZHNba3NSb3ddO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSAxXTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKGtzUm93ICUga2V5U2l6ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm90IHdvcmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWIgd29yZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKFNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbdCAmIDB4ZmZdO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1peCBSY29uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgXj0gUkNPTlsoa3NSb3cgLyBrZXlTaXplKSB8IDBdIDw8IDI0O1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ViIHdvcmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9IChTQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3QgJiAweGZmXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgaW52IGtleSBzY2hlZHVsZVxuXHQgICAgICAgICAgICB2YXIgaW52S2V5U2NoZWR1bGUgPSB0aGlzLl9pbnZLZXlTY2hlZHVsZSA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcblxuXHQgICAgICAgICAgICAgICAgaWYgKGludktzUm93ICUgNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3ddO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gNF07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IElOVl9TVUJfTUlYXzBbU0JPWFt0ID4+PiAyNF1dIF4gSU5WX1NVQl9NSVhfMVtTQk9YWyh0ID4+PiAxNikgJiAweGZmXV0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElOVl9TVUJfTUlYXzJbU0JPWFsodCA+Pj4gOCkgJiAweGZmXV0gXiBJTlZfU1VCX01JWF8zW1NCT1hbdCAmIDB4ZmZdXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBlbmNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5fa2V5U2NoZWR1bGUsIFNVQl9NSVhfMCwgU1VCX01JWF8xLCBTVUJfTUlYXzIsIFNVQl9NSVhfMywgU0JPWCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRlY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTd2FwIDJuZCBhbmQgNHRoIHJvd3Ncblx0ICAgICAgICAgICAgdmFyIHQgPSBNW29mZnNldCArIDFdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQ7XG5cblx0ICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5faW52S2V5U2NoZWR1bGUsIElOVl9TVUJfTUlYXzAsIElOVl9TVUJfTUlYXzEsIElOVl9TVUJfTUlYXzIsIElOVl9TVUJfTUlYXzMsIElOVl9TQk9YKTtcblxuXHQgICAgICAgICAgICAvLyBJbnYgc3dhcCAybmQgYW5kIDR0aCByb3dzXG5cdCAgICAgICAgICAgIHZhciB0ID0gTVtvZmZzZXQgKyAxXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9DcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0LCBrZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBuUm91bmRzID0gdGhpcy5fblJvdW5kcztcblxuXHQgICAgICAgICAgICAvLyBHZXQgaW5wdXQsIGFkZCByb3VuZCBrZXlcblx0ICAgICAgICAgICAgdmFyIHMwID0gTVtvZmZzZXRdICAgICBeIGtleVNjaGVkdWxlWzBdO1xuXHQgICAgICAgICAgICB2YXIgczEgPSBNW29mZnNldCArIDFdIF4ga2V5U2NoZWR1bGVbMV07XG5cdCAgICAgICAgICAgIHZhciBzMiA9IE1bb2Zmc2V0ICsgMl0gXiBrZXlTY2hlZHVsZVsyXTtcblx0ICAgICAgICAgICAgdmFyIHMzID0gTVtvZmZzZXQgKyAzXSBeIGtleVNjaGVkdWxlWzNdO1xuXG5cdCAgICAgICAgICAgIC8vIEtleSBzY2hlZHVsZSByb3cgY291bnRlclxuXHQgICAgICAgICAgICB2YXIga3NSb3cgPSA0O1xuXG5cdCAgICAgICAgICAgIC8vIFJvdW5kc1xuXHQgICAgICAgICAgICBmb3IgKHZhciByb3VuZCA9IDE7IHJvdW5kIDwgblJvdW5kczsgcm91bmQrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBtaXggY29sdW1ucywgYWRkIHJvdW5kIGtleVxuXHQgICAgICAgICAgICAgICAgdmFyIHQwID0gU1VCX01JWF8wW3MwID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMxID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczIgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczMgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxID0gU1VCX01JWF8wW3MxID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMyID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczMgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczAgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQyID0gU1VCX01JWF8wW3MyID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMzID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczAgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczEgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQzID0gU1VCX01JWF8wW3MzID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMwID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczEgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczIgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc3RhdGVcblx0ICAgICAgICAgICAgICAgIHMwID0gdDA7XG5cdCAgICAgICAgICAgICAgICBzMSA9IHQxO1xuXHQgICAgICAgICAgICAgICAgczIgPSB0Mjtcblx0ICAgICAgICAgICAgICAgIHMzID0gdDM7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcblx0ICAgICAgICAgICAgdmFyIHQwID0gKChTQk9YW3MwID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMxID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczIgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MzICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgIHZhciB0MSA9ICgoU0JPWFtzMSA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMiA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMzID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMCAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICB2YXIgdDIgPSAoKFNCT1hbczIgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczMgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczEgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgdmFyIHQzID0gKChTQk9YW3MzID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMwID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczEgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MyICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cblx0ICAgICAgICAgICAgLy8gU2V0IG91dHB1dFxuXHQgICAgICAgICAgICBNW29mZnNldF0gICAgID0gdDA7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSB0MTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAyXSA9IHQyO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGtleVNpemU6IDI1Ni8zMlxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuQUVTLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuQUVTLmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICovXG5cdCAgICBDLkFFUyA9IEJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoQUVTKTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5BRVM7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiA2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uIChNYXRoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gQ29uc3RhbnRzIHRhYmxlXG5cdCAgICB2YXIgVCA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIGNvbnN0YW50c1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcblx0ICAgICAgICAgICAgVFtpXSA9IChNYXRoLmFicyhNYXRoLnNpbihpICsgMSkpICogMHgxMDAwMDAwMDApIHwgMDtcblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIE1ENSBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIE1ENSA9IENfYWxnby5NRDUgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KFtcblx0ICAgICAgICAgICAgICAgIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksXG5cdCAgICAgICAgICAgICAgICAweDk4YmFkY2ZlLCAweDEwMzI1NDc2XG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBvZmZzZXRfaSA9IG9mZnNldCArIGk7XG5cdCAgICAgICAgICAgICAgICB2YXIgTV9vZmZzZXRfaSA9IE1bb2Zmc2V0X2ldO1xuXG5cdCAgICAgICAgICAgICAgICBNW29mZnNldF9pXSA9IChcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDgpICB8IChNX29mZnNldF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgMjQpIHwgKE1fb2Zmc2V0X2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzAgID0gTVtvZmZzZXQgKyAwXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEgID0gTVtvZmZzZXQgKyAxXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzIgID0gTVtvZmZzZXQgKyAyXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzMgID0gTVtvZmZzZXQgKyAzXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzQgID0gTVtvZmZzZXQgKyA0XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzUgID0gTVtvZmZzZXQgKyA1XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzYgID0gTVtvZmZzZXQgKyA2XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzcgID0gTVtvZmZzZXQgKyA3XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzggID0gTVtvZmZzZXQgKyA4XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzkgID0gTVtvZmZzZXQgKyA5XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEwID0gTVtvZmZzZXQgKyAxMF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMSA9IE1bb2Zmc2V0ICsgMTFdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTIgPSBNW29mZnNldCArIDEyXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEzID0gTVtvZmZzZXQgKyAxM107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xNCA9IE1bb2Zmc2V0ICsgMTRdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTUgPSBNW29mZnNldCArIDE1XTtcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhbGJlc1xuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBiID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsICA3LCAgVFswXSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF8xLCAgMTIsIFRbMV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgIDE3LCBUWzJdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzMsICAyMiwgVFszXSk7XG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF80LCAgNywgIFRbNF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfNSwgIDEyLCBUWzVdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsICAxNywgVFs2XSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF83LCAgMjIsIFRbN10pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfOCwgIDcsICBUWzhdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzksICAxMiwgVFs5XSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTcsIFRbMTBdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzExLCAyMiwgVFsxMV0pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDcsICBUWzEyXSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF8xMywgMTIsIFRbMTNdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE0LCAxNywgVFsxNF0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTUsIDIyLCBUWzE1XSk7XG5cblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEsICA1LCAgVFsxNl0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfNiwgIDksICBUWzE3XSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xMSwgMTQsIFRbMThdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzAsICAyMCwgVFsxOV0pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDUsICBUWzIwXSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xMCwgOSwgIFRbMjFdKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNCwgVFsyMl0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfNCwgIDIwLCBUWzIzXSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF85LCAgNSwgIFRbMjRdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE0LCA5LCAgVFsyNV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgIDE0LCBUWzI2XSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF84LCAgMjAsIFRbMjddKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA1LCAgVFsyOF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMiwgIDksICBUWzI5XSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF83LCAgMTQsIFRbMzBdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEyLCAyMCwgVFszMV0pO1xuXG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF81LCAgNCwgIFRbMzJdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzgsICAxMSwgVFszM10pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE2LCBUWzM0XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xNCwgMjMsIFRbMzVdKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEsICA0LCAgVFszNl0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfNCwgIDExLCBUWzM3XSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF83LCAgMTYsIFRbMzhdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEwLCAyMywgVFszOV0pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTMsIDQsICBUWzQwXSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8wLCAgMTEsIFRbNDFdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNiwgVFs0Ml0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfNiwgIDIzLCBUWzQzXSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF85LCAgNCwgIFRbNDRdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEyLCAxMSwgVFs0NV0pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTUsIDE2LCBUWzQ2XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8yLCAgMjMsIFRbNDddKTtcblxuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgIDYsICBUWzQ4XSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF83LCAgMTAsIFRbNDldKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE0LCAxNSwgVFs1MF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfNSwgIDIxLCBUWzUxXSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF8xMiwgNiwgIFRbNTJdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzMsICAxMCwgVFs1M10pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE1LCBUWzU0XSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xLCAgMjEsIFRbNTVdKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA2LCAgVFs1Nl0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTUsIDEwLCBUWzU3XSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTUsIFRbNThdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEzLCAyMSwgVFs1OV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDYsICBUWzYwXSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xMSwgMTAsIFRbNjFdKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNSwgVFs2Ml0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfOSwgIDIxLCBUWzYzXSk7XG5cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuXHQgICAgICAgICAgICBIWzFdID0gKEhbMV0gKyBiKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcblx0ICAgICAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxIID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbEwgPSBuQml0c1RvdGFsO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IChcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxIIDw8IDgpICB8IChuQml0c1RvdGFsSCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxIIDw8IDI0KSB8IChuQml0c1RvdGFsSCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gKFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEwgPDwgOCkgIHwgKG5CaXRzVG90YWxMID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEwgPDwgMjQpIHwgKG5CaXRzVG90YWxMID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgKTtcblxuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gKGRhdGFXb3Jkcy5sZW5ndGggKyAxKSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2hhc2g7XG5cdCAgICAgICAgICAgIHZhciBIID0gaGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgICAgIHZhciBIX2kgPSBIW2ldO1xuXG5cdCAgICAgICAgICAgICAgICBIW2ldID0gKCgoSF9pIDw8IDgpICB8IChIX2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgKCgoSF9pIDw8IDI0KSB8IChIX2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBmdW5jdGlvbiBGRihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKChiICYgYykgfCAofmIgJiBkKSkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBHRyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKChiICYgZCkgfCAoYyAmIH5kKSkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBISChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKGIgXiBjIF4gZCkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBJSShhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKGMgXiAoYiB8IH5kKSkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5NRDUod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5NRDUgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihNRDUpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY01ENShtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNNRDUgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoTUQ1KTtcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuTUQ1O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogNjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBkZWZhdWx0c18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg4KSk7XG52YXIgZXJyb3JpbmZvXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIEh0dHBNZXRob2RzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KSk7XG52YXIgeGhycmVxdWVzdF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNikpO1xudmFyIFhIUlN0YXRlc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyMSkpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIganNvbnB0cmFuc3BvcnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xudmFyIGZldGNocmVxdWVzdF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg2MykpO1xudmFyIEh0dHBTdGF0dXNDb2Rlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5mdW5jdGlvbiBzaG91bGRGYWxsYmFjayhlcnJvckluZm8pIHtcbiAgICB2YXIgc3RhdHVzQ29kZSA9IGVycm9ySW5mby5zdGF0dXNDb2RlO1xuICAgIC8qIDQwMCArIG5vIGNvZGUgPSBhIGdlbmVyaWMgeGhyIG9uZXJyb3IuIEJyb3dzZXIgZG9lc24ndCBnaXZlIHVzIGVub3VnaFxuICAgICAqIGRldGFpbCB0byBrbm93IHdoZXRoZXIgaXQncyBmYWxsYmFjay1maXhhYmxlLCBidXQgaXQgbWF5IGJlIChlZyBpZiBhXG4gICAgICogbmV0d29yayBpc3N1ZSksIHNvIHRyeSBqdXN0IGluIGNhc2UgKi9cbiAgICByZXR1cm4gKChzdGF0dXNDb2RlID09PSA0MDggJiYgIWVycm9ySW5mby5jb2RlKSB8fFxuICAgICAgICAoc3RhdHVzQ29kZSA9PT0gNDAwICYmICFlcnJvckluZm8uY29kZSkgfHxcbiAgICAgICAgKHN0YXR1c0NvZGUgPj0gNTAwICYmIHN0YXR1c0NvZGUgPD0gNTA0KSk7XG59XG5mdW5jdGlvbiBnZXRIb3N0cyhjbGllbnQpIHtcbiAgICAvKiBJZiB3ZSdyZSBhIGNvbm5lY3RlZCByZWFsdGltZSBjbGllbnQsIHRyeSB0aGUgZW5kcG9pbnQgd2UncmUgY29ubmVjdGVkXG4gICAgICogdG8gZmlyc3QgLS0gYnV0IHN0aWxsIGhhdmUgZmFsbGJhY2tzLCBiZWluZyBjb25uZWN0ZWQgaXMgbm90IGFuIGFic29sdXRlXG4gICAgICogZ3VhcmFudGVlIHRoYXQgYSBkYXRhY2VudGVyIGhhcyBmcmVlIGNhcGFjaXR5IHRvIHNlcnZpY2UgUkVTVCByZXF1ZXN0cy4gKi9cbiAgICB2YXIgY29ubmVjdGlvbiA9IGNsaWVudC5jb25uZWN0aW9uLCBjb25uZWN0aW9uSG9zdCA9IGNvbm5lY3Rpb24gJiYgY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5ob3N0O1xuICAgIGlmIChjb25uZWN0aW9uSG9zdCkge1xuICAgICAgICByZXR1cm4gW2Nvbm5lY3Rpb25Ib3N0XS5jb25jYXQoZGVmYXVsdHNfMS5kZWZhdWx0LmdldEZhbGxiYWNrSG9zdHMoY2xpZW50Lm9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRzXzEuZGVmYXVsdC5nZXRIb3N0cyhjbGllbnQub3B0aW9ucyk7XG59XG52YXIgSHR0cCA9IChfYSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMShvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrc0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpdml0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc3VwcG9ydHNBdXRoSGVhZGVycyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdXBwb3J0c0xpbmtIZWFkZXJzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9nZXRIb3N0cyA9IGdldEhvc3RzO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBjb25uZWN0aXZpdHlDaGVja1VybCA9IHRoaXMub3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybCB8fCBkZWZhdWx0c18xLmRlZmF1bHQuY29ubmVjdGl2aXR5Q2hlY2tVcmw7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXMgPSB0aGlzLm9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXM7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGl2aXR5VXJsSXNEZWZhdWx0ID0gIXRoaXMub3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybDtcbiAgICAgICAgICAgIGlmIChwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLnhoclN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VwcG9ydHNBdXRoSGVhZGVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5SZXF1ZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgcmVzdCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSB4aHJyZXF1ZXN0XzEuZGVmYXVsdC5jcmVhdGVSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBYSFJTdGF0ZXNfMS5kZWZhdWx0LlJFUV9TRU5ELCByZXN0ICYmIHJlc3Qub3B0aW9ucy50aW1lb3V0cywgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uY2UoJ2NvbXBsZXRlJywgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICByZXEuZXhlYygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlQ29ubmVjdGl2aXR5Q2hlY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpdml0eSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGl2aXR5ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJyhYSFJSZXF1ZXN0KUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKScsICdTZW5kaW5nOyAnICsgY29ubmVjdGl2aXR5Q2hlY2tVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1VyaShIdHRwTWV0aG9kc18xLmRlZmF1bHQuR2V0LCBudWxsLCBjb25uZWN0aXZpdHlDaGVja1VybCwgbnVsbCwgbnVsbCwgY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXMsIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlVGV4dCwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25uZWN0aXZpdHlVcmxJc0RlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gIWVyciAmJiAoMCwgSHR0cFN0YXR1c0NvZGVzXzEuaXNTdWNjZXNzQ29kZSkoc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAhZXJyICYmIChyZXNwb25zZVRleHQgPT09IG51bGwgfHwgcmVzcG9uc2VUZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZVRleHQucmVwbGFjZSgvXFxuLywgJycpKSA9PSAneWVzJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICcoWEhSUmVxdWVzdClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCknLCAnUmVzdWx0OiAnICsgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5qc29ucFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuUmVxdWVzdCA9IGZ1bmN0aW9uIChtZXRob2QsIHJlc3QsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gKDAsIGpzb25wdHJhbnNwb3J0XzEuY3JlYXRlUmVxdWVzdCkodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIFhIUlN0YXRlc18xLmRlZmF1bHQuUkVRX1NFTkQsIHJlc3QgJiYgcmVzdC5vcHRpb25zLnRpbWVvdXRzLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICByZXEub25jZSgnY29tcGxldGUnLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmV4ZWMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXE7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVDb25uZWN0aXZpdHlDaGVjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGl2aXR5ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aXZpdHkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXBVcmwgPSBkZWZhdWx0c18xLmRlZmF1bHQuanNvbnBJbnRlcm5ldFVwVXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tzSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tzSW5Qcm9ncmVzcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrc0luUHJvZ3Jlc3MgPSBbY2FsbGJhY2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICcoSlNPTlApSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpJywgJ1NlbmRpbmc7ICcgKyB1cFVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gbmV3IGpzb25wdHJhbnNwb3J0XzEuUmVxdWVzdCgnaXNUaGVJbnRlcm5ldFVwJywgdXBVcmwsIG51bGwsIG51bGwsIG51bGwsIFhIUlN0YXRlc18xLmRlZmF1bHQuUkVRX1NFTkQsIGRlZmF1bHRzXzEuZGVmYXVsdC5USU1FT1VUUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEub25jZSgnY29tcGxldGUnLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAhZXJyICYmIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnKEpTT05QKUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKScsICdSZXN1bHQ6ICcgKyByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMuY2hlY2tzSW5Qcm9ncmVzcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tzSW5Qcm9ncmVzc1tpXShudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNoZWNrc0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEuZXhlYygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5mZXRjaFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VwcG9ydHNBdXRoSGVhZGVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5SZXF1ZXN0ID0gZmV0Y2hyZXF1ZXN0XzEuZGVmYXVsdDtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGl2aXR5ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnKEZldGNoKUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKScsICdTZW5kaW5nOyAnICsgY29ubmVjdGl2aXR5Q2hlY2tVcmwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvVXJpKEh0dHBNZXRob2RzXzEuZGVmYXVsdC5HZXQsIG51bGwsIGNvbm5lY3Rpdml0eUNoZWNrVXJsLCBudWxsLCBudWxsLCBudWxsLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZVRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAhZXJyICYmIChyZXNwb25zZVRleHQgPT09IG51bGwgfHwgcmVzcG9uc2VUZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZVRleHQucmVwbGFjZSgvXFxuLywgJycpKSA9PSAneWVzJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnKEZldGNoKUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKScsICdSZXN1bHQ6ICcgKyByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuUmVxdWVzdCA9IGZ1bmN0aW9uIChtZXRob2QsIHJlc3QsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygnbm8gc3VwcG9ydGVkIEhUVFAgdHJhbnNwb3J0cyBhdmFpbGFibGUnLCBudWxsLCA0MDApLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIFVubGlrZSBmb3IgZG9VcmksIHRoZSAncmVzdCcgcGFyYW0gaGVyZSBpcyBtYW5kYXRvcnksIGFzIGl0J3MgdXNlZCB0byBnZW5lcmF0ZSB0aGUgaG9zdHMgKi9cbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZG8gPSBmdW5jdGlvbiAobWV0aG9kLCByZXN0LCBwYXRoLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHVyaUZyb21Ib3N0ID0gdHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgID8gcGF0aFxuICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKGhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3QuYmFzZVVyaShob3N0KSArIHBhdGg7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50RmFsbGJhY2sgPSByZXN0Ll9jdXJyZW50RmFsbGJhY2s7XG4gICAgICAgICAgICBpZiAoY3VycmVudEZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGYWxsYmFjay52YWxpZFVudGlsID4gVXRpbHMubm93KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogVXNlIHN0b3JlZCBmYWxsYmFjayAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdSZXF1ZXN0IGludm9rZWQgYmVmb3JlIGFzc2lnbmVkIHRvJywgbnVsbCwgNTAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5SZXF1ZXN0KG1ldGhvZCwgcmVzdCwgdXJpRnJvbUhvc3QoY3VycmVudEZhbGxiYWNrLmhvc3QpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHR5cGVjYXN0IGlzIHNhZmUgYmVjYXVzZSBFcnJub0V4Y2VwdGlvbnMgYXJlIG9ubHkgdGhyb3duIGluIE5vZGVKU1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBzaG91bGRGYWxsYmFjayhlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogdW5zdG9yZSB0aGUgZmFsbGJhY2sgYW5kIHN0YXJ0IGZyb20gdGhlIHRvcCB3aXRoIHRoZSBkZWZhdWx0IHNlcXVlbmNlICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdC5fY3VycmVudEZhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kbyhtZXRob2QsIHJlc3QsIHBhdGgsIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjay5hcHBseSh2b2lkIDAsIHRzbGliXzEuX19zcHJlYWRBcnJheShbZXJyXSwgYXJncywgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIEZhbGxiYWNrIGV4cGlyZWQ7IHJlbW92ZSBpdCBhbmQgZmFsbHRocm91Z2ggdG8gbm9ybWFsIHNlcXVlbmNlICovXG4gICAgICAgICAgICAgICAgICAgIHJlc3QuX2N1cnJlbnRGYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhvc3RzID0gZ2V0SG9zdHMocmVzdCk7XG4gICAgICAgICAgICAvKiBpZiB0aGVyZSBpcyBvbmx5IG9uZSBob3N0IGRvIGl0ICovXG4gICAgICAgICAgICBpZiAoaG9zdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb1VyaShtZXRob2QsIHJlc3QsIHVyaUZyb21Ib3N0KGhvc3RzWzBdKSwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaG9zdHMgaXMgYW4gYXJyYXkgd2l0aCBwcmVmZXJyZWQgaG9zdCBwbHVzIGF0IGxlYXN0IG9uZSBmYWxsYmFjayAqL1xuICAgICAgICAgICAgdmFyIHRyeUFIb3N0ID0gZnVuY3Rpb24gKGNhbmRpZGF0ZUhvc3RzLCBwZXJzaXN0T25TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhvc3QgPSBjYW5kaWRhdGVIb3N0cy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmRvVXJpKG1ldGhvZCwgcmVzdCwgdXJpRnJvbUhvc3QoaG9zdCksIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHR5cGVjYXN0IGlzIHNhZmUgYmVjYXVzZSBFcnJub0V4Y2VwdGlvbnMgYXJlIG9ubHkgdGhyb3duIGluIE5vZGVKU1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyICYmIHNob3VsZEZhbGxiYWNrKGVycikgJiYgY2FuZGlkYXRlSG9zdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnlBSG9zdChjYW5kaWRhdGVIb3N0cywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlcnNpc3RPblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFJTQzE1ZiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdC5fY3VycmVudEZhbGxiYWNrID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IGhvc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRVbnRpbDogVXRpbHMubm93KCkgKyByZXN0Lm9wdGlvbnMudGltZW91dHMuZmFsbGJhY2tSZXRyeVRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjay5hcHBseSh2b2lkIDAsIHRzbGliXzEuX19zcHJlYWRBcnJheShbZXJyXSwgYXJncywgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cnlBSG9zdChob3N0cyk7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmRvVXJpID0gZnVuY3Rpb24gKG1ldGhvZCwgcmVzdCwgdXJpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdSZXF1ZXN0IGludm9rZWQgYmVmb3JlIGFzc2lnbmVkIHRvJywgbnVsbCwgNTAwKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5SZXF1ZXN0KG1ldGhvZCwgcmVzdCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNsYXNzXzE7XG4gICAgfSgpKSxcbiAgICBfYS5tZXRob2RzID0gW0h0dHBNZXRob2RzXzEuZGVmYXVsdC5HZXQsIEh0dHBNZXRob2RzXzEuZGVmYXVsdC5EZWxldGUsIEh0dHBNZXRob2RzXzEuZGVmYXVsdC5Qb3N0LCBIdHRwTWV0aG9kc18xLmRlZmF1bHQuUHV0LCBIdHRwTWV0aG9kc18xLmRlZmF1bHQuUGF0Y2hdLFxuICAgIF9hLm1ldGhvZHNXaXRob3V0Qm9keSA9IFtIdHRwTWV0aG9kc18xLmRlZmF1bHQuR2V0LCBIdHRwTWV0aG9kc18xLmRlZmF1bHQuRGVsZXRlXSxcbiAgICBfYS5tZXRob2RzV2l0aEJvZHkgPSBbSHR0cE1ldGhvZHNfMS5kZWZhdWx0LlBvc3QsIEh0dHBNZXRob2RzXzEuZGVmYXVsdC5QdXQsIEh0dHBNZXRob2RzXzEuZGVmYXVsdC5QYXRjaF0sXG4gICAgX2EpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSHR0cDtcblxuXG4vKioqLyB9KSxcbi8qIDYzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgZGVmYXVsdHNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOCkpO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5mdW5jdGlvbiBpc0FibHlFcnJvcihyZXNwb25zZUJvZHksIGhlYWRlcnMpIHtcbiAgICByZXR1cm4gISFoZWFkZXJzLmdldCgneC1hYmx5LWVycm9yY29kZScpO1xufVxuZnVuY3Rpb24gZ2V0QWJseUVycm9yKHJlc3BvbnNlQm9keSwgaGVhZGVycykge1xuICAgIGlmIChpc0FibHlFcnJvcihyZXNwb25zZUJvZHksIGhlYWRlcnMpKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZUJvZHkuZXJyb3IgJiYgZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHJlc3BvbnNlQm9keS5lcnJvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gZmV0Y2hSZXF1ZXN0KG1ldGhvZCwgcmVzdCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZldGNoSGVhZGVycyA9IG5ldyBIZWFkZXJzKGhlYWRlcnMgfHwge30pO1xuICAgIHZhciBfbWV0aG9kID0gbWV0aG9kID8gbWV0aG9kLnRvVXBwZXJDYXNlKCkgOiBVdGlscy5pc0VtcHR5QXJnKGJvZHkpID8gJ0dFVCcgOiAnUE9TVCc7XG4gICAgdmFyIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygnUmVxdWVzdCB0aW1lZCBvdXQnLCBudWxsLCA0MDgpKTtcbiAgICB9LCByZXN0ID8gcmVzdC5vcHRpb25zLnRpbWVvdXRzLmh0dHBSZXF1ZXN0VGltZW91dCA6IGRlZmF1bHRzXzEuZGVmYXVsdC5USU1FT1VUUy5odHRwUmVxdWVzdFRpbWVvdXQpO1xuICAgIHZhciByZXF1ZXN0SW5pdCA9IHtcbiAgICAgICAgbWV0aG9kOiBfbWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiBmZXRjaEhlYWRlcnMsXG4gICAgICAgIGJvZHk6IGJvZHksXG4gICAgfTtcbiAgICBpZiAoIXBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaXNXZWJ3b3JrZXIpIHtcbiAgICAgICAgcmVxdWVzdEluaXQuY3JlZGVudGlhbHMgPSBmZXRjaEhlYWRlcnMuaGFzKCdhdXRob3JpemF0aW9uJykgPyAnaW5jbHVkZScgOiAnc2FtZS1vcmlnaW4nO1xuICAgIH1cbiAgICAoMCwgdXRpbHNfMS5nZXRHbG9iYWxPYmplY3QpKClcbiAgICAgICAgLmZldGNoKHVyaSArICc/JyArIG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zIHx8IHt9KSwgcmVxdWVzdEluaXQpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB2YXIgY29udGVudFR5cGUgPSByZXMuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICB2YXIgcHJvbTtcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL3gtbXNncGFjaycpID4gLTEpIHtcbiAgICAgICAgICAgIHByb20gPSByZXMuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPiAtMSkge1xuICAgICAgICAgICAgcHJvbSA9IHJlcy5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm9tID0gcmVzLnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9tLnRoZW4oZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgIHZhciB1bnBhY2tlZCA9ICEhY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24veC1tc2dwYWNrJykgPT09IC0xO1xuICAgICAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gZ2V0QWJseUVycm9yKGJvZHksIHJlcy5oZWFkZXJzKSB8fFxuICAgICAgICAgICAgICAgICAgICBuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygnRXJyb3IgcmVzcG9uc2UgcmVjZWl2ZWQgZnJvbSBzZXJ2ZXI6ICcgKyByZXMuc3RhdHVzICsgJyBib2R5IHdhczogJyArIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChib2R5KSwgbnVsbCwgcmVzLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBib2R5LCByZXMuaGVhZGVycywgdW5wYWNrZWQsIHJlcy5zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYm9keSwgcmVzLmhlYWRlcnMsIHVucGFja2VkLCByZXMuc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZmV0Y2hSZXF1ZXN0O1xuXG5cbi8qKiovIH0pLFxuLyogNjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBtc2dwYWNrXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKSk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbi8vIFdvcmthcm91bmQgZm9yIHNhbGVzZm9yY2UgbGlnaHRuaW5nIGxvY2tlciBjb21wYXRcbnZhciBnbG9iYWxPYmplY3QgPSBVdGlscy5nZXRHbG9iYWxPYmplY3QoKTtcbmlmICh0eXBlb2YgV2luZG93ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5sb2coXCJXYXJuaW5nOiB0aGlzIGRpc3RyaWJ1dGlvbiBvZiBBYmx5IGlzIGludGVuZGVkIGZvciBicm93c2Vycy4gT24gbm9kZWpzLCBwbGVhc2UgdXNlIHRoZSAnYWJseScgcGFja2FnZSBvbiBucG1cIik7XG59XG5mdW5jdGlvbiBhbGxvd0NvbWV0KCkge1xuICAgIC8qIHhociByZXF1ZXN0cyBmcm9tIGxvY2FsIGZpbGVzIGFyZSB1bnJlbGlhYmxlIGluIHNvbWUgYnJvd3NlcnMsIHN1Y2ggYXMgQ2hyb21lIDY1IGFuZCBoaWdoZXIgLS0gc2VlIGVnXG4gICAgICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDkyNTY0MjkvY2hyb21lLTY1LXVuYWJsZS10by1tYWtlLXBvc3QtcmVxdWVzdHMtZnJvbS1sb2NhbC1maWxlcy10by1mbGFza1xuICAgICAqIFNvIGlmIHdlYnNvY2tldHMgYXJlIHN1cHBvcnRlZCwgdGhlbiBqdXN0IGZvcmdldCBhYm91dCBjb21ldCB0cmFuc3BvcnRzIGFuZCB1c2UgdGhhdCAqL1xuICAgIHZhciBsb2MgPSBnbG9iYWxPYmplY3QubG9jYXRpb247XG4gICAgcmV0dXJuICFnbG9iYWxPYmplY3QuV2ViU29ja2V0IHx8ICFsb2MgfHwgIWxvYy5vcmlnaW4gfHwgbG9jLm9yaWdpbi5pbmRleE9mKCdodHRwJykgPiAtMTtcbn1cbnZhciB1c2VyQWdlbnQgPSBnbG9iYWxPYmplY3QubmF2aWdhdG9yICYmIGdsb2JhbE9iamVjdC5uYXZpZ2F0b3IudXNlckFnZW50LnRvU3RyaW5nKCk7XG52YXIgY3VycmVudFVybCA9IGdsb2JhbE9iamVjdC5sb2NhdGlvbiAmJiBnbG9iYWxPYmplY3QubG9jYXRpb24uaHJlZjtcbnZhciBDb25maWcgPSB7XG4gICAgYWdlbnQ6ICdicm93c2VyJyxcbiAgICBsb2dUaW1lc3RhbXBzOiB0cnVlLFxuICAgIHVzZXJBZ2VudDogdXNlckFnZW50LFxuICAgIGN1cnJlbnRVcmw6IGN1cnJlbnRVcmwsXG4gICAgbm9VcGdyYWRlOiB1c2VyQWdlbnQgJiYgISF1c2VyQWdlbnQubWF0Y2goL01TSUVcXHM4XFwuMC8pLFxuICAgIGJpbmFyeVR5cGU6ICdhcnJheWJ1ZmZlcicsXG4gICAgV2ViU29ja2V0OiBnbG9iYWxPYmplY3QuV2ViU29ja2V0LFxuICAgIGZldGNoU3VwcG9ydGVkOiAhIWdsb2JhbE9iamVjdC5mZXRjaCxcbiAgICB4aHJTdXBwb3J0ZWQ6IGdsb2JhbE9iamVjdC5YTUxIdHRwUmVxdWVzdCAmJiAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKSxcbiAgICBqc29ucFN1cHBvcnRlZDogdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyxcbiAgICBhbGxvd0NvbWV0OiBhbGxvd0NvbWV0KCksXG4gICAgc3RyZWFtaW5nU3VwcG9ydGVkOiB0cnVlLFxuICAgIHVzZVByb3RvY29sSGVhcnRiZWF0czogdHJ1ZSxcbiAgICBjcmVhdGVIbWFjOiBudWxsLFxuICAgIG1zZ3BhY2s6IG1zZ3BhY2tfMS5kZWZhdWx0LFxuICAgIHN1cHBvcnRzQmluYXJ5OiAhIWdsb2JhbE9iamVjdC5UZXh0RGVjb2RlcixcbiAgICBwcmVmZXJCaW5hcnk6IGZhbHNlLFxuICAgIEFycmF5QnVmZmVyOiBnbG9iYWxPYmplY3QuQXJyYXlCdWZmZXIsXG4gICAgYXRvYjogZ2xvYmFsT2JqZWN0LmF0b2IsXG4gICAgbmV4dFRpY2s6IHR5cGVvZiBnbG9iYWxPYmplY3Quc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IGdsb2JhbE9iamVjdC5zZXRJbW1lZGlhdGUuYmluZChnbG9iYWxPYmplY3QpXG4gICAgICAgIDogZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZiwgMCk7XG4gICAgICAgIH0sXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogZ2xvYmFsT2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIsXG4gICAgaW5zcGVjdDogSlNPTi5zdHJpbmdpZnksXG4gICAgc3RyaW5nQnl0ZVNpemU6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgLyogc3RyLmxlbmd0aCB3aWxsIGJlIGFuIHVuZGVyZXN0aW1hdGUgZm9yIG5vbi1hc2NpaSBzdHJpbmdzLiBCdXQgaWYgd2UncmVcbiAgICAgICAgICogaW4gYSBicm93c2VyIHRvbyBvbGQgdG8gc3VwcG9ydCBUZXh0RGVjb2Rlciwgbm90IG11Y2ggd2UgY2FuIGRvLiBCZXR0ZXJcbiAgICAgICAgICogdG8gdW5kZXJlc3RpbWF0ZSwgc28gaWYgd2UgZG8gZ28gb3Zlci1zaXplLCB0aGUgc2VydmVyIHdpbGwgcmVqZWN0IHRoZVxuICAgICAgICAgKiBtZXNzYWdlICovXG4gICAgICAgIHJldHVybiAoZ2xvYmFsT2JqZWN0LlRleHREZWNvZGVyICYmIG5ldyBnbG9iYWxPYmplY3QuVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKS5sZW5ndGgpIHx8IHN0ci5sZW5ndGg7XG4gICAgfSxcbiAgICBUZXh0RW5jb2RlcjogZ2xvYmFsT2JqZWN0LlRleHRFbmNvZGVyLFxuICAgIFRleHREZWNvZGVyOiBnbG9iYWxPYmplY3QuVGV4dERlY29kZXIsXG4gICAgUHJvbWlzZTogZ2xvYmFsT2JqZWN0LlByb21pc2UsXG4gICAgZ2V0UmFuZG9tVmFsdWVzOiAoZnVuY3Rpb24gKGNyeXB0bykge1xuICAgICAgICBpZiAoY3J5cHRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KShnbG9iYWxPYmplY3QuY3J5cHRvIHx8IG1zQ3J5cHRvKSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBDb25maWc7XG5cblxuLyoqKi8gfSksXG4vKiA2NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIHRlc3QgPSAnYWJseWpzLXN0b3JhZ2UtdGVzdCc7XG52YXIgV2Vic3RvcmFnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXZWJzdG9yYWdlKCkge1xuICAgICAgICAvKiBFdmVuIGp1c3QgYWNjZXNzaW5nIHRoZSBzZXNzaW9uL2xvY2FsU3RvcmFnZSBvYmplY3QgY2FuIHRocm93IGFcbiAgICAgICAgICogc2VjdXJpdHkgZXhjZXB0aW9uIGluIHNvbWUgY2lyY3Vtc3RhbmNlcyB3aXRoIHNvbWUgYnJvd3NlcnMuIEluXG4gICAgICAgICAqIG90aGVycywgY2FsbGluZyBzZXRJdGVtIHdpbGwgdGhyb3cuIFNvIGhhdmUgdG8gY2hlY2sgaW4gdGhpc1xuICAgICAgICAgKiBzb21ld2hhdCByb3VuZGFib3V0IHdheS4gKElmIHVuc3VwcG9ydGVkIG9yIG5vIGdsb2JhbCBvYmplY3QsXG4gICAgICAgICAqIHdpbGwgdGhyb3cgb24gYWNjZXNzaW5nIGEgcHJvcGVydHkgb2YgdW5kZWZpbmVkKSAqL1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZ2xvYmFsLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0odGVzdCwgdGVzdCk7XG4gICAgICAgICAgICBnbG9iYWwuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh0ZXN0KTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvblN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvblN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBnbG9iYWwubG9jYWxTdG9yYWdlLnNldEl0ZW0odGVzdCwgdGVzdCk7XG4gICAgICAgICAgICBnbG9iYWwubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGVzdCk7XG4gICAgICAgICAgICB0aGlzLmxvY2FsU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIFdlYnN0b3JhZ2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXQobmFtZSwgZmFsc2UpO1xuICAgIH07XG4gICAgV2Vic3RvcmFnZS5wcm90b3R5cGUuZ2V0U2Vzc2lvbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXQobmFtZSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBXZWJzdG9yYWdlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlKG5hbWUsIGZhbHNlKTtcbiAgICB9O1xuICAgIFdlYnN0b3JhZ2UucHJvdG90eXBlLnJlbW92ZVNlc3Npb24gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlKG5hbWUsIHRydWUpO1xuICAgIH07XG4gICAgV2Vic3RvcmFnZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCB0dGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldChuYW1lLCB2YWx1ZSwgdHRsLCBmYWxzZSk7XG4gICAgfTtcbiAgICBXZWJzdG9yYWdlLnByb3RvdHlwZS5zZXRTZXNzaW9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCB0dGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldChuYW1lLCB2YWx1ZSwgdHRsLCB0cnVlKTtcbiAgICB9O1xuICAgIFdlYnN0b3JhZ2UucHJvdG90eXBlLl9zZXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHR0bCwgc2Vzc2lvbikge1xuICAgICAgICB2YXIgd3JhcHBlZFZhbHVlID0geyB2YWx1ZTogdmFsdWUgfTtcbiAgICAgICAgaWYgKHR0bCkge1xuICAgICAgICAgICAgd3JhcHBlZFZhbHVlLmV4cGlyZXMgPSBVdGlscy5ub3coKSArIHR0bDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLnNldEl0ZW0obmFtZSwgSlNPTi5zdHJpbmdpZnkod3JhcHBlZFZhbHVlKSk7XG4gICAgfTtcbiAgICBXZWJzdG9yYWdlLnByb3RvdHlwZS5fZ2V0ID0gZnVuY3Rpb24gKG5hbWUsIHNlc3Npb24pIHtcbiAgICAgICAgaWYgKHNlc3Npb24gJiYgIXRoaXMuc2Vzc2lvblN1cHBvcnRlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2Vzc2lvbiBTdG9yYWdlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgaWYgKCFzZXNzaW9uICYmICF0aGlzLmxvY2FsU3VwcG9ydGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2NhbCBTdG9yYWdlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgdmFyIHJhd0l0ZW0gPSB0aGlzLnN0b3JhZ2VJbnRlcmZhY2Uoc2Vzc2lvbikuZ2V0SXRlbShuYW1lKTtcbiAgICAgICAgaWYgKCFyYXdJdGVtKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciB3cmFwcGVkVmFsdWUgPSBKU09OLnBhcnNlKHJhd0l0ZW0pO1xuICAgICAgICBpZiAod3JhcHBlZFZhbHVlLmV4cGlyZXMgJiYgd3JhcHBlZFZhbHVlLmV4cGlyZXMgPCBVdGlscy5ub3coKSkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLnJlbW92ZUl0ZW0obmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JhcHBlZFZhbHVlLnZhbHVlO1xuICAgIH07XG4gICAgV2Vic3RvcmFnZS5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uIChuYW1lLCBzZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2VJbnRlcmZhY2Uoc2Vzc2lvbikucmVtb3ZlSXRlbShuYW1lKTtcbiAgICB9O1xuICAgIFdlYnN0b3JhZ2UucHJvdG90eXBlLnN0b3JhZ2VJbnRlcmZhY2UgPSBmdW5jdGlvbiAoc2Vzc2lvbikge1xuICAgICAgICByZXR1cm4gc2Vzc2lvbiA/IGdsb2JhbC5zZXNzaW9uU3RvcmFnZSA6IGdsb2JhbC5sb2NhbFN0b3JhZ2U7XG4gICAgfTtcbiAgICByZXR1cm4gV2Vic3RvcmFnZTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgV2Vic3RvcmFnZSgpO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxMykpKVxuXG4vKioqLyB9KSxcbi8qIDY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVHJhbnNwb3J0TmFtZXNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNjcpKTtcbnZhciBEZWZhdWx0cyA9IHtcbiAgICBjb25uZWN0aXZpdHlDaGVja1VybDogJ2h0dHBzOi8vaW50ZXJuZXQtdXAuYWJseS1yZWFsdGltZS5jb20vaXMtdGhlLWludGVybmV0LXVwLnR4dCcsXG4gICAganNvbnBJbnRlcm5ldFVwVXJsOiAnaHR0cHM6Ly9pbnRlcm5ldC11cC5hYmx5LXJlYWx0aW1lLmNvbS9pcy10aGUtaW50ZXJuZXQtdXAtMC05LmpzJyxcbiAgICAvKiBPcmRlciBtYXR0ZXJzIGhlcmU6IHRoZSBiYXNlIHRyYW5zcG9ydCBpcyB0aGUgbGVmdG1vc3Qgb25lIGluIHRoZVxuICAgICAqIGludGVyc2VjdGlvbiBvZiBiYXNlVHJhbnNwb3J0T3JkZXIgYW5kIHRoZSB0cmFuc3BvcnRzIGNsaWVudE9wdGlvbiB0aGF0J3NcbiAgICAgKiBzdXBwb3J0ZWQuICBUaGlzIGlzIG5vdCBxdWl0ZSB0aGUgc2FtZSBhcyB0aGUgcHJlZmVyZW5jZSBvcmRlciAtLSBlLmcuXG4gICAgICogeGhyX3BvbGxpbmcgaXMgcHJlZmVycmVkIHRvIGpzb25wLCBidXQgZm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBpdCB3ZSB3YW50XG4gICAgICogdGhlIGJhc2UgdHJhbnNwb3J0IHRvIGJlIHhocl9wb2xsaW5nLCBub3QganNvbnAgKi9cbiAgICBkZWZhdWx0VHJhbnNwb3J0czogW1xuICAgICAgICBUcmFuc3BvcnROYW1lc18xLmRlZmF1bHQuWGhyUG9sbGluZyxcbiAgICAgICAgVHJhbnNwb3J0TmFtZXNfMS5kZWZhdWx0LlhoclN0cmVhbWluZyxcbiAgICAgICAgVHJhbnNwb3J0TmFtZXNfMS5kZWZhdWx0Lkpzb25QLFxuICAgICAgICBUcmFuc3BvcnROYW1lc18xLmRlZmF1bHQuV2ViU29ja2V0LFxuICAgIF0sXG4gICAgYmFzZVRyYW5zcG9ydE9yZGVyOiBbXG4gICAgICAgIFRyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5YaHJQb2xsaW5nLFxuICAgICAgICBUcmFuc3BvcnROYW1lc18xLmRlZmF1bHQuWGhyU3RyZWFtaW5nLFxuICAgICAgICBUcmFuc3BvcnROYW1lc18xLmRlZmF1bHQuSnNvblAsXG4gICAgICAgIFRyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5XZWJTb2NrZXQsXG4gICAgXSxcbiAgICB0cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXI6IFtcbiAgICAgICAgVHJhbnNwb3J0TmFtZXNfMS5kZWZhdWx0Lkpzb25QLFxuICAgICAgICBUcmFuc3BvcnROYW1lc18xLmRlZmF1bHQuWGhyUG9sbGluZyxcbiAgICAgICAgVHJhbnNwb3J0TmFtZXNfMS5kZWZhdWx0LlhoclN0cmVhbWluZyxcbiAgICAgICAgVHJhbnNwb3J0TmFtZXNfMS5kZWZhdWx0LldlYlNvY2tldCxcbiAgICBdLFxuICAgIHVwZ3JhZGVUcmFuc3BvcnRzOiBbVHJhbnNwb3J0TmFtZXNfMS5kZWZhdWx0LlhoclN0cmVhbWluZywgVHJhbnNwb3J0TmFtZXNfMS5kZWZhdWx0LldlYlNvY2tldF0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gRGVmYXVsdHM7XG5cblxuLyoqKi8gfSksXG4vKiA2NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFRyYW5zcG9ydE5hbWVzO1xuKGZ1bmN0aW9uIChUcmFuc3BvcnROYW1lcykge1xuICAgIFRyYW5zcG9ydE5hbWVzW1wiV2ViU29ja2V0XCJdID0gXCJ3ZWJfc29ja2V0XCI7XG4gICAgVHJhbnNwb3J0TmFtZXNbXCJDb21ldFwiXSA9IFwiY29tZXRcIjtcbiAgICBUcmFuc3BvcnROYW1lc1tcIlhoclN0cmVhbWluZ1wiXSA9IFwieGhyX3N0cmVhbWluZ1wiO1xuICAgIFRyYW5zcG9ydE5hbWVzW1wiWGhyUG9sbGluZ1wiXSA9IFwieGhyX3BvbGxpbmdcIjtcbiAgICBUcmFuc3BvcnROYW1lc1tcIkpzb25QXCJdID0gXCJqc29ucFwiO1xufSkoVHJhbnNwb3J0TmFtZXMgfHwgKFRyYW5zcG9ydE5hbWVzID0ge30pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRyYW5zcG9ydE5hbWVzO1xuXG5cbi8qKiovIH0pLFxuLyogNjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9wbGF0Zm9ybS93ZWIvbGliL3RyYW5zcG9ydC9qc29ucHRyYW5zcG9ydC50c1xudmFyIGpzb25wdHJhbnNwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG52YXIganNvbnB0cmFuc3BvcnRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanNvbnB0cmFuc3BvcnQpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbW1vbi9saWIvdXRpbC91dGlscy50c1xudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21tb24vcGxhdGZvcm0udHNcbnZhciBwbGF0Zm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgcGxhdGZvcm1fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocGxhdGZvcm0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbW1vbi9saWIvdHJhbnNwb3J0L2NvbWV0dHJhbnNwb3J0LnRzXG52YXIgY29tZXR0cmFuc3BvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciBjb21ldHRyYW5zcG9ydF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb21ldHRyYW5zcG9ydCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvcGxhdGZvcm0vd2ViL2xpYi90cmFuc3BvcnQveGhycmVxdWVzdC50c1xudmFyIHhocnJlcXVlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcbnZhciB4aHJyZXF1ZXN0X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHhocnJlcXVlc3QpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9wbGF0Zm9ybS93ZWIvbGliL3RyYW5zcG9ydC94aHJwb2xsaW5ndHJhbnNwb3J0LmpzXG5cblxuXG5cblxudmFyIHhocnBvbGxpbmd0cmFuc3BvcnRfWEhSUG9sbGluZ1RyYW5zcG9ydCA9IGZ1bmN0aW9uIChjb25uZWN0aW9uTWFuYWdlcikge1xuICB2YXIgc2hvcnROYW1lID0gJ3hocl9wb2xsaW5nJztcblxuICBmdW5jdGlvbiBYSFJQb2xsaW5nVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcbiAgICBwYXJhbXMuc3RyZWFtID0gZmFsc2U7XG4gICAgY29tZXR0cmFuc3BvcnRfZGVmYXVsdC5hLmNhbGwodGhpcywgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG4gICAgdGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWU7XG4gIH1cbiAgdXRpbHNbXCJpbmhlcml0c1wiXShYSFJQb2xsaW5nVHJhbnNwb3J0LCBjb21ldHRyYW5zcG9ydF9kZWZhdWx0LmEpO1xuXG4gIFhIUlBvbGxpbmdUcmFuc3BvcnQuaXNBdmFpbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBsYXRmb3JtX2RlZmF1bHQuYS5Db25maWcueGhyU3VwcG9ydGVkICYmIHBsYXRmb3JtX2RlZmF1bHQuYS5Db25maWcuYWxsb3dDb21ldDtcbiAgfTtcblxuICBYSFJQb2xsaW5nVHJhbnNwb3J0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ1hIUlBvbGxpbmdUcmFuc3BvcnQ7IHVyaT0nICsgdGhpcy5iYXNlVXJpICsgJzsgaXNDb25uZWN0ZWQ9JyArIHRoaXMuaXNDb25uZWN0ZWQ7XG4gIH07XG5cbiAgWEhSUG9sbGluZ1RyYW5zcG9ydC5wcm90b3R5cGUuY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uICh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUpIHtcbiAgICByZXR1cm4geGhycmVxdWVzdF9kZWZhdWx0LmEuY3JlYXRlUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRoaXMudGltZW91dHMpO1xuICB9O1xuXG4gIGlmICh0eXBlb2YgY29ubmVjdGlvbk1hbmFnZXIgIT09ICd1bmRlZmluZWQnICYmIFhIUlBvbGxpbmdUcmFuc3BvcnQuaXNBdmFpbGFibGUoKSkge1xuICAgIGNvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHNbc2hvcnROYW1lXSA9IFhIUlBvbGxpbmdUcmFuc3BvcnQ7XG4gIH1cblxuICByZXR1cm4gWEhSUG9sbGluZ1RyYW5zcG9ydDtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHhocnBvbGxpbmd0cmFuc3BvcnQgPSAoeGhycG9sbGluZ3RyYW5zcG9ydF9YSFJQb2xsaW5nVHJhbnNwb3J0KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcGxhdGZvcm0vd2ViL2xpYi90cmFuc3BvcnQveGhyc3RyZWFtaW5ndHJhbnNwb3J0LmpzXG5cblxuXG5cblxudmFyIHhocnN0cmVhbWluZ3RyYW5zcG9ydF9YSFJTdHJlYW1pbmdUcmFuc3BvcnQgPSBmdW5jdGlvbiAoY29ubmVjdGlvbk1hbmFnZXIpIHtcbiAgdmFyIHNob3J0TmFtZSA9ICd4aHJfc3RyZWFtaW5nJztcblxuICAvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cbiAgZnVuY3Rpb24gWEhSU3RyZWFtaW5nVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcbiAgICBjb21ldHRyYW5zcG9ydF9kZWZhdWx0LmEuY2FsbCh0aGlzLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcbiAgICB0aGlzLnNob3J0TmFtZSA9IHNob3J0TmFtZTtcbiAgfVxuICB1dGlsc1tcImluaGVyaXRzXCJdKFhIUlN0cmVhbWluZ1RyYW5zcG9ydCwgY29tZXR0cmFuc3BvcnRfZGVmYXVsdC5hKTtcblxuICBYSFJTdHJlYW1pbmdUcmFuc3BvcnQuaXNBdmFpbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBsYXRmb3JtX2RlZmF1bHQuYS5Db25maWcueGhyU3VwcG9ydGVkICYmIHBsYXRmb3JtX2RlZmF1bHQuYS5Db25maWcuc3RyZWFtaW5nU3VwcG9ydGVkICYmIHBsYXRmb3JtX2RlZmF1bHQuYS5Db25maWcuYWxsb3dDb21ldDtcbiAgfTtcblxuICBYSFJTdHJlYW1pbmdUcmFuc3BvcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnWEhSU3RyZWFtaW5nVHJhbnNwb3J0OyB1cmk9JyArIHRoaXMuYmFzZVVyaSArICc7IGlzQ29ubmVjdGVkPScgKyB0aGlzLmlzQ29ubmVjdGVkO1xuICB9O1xuXG4gIFhIUlN0cmVhbWluZ1RyYW5zcG9ydC5wcm90b3R5cGUuY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uICh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUpIHtcbiAgICByZXR1cm4geGhycmVxdWVzdF9kZWZhdWx0LmEuY3JlYXRlUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRoaXMudGltZW91dHMpO1xuICB9O1xuXG4gIGlmICh0eXBlb2YgY29ubmVjdGlvbk1hbmFnZXIgIT09ICd1bmRlZmluZWQnICYmIFhIUlN0cmVhbWluZ1RyYW5zcG9ydC5pc0F2YWlsYWJsZSgpKSB7XG4gICAgY29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0c1tzaG9ydE5hbWVdID0gWEhSU3RyZWFtaW5nVHJhbnNwb3J0O1xuICB9XG5cbiAgcmV0dXJuIFhIUlN0cmVhbWluZ1RyYW5zcG9ydDtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHhocnN0cmVhbWluZ3RyYW5zcG9ydCA9ICh4aHJzdHJlYW1pbmd0cmFuc3BvcnRfWEhSU3RyZWFtaW5nVHJhbnNwb3J0KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcGxhdGZvcm0vd2ViL2xpYi90cmFuc3BvcnQvaW5kZXguanNcblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwb3J0ID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoW2pzb25wdHJhbnNwb3J0X2RlZmF1bHQuYSwgeGhycG9sbGluZ3RyYW5zcG9ydCwgeGhyc3RyZWFtaW5ndHJhbnNwb3J0XSk7XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pW1wiZGVmYXVsdFwiXTtcbn0pOyIsIid1c2Ugc3RyaWN0JztcbmZ1bmN0aW9uIHByb21pc2lmeU9wdGlvbnMob3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucy5pbmRleE9mKCc6JykgPT0gLTEgPyB7IHRva2VuOiBvcHRpb25zIH0gOiB7IGtleTogb3B0aW9ucyB9O1xuICB9XG4gIG9wdGlvbnMucHJvbWlzZXMgPSB0cnVlO1xuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyogUGxlYXNlIG5vdGUgdGhhdCB0aGUgZmlsZSBpbXBvcnRlZCBiZWxvdyBpcyBvbmx5IGdlbmVyYXRlZCBhZnRlciBydW5uaW5nXG4gKiB0aGUgYnVpbGQgdGFzay4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG52YXIgQWJseSA9IHJlcXVpcmUoJy4vYnVpbGQvYWJseS1ub2RlJyk7XG5cbnZhciBSZXN0UHJvbWlzZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgQWJseS5SZXN0KHByb21pc2lmeU9wdGlvbnMob3B0aW9ucykpO1xufTtcbk9iamVjdC5hc3NpZ24oUmVzdFByb21pc2UsIEFibHkuUmVzdCk7XG5cbnZhciBSZWFsdGltZVByb21pc2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICByZXR1cm4gbmV3IEFibHkuUmVhbHRpbWUocHJvbWlzaWZ5T3B0aW9ucyhvcHRpb25zKSk7XG59O1xuT2JqZWN0LmFzc2lnbihSZWFsdGltZVByb21pc2UsIEFibHkuUmVhbHRpbWUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUmVzdDogUmVzdFByb21pc2UsXG4gIFJlYWx0aW1lOiBSZWFsdGltZVByb21pc2UsXG59O1xuIiwiaW1wb3J0IHsgbWVzc2FnZXMsIHNlcnZlciB9IGZyb20gXCIuL3NlcnZlclwiO1xyXG5pbXBvcnQgeyB2aWV3IH0gZnJvbSBcIi4vdmlld1wiO1xyXG5pbXBvcnQgeyBnZXRSYW5kb21JbnQgfSBmcm9tIFwiLi91bnRpbHMvcmFuZG9tXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgQ29udHJvbGxlciB7XHJcbiAgbG9jYWxTdGF0ZSA9IHtcclxuICAgIHVzZXJJRDogXCJcIixcclxuICAgIHVzZXJOYW1lOiBcIlwiLFxyXG4gICAgdGhlbWU6IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic3R5bGVcIikgPz8gXCJsaWdodFwiLFxyXG4gIH07XHJcblxyXG4gIGdhbWVTdGF0ZSA9IHtcclxuICAgIHJvbGVzOiB7XHJcbiAgICAgIHBsYXllcjE6IFwiXCIsXHJcbiAgICAgIHBsYXllcjI6IFwiXCIsXHJcbiAgICB9LFxyXG4gICAgY2VsbHNEYXRhOiBbXSxcclxuICAgIGN1cnJlbnRNb3ZlOiBnZXRSYW5kb21JbnQoMSkgPT09IDAgPyBcInhcIiA6IFwib1wiLFxyXG4gIH07XHJcblxyXG4gIGFzeW5jIGluaXQoKSB7XHJcbiAgICB0aGlzLnJlc3RvcmVMb2NhbFN0YXRlKCk7XHJcblxyXG4gICAgdmlldy5zZXRTdHlsZSh0aGlzLmxvY2FsU3RhdGUudGhlbWUpO1xyXG5cclxuICAgIHZpZXcub25DZWxsUHJlc3MgPSAoY2VsbCkgPT4gdGhpcy5vbkNlbGxQcmVzcyhjZWxsKTtcclxuXHJcbiAgICB2aWV3LnRoZW1lU3dpdGNoZXIub25jbGljayA9ICgpID0+IHRoaXMudG9nZ2xlU3R5bGUoKTtcclxuXHJcbiAgICBpZiAoIXRoaXMubG9jYWxTdGF0ZS51c2VyTmFtZSkge1xyXG4gICAgICBjb25zdCB1c2VyTmFtZSA9IGF3YWl0IHZpZXcuc2hvd1VzZXJOYW1lSW5wdXQoKTtcclxuICAgICAgY29uc3QgdXNlcklEID0gYnRvYSh1c2VyTmFtZSArIERhdGUubm93KCkgKyBNYXRoLnJhbmRvbSgpKTtcclxuICAgICAgdGhpcy51cGRhdGVMb2NhbFN0YXRlKHsgdXNlck5hbWUsIHVzZXJJRCB9KTtcclxuICAgIH1cclxuXHJcbiAgICB2aWV3LmNoYW5nZU5hbWUgPSAodXNlck5hbWUpID0+IHRoaXMuY2hhbmdlTmFtZSh1c2VyTmFtZSk7XHJcblxyXG4gICAgdmlldy5zaG93TWVzc2FnZShcIldhaXRpbmcgZm9yIG9wcG9uZW50Li4uXCIpO1xyXG4gICAgdmlldy5oaWRlUm9vbU5hbWVJbnB1dCgpO1xyXG5cclxuICAgIHRoaXMuZ2VuZXJhdGVSb29tSUQoKTtcclxuICAgIGF3YWl0IHNlcnZlci5pbml0Um9vbSh0aGlzLnJvb21JRCk7XHJcblxyXG4gICAgdGhpcy5zZW5kVXNlclJlYWR5KHRoaXMucm9vbUlEKTtcclxuXHJcbiAgICBzZXJ2ZXIub25bbWVzc2FnZXMudXNlclJlYWR5XSA9IChkYXRhKSA9PiB7XHJcbiAgICAgIGlmIChkYXRhLnVzZXJJRCA9PT0gdGhpcy5sb2NhbFN0YXRlLnVzZXJJRCkgcmV0dXJuO1xyXG4gICAgICBjb25zb2xlLmxvZyhtZXNzYWdlcy51c2VyUmVhZHksIGRhdGEpO1xyXG5cclxuICAgICAgdmlldy5zaG93TWVzc2FnZShgJHtkYXRhLnVzZXJOYW1lfSBqb2luZWQgZ2FtZWApO1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHZpZXcuaGlkZU1lc3NhZ2UoKSwgMzAwMCk7XHJcblxyXG4gICAgICB2aWV3LnNob3dGaWVsZCgpO1xyXG5cclxuICAgICAgdGhpcy5zdGFydEdhbWUoKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VydmVyLm9uW21lc3NhZ2VzLnN0YXJ0R2FtZV0gPSAoZGF0YSkgPT4ge1xyXG4gICAgICBpZiAoZGF0YS51c2VySUQgPT09IHRoaXMubG9jYWxTdGF0ZS51c2VySUQpIHJldHVybjtcclxuICAgICAgY29uc29sZS5sb2cobWVzc2FnZXMudXNlclJlYWR5LCBkYXRhKTtcclxuXHJcbiAgICAgIHZpZXcuc2hvd0ZpZWxkKCk7XHJcblxyXG4gICAgICB2aWV3LnNob3dNZXNzYWdlKGAke2RhdGEudXNlck5hbWV9IGpvaW5lZCBnYW1lYCk7XHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdmlldy5oaWRlTWVzc2FnZSgpLCAzMDAwKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VydmVyLm9uW21lc3NhZ2VzLm1vdmVdID0gKGRhdGEpID0+IHRoaXMub25Nb3ZlKGRhdGEpO1xyXG5cclxuICAgIC8vIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGFzeW5jIChldmVudCkgPT4ge1xyXG4gICAgLy8gICBldmVudC5yZXR1cm5WYWx1ZSA9IGBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gbGVhdmU/YDtcclxuXHJcbiAgICAvLyAgIHNlcnZlci5jbG9zZUNvbm5lY3Rpb24oKTtcclxuICAgIC8vIH0pO1xyXG4gIH1cclxuXHJcbiAgcmVzdG9yZUxvY2FsU3RhdGUoKSB7XHJcbiAgICBjb25zdCBzdG9yZWRTdGF0ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibG9jYWxTdGF0ZVwiKTtcclxuXHJcbiAgICBpZiAoIXN0b3JlZFN0YXRlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmxvY2FsU3RhdGUgPSBKU09OLnBhcnNlKHN0b3JlZFN0YXRlKTtcclxuICB9XHJcblxyXG4gIHNhdmVMb2NhbFN0YXRlKCkge1xyXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJsb2NhbFN0YXRlXCIsIEpTT04uc3RyaW5naWZ5KHRoaXMubG9jYWxTdGF0ZSkpO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlTG9jYWxTdGF0ZShzdGF0ZSkge1xyXG4gICAgdGhpcy5sb2NhbFN0YXRlID0ge1xyXG4gICAgICAuLi50aGlzLmxvY2FsU3RhdGUsXHJcbiAgICAgIC4uLnN0YXRlLFxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNhdmVMb2NhbFN0YXRlKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgcm9vbUlEKCkge1xyXG4gICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcclxuXHJcbiAgICByZXR1cm4gdXJsUGFyYW1zLmdldChcInJvb21JRFwiKTtcclxuICB9XHJcblxyXG4gIHNldCByb29tSUQocm9vbUlEKSB7XHJcbiAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xyXG5cclxuICAgIGlmICh1cmxQYXJhbXMuZ2V0KFwicm9vbUlEXCIpID09PSByb29tSUQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHVybFBhcmFtcy5zZXQoXCJyb29tSURcIiwgcm9vbUlEKTtcclxuICAgIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggPSB1cmxQYXJhbXM7XHJcbiAgfVxyXG5cclxuICBnZW5lcmF0ZVJvb21JRCgpIHtcclxuICAgIGlmICghdGhpcy5yb29tSUQpIHtcclxuICAgICAgdGhpcy5yb29tSUQgPSB0aGlzLmxvY2FsU3RhdGUudXNlcklEO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2VuZFVzZXJSZWFkeShyb29tSUQpIHtcclxuICAgIHNlcnZlci5tZXNzYWdlKG1lc3NhZ2VzLnVzZXJSZWFkeSwge1xyXG4gICAgICB1c2VySUQ6IHRoaXMubG9jYWxTdGF0ZS51c2VySUQsXHJcbiAgICAgIHVzZXJOYW1lOiB0aGlzLmxvY2FsU3RhdGUudXNlck5hbWUsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG5cclxuXHJcbiAgc3RhcnRHYW1lKCkge1xyXG4gICAgc2VydmVyLm1lc3NhZ2UobWVzc2FnZXMuc3RhcnRHYW1lLCB7XHJcbiAgICAgIHVzZXJJRDogdGhpcy5sb2NhbFN0YXRlLnVzZXJJRCxcclxuICAgICAgdXNlck5hbWU6IHRoaXMubG9jYWxTdGF0ZS51c2VyTmFtZSxcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMucmVzZXRHYW1lKCk7XHJcblxyXG4gICAgdmlldy5zZXRUdXJuKHRoaXMuc3RlcCk7XHJcbiAgfVxyXG5cclxuICB0b2dnbGVTdHlsZSgpIHtcclxuICAgIGNvbnN0IHRoZW1lID0gdGhpcy5sb2NhbFN0YXRlLnRoZW1lID09PSBcImxpZ2h0XCIgPyBcImRhcmtcIiA6IFwibGlnaHRcIjtcclxuICAgIHZpZXcuc2V0U3R5bGUodGhlbWUpO1xyXG4gICAgdGhpcy51cGRhdGVMb2NhbFN0YXRlKHsgdGhlbWUgfSk7XHJcbiAgfVxyXG5cclxuICByZXNldEdhbWUoKSB7XHJcbiAgICB0aGlzLmdhbWVTdGF0ZS5jZWxsc0RhdGEgPSBuZXcgQXJyYXkoOSkuZmlsbChcImVtcHR5XCIpO1xyXG4gICAgdmlldy5jbGVhckNlbGxzKCk7XHJcbiAgICB2aWV3LnNldFR1cm4odGhpcy5zdGVwKTtcclxuICB9XHJcblxyXG4gIG9uTW92ZShkYXRhKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIm9uTW92ZVwiLCBkYXRhKTtcclxuICAgIHRoaXMuc3RlcCA9IGRhdGEuc3RlcDtcclxuICAgIHRoaXMuY2VsbCA9IHZpZXcuY2VsbHNbZGF0YS5jZWxsXTtcclxuICAgIHRoaXMuZ2FtZVN0YXRlLmNlbGxzRGF0YVtkYXRhLmNlbGxdID0gdGhpcy5zdGVwO1xyXG5cclxuICAgIHZpZXcudXBkYXRlQ2VsbCh2aWV3LmNlbGxzW2RhdGEuY2VsbF0sIHRoaXMuc3RlcCk7XHJcbiAgICB2aWV3LnNldFR1cm4odGhpcy5zdGVwKTtcclxuXHJcbiAgICB0aGlzLnN3aXRjaFN0ZXAoKTtcclxuICAgIHZpZXcuc2V0VHVybih0aGlzLnN0ZXApO1xyXG5cclxuICAgIHRoaXMuY2hlY2tEcmF3KCk7XHJcbiAgICB0aGlzLmNoZWNrV2luKCk7XHJcbiAgfVxyXG5cclxuICBvblVzZXJDb25uZWN0ZWQobWVzc2FnZSkge1xyXG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UobWVzc2FnZS5kYXRhKTtcclxuXHJcbiAgICAvLyBUT0RPOiBzaG93IHVzZXIgbWVzc2FnZTogXCIke2ZyaWVuZE5hbX0gam9pbmVkIGdhbWVcIlxyXG4gICAgY29uc29sZS5sb2coZGF0YS5uYW1lKTtcclxuXHJcbiAgICB0aGlzLmdhbWVTdGF0ZS5vcHBvbmVudE5hbWUgPSBkYXRhLm5hbWU7XHJcblxyXG4gICAgLy8gdmVpdy5zaG93TWVzc2FnZShgJHtkYXRhLm5hbWV9IGpvaW5lZCBnYW1lYCk7XHJcblxyXG4gICAgLy8gdGhpcy5hc3NpZ25Vc2VyUm9sZXMoKTtcclxuICB9XHJcblxyXG4gIC8vIFRPRE86IGNhbGwgdGhpcyBtZXRob2Qgd2hlbiB1c2VyIGVudGVyIG5hbWUgYW5kIHByZXNzIE9LXHJcbiAgY2hhbmdlTmFtZShuYW1lKSB7XHJcbiAgICB0aGlzLmdhbWVTdGF0ZS5jdXJyZW50VXNlck5hbWUgPSBuYW1lO1xyXG5cclxuICAgIHNlcnZlci5jaGFuZ2VOYW1lKHtcclxuICAgICAgbmFtZTogbmFtZSxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgc3dpdGNoU3RlcCgpIHtcclxuICAgIHRoaXMuc3RlcCA9IHRoaXMuc3RlcCA9PT0gXCJ4XCIgPyBcIm9cIiA6IFwieFwiO1xyXG4gICAgY29uc29sZS5sb2coXCJzd2l0Y2hTdGVwXCIsIHRoaXMuc3RlcCk7XHJcbiAgfVxyXG5cclxuICBvbkNlbGxQcmVzcyhjZWxsKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIm9uQ2VsbFByZXNzXCIsIHRoaXMuc3RlcCk7XHJcblxyXG4gICAgaWYgKHRoaXMuZ2FtZVN0YXRlLmNlbGxzRGF0YVt2aWV3LmNlbGxzLmluZGV4T2YoY2VsbCldICE9PSBcImVtcHR5XCIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHNlcnZlci5tZXNzYWdlKG1lc3NhZ2VzLm1vdmUsIHtcclxuICAgICAgY2VsbDogdmlldy5jZWxscy5pbmRleE9mKGNlbGwpLFxyXG4gICAgICBzdGVwOiB0aGlzLnN0ZXAsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGNoZWNrV2luKCkge1xyXG4gICAgY29uc3Qgd2lubmVyID0gdGhpcy5nZXRXaW5uZXIoKTtcclxuXHJcbiAgICBpZiAoIXdpbm5lcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmlldy5zZXRXaW4oKTtcclxuICAgIHZpZXcuc2V0Q29tbWVudCh0aGlzLnN0ZXApO1xyXG4gICAgdmlldy5zZXRXaW5UZXh0KHdpbm5lcik7XHJcbiAgICB0aGlzLmdhbWVTdGF0ZS5jZWxsc0RhdGEuZmlsbChcImZ1bGxcIik7XHJcblxyXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlc2V0R2FtZSgpLCA1MDAwKTtcclxuICAgIGNvbnNvbGUubG9nKGB3aW5uZXI6ICR7d2lubmVyfWApO1xyXG4gIH1cclxuXHJcbiAgZ2V0V2lubmVyKCkge1xyXG4gICAgaWYgKHRoaXMuY2hlY2tXaW5uaW5nUG9zaXRpb25zKFwieFwiKSkge1xyXG4gICAgICByZXR1cm4gXCJ4XCI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuY2hlY2tXaW5uaW5nUG9zaXRpb25zKFwib1wiKSkge1xyXG4gICAgICByZXR1cm4gXCJvXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBjaGVja1dpbm5pbmdQb3NpdGlvbnMod2lubmluZ01hcmspIHtcclxuICAgIGxldCB3aW5uaW5nUG9zaXRpb25zID0gW1xyXG4gICAgICBbMCwgMSwgMl0sXHJcbiAgICAgIFszLCA0LCA1XSxcclxuICAgICAgWzYsIDcsIDhdLFxyXG4gICAgICBbMCwgMywgNl0sXHJcbiAgICAgIFsxLCA0LCA3XSxcclxuICAgICAgWzIsIDUsIDhdLFxyXG4gICAgICBbMCwgNCwgOF0sXHJcbiAgICAgIFsyLCA0LCA2XSxcclxuICAgIF07XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aW5uaW5nUG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IFtwb3MxLCBwb3MyLCBwb3MzXSA9IHdpbm5pbmdQb3NpdGlvbnNbaV07XHJcblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdGhpcy5nYW1lU3RhdGUuY2VsbHNEYXRhW3BvczFdID09PSB3aW5uaW5nTWFyayAmJlxyXG4gICAgICAgIHRoaXMuZ2FtZVN0YXRlLmNlbGxzRGF0YVtwb3MyXSA9PT0gd2lubmluZ01hcmsgJiZcclxuICAgICAgICB0aGlzLmdhbWVTdGF0ZS5jZWxsc0RhdGFbcG9zM10gPT09IHdpbm5pbmdNYXJrXHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgY2hlY2tEcmF3KCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmdhbWVTdGF0ZS5jZWxsc0RhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIHRoaXMuZ2FtZVN0YXRlLmNlbGxzRGF0YVtpXSAhPT0gXCJ4XCIgJiZcclxuICAgICAgICB0aGlzLmdhbWVTdGF0ZS5jZWxsc0RhdGFbaV0gIT09IFwib1wiXHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coXCJEUkFXXCIpO1xyXG5cclxuICAgIHZpZXcuc2V0RHJhdygpO1xyXG4gICAgdmlldy5zZXRDb21tZW50KHRoaXMuc3RlcCk7XHJcblxyXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlc2V0R2FtZSgpLCA1MDAwKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IGFibHkgZnJvbSBcImFibHkvcHJvbWlzZXNcIjtcclxuXHJcbmNvbnN0IEFQSV9LRVkgPSBcIlo5b3Etdy5TZUMwc0E6UldjaFFWb2U1T1c2SEN4X29nay1wUnRfZzJxb0JrekUzaHVoeGRzU0lfQVwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IG1lc3NhZ2VzID0ge1xyXG4gIHVzZXJSZWFkeTogXCJ1c2VyUmVhZHlcIixcclxuICBzdGFydEdhbWU6IFwic3RhcnRHYW1lXCIsXHJcbiAgbW92ZTogXCJtb3ZlXCIsXHJcbn07XHJcblxyXG5jbGFzcyBTZXJ2ZXIge1xyXG4gIHJvb21TdGF0ZSA9IHtcclxuICAgIHVzZXJzOiBuZXcgTWFwKCksXHJcbiAgfTtcclxuXHJcbiAgb24gPSB7XHJcbiAgICBbbWVzc2FnZXMudXNlclJlYWR5XTogKCkgPT4ge30sXHJcbiAgfTtcclxuXHJcbiAgYXN5bmMgY29ubmVjdCgpIHtcclxuICAgIC8vIEZvciB0aGUgZnVsbCBjb2RlIHNhbXBsZSBzZWUgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL2FibHkvcXVpY2tzdGFydC1qc1xyXG4gICAgY29uc3Qgc2VydmVyID0gbmV3IGFibHkuUmVhbHRpbWUuUHJvbWlzZShBUElfS0VZKTtcclxuXHJcbiAgICBhd2FpdCBzZXJ2ZXIuY29ubmVjdGlvbi5vbmNlKFwiY29ubmVjdGVkXCIpO1xyXG5cclxuICAgIHJldHVybiBzZXJ2ZXI7XHJcbiAgfVxyXG5cclxuICBhc3luYyBpbml0Um9vbShjaGFubmVsTmFtZSkge1xyXG4gICAgY29uc3Qgc2VydmVyID0gYXdhaXQgdGhpcy5jb25uZWN0KCk7XHJcblxyXG4gICAgdGhpcy5jaGFubmVsID0gc2VydmVyLmNoYW5uZWxzLmdldChjaGFubmVsTmFtZSk7XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJDb25uZWN0ZWQgdG8gcm9vbSBcIiArIGNoYW5uZWxOYW1lKTtcclxuXHJcbiAgICB0aGlzLnN1YnNjcmliZVRvTWVzc2FnZXMoKTtcclxuICB9XHJcblxyXG4gIHN1YnNjcmliZVRvTWVzc2FnZXMoKSB7XHJcbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2UgaW4gbWVzc2FnZXMpIHtcclxuICAgICAgdGhpcy5vblttZXNzYWdlXSA9ICgpID0+IHt9O1xyXG5cclxuICAgICAgdGhpcy5jaGFubmVsLnN1YnNjcmliZShtZXNzYWdlLCAoZGF0YSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKGRhdGEuZGF0YSk7XHJcbiAgICAgICAgdGhpcy5vblttZXNzYWdlXShwYXJzZWREYXRhKTtcclxuXHJcbiAgICAgICAgY29uc3QgeyB1c2VycyB9ID0gdGhpcy5yb29tU3RhdGU7XHJcblxyXG4gICAgICAgIHN3aXRjaCAobWVzc2FnZSkge1xyXG4gICAgICAgICAgY2FzZSBtZXNzYWdlcy51c2VyUmVhZHk6XHJcbiAgICAgICAgICBjYXNlIG1lc3NhZ2VzLnN0YXJ0R2FtZTpcclxuICAgICAgICAgICAgdXNlcnMuc2V0KHBhcnNlZERhdGEudXNlcklELCBwYXJzZWREYXRhLnVzZXJOYW1lKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIG1lc3NhZ2UobWVzc2FnZVR5cGUsIGRhdGEpIHtcclxuICAgIGF3YWl0IHRoaXMuY2hhbm5lbC5wdWJsaXNoKG1lc3NhZ2VUeXBlLCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XHJcbiAgfVxyXG5cclxuICBjbG9zZUNvbm5lY3Rpb24oKSB7XHJcbiAgICBhYmx5LmNsb3NlKCk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgc2VydmVyID0gbmV3IFNlcnZlcigpO1xyXG5cclxuIiwiZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURpdihjbGFzc05hbWUpIHtcclxuICByZXR1cm4gY3JlYXRlSFRNTEVsZW1lbnQoXCJkaXZcIiwgY2xhc3NOYW1lKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJ1dHRvbih0ZXh0LCBjbGFzc05hbWUpIHtcclxuICBjb25zdCBidXR0b24gPSBjcmVhdGVIVE1MRWxlbWVudChcImJ1dHRvblwiLCBjbGFzc05hbWUpO1xyXG5cclxuICBidXR0b24uaW5uZXJIVE1MID0gdGV4dDtcclxuXHJcbiAgcmV0dXJuIGJ1dHRvbjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUlucHV0KHBsYWNlaG9sZGVyLCBjbGFzc05hbWUsIHZhbHVlKSB7XHJcbiAgY29uc3QgaW5wdXQgPSBjcmVhdGVIVE1MRWxlbWVudChcImlucHV0XCIsIGNsYXNzTmFtZSk7XHJcblxyXG4gIGlmIChwbGFjZWhvbGRlcikgaW5wdXQucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcclxuICBpZiAodmFsdWUpIGlucHV0LnZhbHVlID0gdmFsdWU7XHJcblxyXG4gIHJldHVybiBpbnB1dDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhUTUxFbGVtZW50KHRhZ05hbWUsIGNsYXNzTmFtZSkge1xyXG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG4gIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xyXG5cclxuICByZXR1cm4gZWxlbWVudDtcclxufSIsImV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kb21JbnQobWF4KSB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KTtcclxufSIsImltcG9ydCB7IGNyZWF0ZUJ1dHRvbiwgY3JlYXRlRGl2LCBjcmVhdGVJbnB1dCB9IGZyb20gXCIuL3VudGlscy9odG1sSGVscGVyc1wiO1xyXG5leHBvcnQgY2xhc3MgVmlldyB7XHJcbiAgY2VsbHMgPSBbXTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLnBhcmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGFyZW50XCIpO1xyXG5cclxuICAgIHRoaXMudGljVGFjVG9lRGl2ID0gY3JlYXRlRGl2KFwidGljdGFjdG9lRGl2XCIpO1xyXG4gICAgdGhpcy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy50aWNUYWNUb2VEaXYpO1xyXG5cclxuICAgIHRoaXMudGhlbWVTd2l0Y2hlciA9IGNyZWF0ZUJ1dHRvbihcIlwiLCBcImJ1dHRvblRvcGljXCIpO1xyXG4gICAgdGhpcy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy50aGVtZVN3aXRjaGVyKTtcclxuXHJcbiAgICBjb25zdCBwbGF5ZXJEaXYgPSBjcmVhdGVEaXYoXCJwbGF5ZXJEaXZcIik7XHJcbiAgICB0aGlzLnRpY1RhY1RvZURpdi5hcHBlbmRDaGlsZChwbGF5ZXJEaXYpO1xyXG5cclxuICAgIHRoaXMudHVyblBvaW50ZXIgPSBjcmVhdGVEaXYoXCJwbGF5ZXJcIik7XHJcbiAgICBwbGF5ZXJEaXYuYXBwZW5kQ2hpbGQodGhpcy50dXJuUG9pbnRlcik7XHJcblxyXG4gICAgdGhpcy5jb21tZW50cyA9IGNyZWF0ZURpdihcInBsYXllclBcIik7XHJcbiAgICBwbGF5ZXJEaXYuYXBwZW5kQ2hpbGQodGhpcy5jb21tZW50cyk7XHJcblxyXG4gICAgY29uc3QgY2VsbERpdiA9IGNyZWF0ZURpdihcImNlbGxEaXZcIik7XHJcbiAgICB0aGlzLnRpY1RhY1RvZURpdi5hcHBlbmRDaGlsZChjZWxsRGl2KTtcclxuXHJcbiAgICB0aGlzLmNyZWF0ZVVzZXJOYW1lSW5wdXQoKTtcclxuICAgIHRoaXMuY3JlYXRlTWVzc2FnZURpdigpO1xyXG4gICAgdGhpcy5jcmVhdGVFcnJvckRpdigpO1xyXG5cclxuICAgIHRoaXMuY3JlYXRlQ2VsbHMoY2VsbERpdik7XHJcblxyXG4gICAgdGhpcy5oaWRlRmllbGQoKTtcclxuICB9XHJcbiAgXHJcbiAgY3JlYXRlRXJyb3JEaXYoKSB7XHJcbiAgICB0aGlzLmVycm9yTWVzc2FnZSA9IGNyZWF0ZURpdihcImVycm9yTWVzc2FnZVwiKTtcclxuICAgIHRoaXMuZXJyb3JNZXNzYWdlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgIHRoaXMucGFyZW50LmFwcGVuZENoaWxkKHRoaXMuZXJyb3JNZXNzYWdlKTtcclxuICB9XHJcbiAgXHJcbiAgY3JlYXRlTWVzc2FnZURpdigpIHtcclxuICAgIHRoaXMubWVzc2FnZSA9IGNyZWF0ZURpdihcIm1lc3NhZ2VcIik7XHJcbiAgICB0aGlzLm1lc3NhZ2Uuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgdGhpcy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5tZXNzYWdlKTtcclxuICB9XHJcblxyXG4gIGNyZWF0ZVVzZXJOYW1lSW5wdXQoKSB7XHJcbiAgICB0aGlzLnVzZXJOYW1lSW5wdXREaXYgPSBjcmVhdGVEaXYoXCJyb29tTmFtZUlucHV0RGl2XCIpO1xyXG4gICAgdGhpcy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy51c2VyTmFtZUlucHV0RGl2KTtcclxuXHJcbiAgICB0aGlzLnVzZXJOYW1lSW5wdXQgPSBjcmVhdGVJbnB1dChcIkVudGVyIHlvdXIgbmFtZVwiLCBcIm5hbWVJbnB1dFwiKTtcclxuICAgIHRoaXMudXNlck5hbWVJbnB1dERpdi5hcHBlbmRDaGlsZCh0aGlzLnVzZXJOYW1lSW5wdXQpO1xyXG5cclxuICAgIHRoaXMudXNlck5hbWVJbnB1dEVudGVyID0gY3JlYXRlQnV0dG9uKFwiRW50ZXIgcm9vbVwiLCBcIm5hbWVJbnB1dEVudGVyXCIpO1xyXG4gICAgdGhpcy51c2VyTmFtZUlucHV0RGl2LmFwcGVuZENoaWxkKHRoaXMudXNlck5hbWVJbnB1dEVudGVyKTtcclxuICB9XHJcblxyXG4gIGNyZWF0ZUNlbGxzKGNlbGxzRGl2KSB7XHJcbiAgICBmb3IgKGxldCBjZWxsTnVtID0gMDsgY2VsbE51bSA8IDk7IGNlbGxOdW0rKykge1xyXG4gICAgICBjb25zdCBjZWxsID0gY3JlYXRlQnV0dG9uKFwiXCIsIFwiY2VsbCBmdWxsXCIpO1xyXG5cclxuICAgICAgY2VsbC5vbmNsaWNrID0gKCkgPT4gdGhpcy5vbkNlbGxQcmVzcyhjZWxsKTtcclxuXHJcbiAgICAgIGNlbGxzRGl2LmFwcGVuZENoaWxkKGNlbGwpO1xyXG5cclxuICAgICAgdGhpcy5jZWxscy5wdXNoKGNlbGwpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2hvd01lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgY29uc29sZS5sb2cobWVzc2FnZSk7XHJcbiAgfVxyXG5cclxuICBzZXRUdXJuKHR1cm4pIHtcclxuICAgIGlmICh0dXJuID09PSBcInhcIikge1xyXG4gICAgICB0aGlzLnR1cm5Qb2ludGVyLmlubmVySFRNTCA9IFwiWCBUdXJuXCI7XHJcbiAgICB9IGVsc2UgaWYgKHR1cm4gPT09IFwib1wiKSB7XHJcbiAgICAgIHRoaXMudHVyblBvaW50ZXIuaW5uZXJIVE1MID0gXCJPIFR1cm5cIjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldENvbW1lbnQodHVybikge1xyXG4gICAgaWYgKHR1cm4gPT09IFwieFwiKSB7XHJcbiAgICAgIHRoaXMuY29tbWVudHMuaW5uZXJIVE1MID0gXCJOZXh0IHR1cm4gWFwiO1xyXG4gICAgfSBlbHNlIGlmICh0dXJuID09PSBcIm9cIikge1xyXG4gICAgICB0aGlzLmNvbW1lbnRzLmlubmVySFRNTCA9IFwiTmV4dCB0dXJuIE9cIjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldFdpblRleHQod2luU3ltYm9sKSB7XHJcbiAgICBpZiAod2luU3ltYm9sID09PSBcInhcIikge1xyXG4gICAgICB0aGlzLnR1cm5Qb2ludGVyLmlubmVySFRNTCA9IFwiWCBXb24hXCI7XHJcbiAgICB9IGVsc2UgaWYgKHdpblN5bWJvbCA9PT0gXCJvXCIpIHtcclxuICAgICAgdGhpcy50dXJuUG9pbnRlci5pbm5lckhUTUwgPSBcIk8gV29uIVwiO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2V0U3R5bGUoc3R5bGUpIHtcclxuICAgIGlmIChzdHlsZSA9PT0gXCJkYXJrXCIpIHtcclxuICAgICAgdGhpcy5wYXJlbnQuY2xhc3NMaXN0LmFkZChcImRhcmtcIik7XHJcbiAgICB9IGVsc2UgaWYgKHN0eWxlID09PSBcImxpZ2h0XCIpIHtcclxuICAgICAgdGhpcy5wYXJlbnQuY2xhc3NMaXN0LnJlbW92ZShcImRhcmtcIik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1cGRhdGVDZWxsKGNlbGwsIHN0ZXApIHtcclxuICAgIGlmIChzdGVwID09PSBcInhcIikge1xyXG4gICAgICBjZWxsLmNsYXNzTGlzdC5hZGQoXCJ4XCIsIFwiZW1wdHlcIiwgXCJzdGVwWFwiKTtcclxuICAgICAgY2VsbC5jbGFzc0xpc3QucmVtb3ZlKFwiZnVsbFwiKTtcclxuICAgIH0gZWxzZSBpZiAoc3RlcCA9PT0gXCJvXCIpIHtcclxuICAgICAgY2VsbC5jbGFzc0xpc3QuYWRkKFwib1wiLCBcImVtcHR5XCIsIFwic3RlcE9cIik7XHJcbiAgICAgIGNlbGwuY2xhc3NMaXN0LnJlbW92ZShcImNlbGxXYWl0XCIsIFwiZnVsbFwiKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldFdpbigpIHtcclxuICAgIHRoaXMucGFyZW50LmNsYXNzTGlzdC5hZGQoXCJ3aW5cIik7XHJcbiAgfVxyXG5cclxuICBzZXREcmF3KCkge1xyXG4gICAgdGhpcy50dXJuUG9pbnRlci5pbm5lckhUTUwgPSBcIkRyYXchXCI7XHJcbiAgICB0aGlzLnBhcmVudC5jbGFzc0xpc3QuYWRkKFwiZHJhd1wiKTtcclxuICB9XHJcblxyXG4gIGNsZWFyQ2VsbHMoKSB7XHJcbiAgICBmb3IgKGNvbnN0IGNlbGwgb2YgdGhpcy5jZWxscykge1xyXG4gICAgICBjZWxsLmNsYXNzTGlzdC5hZGQoXCJmdWxsXCIpO1xyXG4gICAgICBjZWxsLmNsYXNzTGlzdC5yZW1vdmUoXCJvXCIsIFwieFwiLCBcInN0ZXBYXCIsIFwic3RlcE9cIiwgXCJlbXB0eVwiKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnBhcmVudC5jbGFzc0xpc3QucmVtb3ZlKFwid2luXCIsIFwiZHJhd1wiKTtcclxuICAgIHRoaXMuY29tbWVudHMuaW5uZXJIVE1MID0gXCJcIjtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcImNsZWFyXCIpO1xyXG4gIH1cclxuXHJcbiAgc2hvd1VzZXJOYW1lSW5wdXQodXNlck5hbWUpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICBpZiAodXNlck5hbWUpIHtcclxuICAgICAgICB2aWV3LnVzZXJOYW1lSW5wdXQudmFsdWUgPSB1c2VyTmFtZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy51c2VyTmFtZUlucHV0RW50ZXIub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICBpZiAodmlldy51c2VyTmFtZUlucHV0LnZhbHVlID09PSBcIlwiKSB7XHJcbiAgICAgICAgICB0aGlzLnNob3dFcnJvcihcIlBsZWFzZSBlbnRlciB5b3VyIG5hbWVcIik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNoYW5nZU5hbWUodXNlck5hbWUpO1xyXG4gICAgICAgICAgcmVzb2x2ZSh2aWV3LnVzZXJOYW1lSW5wdXQudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcblxyXG5cclxuICBzaG93RXJyb3IobWVzc2FnZSkge1xyXG4gICAgdGhpcy5oaWRlTWVzc2FnZSgpO1xyXG4gICAgdGhpcy5lcnJvck1lc3NhZ2UuaW5uZXJIVE1MID0gbWVzc2FnZTtcclxuICAgIHRoaXMuZXJyb3JNZXNzYWdlLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaGlkZUVycm9yKCksIDMwMDApO1xyXG4gIH1cclxuXHJcbiAgXHJcblxyXG4gIHNob3dNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgIHRoaXMuaGlkZUVycm9yKCk7XHJcbiAgICB0aGlzLm1lc3NhZ2UuaW5uZXJIVE1MID0gbWVzc2FnZTtcclxuICAgIHRoaXMubWVzc2FnZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xyXG4gIH1cclxuXHJcbiAgaGlkZUVycm9yKCkge1xyXG4gICAgdGhpcy5lcnJvck1lc3NhZ2Uuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gIH1cclxuXHJcbiAgaGlkZU1lc3NhZ2UoKSB7XHJcbiAgICB0aGlzLm1lc3NhZ2Uuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gIH1cclxuXHJcbiAgaGlkZUZpZWxkKCkge1xyXG4gICAgdGhpcy50aWNUYWNUb2VEaXYuY2xhc3NMaXN0LmFkZChcImRpc3BsYXlOb25lXCIpO1xyXG4gIH1cclxuXHJcbiAgaGlkZVJvb21OYW1lSW5wdXQoKSB7XHJcbiAgICB0aGlzLnVzZXJOYW1lSW5wdXREaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgdGhpcy50aWNUYWNUb2VEaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcclxuICB9XHJcblxyXG4gIHNob3dGaWVsZCgpIHtcclxuICAgIHRoaXMudGljVGFjVG9lRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgdmlldyA9IG5ldyBWaWV3KCk7XHJcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgeyBDb250cm9sbGVyIH0gZnJvbSBcIi4vY29udHJvbGxlclwiO1xyXG5cclxubmV3IENvbnRyb2xsZXIoKS5pbml0KCk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==